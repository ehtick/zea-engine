<!DOCTYPE html>
<html class="h-full">
  <head>
    <title>Zea CAD Viewer</title>
    <link
      rel="shortcut icon"
      type="image/png"
      href="./data/favicon-32x32.png"
    />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.9/tailwind.min.css"
    />
    <link rel="stylesheet" href="./src/styles.css"/>
    <!-- <link rel="stylesheet" href="styles/test.css" /> -->
    <style>
      .fps-display {
        position: fixed;
        bottom: 35px;
        right: 10px;
        color: #333333;
        font-size: 25px;
      }
      .status-display {
        position: fixed;
        bottom: 2px;
        left: 10px;
        color: #ffffff;
        font-size: 18px;
      }
      .cull-stats {
        position: fixed;
        bottom: 2px;
        right: 10px;
        color: #ffffff;
        font-size: 18px;
      }
      #surface-info {
        position: fixed;
        top: 50px;
        right: 10px;
        width: 340px;
        color: #333333;
        font-size: 12px;
      }
      #bottomPanel {
        height: 30px;
      }

      
    .rendermode-buttons {
     left: 150px;
      top: 2px; 
      display: block;
      position: fixed;
    }

    .rendermode-button {
      top: 10px;
      font-family: 'arial';
      background-color: #f9ce03; /* Green */
      border: none;
      color: black;
      padding: 4px 10px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      user-select: none;
    }
    </style>
    <script src="../dist/index.umd.js"></script>
    <script src="./src/zea-fps-display.js" type="module"></script>
    <script src="../node_modules/@zeainc/zea-tree-view/dist/index.umd.development.js"></script>
  </head>

  <body class="overflow-hidden h-full">
    <div class="h-full flex flex-col">
      <header class="p-2">
        <img src="./data/logo-zea.svg" id="logo"></img>
        <div class="rendermode-buttons">
          <button class="rendermode-button" id="rendermode-Wireframe">Wireframe</button>
          <button class="rendermode-button" id="rendermode-Flat">Flat</button>
          <button class="rendermode-button" id="rendermode-HiddenLine">HiddenLine</button>
          <button class="rendermode-button" id="rendermode-PBR">PBR</button>
        </div>
      </header>
      <main class="flex flex-col flex-1">
        <div class="flex-1" id="topPanel">
          <div class="splitter">
            <div id="leftPanel">
              <zea-tree-view
                id="tree"
                class="select-none"
              ></zea-tree-view>
            </div>
            <div class="separator" id="separatorV"></div>
            <div id="mainPanel" class="flex-1">
              <div id="canvas-holder">
                <canvas id="canvas" > </canvas>
              </div>
              <div class="xr-button hidden" id="xr-button"></div>
              <div id="surface-info"></div>
              <div id="cull-stats" class="cull-stats"></div>
              <!-- Uncomment for an Fps display. however, not for testing. (tests will continuously fail)
                <zea-fps-display class="fps-display" id="fps"></zea-fps-display>
               -->
              <progress class="progress-display" id="progress" value="0" max="100">
                0%
              </progress>
            </div>
          </div>
        </div>
        <!-- Uncomment these lines to provide a resizable bottom panel
        <div class="separator" id="separatorH"></div>-->
        <div id="bottomPanel">
              <div class="status-display" id="status"></div>
        </div> 
      </main>
    </div>
    <script type="module">
      import dragElement from './src/panels.js'
      const separatorV = document.getElementById("separatorV");
      const leftPanel = document.getElementById("leftPanel");
      const mainPanel = document.getElementById("mainPanel");
      dragElement(separatorV, leftPanel, mainPanel, "H");

      const separatorH = document.getElementById("separatorH");
      const topPanel = document.getElementById("topPanel");
      const bottomPanel = document.getElementById("bottomPanel");
      if (separatorH && topPanel && bottomPanel) {
        dragElement(separatorH, topPanel, bottomPanel, "V");
      }
    </script>

    <script type="module">

import '../../node_modules/@zeainc/zea-ux/dist/index.umd.js'


const { CADBody, CADAsset } = zeaEngine
const materialCache = {}

const resetMaterial = (material) => {
    if (! materialCache[material.getId()]) {
      materialCache[material.getId()] = {
        BaseColor: material.getParameter('BaseColor').value.clone(),
        Reflectance: material.getParameter('Reflectance').value,
        EmissiveStrength: material.getParameter('EmissiveStrength').value
      }
    }
    else {
      const values = materialCache[material.getId()]
      material.getParameter('BaseColor').value = values.BaseColor.clone()
      material.getParameter('Reflectance').value= values.Reflectance
      material.getParameter('EmissiveStrength').value= values.EmissiveStrength
    }
  }

function setRendermodeWireframe (treeItem) {
  const processed = {}
  const modifyMaterial = (material) => {
    if (processed[material.getId()]) return
    processed[material.getId()] = true
    resetMaterial(material)

    material.getParameter('BaseColor').value.a = 0
    material.getParameter('Reflectance').value = 0
    material.getParameter('EmissiveStrength').value = 1
  }
  treeItem.traverse(item => {
    if (item instanceof CADAsset) {
      const materialLibrary = item.materialLibrary
      const materials = materialLibrary.getMaterials()
      materials.forEach((material) => {
        if(material.getShaderName() == "StandardSurfaceShader" ) {
          modifyMaterial(material)
        }
      })
    }
    if (item instanceof CADBody) {
      const material = item.materialParam.value
      modifyMaterial(material)
    }
  })
}

function setRendermodeFlat (treeItem) {
  const processed = {}
  const modifyMaterial = (material) => {
    if (processed[material.getId()]) return
    processed[material.getId()] = true
    resetMaterial(material)
    material.getParameter('Reflectance').value = 0
    material.getParameter('EmissiveStrength').value = 1
  }
  treeItem.traverse(item => {
    if (item instanceof CADAsset) {
      const materialLibrary = item.materialLibrary
      const materials = materialLibrary.getMaterials()
      materials.forEach((material) => {
        if(material.getShaderName() == "StandardSurfaceShader" ) {
          modifyMaterial(material)
        }
      })
    }
    if (item instanceof CADBody) {
      const material = item.materialParam.value
      modifyMaterial(material)
    }
  })
}

function setRendermodeHiddenLine(treeItem, backgroundColor) {
  const processed = {}
  const modifyMaterial = (material) => {
    if (processed[material.getId()]) return
    processed[material.getId()] = true
    resetMaterial(material)
    material.getParameter('BaseColor').value = backgroundColor
    material.getParameter('Reflectance').value = 0
    material.getParameter('EmissiveStrength').value = 1
  }
  treeItem.traverse(item => {
    if (item instanceof CADAsset) {
      const materialLibrary = item.materialLibrary
      const materials = materialLibrary.getMaterials()
      materials.forEach((material) => {
        if(material.getShaderName() == "StandardSurfaceShader" ) {
          modifyMaterial(material)
        }
      })
    }
    if (item instanceof CADBody) {
      const material = item.materialParam.value
      modifyMaterial(material)
    }
  })
}
function setRendermodePBR(treeItem, backgroundColor) {
  const processed = {}
  const modifyMaterial = (material) => {
    if (processed[material.getId()]) return
    processed[material.getId()] = true
    resetMaterial(material)
  }
  treeItem.traverse(item => {
    if (item instanceof CADAsset) {
      const materialLibrary = item.materialLibrary
      const materials = materialLibrary.getMaterials()
      materials.forEach((material) => {
        if(material.getShaderName() == "StandardSurfaceShader" ) {
          modifyMaterial(material)
        }
      })
    }
    if (item instanceof CADBody) {
      const material = item.materialParam.value
      modifyMaterial(material)
    }
  })
}


/* eslint-disable require-jsdoc */
function init() {
  const {
    Color,
    Vec3,
    Scene,
    GLRenderer,
    EnvMap,
    resourceLoader,
    GeomItem,
    MeshProxy,
    LinesProxy,
    AssetLoadContext,
    CADAsset,
    CADBody,
    PMIItem,
    CompoundGeom,
    StringFunctions
  } = zeaEngine

  const urlParams = new URLSearchParams(window.location.search)
  const scene = new Scene()
  // scene.setupGrid(10.0, 10)

  const renderer = new GLRenderer(document.getElementById('canvas'), {
    antialias: false,
    debugGeomDataBuffer: false,
    enableFrustumCulling: false,
    enableOcclusionCulling: false,
  })

  renderer.outlineThickness = 0.5
  renderer.outlineSensitivity = 5
  
  renderer.setScene(scene)
  renderer.getViewport().getCamera().setPositionAndTarget(new Vec3(12, 12, 10), new Vec3(0, 0, 1.5))
  // renderer.getViewport().backgroundColorParam.value = new Color(1, 0, 0)
  renderer.getViewport().getManipulator().setDefaultManipulationMode('tumbler')

  const envMap = new EnvMap()
  envMap.load('./data/StudioG.zenv')
  scene.setEnvMap(envMap)

  const appData = { scene, renderer }

  /** SELECTION START */
  const { SelectionManager, SelectionTool } = window.zeaUx

  const selectionManager = new SelectionManager(appData, {
    enableXfoHandles: true,
  })
  appData.selectionManager = selectionManager

  // Users can enable the handles using a menu or hotkey.
  selectionManager.showHandles(false)

  const selectionTool = new SelectionTool(appData)
  const filterItemSelection = (item) => {
    return item
  }
  selectionTool.setSelectionFilter(filterItemSelection)

  // Note: the alpha value determines  the fill of the highlight.
  const selectionColor = new Color('#F9CE03')
  selectionColor.a = 0.1
  selectionManager.selectionGroup.highlightColorParam.value = selectionColor

  // Color the selection rect.
  const selectionRectColor = new Color(0, 0, 0, 1)
  selectionTool.rectItem.materialParam.value.getParameter('BaseColor').value = selectionRectColor

  /** SELECTION END */

  // Setup FPS Display
  const fpsElement = document.getElementById('fps')
  if (fpsElement) fpsElement.renderer = renderer

  // Setup TreeView Display
  const treeElement = document.getElementById('tree')
  treeElement.setTreeItem(scene.getRoot(), appData)
  treeElement.setSelectionManager(selectionManager)

  // let highlightedItem

  /** HIGHLIGHT START */
  let highlightKey
  let highlightedItem

  const highlightColor = new Color('#F9CE03')
  highlightColor.a = 0.1
  const filterItem = (item) => {
    while (item && !((item instanceof CADBody) || (item instanceof PMIItem))) item = item.getOwner()
    return item
  }


  // renderer.getViewport().on('pointerOverGeom', (event) => {
  //   const item = event.intersectionData.geomItem
  //   if (item) {
  //     if (highlightedItem == item) highlightedItem.removeHighlight(highlightKey, true)
  //     highlightedItem = item
  //     if (event.intersectionData.componentId >= 0) {
  //       highlightKey = 'pointerOverGeom:' + event.intersectionData.componentId
  //     } else {
  //       highlightKey = 'pointerOverGeom'
  //     }
  //     highlightedItem.addHighlight(highlightKey, highlightColor, true)
  //   }
  // })
  // renderer.getViewport().on('pointerLeaveGeom', (event) => {
  //   highlightedItem.removeHighlight(highlightKey, true)
  //   highlightedItem = null
  // })


  const shatterGeomsOnMouseOver = true
  renderer.getViewport().on('pointerMove', (event) => {
    if (event.intersectionData) {
      const item = event.intersectionData.geomItem
      if (item) {
        let key
        if (event.intersectionData.componentId >= 0) {
          key = 'pointerOverGeom:' + event.intersectionData.componentId
          if (key != highlightKey) {
            if (highlightedItem) highlightedItem.removeHighlight(highlightKey, true)
            highlightedItem = item
            highlightKey = key
            highlightedItem.addHighlight(highlightKey, highlightColor, true)
          }
        } else {
          if (item instanceof CADBody && shatterGeomsOnMouseOver) {
            item.setShatterState(true)
            return
          }
          if (highlightedItem && item != highlightedItem) {
            highlightedItem.removeHighlight(highlightKey, true)
          }
          highlightedItem = filterItem(item)
          highlightKey = 'pointerOverGeom'
          highlightedItem.addHighlight(highlightKey, highlightColor, true)
        }
      }
    } else {
      if (highlightedItem) {
        highlightedItem.removeHighlight(highlightKey, true)
        if (highlightedItem instanceof CADBody) {
          highlightedItem.setShatterState(false)
        }
        highlightedItem = null
        highlightKey = ''
      }
    }
  })
  renderer.getViewport().on('keyDown', (event) => {
    if (event.key == 'f') renderer.frameAll()
  })
  renderer.getViewport().on('pointerDown', (event) => {
    if (event.intersectionData) {
      if (event.intersectionData.componentId >= 0) {
        // const geomItem = filterItem(event.intersectionData.geomItem)
        // if (geomItem instanceof CADBody && geomItem.geomParam.value instanceof CompoundGeom) {
        //   // geomItem.assetItem.loadMetadata().then(() => {
        //   //   const geom = geomItem.geomParam.value

        //   //   const subGeom = geom.subGeoms[event.intersectionData.componentId]
        //   //   const json = subGeom.toJSON()
        //   //   const surfaceInfoElement = document.getElementById('surface-info')
        //   //   surfaceInfoElement.innerHTML = ''
        //   //   // surfaceInfoElement.textContent = JSON.stringify(json, null, 2)
        //   //   for (let key in json.params) {
        //   //     const p = document.createElement('p')
        //   //     p.textContent = `${key} : ${StringFunctions.stringifyJSONWithFixedPrecision(json.params[key].value, 0, 3)}`
        //   //     surfaceInfoElement.appendChild(p)
        //   //   }
        //   //   // textContent.split('\n').forEach(line => {
        //   //   //   const p = document.createElement('p')
        //   //   //   p.textContent = line
        //   //   //   surfaceInfoElement.appendChild(p)
        //   //   // })
        //   // })
        // }
      } else {
        const item = filterItem(event.intersectionData.geomItem)
        if (item)
          selectionManager.toggleItemSelection(item, event.ctrlKey)
      }
    }
  })
  renderer.getViewport().on('pointerUp', (event) => {
    if (event.intersectionData) {
      const geomItem = event.intersectionData.geomItem
      console.log('', geomItem.getPath())
    }
  })
  renderer.getViewport().on('keyDown', (event) => {
    if (event.key == 'f') renderer.frameAll()
    else if (event.key == 'd') {
      renderer.getViewport().debugGeomDataBuffer = !renderer.getViewport().debugGeomDataBuffer
      renderer.requestRedraw()
    }
  })
  /** HIGHLIGHT START */


  resourceLoader.on('progressIncremented', (event) => {
    const pct = document.getElementById('progress')
    pct.value = event.percent
    if (event.percent >= 100) {
      setTimeout(() => pct.classList.add('hidden'), 1000)
    }
  })

  renderer.getXRViewport().then((xrvp) => {
    fpsElement.style.bottom = '70px'

    const xrButton = document.getElementById('xr-button')
    xrButton.textContent = 'Launch VR'
    xrButton.classList.remove('hidden')

    xrvp.on('presentingChanged', (event) => {
      const { state } = event
      if (state) {
        xrButton.textContent = 'Exit VR'
      } else {
        xrButton.textContent = 'Launch VR'
      }
    })

    xrButton.addEventListener('click', function (event) {
      xrvp.togglePresenting()
    })

    document.addEventListener('keydown', (event) => {
      if (event.key == ' ') {
        xrvp.togglePresenting()
      }
    })
  })

  if (urlParams.has('profile')) {
    renderer.startContinuousDrawing()
  }

  // ////////////////////////////////////////////
  // Render Modes
  document.getElementById('rendermode-Wireframe').addEventListener('click', () => {
      setRendermodeWireframe(asset)
  })
  document.getElementById('rendermode-Flat').addEventListener('click', () => {
    setRendermodeFlat(asset)
  })
  document.getElementById('rendermode-HiddenLine').addEventListener('click', () => {
    setRendermodeHiddenLine(asset, renderer.getViewport().backgroundColorParam.value.toLinear())
  })
  document.getElementById('rendermode-PBR').addEventListener('click', () => {
    setRendermodePBR(asset)
  })
  // 

  // ////////////////////////////////////////////
  // Load the asset

  const asset = new CADAsset()
  const zcad = urlParams.has('zcad') ? urlParams.get('zcad') : '../data/HC_SRO4.zcad'
  if (zcad) {
    const context = new AssetLoadContext()
    context.camera = renderer.getViewport().getCamera()
    asset.load(zcad, context).then(() => {
      renderer.frameAll()
    })
    asset.getGeometryLibrary().on('loaded', () => {
      setStatusText('done-loading')
    })
  }

  scene.getRoot().addChild(asset)

  const cullElement = document.getElementById('cull-stats')
  renderer.on('CullingUpdated', (event) => {
    if (event.visible && event.total) {
      cullElement.textContent = `visible: ${event.visible} / total: ${event.total}`
    }
  })
  const statusElement = document.getElementById('status')
  const setStatusText = (text) => {
    renderer.forceRender()
    statusElement.textContent = text
  }
}


// To enable simple authentication in this app
// change this value to true.
if (false) {
  // Show the login page.
  const login = document.getElementById("login");
  login.show(()=> {
    // When it is closed, init the scene.
    init()
  })
} else {
  init()
}
    </script>
  </body>
</html>
