"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2639],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return d}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,h=a(e,["components","mdxType","originalType","parentName"]),p=c(n),d=i,m=p["".concat(l,".").concat(d)]||p[d]||u[d]||s;return n?r.createElement(m,o(o({ref:t},h),{},{components:n})):r.createElement(m,o({ref:t},h))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,o=new Array(s);o[0]=p;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a.mdxType="string"==typeof e?e:i,o[1]=a;for(var c=2;c<s;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4567:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return a},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return h},default:function(){return p}});var r=n(7462),i=n(3366),s=(n(7294),n(3905)),o=["components"],a={sidebar_position:4,title:"Highlighting objects from the Tree View"},l=void 0,c={unversionedId:"Tutorials/react/highlights",id:"Tutorials/react/highlights",isDocsHomePage:!1,title:"Highlighting objects from the Tree View",description:"In this tutorial, we will cover how to use the tree view to select items in our scene.",source:"@site/docs/Tutorials/react/highlights.md",sourceDirName:"Tutorials/react",slug:"/Tutorials/react/highlights",permalink:"/zea-engine/Tutorials/react/highlights",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Highlighting objects from the Tree View"},sidebar:"tutorialSidebar",previous:{title:"Setting up a Tree View in React",permalink:"/zea-engine/Tutorials/react/treeview"},next:{title:"Moving Objects Using Your Mouse",permalink:"/zea-engine/Tutorials/move-object"}},h=[{value:"Making select work from the viewport and treeview.",id:"making-select-work-from-the-viewport-and-treeview",children:[{value:"Viewport3D.tsx",id:"viewport3dtsx",children:[]},{value:"Main.tsx",id:"maintsx",children:[]}]},{value:"Result",id:"result",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],u={toc:h};function p(e){var t=e.components,a=(0,i.Z)(e,o);return(0,s.kt)("wrapper",(0,r.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"In this tutorial, we will cover how to use the tree view to select items in our scene."),(0,s.kt)("h2",{id:"making-select-work-from-the-viewport-and-treeview"},"Making select work from the viewport and treeview."),(0,s.kt)("h3",{id:"viewport3dtsx"},"Viewport3D.tsx"),(0,s.kt)("p",null,'First, we can add the callback "setSelected" to our component\'s state. This will be set by the Main component. The callback will enable us to modify the state (which variable is selected) of the Main component.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"class Viewport3D extends React.Component<any, any> {\n  scene: Scene = new Scene()\n  renderer?: GLRenderer\n  canvasRef: React.RefObject<any>\n  constructor(props: any) {\n    super(props)\n    this.state = {\n      setSelected: props.setSelected,\n      setTree: props.setTree,\n    }\n    this.canvasRef = React.createRef()\n  }\n  // ...\n")),(0,s.kt)("p",null,'We can add an event listener to our viewport. We can do this by using the "on" method with the right arguments.\nWhen a click happens within the viewport, we will check to see if there are any intersections with our pointer ray and the geometry of our scene.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"  componentDidMount() {\n    this.renderer = new GLRenderer(this.canvasRef.current)\n    this.renderer.setScene(this.scene)\n    this.scene.setGrid(10, 10)\n\n    const camera = this.renderer.getViewport().getCamera()\n    camera.setPositionAndTarget(new Vec3(6, 6, 5), new Vec3(0, 0, 1.5))\n\n    this.setupScene()\n\n    const nodes = this.traverse_tree()\n    this.state.setTree(nodes)\n\n    this.renderer.getViewport().on('pointerDown', (event: any) => {\n      const geomItem = event?.intersectionData?.geomItem\n      if (geomItem instanceof GeomItem) {\n        this.state.setSelected(geomItem)\n      } else {\n        this.state.setSelected(null)\n      }\n    })\n  }\n")),(0,s.kt)("p",null,"To actually highlight a GeomItem, we can use the method addHighlight()."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"  toggle_highlight(treeItem: GeomItem) {\n    if (treeItem == null) return\n    if (!(treeItem instanceof GeomItem)) return\n\n    if (!treeItem.isHighlighted()) {\n      treeItem.addHighlight('hl', new Color(1.0, 1.0, 0.2, 0.5), false)\n    } else {\n      treeItem.removeHighlight('hl', false)\n    }\n  }\n\n  unhighlight(treeItem: GeomItem) {\n    if (treeItem == null) return\n    if (!(treeItem instanceof GeomItem)) return\n\n    if (treeItem.isHighlighted()) {\n      treeItem.removeHighlight('hl', false)\n    }\n  }\n")),(0,s.kt)("p",null,"This method will execute when any of the component's state changes. Here, we check if the selected object has changed, and if so, we highlight it."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"  componentDidUpdate(prevProps: any) {\n    if (prevProps.selected !== this.props.selected) {\n      this.unhighlight(prevProps.selected)\n      this.toggle_highlight(this.props.selected)\n    } else {\n      this.toggle_highlight(this.props.selected)\n    }\n  }\n")),(0,s.kt)("h3",{id:"maintsx"},"Main.tsx"),(0,s.kt)("p",null,'In Main.tsx, we can augment the existing state variable to include "selected." When the selected variable changes, this will cause the render() method of the Main component to execute.\nThis is useful since, in the render() method we pass props containing the "selected" variable in. We can use this to later compare the previously selected object and currently selected object to then determine which object we should highlight.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"class Main extends React.Component<any, any> {\n  constructor(props: any) {\n    super(props)\n    this.state = {\n      treeNodes: [],\n      selected: null,\n    }\n  }\n")),(0,s.kt)("p",null,'This is a handler that is used in the DeniReactTreeView component. When we click on a item in the tree view, it will trigger this code. The code below sets the "selected" state variable.'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"onSelectItemHandler = (item: any) => {\n  this.setState({ selected: item.geomItem });\n};\n")),(0,s.kt)("p",null,"Here we add the above handler to the DeniReactTreeView."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'<DeniReactTreeView\n  style={{ width: "auto", height: "99%" }}\n  theme={"classic"}\n  items={this.state.treeNodes}\n  onSelectItem={this.onSelectItemHandler}\n/>\n')),(0,s.kt)("p",null,"We also have to pass the setSelected callback, along with the selected state variable."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"<Viewport3D\n  selected={this.state.selected}\n  setSelected={(selected: number) => {\n    this.setState({ selected: selected });\n  }}\n  setTree={(nodes: any) => {\n    this.setState({ treeNodes: nodes });\n  }}\n></Viewport3D>\n")),(0,s.kt)("h2",{id:"result"},"Result"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"highlight",src:n(506).Z})),(0,s.kt)("h2",{id:"conclusion"},"Conclusion"),(0,s.kt)("p",null,"You should now be able to select GeomItems in the scene with either the tree view or by clicking on the viewport."))}p.isMDXComponent=!0},506:function(e,t,n){t.Z=n.p+"assets/images/highlight-result-e39d5e89d5479e442d976a50bba0709c.png"}}]);