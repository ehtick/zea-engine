!function(U,F){"object"==typeof exports&&"undefined"!=typeof module?F(exports):"function"==typeof define&&define.amd?define(["exports"],F):F((U="undefined"!=typeof globalThis?globalThis:U||self).zeaEngine={})}(this,(function(U){"use strict";var F={name:"@zeainc/zea-engine",fileName:"index",libraryName:"ZeaEngine",version:"4.0.0",description:"Zea Engine",browser:"dist/index.umd.js",author:"Zea Inc.",typings:"dist/index.d.ts",files:["dist/**/*.ts","dist/index.umd.js.map","dist/index.umd.js"],engines:{node:">=10"},scripts:{"build:tsc":"npx tsc","build:tsc:watch":"npx tsc --watch","build:rollup":"rollup -c","build:rollup:watch":"rollup -w -c",copyJSFilesToDist:"copyfiles -u 1 src/**/*.{js,wasm,glsl,vert,frag} dist",copyPackageJson:'copyfiles -f "./package.json" dist',docs:"cp CHANGELOG.md docs_src/docs/Manual/ && yarn --cwd ./docs_src/ changelog && yarn --cwd ./docs_src/ run docs",prepare:"yarn run build",generate:"plop",release:"standard-version",start:"http-server --cors --port 8000 --silent","start:watch":"es-dev-server --cors --app-index testing-e2e/index.html --open --watch",build:"npm-run-all clean:build build:tsc copyJSFilesToDist copyPackageJson build:rollup",dev:"npm-run-all --parallel build:tsc:watch copyJSFilesToDist copyPackageJson build:rollup:watch start:watch",test:"jest","test:coverage":"jest --coverage","test:debug":"node --inspect ./node_modules/jest/bin/jest.js --runInBand --watch","test:watch":"jest --watch","test:e2e":"percy exec cypress run --browser chrome --headless","test:e2e:watch":"percy exec cypress open",lint:"tsdx lint",size:"size-limit",analyze:"size-limit --why","clean:build":"rm -Rf dist/ buildcache","clean:all":"rm -Rf dist/ node_modules/ buildcache yarn.lock"},husky:{hooks:{"pre-commit":"tsdx lint"}},dependencies:{lodash:"^4.17.21"},"size-limit":[{path:"dist/zea-engine.cjs.production.min.js",limit:"2100 KB"},{path:"dist/zea-engine.esm.js",limit:"2100 KB"}],devDependencies:{"@percy/cypress":"^2.3.1","@rollup/plugin-commonjs":"^15.1.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^9.0.0","@rollup/plugin-replace":"^3.0.0","@size-limit/preset-small-lib":"^5.0.3","@types/debug":"^4.1.7","@types/jest":"^26.0.23","@types/semver":"^7.3.8","@zeainc/gltf-loader":"^3.2.2","@zeainc/jsdocs2md":"^0.0.8","@zeainc/zea-cad":"^4.0.0","@zeainc/zea-collab":"^5.2.0","@zeainc/zea-potree":"^3.2.1","@zeainc/zea-ux":"^3.2.0","babel-jest":"^27.0.5",copyfiles:"latest",cypress:"^5.1.0","es-dev-server":"^2.1.0","http-server":"^13.0.1",husky:"^7.0.4",jest:"^27.0.6","jest-coverage-badges":"^1.1.2","npm-run-all":"^4.1.5",prettier:"^2.4.1",rollup:"^2.32.1","rollup-plugin-base64":"^1.0.1","rollup-plugin-glslify":"^1.2.0","rollup-plugin-node-polyfills":"^0.2.1","rollup-plugin-svg":"^2.0.0","rollup-plugin-terser":"^7.0.2","rollup-plugin-typescript2":"0.30.0","rollup-plugin-web-worker-loader":"^1.6.1","size-limit":"^5.0.3","standard-version":"^9.3.2","ts-jest":"^27.0.3",tsdx:"^0.14.1",tslib:"^2.3.1",typescript:"^4.4.2"}};const e=function(){if(!globalThis.navigator)return{isMobileDevice:!1,isIOSDevice:!1,browserName:"Node",webGLSupported:!1,deviceCategory:"High",hardwareConcurrency:4};const U=null!=(navigator.userAgent.match(/Android/i)||navigator.userAgent.match(/webOS/i)||navigator.userAgent.match(/iPhone/i)||navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPod/i)||navigator.userAgent.match(/BlackBerry/i)||navigator.userAgent.match(/Pixel/i)||navigator.userAgent.match(/Windows Phone/i)),F=function(){const U=navigator.userAgent;let F,e,t,Q=navigator.appName,l=""+parseFloat(navigator.appVersion),n=parseInt(navigator.appVersion,10);return navigator.brave?(Q="Brave",e=U.indexOf("Chrome"),l=U.substring(e+7,U.indexOf(" ",e+7))):-1!=(e=U.indexOf("Opera"))?(Q="Opera",l=U.substring(e+6),-1!=(e=U.indexOf("Version"))&&(l=U.substring(e+8))):-1!=(e=U.indexOf("MSIE"))?(Q="Microsoft Internet Explorer",l=U.substring(e+5)):-1!=(e=U.indexOf("Edge"))?(Q="Edge",l=U.substring(e+4)):-1!=(e=U.indexOf("Chrome"))?(Q="Chrome",l=U.substring(e+7,U.indexOf(" ",e+7))):-1!=(e=U.indexOf("Safari"))?(Q="Safari",l=U.substring(e+7),-1!=(e=U.indexOf("Version"))&&(l=U.substring(e+8))):-1!=(e=U.indexOf("Firefox"))?(Q="Firefox",l=U.substring(e+8)):(F=U.lastIndexOf(" ")+1)<(e=U.lastIndexOf("/"))&&(Q=U.substring(F,e),l=U.substring(e+1),Q.toLowerCase()==Q.toUpperCase()&&(Q=navigator.appName)),-1!=(t=l.indexOf(";"))&&(l=l.substring(0,t)),-1!=(t=l.indexOf(" "))&&(l=l.substring(0,t)),n=parseInt(""+l,10),isNaN(n)&&(l=""+parseFloat(navigator.appVersion),n=parseInt(navigator.appVersion,10)),{browserName:Q,fullVersion:l,majorVersion:n,appName:navigator.appName,userAgent:navigator.userAgent}}(),e=function(){let U,F;try{U=document.createElement("canvas").getContext("webgl")}catch(U){}if(!U)return{vendor:"Unknown",renderer:"Unknown",gpuVendor:"Unknown",maxTextureSize:0,supportsWebGL:!1,supportsWebGL2:!1};try{F=document.createElement("canvas").getContext("webgl2")}catch(U){}const e=U.getExtension("WEBGL_debug_renderer_info");if(!e)return console.warn("Unable to determine GPU Info:"),{vendor:"Unknown",renderer:"Unknown",gpuVendor:"Unknown",maxTextureSize:0,supportsWebGL:null!=U,supportsWebGL2:null!=F};const t=U.getParameter(e.UNMASKED_VENDOR_WEBGL),Q=U.getParameter(e.UNMASKED_RENDERER_WEBGL),l=U.getParameter(U.MAX_TEXTURE_SIZE);let n;return Q.match(/NVIDIA/i)?n="NVidia":Q.match(/AMD/i)||Q.match(/Radeon/i)?n="AMD":Q.match(/Intel/i)?n="Intel":Q.match(/Mali/i)?n="ARM":Q.match(/Apple/i)?n="Apple":Q.match(/Adreno/i)?n="Adreno":Q.match(/Swiftshader/i)?(n="Google",console.warn("Hardware rendering is disabled or not working on your system. Falling back to the Swiftshader. Expect poor performance:",Q)):console.warn("Unable to determine GPU vendor:",Q),{vendor:t,renderer:Q,gpuVendor:n,maxTextureSize:l,supportsWebGL:!0,supportsWebGL2:null!=F}}();let t="Low";if(e.supportsWebGL)if(U)t="Low";else{const U=e.renderer.replace(/[()]/g,"").split(" ");if("NVidia"==e.gpuVendor){const F=U.indexOf("GTX");if(-1!=F){const e=U[F+1];if(e.endsWith("M")){t=parseInt(e.substring(0,e.length-2))>=900?"Medium":"Low"}else{t=parseInt(e)>=1030?"High":"Medium"}}else t=U.includes("RTX")||U.includes("TITAN")||U.includes("Quadro")?"High":"Low"}else if("AMD"==e.gpuVendor){const F=U.indexOf("Radeon");if(-1!=F){const e=U.indexOf("RX");if(-1!=e)if("Vega"==U[e+1])t="High";else{const F=U[e+1];let Q;F.endsWith("X")?(Q=parseInt(F.substring(0,F.length-2)),t="High"):Q=parseInt(F),t=Q>=480?"High":"Medium"}else if("Pro"==U[F+1]){t=parseInt(U[e+1])>=450?"Medium":"Low"}else if("Sky"==U[F+1]){t=parseInt(U[e+1])>=700?"Medium":"Low"}else t="Low"}else t=U.includes("FirePro")||U.includes("Quadro")?"High":"Low"}else("Adreno"==e.gpuVendor||"Intel"==e.gpuVendor||"Google"==e.gpuVendor)&&(t="Low")}let Q=globalThis.navigator.hardwareConcurrency;return Q||(Q=U?4:6),{isMobileDevice:U,isIOSDevice:null!=(navigator.userAgent.match(/iPhone/i)||navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPod/i)),browserName:F.browserName,fullVersion:F.fullVersion,majorVersion:F.majorVersion,appName:F.appName,userAgent:F.userAgent,webGLSupported:e.supportsWebGL,gpuDesc:e,deviceCategory:t,hardwareConcurrency:Q}}();globalThis.ZeaSystemDesc||(globalThis.ZeaSystemDesc=e);let t={},Q={},l=[];class n{static register(U,F){U in t&&console.warn(`There's a class registered with '${U}' name`);const e=l.length;l.push(F),Q[e]=U,t[U]=e}static getClassDefinition(U){if(!(U in t))throw new Error(`${U} class is not registered`);return l[t[U]]}static getClassName(U){const F=l.indexOf(U);if(F>=0&&Q[F])return Q[F];throw new Error("class is not registered")}static constructClass(U){const F=l[t[U]];if(!F)throw new Error(`${U} class is not registered`);return new F}static flush(){t={},Q={},l=[]}}class a{static replaceAll(U,F,e){return U.replace(new RegExp(F,"g"),e)}static stringifyJSONWithFixedPrecision(U,F=0,e=5){return JSON.stringify(U,((U,F)=>F&&F.toFixed?Number(F.toFixed(e)):F),F)}static hashStr(U){let F,e,t,Q=0;if(0===U.length)return Q;for(F=0,t=U.length;F<t;F++)e=U.charCodeAt(F),Q=(Q<<5)-Q+e,Q|=0;return Math.abs(Q)}}class d{constructor(U=0,F=0){U instanceof Float32Array||U instanceof Uint32Array||U instanceof Int32Array?this.__data=U:"number"==typeof U&&"number"==typeof F?(this.__data=new Float32Array(2),this.__data[0]=U,this.__data[1]=F):"object"==typeof U?(this.__data=new Float32Array(2),this.fromJSON(U)):this.__data=new Float32Array(2)}get x(){return this.__data[0]}set x(U){this.__data[0]=U}get y(){return this.__data[1]}set y(U){this.__data[1]=U}set(U,F){this.__data[0]=U,this.__data[1]=F}setFromOther(U){this.x=U.x,this.y=U.y}isEqual(U){return this.x==U.x&&this.y==U.y}notEqual(U){return this.x!=U.x&&this.y!=U.y}approxEqual(U,F=Number.EPSILON){return Math.abs(this.x-U.x)<F&&Math.abs(this.y-U.y)<F}add(U){return new d(this.x+U.x,this.y+U.y)}addInPlace(U){this.x+=U.x,this.y+=U.y}subtract(U){return new d(this.x-U.x,this.y-U.y)}subtractInPlace(U){return this.x-=U.x,this.y-=U.y,this}scale(U){return new d(this.x*U,this.y*U)}scaleInPlace(U){this.x*=U,this.y*=U}invert(){return new d(1/this.x,1/this.y)}invertInPlace(){return this.x=1/this.x,this.y=1/this.y,this}multiply(U){return new d(this.x*U.x,this.y*U.y)}multiplyInPlace(U){this.x*=U.x,this.y*=U.y}lengthSquared(){const U=this.__data[0],F=this.__data[1];return U*U+F*F}length(){return Math.sqrt(this.lengthSquared())}distanceTo(U){const F=this.__data[0]-U.x,e=this.__data[1]-U.y;return Math.sqrt(F*F+e*e)}normalize(){const U=this.__data[0],F=this.__data[1];let e=U*U+F*F;return e<Number.EPSILON?new d:(e=1/Math.sqrt(e),new d(U*e,F*e))}normalizeInPlace(){const U=this.__data[0],F=this.__data[1];let e=U*U+F*F;e<Number.EPSILON||(e=1/Math.sqrt(e),this.set(U*e,F*e))}dot(U){return this.x*U.x+this.y*U.y}cross(U){return this.x*U.y-this.y*U.x}angleTo(U){const F=this.normalize().dot(U.normalize());return F>1?0:F<-1?Math.PI:Math.acos(F)}signedAngleTo(U){const F=this.angleTo(U);return this.cross(U)<0?-F:F}rotate(U){const F=Math.cos(U),e=Math.sin(U);return new d(this.x*F-this.y*e,this.x*e+this.y*F)}lerp(U,F){const e=this.x,t=this.y;return new d(e+F*(U.x-e),t+F*(U.y-t))}setRandomDir(U=1){const F=2*Math.random()*Math.PI;return this.__data[0]=Math.cos(F)*U,this.__data[1]=Math.sin(F)*U,this}setRandom(U=1){return this.__data[0]=Math.random()*U,this.__data[1]=Math.random()*U,this}clone(){return new d(this.__data[0],this.__data[1])}asArray(){return this.__data}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}toJSON(){return{x:this.x,y:this.y}}fromJSON(U){this.x=U.x,this.y=U.y}readBinary(U){this.x=U.loadFloat32(),this.y=U.loadFloat32()}static intersectionOfLines(U,F,e,t){const Q=(U.x-F.x)*(e.y-t.y)-(U.y-F.y)*(e.x-t.x);if(0==Q)return null;const l=U.x*F.y-U.y*F.x,n=e.x*t.y-e.y*t.x,a=e.x-t.x,i=U.x-F.x,s=e.y-t.y,R=U.y-F.y;return new d((l*a-i*n)/Q,(l*s-R*n)/Q)}isValid(){for(const U of this.__data)if(U==1/0||isNaN(U))return!1;return!0}}class i{constructor(U=0,F=0,e=0){if(U instanceof Float32Array||U instanceof Uint32Array)this.__data=U;else if(U instanceof ArrayBuffer){console.warn("deprecated, please use new Vec3(new Float32Array(buffer, byteOffset, 3))");const e=U,t=F;this.__data=new Float32Array(e,t,3)}else"number"==typeof U&&"number"==typeof F&&"number"==typeof e?(this.__data=new Float32Array(3),this.__data[0]=U,this.__data[1]=F,this.__data[2]=e):null!=U&&"object"==typeof U?(this.__data=new Float32Array(3),this.fromJSON(U)):this.__data=new Float32Array(3)}get x(){return this.__data[0]}set x(U){this.__data[0]=U}get y(){return this.__data[1]}set y(U){this.__data[1]=U}get z(){return this.__data[2]}set z(U){this.__data[2]=U}get xy(){return new d(this.__data[0],this.__data[1])}get yz(){return new d(this.__data[1],this.__data[2])}set(U,F,e){this.x=U,this.y=void 0!==F?F:U,this.z=void 0!==e?e:U}setDataArray(U){this.__data=U}setFromOther(U){this.x=U.x,this.y=U.y,this.z=U.z}isNull(){return Math.abs(this.x)<Number.EPSILON&&Math.abs(this.y)<Number.EPSILON&&Math.abs(this.z)<Number.EPSILON}is111(){return Math.abs(1-this.x)<Number.EPSILON&&Math.abs(1-this.y)<Number.EPSILON&&Math.abs(1-this.z)<Number.EPSILON}isEqual(U){return this.x==U.x&&this.y==U.y&&this.z==U.z}notEqual(U){return this.x!=U.x&&this.y!=U.y&&this.z!=U.z}approxEqual(U,F=Number.EPSILON){return Math.abs(this.x-U.x)<F&&Math.abs(this.y-U.y)<F&&Math.abs(this.z-U.z)<F}add(U){return new i(this.x+U.x,this.y+U.y,this.z+U.z)}addInPlace(U){this.x+=U.x,this.y+=U.y,this.z+=U.z}subtract(U){return new i(this.x-U.x,this.y-U.y,this.z-U.z)}subtractInPlace(U){this.x-=U.x,this.y-=U.y,this.z-=U.z}multiply(U){return new i(this.x*U.x,this.y*U.y,this.z*U.z)}multiplyInPlace(U){this.x*=U.x,this.y*=U.y,this.z*=U.z}divide(U){return new i(this.x/U.x,this.y/U.y,this.z/U.z)}divideInPlace(U){this.x/=U.x,this.y/=U.y,this.z/=U.z}scale(U){return new i(this.x*U,this.y*U,this.z*U)}scaleInPlace(U){this.x*=U,this.y*=U,this.z*=U}negate(){return new i(-this.x,-this.y,-this.z)}inverse(){return new i(1/this.x,1/this.y,1/this.z)}lengthSquared(){const U=this.__data[0],F=this.__data[1],e=this.__data[2];return U*U+F*F+e*e}length(){return Math.sqrt(this.lengthSquared())}distanceTo(U){const F=this.__data[0]-U.x,e=this.__data[1]-U.y,t=this.__data[2]-U.z;return Math.sqrt(F*F+e*e+t*t)}normalize(){let U=this.__data[0]*this.__data[0]+this.__data[1]*this.__data[1]+this.__data[2]*this.__data[2];return U<Number.EPSILON?new i:(U=1/Math.sqrt(U),new i(this.__data[0]*U,this.__data[1]*U,this.__data[2]*U))}normalizeInPlace(){let U=this.__data[0]*this.__data[0]+this.__data[1]*this.__data[1]+this.__data[2]*this.__data[2];if(U<Number.EPSILON)return;U=Math.sqrt(U);const F=1/U;return this.__data[0]*=F,this.__data[1]*=F,this.__data[2]*=F,U}resize(U){const F=this.__data[0]*this.__data[0]+this.__data[1]*this.__data[1]+this.__data[2]*this.__data[2];if(F<Number.EPSILON)return;const e=U/Math.sqrt(F);return new i(this.__data[0]*e,this.__data[1]*e,this.__data[2]*e)}resizeInPlace(U){const F=this.__data[0]*this.__data[0]+this.__data[1]*this.__data[1]+this.__data[2]*this.__data[2];if(F<Number.EPSILON)return;const e=U/Math.sqrt(F);this.__data[0]*=e,this.__data[1]*=e,this.__data[2]*=e}dot(U){return this.x*U.x+this.y*U.y+this.z*U.z}cross(U){const F=this.x,e=this.y,t=this.z,Q=U.x,l=U.y,n=U.z;return new i(e*n-t*l,t*Q-F*n,F*l-e*Q)}angleTo(U){const F=this.dot(U);return F>1?0:Math.acos(F)}lerp(U,F){const e=this.x,t=this.y,Q=this.z;return new i(e+F*(U.x-e),t+F*(U.y-t),Q+F*(U.z-Q))}abs(){return new i(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}setRandomDir(U=1){const F=2*Math.random()*Math.PI,e=2*Math.random()-1,t=Math.sqrt(1-e*e)*U;return this.__data[0]=Math.cos(F)*t,this.__data[1]=Math.sin(F)*t,this.__data[2]=e*U,this}setRandom(U=1){return this.__data[0]=(Math.random()-.5)*U,this.__data[1]=(Math.random()-.5)*U,this.__data[2]=(Math.random()-.5)*U,this}clone(){return new i(this.__data[0],this.__data[1],this.__data[2])}asArray(){return this.__data}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}toJSON(){return{x:this.x,y:this.y,z:this.z}}fromJSON(U){this.x=U.x,this.y=U.y,this.z=U.z}readBinary(U){this.x=U.loadFloat32(),this.y=U.loadFloat32(),this.z=U.loadFloat32()}isValid(){for(const U of this.__data)if(U==1/0||isNaN(U))return!1;return!0}}class s{constructor(U=0,F=0,e=0,t=0){if(U instanceof Float32Array||U instanceof Uint32Array)this.__data=U;else if(U instanceof ArrayBuffer){console.warn("deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))");const e=U,t=F;this.__data=new Float32Array(e,t,4)}else"number"==typeof U&&"number"==typeof F&&"number"==typeof e&&"number"==typeof t?(this.__data=new Float32Array(4),this.__data[0]=U,this.__data[1]=F,this.__data[2]=e,this.__data[3]=t):null!=U&&"object"==typeof U?(this.__data=new Float32Array(4),this.fromJSON(U)):this.__data=new Float32Array(4)}get x(){return this.__data[0]}set x(U){this.__data[0]=U}get y(){return this.__data[1]}set y(U){this.__data[1]=U}get z(){return this.__data[2]}set z(U){this.__data[2]=U}get t(){return this.__data[3]}set t(U){this.__data[3]=U}get w(){return this.__data[3]}set w(U){this.__data[3]=U}get xyz(){return new i(this.__data[0],this.__data[1],this.__data[2])}set(U,F,e,t){this.x=U,this.y=F,this.z=e,this.t=t}setFromOther(U){this.x=U.x,this.y=U.y,this.z=U.z,this.t=U.t}isEqual(U){return this.x==U.x&&this.y==U.y&&this.z==U.z&&this.t==U.t}notEqual(U){return this.x!=U.x&&this.y!=U.y&&this.z!=U.z&&this.t!=U.t}approxEqual(U,F=Number.EPSILON){return Math.abs(this.x-U.x)<F&&Math.abs(this.y-U.y)<F&&Math.abs(this.z-U.z)<F&&Math.abs(this.t-U.t)<F}add(U){return new s(this.x+U.x,this.y+U.y,this.z+U.z,this.t+U.t)}addInPlace(U){this.x+=U.x,this.y+=U.y,this.z+=U.z,this.t+=U.t}subtract(U){return new s(this.x-U.x,this.y-U.y,this.z-U.z,this.t-U.t)}subtractInPlace(U){this.x-=U.x,this.y-=U.y,this.z-=U.z,this.t-=U.t}multiply(U){return new s(this.x*U.x,this.y*U.y,this.z*U.z,this.t*U.t)}multiplyInPlace(U){this.x*=U.x,this.y*=U.y,this.z*=U.z,this.t*=U.t}divide(U){return new s(this.x/U.x,this.y/U.y,this.z/U.z,this.t/U.t)}divideInPlace(U){this.x/=U.x,this.y/=U.y,this.z/=U.z,this.t/=U.t}scale(U){return new s(this.x*U,this.y*U,this.z*U,this.t*U)}scaleInPlace(U){this.set(this.x*U,this.y*U,this.z*U,this.t*U)}length(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[2];return Math.sqrt(U*U+F*F+e*e+t*t)}lengthSquared(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3];return U*U+F*F+e*e+t*t}normalize(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3];let Q=U*U+F*F+e*e+t*t;return Q<Number.EPSILON?new s:(Q=1/Math.sqrt(Q),new s(U*Q,F*Q,e*Q))}normalizeInPlace(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3];let Q=U*U+F*F+e*e+t*t;Q<Number.EPSILON||(Q=1/Math.sqrt(Q),this.set(U*Q,F*Q,e*Q,t*Q))}dot(U){return this.x*U.x+this.y*U.y+this.z*U.z+this.t*U.t}cross(U){const F=this.x,e=this.y,t=this.z,Q=this.t,l=U.x,n=U.y,a=U.z,d=U.t;return new s(e*a-t*n,t*d-Q*a,Q*l-F*d,F*n-e*l)}angleTo(U){const F=this.normalize(),e=U.normalize(),t=F.dot(e);return t>1?0:Math.acos(t)}lerp(U,F){const e=this.x,t=this.y,Q=this.z,l=this.t;return new s(e+F*(U.x-e),t+F*(U.y-t),Q+F*(U.z-Q),l+F*(U.t-l))}clone(){return new s(this.__data[0],this.__data[1],this.__data[2],this.__data[3])}toVec3(){return new i(this.__data[0],this.__data[1],this.__data[2])}asArray(){return this.__data}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}toJSON(){return{x:this.x,y:this.y,z:this.z,t:this.t}}fromJSON(U){this.x=U.x,this.y=U.y,this.z=U.z,this.t=U.t}readBinary(U){this.x=U.loadFloat32(),this.y=U.loadFloat32(),this.z=U.loadFloat32(),this.t=U.loadFloat32()}isValid(){for(const U of this.__data)if(U==1/0||isNaN(U))return!1;return!0}}class R{constructor(U=0,F=0,e=0,t=255){if(U instanceof Uint8Array)this.__data=U;else if(U instanceof ArrayBuffer){const e=U,t=F;this.__data=new Uint8Array(e,t,4)}else this.__data=new Uint8Array(4),"string"==typeof U?U.startsWith("#")?this.setFromHex(U):this.setFromCSSColorName(U):(this.__data[0]=U,this.__data[1]=F,this.__data[2]=e,this.__data[3]=t)}get r(){return this.__data[0]}set r(U){this.__data[0]=U}get g(){return this.__data[1]}set g(U){this.__data[1]=U}get b(){return this.__data[2]}set b(U){this.__data[2]=U}get a(){return this.__data[3]}set a(U){this.__data[3]=U}set(U,F,e,t=255){this.r=U,this.g=F,this.b=e,this.a=t}setFromOther(U){this.r=U.r,this.g=U.g,this.b=U.b,this.a=U.a}setFromArray(U){this.r=U[0],this.g=U[1],this.b=U[2],this.a=4==U.length?U[3]:1}setFromHex(U){const F=function(U){const F=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(U);return F?{r:parseInt(F[1],16),g:parseInt(F[2],16),b:parseInt(F[3],16)}:null}(U);F?this.set(F.r,F.g,F.b):console.warn("Invalid hex code:"+U)}setFromCSSColorName(U){if(U.startsWith("#"))this.setFromHex(U);else{const F={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4","indianred ":"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"}[U.toLowerCase()];F&&this.setFromHex(F)}}toHex(){function U(U){const F=U.toString(16);return 1==F.length?"0"+F:F}return"#"+U(this.r)+U(this.g)+U(this.b)}equal(U){return this.r==U.r&&this.g==U.g&&this.b==U.b&&this.a==U.a}notEquals(U){return this.r!=U.r&&this.g!=U.g&&this.b!=U.b&&this.a!=U.a}approxEqual(U,F=Number.EPSILON){return Math.abs(this.r-U.r)<F&&Math.abs(this.g-U.g)<F&&Math.abs(this.b-U.b)<F&&Math.abs(this.a-U.a)<F}add(U){return new R(this.r+U.r,this.g+U.g,this.b+U.b,this.a+U.a)}subtract(U){return new R(this.r-U.r,this.g-U.g,this.b-U.b,this.a-U.a)}scale(U){return new R(this.r*U,this.g*U,this.b*U,this.a*U)}scaleInPlace(U){this.r*=U,this.g*=U,this.b*=U,this.a*=U}applyGamma(U){this.set(Math.pow(this.r,U),Math.pow(this.g,U),Math.pow(this.b,U),this.a)}toLinear(U=2.2){return new R(Math.pow(this.r,U),Math.pow(this.g,U),Math.pow(this.b,U),this.a)}toGamma(U=2.2){return new R(Math.pow(this.r,1/U),Math.pow(this.g,1/U),Math.pow(this.b,1/U),this.a)}luminance(){return.2126*this.r+.7152*this.g+.0722*this.b}lerp(U,F){const e=this.r,t=this.g,Q=this.b,l=this.a;return new R(e+F*(U.r-e),t+F*(U.g-t),Q+F*(U.b-Q),l+F*(U.a-l))}static random(U=0,F=!1){return U>0?new R(U+Math.random()*(1-U),U+Math.random()*(1-U),U+Math.random()*(1-U),F?U+Math.random()*(1-U):1):U<0?new R(Math.random()*(1+U),Math.random()*(1+U),Math.random()*(1+U),F?Math.random()*(1+U):1):new R(Math.random(),Math.random(),Math.random(),F?Math.random():1)}clone(){return new R(this.__data[0],this.__data[1],this.__data[2],this.__data[3])}asArray(){return this.__data}as3ComponentArray(){return[this.__data[0],this.__data[1],this.__data[2]]}toJSON(){return{r:this.r,g:this.g,b:this.b,a:this.a}}fromJSON(U){this.r=U.r,this.g=U.g,this.b=U.b,this.a=U.a}toCSSString(){return"rgba("+Math.round(255*this.r)+", "+Math.round(255*this.g)+", "+Math.round(255*this.b)+", "+this.a+")"}}class B{constructor(U=0,F=0,e=0,t=1){if(U instanceof Float32Array)this.__data=U;else if(U instanceof ArrayBuffer){console.warn("deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))");const e=U,t=F;this.__data=new Float32Array(e,t,4)}else this.__data=new Float32Array(4),"string"==typeof U?U.startsWith("#")?this.setFromHex(U):this.setFromCSSColorName(U):(this.__data[0]=U,this.__data[1]=F,this.__data[2]=e,this.__data[3]=t)}get r(){return this.__data[0]}set r(U){this.__data[0]=U}get g(){return this.__data[1]}set g(U){this.__data[1]=U}get b(){return this.__data[2]}set b(U){this.__data[2]=U}get a(){return this.__data[3]}set a(U){this.__data[3]=U}set(U,F,e,t=1){this.r=U,this.g=F,this.b=e,this.a=t}setFromOther(U){this.r=U.r,this.g=U.g,this.b=U.b,this.a=U.a}setFromScalarArray(U){this.r=U[0],this.g=U[1],this.b=U[2],this.a=4==U.length?U[3]:1}getAsRGBArray(){return[255*this.r,255*this.g,255*this.b]}getAsRGBDict(){return{r:255*this.r,g:255*this.g,b:255*this.b}}setFromRGB(U,F,e,t){this.r=U/255,this.g=F/255,this.b=e/255,this.a=t?t/255:1}setFromRGBArray(U){this.r=U[0]/255,this.g=U[1]/255,this.b=U[2]/255,this.a=4==U.length?U[3]/255:1}setFromRGBDict(U){this.r=U.r/255,this.g=U.g/255,this.b=U.b/255,this.a=4==U.a?U.a/255:1}setFromHex(U){const F=function(U){const F=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(U);return F?{r:parseInt(F[1],16),g:parseInt(F[2],16),b:parseInt(F[3],16)}:null}(U);F?this.setFromRGB(F.r,F.g,F.b):console.warn("Invalid hex code:"+U)}setFromCSSColorName(U){if(U.startsWith("#"))this.setFromHex(U);else{const F={aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",gray:"#808080",green:"#008000",greenyellow:"#adff2f",honeydew:"#f0fff0",hotpink:"#ff69b4","indianred ":"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgrey:"#d3d3d3",lightgreen:"#90ee90",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370d8",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ffa500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#d87093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",purple:"#800080",rebeccapurple:"#663399",red:"#ff0000",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5f5",yellow:"#ffff00",yellowgreen:"#9acd32"}[U.toLowerCase()];F&&this.setFromHex(F)}}toHex(){function U(U){const F=Math.round(255*U).toString(16);return 1==F.length?"0"+F:F}return"#"+U(this.r)+U(this.g)+U(this.b)}isEqual(U){return this.r==U.r&&this.g==U.g&&this.b==U.b&&this.a==U.a}notEquals(U){return this.r!=U.r&&this.g!=U.g&&this.b!=U.b&&this.a!=U.a}approxEqual(U,F=Number.EPSILON){return Math.abs(this.r-U.r)<F&&Math.abs(this.g-U.g)<F&&Math.abs(this.b-U.b)<F&&Math.abs(this.a-U.a)<F}add(U){return new B(this.r+U.r,this.g+U.g,this.b+U.b,this.a+U.a)}addInPlace(U){this.r+=U.r,this.g+=U.g,this.b+=U.b,this.a+=U.a}subtract(U){return new B(this.r-U.r,this.g-U.g,this.b-U.b,this.a-U.a)}scale(U){return new B(this.r*U,this.g*U,this.b*U,this.a*U)}scaleInPlace(U){this.r*=U,this.g*=U,this.b*=U,this.a*=U}applyGamma(U){this.set(Math.pow(this.r,U),Math.pow(this.g,U),Math.pow(this.b,U),this.a)}toLinear(U=2.2){return new B(Math.pow(this.r,U),Math.pow(this.g,U),Math.pow(this.b,U),this.a)}toGamma(U=2.2){return new B(Math.pow(this.r,1/U),Math.pow(this.g,1/U),Math.pow(this.b,1/U),this.a)}luminance(){return.2126*this.r+.7152*this.g+.0722*this.b}lerp(U,F){const e=this.r,t=this.g,Q=this.b,l=this.a;return new B(e+F*(U.r-e),t+F*(U.g-t),Q+F*(U.b-Q),l+F*(U.a-l))}static random(U=0,F=!1){return U>0?new B(U+Math.random()*(1-U),U+Math.random()*(1-U),U+Math.random()*(1-U),F?U+Math.random()*(1-U):1):U<0?new B(Math.random()*(1+U),Math.random()*(1+U),Math.random()*(1+U),F?Math.random()*(1+U):1):new B(Math.random(),Math.random(),Math.random(),F?Math.random():1)}clone(){return new B(this.__data[0],this.__data[1],this.__data[2],this.__data[3])}asArray(){return this.__data}as3ComponentArray(){return[this.__data[0],this.__data[1],this.__data[2]]}toJSON(){return{r:this.r,g:this.g,b:this.b,a:this.a}}fromJSON(U){this.r=U.r,this.g=U.g,this.b=U.b,this.a=U.a}readBinary(U){this.r=U.loadFloat32(),this.g=U.loadFloat32(),this.b=U.loadFloat32(),this.a=U.loadFloat32()}toCSSString(){return"rgba("+Math.round(255*this.r)+", "+Math.round(255*this.g)+", "+Math.round(255*this.b)+", "+this.a+")"}}class V{constructor(U=0,F=0,e=0,t=0){if("number"!=typeof t||isNaN(t))switch(t){case"XYZ":this.order=0;break;case"YZX":this.order=1;break;case"ZXY":this.order=2;break;case"XZY":this.order=3;break;case"ZYX":this.order=4;break;case"YXZ":this.order=5;break;default:throw new Error("Invalid Euler Angles Order:"+t)}else this.order=t;if(U instanceof ArrayBuffer){const e=U,t=F;this.__data=new Float32Array(e,t,4)}else this.__data=new Float32Array(3),this.__data[0]=U,this.__data[1]=F,this.__data[2]=e}get x(){return this.__data[0]}set x(U){this.__data[0]=U}get y(){return this.__data[1]}set y(U){this.__data[1]=U}get z(){return this.__data[2]}set z(U){this.__data[2]=U}set(U,F,e){this.__data[0]=U,this.__data[1]=F,this.__data[2]=e}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}toJSON(){return{x:this.__data[0],y:this.__data[1],z:this.__data[2],order:this.order}}fromJSON(U){this.__data[0]=U.x,this.__data[1]=U.y,this.__data[2]=U.z,this.order=U.order}}class r{constructor(U=1,F=0,e=0,t=0,Q=1,l=0,n=0,a=0,d=1){if(U instanceof i&&F instanceof i&&e instanceof i)this.__data=new Float32Array(9),this.set(U.x,U.y,U.z,F.x,F.y,F.z,e.x,e.y,e.z);else if(U instanceof Float32Array)this.__data=U;else if(U instanceof ArrayBuffer){console.warn("Deprecated, please use new Vec3(new Float32Array(buffer, byteOffset, 9))");const e=U,t=F;this.__data=new Float32Array(e,t,9)}else this.__data=new Float32Array(9),this.set(U,F,e,t,Q,l,n,a,d)}get m00(){return this.__data[0]}set m00(U){this.__data[0]=U}get m01(){return this.__data[1]}set m01(U){this.__data[1]=U}get m02(){return this.__data[2]}set m02(U){this.__data[2]=U}get m10(){return this.__data[3]}set m10(U){this.__data[3]=U}get m11(){return this.__data[4]}set m11(U){this.__data[4]=U}get m12(){return this.__data[5]}set m12(U){this.__data[5]=U}get m20(){return this.__data[6]}set m20(U){this.__data[6]=U}get m21(){return this.__data[7]}set m21(U){this.__data[7]=U}get m22(){return this.__data[8]}set m22(U){this.__data[8]=U}get xAxis(){return new i(new Float32Array(this.__data.buffer,0,3))}set xAxis(U){this.xAxis.set(U.x,U.y,U.z)}get yAxis(){return new i(new Float32Array(this.__data.buffer,12,3))}set yAxis(U){this.yAxis.set(U.x,U.y,U.z)}get zAxis(){return new i(new Float32Array(this.__data.buffer,24,3))}set zAxis(U){this.zAxis.set(U.x,U.y,U.z)}set(U=1,F=0,e=0,t=0,Q=1,l=0,n=0,a=0,d=1){this.__data[0]=U,this.__data[1]=F,this.__data[2]=e,this.__data[3]=t,this.__data[4]=Q,this.__data[5]=l,this.__data[6]=n,this.__data[7]=a,this.__data[8]=d}setIdentity(){this.set()}setFromMat(U){this.__data[0]=U.m00,this.__data[1]=U.m01,this.__data[2]=U.m02,this.__data[3]=U.m10,this.__data[4]=U.m11,this.__data[5]=U.m12,this.__data[6]=U.m20,this.__data[7]=U.m21,this.__data[8]=U.m22}setFromDirectionAndUpvector(U,F){const e=U,t=e.length();if(t<Number.EPSILON)return void this.setIdentity();e.scaleInPlace(1/t);const Q=F.cross(e),l=Q.length();l>Number.EPSILON&&Q.scaleInPlace(1/l);const n=e.cross(Q),a=n.length();a>Number.EPSILON&&n.scaleInPlace(1/a),this.set(Q.x,Q.y,Q.z,n.x,n.y,n.z,e.x,e.y,e.z)}inverse(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3],Q=this.__data[4],l=this.__data[5],n=this.__data[6],a=this.__data[7],d=this.__data[8],i=d*Q-l*a,s=-d*t+l*n,R=a*t-Q*n;let B=U*i+F*s+e*R;return B?(B=1/B,new r(i*B,(-d*F+e*a)*B,(l*F-e*Q)*B,s*B,(d*U-e*n)*B,(-l*U+e*t)*B,R*B,(-a*U+F*n)*B,(Q*U-F*t)*B)):(console.warn("Unable to invert Mat3"),new r)}invertInPlace(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3],Q=this.__data[4],l=this.__data[5],n=this.__data[6],a=this.__data[7],d=this.__data[8],i=d*Q-l*a,s=-d*t+l*n,R=a*t-Q*n;let B=U*i+F*s+e*R;return B?(B=1/B,this.set(i*B,(-d*F+e*a)*B,(l*F-e*Q)*B,s*B,(d*U-e*n)*B,(-l*U+e*t)*B,R*B,(-a*U+F*n)*B,(Q*U-F*t)*B),!0):(console.warn("Unable to invert Mat3"),!1)}transpose(){return new r(this.__data[0],this.__data[3],this.__data[6],this.__data[1],this.__data[4],this.__data[7],this.__data[2],this.__data[5],this.__data[8])}transposeInPlace(){const U=this.__data[1],F=this.__data[2],e=this.__data[5];this.__data[1]=this.__data[3],this.__data[2]=this.__data[6],this.__data[3]=U,this.__data[5]=this.__data[7],this.__data[6]=F,this.__data[7]=e}transformVec3(U){return new i(this.__data[0]*U.x+this.__data[1]*U.y+this.__data[2]*U.z,this.__data[3]*U.x+this.__data[4]*U.y+this.__data[5]*U.z,this.__data[6]*U.x+this.__data[7]*U.y+this.__data[8]*U.z)}clone(){return new r(this.__data[0],this.__data[1],this.__data[2],this.__data[3],this.__data[4],this.__data[5],this.__data[6],this.__data[7],this.__data[8])}readBinary(U){this.__data=U.loadFloat32Array(9)}toJSON(){return this.__data}fromJSON(U){this.__data=new Float32Array(U)}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}asArray(){return this.__data}}class h{constructor(U=1,F=0,e=0,t=0,Q=0,l=1,n=0,a=0,d=0,i=0,s=1,R=0,B=0,V=0,r=0,h=1){if(U instanceof Float32Array)this.__data=U;else if(U instanceof ArrayBuffer){const e=U,t=F;this.__data=new Float32Array(e,t,16)}else this.__data=new Float32Array(16),this.set(U,F,e,t,Q,l,n,a,d,i,s,R,B,V,r,h)}get m00(){return this.__data[0]}set m00(U){this.__data[0]=U}get m01(){return this.__data[1]}set m01(U){this.__data[1]=U}get m02(){return this.__data[2]}set m02(U){this.__data[2]=U}get m03(){return this.__data[3]}set m03(U){this.__data[3]=U}get m10(){return this.__data[4]}set m10(U){this.__data[4]=U}get m11(){return this.__data[5]}set m11(U){this.__data[5]=U}get m12(){return this.__data[6]}set m12(U){this.__data[6]=U}get m13(){return this.__data[7]}set m13(U){this.__data[7]=U}get m20(){return this.__data[8]}set m20(U){this.__data[8]=U}get m21(){return this.__data[9]}set m21(U){this.__data[9]=U}get m22(){return this.__data[10]}set m22(U){this.__data[10]=U}get m23(){return this.__data[11]}set m23(U){this.__data[11]=U}get m30(){return this.__data[12]}set m30(U){this.__data[12]=U}get m31(){return this.__data[13]}set m31(U){this.__data[13]=U}get m32(){return this.__data[14]}set m32(U){this.__data[14]=U}get m33(){return this.__data[15]}set m33(U){this.__data[15]=U}get xAxis(){return new i(new Float32Array(this.__data.buffer,0,3))}set xAxis(U){this.xAxis.set(U.x,U.y,U.z)}get yAxis(){return new i(new Float32Array(this.__data.buffer,16,3))}set yAxis(U){this.yAxis.set(U.x,U.y,U.z)}get zAxis(){return new i(new Float32Array(this.__data.buffer,32,3))}set zAxis(U){this.zAxis.set(U.x,U.y,U.z)}get translation(){return new i(new Float32Array(this.__data.buffer,48,3))}set translation(U){this.translation.set(U.x,U.y,U.z)}set(U=1,F=0,e=0,t=0,Q=0,l=1,n=0,a=0,d=0,i=0,s=1,R=0,B=0,V=0,r=0,h=1){this.__data[0]=U,this.__data[1]=F,this.__data[2]=e,this.__data[3]=t,this.__data[4]=Q,this.__data[5]=l,this.__data[6]=n,this.__data[7]=a,this.__data[8]=d,this.__data[9]=i,this.__data[10]=s,this.__data[11]=R,this.__data[12]=B,this.__data[13]=V,this.__data[14]=r,this.__data[15]=h}setIdentity(){this.set()}setDataArray(U){this.__data=U}setFromMat4(U){this.__data[0]=U.m00,this.__data[1]=U.m01,this.__data[2]=U.m02,this.__data[3]=U.m03,this.__data[4]=U.m10,this.__data[5]=U.m11,this.__data[6]=U.m12,this.__data[7]=U.m13,this.__data[8]=U.m20,this.__data[9]=U.m21,this.__data[10]=U.m22,this.__data[11]=U.m23,this.__data[12]=U.m30,this.__data[13]=U.m31,this.__data[14]=U.m32,this.__data[15]=U.m33}toMat3(){return new r(this.__data[0],this.__data[1],this.__data[2],this.__data[4],this.__data[5],this.__data[6],this.__data[8],this.__data[9],this.__data[10])}transposeInPlace(){const U=this.__data[1],F=this.__data[2],e=this.__data[3],t=this.__data[6],Q=this.__data[7],l=this.__data[11];this.__data[1]=this.__data[4],this.__data[2]=this.__data[8],this.__data[3]=this.__data[12],this.__data[4]=U,this.__data[6]=this.__data[9],this.__data[7]=this.__data[13],this.__data[8]=F,this.__data[9]=t,this.__data[11]=this.__data[14],this.__data[12]=e,this.__data[13]=Q,this.__data[14]=l}transpose(){return new h(this.__data[0],this.__data[4],this.__data[8],this.__data[12],this.__data[1],this.__data[5],this.__data[9],this.__data[13],this.__data[2],this.__data[6],this.__data[10],this.__data[14],this.__data[3],this.__data[7],this.__data[11],this.__data[15])}inverse(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3],Q=this.__data[4],l=this.__data[5],n=this.__data[6],a=this.__data[7],d=this.__data[8],i=this.__data[9],s=this.__data[10],R=this.__data[11],B=this.__data[12],V=this.__data[13],r=this.__data[14],o=this.__data[15],J=U*l-F*Q,Z=U*n-e*Q,c=U*a-t*Q,m=F*n-e*l,S=F*a-t*l,W=e*a-t*n,E=d*V-i*B,p=d*r-s*B,u=d*o-R*B,N=i*r-s*V,k=i*o-R*V,b=s*o-R*r;let C=J*b-Z*k+c*N+m*u-S*p+W*E;return C?(C=1/C,new h((l*b-n*k+a*N)*C,(e*k-F*b-t*N)*C,(V*W-r*S+o*m)*C,(s*S-i*W-R*m)*C,(n*u-Q*b-a*p)*C,(U*b-e*u+t*p)*C,(r*c-B*W-o*Z)*C,(d*W-s*c+R*Z)*C,(Q*k-l*u+a*E)*C,(F*u-U*k-t*E)*C,(B*S-V*c+o*J)*C,(i*c-d*S-R*J)*C,(l*p-Q*N-n*E)*C,(U*N-F*p+e*E)*C,(V*Z-B*m-r*J)*C,(d*m-i*Z+s*J)*C)):(console.warn("Unable to invert Mat4"),this)}invertInPlace(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3],Q=this.__data[4],l=this.__data[5],n=this.__data[6],a=this.__data[7],d=this.__data[8],i=this.__data[9],s=this.__data[10],R=this.__data[11],B=this.__data[12],V=this.__data[13],r=this.__data[14],h=this.__data[15],o=U*l-F*Q,J=U*n-e*Q,Z=U*a-t*Q,c=F*n-e*l,m=F*a-t*l,S=e*a-t*n,W=d*V-i*B,E=d*r-s*B,p=d*h-R*B,u=i*r-s*V,N=i*h-R*V,k=s*h-R*r;let b=o*k-J*N+Z*u+c*p-m*E+S*W;return b?(b=1/b,this.set((l*k-n*N+a*u)*b,(e*N-F*k-t*u)*b,(V*S-r*m+h*c)*b,(s*m-i*S-R*c)*b,(n*p-Q*k-a*E)*b,(U*k-e*p+t*E)*b,(r*Z-B*S-h*J)*b,(d*S-s*Z+R*J)*b,(Q*N-l*p+a*W)*b,(F*p-U*N-t*W)*b,(B*m-V*Z+h*o)*b,(i*Z-d*m-R*o)*b,(l*E-Q*u-n*W)*b,(U*u-F*E+e*W)*b,(V*J-B*c-r*o)*b,(d*c-i*J+s*o)*b),!0):(console.warn("Unable to invert Mat4"),!1)}setInverse(U){const F=U.__data[0],e=U.__data[1],t=U.__data[2],Q=U.__data[3],l=U.__data[4],n=U.__data[5],a=U.__data[6],d=U.__data[7],i=U.__data[8],s=U.__data[9],R=U.__data[10],B=U.__data[11],V=U.__data[12],r=U.__data[13],h=U.__data[14],o=U.__data[15],J=F*n-e*l,Z=F*a-t*l,c=F*d-Q*l,m=e*a-t*n,S=e*d-Q*n,W=t*d-Q*a,E=i*r-s*V,p=i*h-R*V,u=i*o-B*V,N=s*h-R*r,k=s*o-B*r,b=R*o-B*h;let C=J*b-Z*k+c*N+m*u-S*p+W*E;if(!C)throw new Error("Unable to invert Mat4");C=1/C,this.set((n*b-a*k+d*N)*C,(t*k-e*b-Q*N)*C,(r*W-h*S+o*m)*C,(R*S-s*W-B*m)*C,(a*u-l*b-d*p)*C,(F*b-t*u+Q*p)*C,(h*c-V*W-o*Z)*C,(i*W-R*c+B*Z)*C,(l*k-n*u+d*E)*C,(e*u-F*k-Q*E)*C,(V*S-r*c+o*J)*C,(s*c-i*S-B*J)*C,(n*p-l*N-a*E)*C,(F*N-e*p+t*E)*C,(r*Z-V*m-h*J)*C,(i*m-s*Z+R*J)*C)}multiply(U){const F=this.__data[0],e=this.__data[1],t=this.__data[2],Q=this.__data[3],l=this.__data[4],n=this.__data[5],a=this.__data[6],d=this.__data[7],i=this.__data[8],s=this.__data[9],R=this.__data[10],B=this.__data[11],V=this.__data[12],r=this.__data[13],o=this.__data[14],J=this.__data[15],Z=U.asArray();let c=Z[0],m=Z[1],S=Z[2],W=Z[3];const E=new h;return E.m00=c*F+m*l+S*i+W*V,E.m01=c*e+m*n+S*s+W*r,E.m02=c*t+m*a+S*R+W*o,E.m03=c*Q+m*d+S*B+W*J,c=Z[4],m=Z[5],S=Z[6],W=Z[7],E.m10=c*F+m*l+S*i+W*V,E.m11=c*e+m*n+S*s+W*r,E.m12=c*t+m*a+S*R+W*o,E.m13=c*Q+m*d+S*B+W*J,c=Z[8],m=Z[9],S=Z[10],W=Z[11],E.m20=c*F+m*l+S*i+W*V,E.m21=c*e+m*n+S*s+W*r,E.m22=c*t+m*a+S*R+W*o,E.m23=c*Q+m*d+S*B+W*J,c=Z[12],m=Z[13],S=Z[14],W=Z[15],E.m30=c*F+m*l+S*i+W*V,E.m31=c*e+m*n+S*s+W*r,E.m32=c*t+m*a+S*R+W*o,E.m33=c*Q+m*d+S*B+W*J,E}multiplyInPlace(U){const F=this.asArray(),e=F[0],t=F[1],Q=F[2],l=F[3],n=F[4],a=F[5],d=F[6],i=F[7],s=F[8],R=F[9],B=F[10],V=F[11],r=F[12],h=F[13],o=F[14],J=F[15],Z=U.asArray();let c=Z[0],m=Z[1],S=Z[2],W=Z[3];return this.m00=c*e+m*n+S*s+W*r,this.m01=c*t+m*a+S*R+W*h,this.m02=c*Q+m*d+S*B+W*o,this.m03=c*l+m*i+S*V+W*J,c=Z[4],m=Z[5],S=Z[6],W=Z[7],this.m10=c*e+m*n+S*s+W*r,this.m11=c*t+m*a+S*R+W*h,this.m12=c*Q+m*d+S*B+W*o,this.m13=c*l+m*i+S*V+W*J,c=Z[8],m=Z[9],S=Z[10],W=Z[11],this.m20=c*e+m*n+S*s+W*r,this.m21=c*t+m*a+S*R+W*h,this.m22=c*Q+m*d+S*B+W*o,this.m23=c*l+m*i+S*V+W*J,c=Z[12],m=Z[13],S=Z[14],W=Z[15],this.m30=c*e+m*n+S*s+W*r,this.m31=c*t+m*a+S*R+W*h,this.m32=c*Q+m*d+S*B+W*o,this.m33=c*l+m*i+S*V+W*J,this}postMultiplyInPlace(U){const F=U.asArray(),e=F[0],t=F[1],Q=F[2],l=F[3],n=F[4],a=F[5],d=F[6],i=F[7],s=F[8],R=F[9],B=F[10],V=F[11],r=F[12],h=F[13],o=F[14],J=F[15],Z=this.asArray();let c=Z[0],m=Z[1],S=Z[2],W=Z[3];return this.m00=c*e+m*n+S*s+W*r,this.m01=c*t+m*a+S*R+W*h,this.m02=c*Q+m*d+S*B+W*o,this.m03=c*l+m*i+S*V+W*J,c=Z[4],m=Z[5],S=Z[6],W=Z[7],this.m10=c*e+m*n+S*s+W*r,this.m11=c*t+m*a+S*R+W*h,this.m12=c*Q+m*d+S*B+W*o,this.m13=c*l+m*i+S*V+W*J,c=Z[8],m=Z[9],S=Z[10],W=Z[11],this.m20=c*e+m*n+S*s+W*r,this.m21=c*t+m*a+S*R+W*h,this.m22=c*Q+m*d+S*B+W*o,this.m23=c*l+m*i+S*V+W*J,c=Z[12],m=Z[13],S=Z[14],W=Z[15],this.m30=c*e+m*n+S*s+W*r,this.m31=c*t+m*a+S*R+W*h,this.m32=c*Q+m*d+S*B+W*o,this.m33=c*l+m*i+S*V+W*J,this}translateInPlace(U){const F=this.__data,e=U.x,t=U.y,Q=U.z;return F[12]=F[0]*e+F[4]*t+F[8]*Q+F[12],F[13]=F[1]*e+F[5]*t+F[9]*Q+F[13],F[14]=F[2]*e+F[6]*t+F[10]*Q+F[14],F[15]=F[3]*e+F[7]*t+F[11]*Q+F[15],this}setLookAt(U,F,e){const t=U.subtract(F),Q=t.length();if(Q<Number.EPSILON)return void this.setIdentity();t.scaleInPlace(1/Q);const l=e.cross(t),n=l.length();n>Number.EPSILON&&l.scaleInPlace(1/n);const a=t.cross(l),d=a.length();d>Number.EPSILON&&a.scaleInPlace(1/d),this.set(l.x,l.y,l.z,0,a.x,a.y,a.z,0,t.x,t.y,t.z,0,U.x,U.y,U.z,1)}setRotation(U,F){const e=U.length();if(Math.abs(e)<Number.EPSILON)return null;const t=U.x/e,Q=U.y/e,l=U.z/e,n=Math.sin(F),a=Math.cos(F),d=1-a,i=this.__data;return i[0]=t*t*d+a,i[1]=Q*t*d+l*n,i[2]=l*t*d-Q*n,i[3]=0,i[4]=t*Q*d-l*n,i[5]=Q*Q*d+a,i[6]=l*Q*d+t*n,i[7]=0,i[8]=t*l*d+Q*n,i[9]=Q*l*d-t*n,i[10]=l*l*d+a,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}setXRotation(U){const F=Math.sin(U),e=Math.cos(U),t=this.__data;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=F,t[7]=0,t[8]=0,t[9]=-F,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}setYRotation(U){const F=Math.sin(U),e=Math.cos(U),t=this.__data;return t[0]=e,t[1]=0,t[2]=-F,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=F,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}setZRotation(U){const F=Math.sin(U),e=Math.cos(U),t=this.__data;return t[0]=e,t[1]=F,t[2]=0,t[3]=0,t[4]=-F,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}transformVec4(U){const F=this.__data,e=U.x,t=U.y,Q=U.z,l=U.t;return new s(F[0]*e+F[4]*t+F[8]*Q+F[12]*l,F[1]*e+F[5]*t+F[9]*Q+F[13]*l,F[2]*e+F[6]*t+F[10]*Q+F[14]*l,F[3]*e+F[7]*t+F[11]*Q+F[15]*l)}transformVec3(U){const F=this.__data,e=U.x,t=U.y,Q=U.z;return new i(F[0]*e+F[4]*t+F[8]*Q+F[12],F[1]*e+F[5]*t+F[9]*Q+F[13],F[2]*e+F[6]*t+F[10]*Q+F[14])}rotateVec3(U){const F=this.__data,e=U.x,t=U.y,Q=U.z;return new i(F[0]*e+F[4]*t+F[8]*Q,F[1]*e+F[5]*t+F[9]*Q,F[2]*e+F[6]*t+F[10]*Q)}setPerspectiveMatrix(U,F,e,t){const Q=Math.tan(.5*Math.PI-.5*U),l=1/(e-t);this.set(Q/F,0,0,0,0,Q,0,0,0,0,(e+t)*l,-1,0,0,e*t*l*2,0)}setOrthographicMatrix(U,F,e,t,Q,l){const n=1/(U-F),a=1/(e-t),d=1/(Q-l);this.set(-2*n,0,0,0,0,-2*a,0,0,0,0,2*d,0,(U+F)*n,(t+e)*a,(l+Q)*d,1)}setScale(U,F,e){U instanceof i?this.set(U.x,0,0,0,0,U.y,0,0,0,0,U.z,0,0,0,0,1):this.set(U,0,0,0,0,F,0,0,0,0,e,0,0,0,0,1)}setFromMat3x4Array(U){this.set(U[0],U[1],U[2],0,U[3],U[4],U[5],0,U[6],U[7],U[8],0,U[9],U[10],U[11],1)}clone(){return new h(this.__data[0],this.__data[1],this.__data[2],this.__data[3],this.__data[4],this.__data[5],this.__data[6],this.__data[7],this.__data[8],this.__data[9],this.__data[10],this.__data[11],this.__data[12],this.__data[13],this.__data[14],this.__data[15])}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}toJSON(){return this.__data}fromJSON(U){this.__data=new Float32Array(U)}readBinary(U){this.__data=U.loadFloat32Array(16)}asArray(){return this.__data}}class o{constructor(U=0,F=0,e=0,t=1){if(U instanceof Float32Array)this.__data=U;else if(U instanceof ArrayBuffer){console.warn("deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))");const e=U,t=F;this.__data=new Float32Array(e,t,4)}else this.__data=new Float32Array(4),"object"==typeof U?(this.__data[0]=0,this.__data[1]=0,this.__data[2]=0,this.__data[3]=1,this.fromJSON(U)):(this.__data[0]=U,this.__data[1]=F,this.__data[2]=e,this.__data[3]=t)}get x(){return this.__data[0]}set x(U){this.__data[0]=U}get y(){return this.__data[1]}set y(U){this.__data[1]=U}get z(){return this.__data[2]}set z(U){this.__data[2]=U}get w(){return this.__data[3]}set w(U){this.__data[3]=U}set(U,F,e,t){this.__data[0]=U,this.__data[1]=F,this.__data[2]=e,this.__data[3]=t}setDataArray(U){this.__data=U}setFromOther(U){this.__data[0]=U.x,this.__data[1]=U.y,this.__data[2]=U.z,this.__data[3]=U.w}setFromEulerAngles(U){const F=new i;switch(U.order){case 0:F.set(U.x,-U.y,U.z);break;case 1:F.set(U.y,-U.z,U.x);break;case 2:F.set(U.z,-U.x,U.y);break;case 3:F.set(U.x,U.z,U.y);break;case 4:F.set(U.z,U.y,U.x);break;case 5:F.set(U.y,U.x,U.z);break;default:throw new Error(`Invalid EulerAngles order: ${U.order}`)}const e=.5*F.x,t=.5*F.y,Q=.5*F.z,l=Math.cos(e),n=Math.cos(t),a=Math.cos(Q),d=Math.sin(e),s=Math.sin(t),R=Math.sin(Q),B=l*a,V=l*R,r=d*a,h=d*R,o=n*r-s*V,J=n*h+s*B,Z=n*V-s*r;switch(this.w=n*B+s*h,U.order){case 0:this.x=o,this.y=-J,this.z=Z;break;case 1:this.x=Z,this.y=o,this.z=-J;break;case 2:this.x=-J,this.y=Z,this.z=o;break;case 3:this.x=o,this.y=Z,this.z=J;break;case 4:this.x=Z,this.y=J,this.z=o;break;case 5:this.x=J,this.y=o,this.z=Z;break;default:throw new Error(`Invalid EulerAngles order: ${U.order}`)}}toEulerAngles(U){const F=new i;switch(U){case 0:F.set(this.z,this.x,this.y);break;case 1:F.set(this.x,this.y,this.z);break;case 2:F.set(this.y,this.z,this.x);break;case 3:F.set(this.y,-this.x,this.z);break;case 4:F.set(this.x,-this.z,this.y);break;case 5:F.set(this.z,-this.y,this.x);break;default:throw new Error("Invalid rotation order:"+U)}const e=new i,t=F.x*F.y+F.z*this.w;if(t>.49999)e.y=2*Math.atan2(F.x,this.w),e.z=.5*Math.PI,e.x=0;else if(t<-.49999)e.y=-2*Math.atan2(F.x,this.w),e.z=-.5*Math.PI,e.x=0;else{const U=F.x*F.x,Q=F.y*F.y,l=F.z*F.z;e.y=Math.atan2(2*F.y*this.w-2*F.x*F.z,1-2*Q-2*l),e.z=Math.asin(2*t),e.x=Math.atan2(2*F.x*this.w-2*F.y*F.z,1-2*U-2*l)}switch(U){case 0:return new V(e.y,e.z,e.x,U);case 1:return new V(e.x,e.y,e.z,U);case 2:return new V(e.z,e.x,e.y,U);case 3:return new V(-e.y,e.x,e.z,U);case 4:return new V(e.x,e.z,-e.y,U);case 5:return new V(e.z,-e.y,e.x,U)}}setFromAxisAndAngle(U,F){const e=F/2,t=U.normalize().scale(Math.sin(e));this.set(t.x,t.y,t.z,Math.cos(e))}setFromDirectionAndUpvector(U,F){const e=new r;e.setFromDirectionAndUpvector(U,F),this.setFromMat3(e)}setFrom2Vectors(U,F){const e=U.cross(F),t=U.dot(F),Q=Math.sqrt(2*(1+t));this.set(e.x/Q,e.y/Q,e.z/Q,Q/2),this.normalizeInPlace()}setFromMat3(U){const F=U.asArray(),e=F[0]+F[4]+F[8];let t;if(e>0)t=Math.sqrt(e+1),this.__data[3]=.5*t,t=.5/t,this.__data[0]=(F[5]-F[7])*t,this.__data[1]=(F[6]-F[2])*t,this.__data[2]=(F[1]-F[3])*t;else{let U=0;F[4]>F[0]&&(U=1),F[8]>F[3*U+U]&&(U=2);const e=(U+1)%3,Q=(U+2)%3;t=Math.sqrt(F[3*U+U]-F[3*e+e]-F[3*Q+Q]+1),this.__data[U]=.5*t,t=.5/t,this.__data[3]=(F[3*e+Q]-F[3*Q+e])*t,this.__data[e]=(F[3*e+U]+F[3*U+e])*t,this.__data[Q]=(F[3*Q+U]+F[3*U+Q])*t}this.normalizeInPlace()}setFromMat4(U){const F=U.asArray(),e=F[0]+F[5]+F[10];let t;if(e>0)t=Math.sqrt(e+1),this.__data[3]=.5*t,t=.5/t,this.__data[0]=(F[6]-F[9])*t,this.__data[1]=(F[8]-F[2])*t,this.__data[2]=(F[1]-F[4])*t;else{let U=0;F[5]>F[0]&&(U=1),F[10]>F[4*U+U]&&(U=2);const e=(U+1)%3,Q=(U+2)%3;t=Math.sqrt(F[4*U+U]-F[4*e+e]-F[4*Q+Q]+1),this.__data[U]=.5*t,t=.5/t,this.__data[3]=(F[4*e+Q]-F[4*Q+e])*t,this.__data[e]=(F[4*e+U]+F[4*U+e])*t,this.__data[Q]=(F[4*Q+U]+F[4*U+Q])*t}this.normalizeInPlace()}isIdentity(){return this.getAngle()<Number.EPSILON}getAngle(){return 2*Math.acos(this.w)}isEqual(U){return this.x==U.x&&this.y==U.y&&this.z==U.z&&this.w==U.w}notEquals(U){return this.x!=U.x&&this.y!=U.y&&this.z!=U.z&&this.w!=U.w}approxEqual(U,F=Number.EPSILON){return Math.abs(this.x-U.x)<F&&Math.abs(this.y-U.y)<F&&Math.abs(this.z-U.z)<F&&Math.abs(this.w-U.w)<F}add(U){return new o(this.x+U.x,this.y+U.y,this.z+U.z,this.w+U.w)}addInPlace(U){this.x+=U.x,this.y+=U.y,this.z+=U.z,this.w+=U.w}subtract(U){return new o(this.x-U.x,this.y-U.y,this.z-U.z,this.w-U.w)}scale(U){return new o(this.x*U,this.y*U,this.z*U,this.w*U)}scaleInPlace(U){this.x*=U,this.y*=U,this.z*=U,this.w*=U}length(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3];return Math.sqrt(U*U+F*F+e*e+t*t)}lengthSquared(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3];return U*U+F*F+e*e+t*t}normalize(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3];let Q=U*U+F*F+e*e+t*t;return Q<Number.EPSILON?new o:(Q=1/Math.sqrt(Q),new o(U*Q,F*Q,e*Q,t*Q))}normalizeInPlace(){const U=this.__data[0],F=this.__data[1],e=this.__data[2],t=this.__data[3];let Q=U*U+F*F+e*e+t*t;Q<Number.EPSILON||(Q=1/Math.sqrt(Q),this.set(U*Q,F*Q,e*Q,t*Q))}dot(U){return this.x*U.x+this.y*U.y+this.z*U.z+this.w*U.w}cross(U){const F=this.x,e=this.y,t=this.z,Q=this.w,l=U.x,n=U.y,a=U.z,d=U.w;return new o(e*a-t*n,t*d-Q*a,Q*l-F*d,F*n-e*l)}conjugate(){return new o(-this.x,-this.y,-this.z,this.w)}inverse(){return this.conjugate()}alignWith(U){this.dot(U)<0&&this.set(-this.x,-this.y,-this.z,-this.w)}multiply(U){const F=this.__data[0],e=this.__data[1],t=this.__data[2],Q=this.__data[3],l=U.__data[0],n=U.__data[1],a=U.__data[2],d=U.__data[3];return new o(F*d+Q*l+e*a-t*n,e*d+Q*n+t*l-F*a,t*d+Q*a+F*n-e*l,Q*d-F*l-e*n-t*a)}multiplyInPlace(U){const F=this.__data[0],e=this.__data[1],t=this.__data[2],Q=this.__data[3],l=U.__data[0],n=U.__data[1],a=U.__data[2],d=U.__data[3];this.set(F*d+Q*l+e*a-t*n,e*d+Q*n+t*l-F*a,t*d+Q*a+F*n-e*l,Q*d-F*l-e*n-t*a)}rotateVec3(U){const F=new o(U.x,U.y,U.z,0),e=this.multiply(F).multiply(this.conjugate());return new i(e.x,e.y,e.z)}rotateX(U){U*=.5;const F=this.x,e=this.y,t=this.z,Q=this.w,l=Math.sin(U),n=Math.cos(U);this.x=F*n+Q*l,this.y=e*n+t*l,this.z=t*n-e*l,this.w=Q*n-F*l}rotateY(U){U*=.5;const F=this.x,e=this.y,t=this.z,Q=this.w,l=Math.sin(U),n=Math.cos(U);this.x=F*n-t*l,this.y=e*n+Q*l,this.z=t*n+F*l,this.w=Q*n-e*l}rotateZ(U){U*=.5;const F=this.x,e=this.y,t=this.z,Q=this.w,l=Math.sin(U),n=Math.cos(U);this.x=F*n+e*l,this.y=e*n-F*l,this.z=t*n+Q*l,this.w=Q*n-t*l}toMat3(){const U=this.x,F=this.y,e=this.z,t=this.w,Q=U+U,l=F+F,n=e+e,a=U*Q,d=F*Q,i=F*l,s=e*Q,R=e*l,B=e*n,V=t*Q,h=t*l,o=t*n,J=new r;return J.m00=1-i-B,J.m10=d-o,J.m20=s+h,J.m01=d+o,J.m11=1-a-B,J.m21=R-V,J.m02=s-h,J.m12=R+V,J.m22=1-a-i,J}getXaxis(){const U=this.x*this.y,F=this.x*this.z,e=this.y*this.y,t=this.y*this.w,Q=this.z*this.z,l=this.z*this.w;return new i(1-2*(Q+e),2*(U+l),2*(F-t))}getYaxis(){const U=this.x*this.x,F=this.x*this.y,e=this.x*this.w,t=this.y*this.z,Q=this.z*this.z,l=this.z*this.w;return new i(2*(F-l),1-2*(Q+U),2*(t+e))}getZaxis(){const U=this.x*this.x,F=this.x*this.z,e=this.x*this.w,t=this.y*this.y,Q=this.y*this.z,l=this.y*this.w;return new i(2*(l+F),2*(Q-e),1-2*(t+U))}mirror(U){switch(U){default:return new o(this.z,this.w,this.x,this.y);case 1:return new o(-this.w,this.z,this.y,-this.x);case 2:return new o(this.x,this.y,this.z,-this.w)}}toMat4(){const U=this.x,F=this.y,e=this.z,t=this.w,Q=U+U,l=F+F,n=e+e,a=U*Q,d=F*Q,i=F*l,s=e*Q,R=e*l,B=e*n,V=t*Q,r=t*l,o=t*n,J=new h;return J.m00=1-i-B,J.m10=d-o,J.m20=s+r,J.m01=d+o,J.m11=1-a-B,J.m21=R-V,J.m02=s-r,J.m12=R+V,J.m22=1-a-i,J}lerp(U,F){const e=new o(this.x+F*(U.x-this.x),this.y+F*(U.y-this.y),this.z+F*(U.z-this.z),this.w+F*(U.w-this.w));return e.normalizeInPlace(),e}slerp(U,F){const e=this.dot(U),t=F/2;let Q=Math.acos(e);Q<0&&(Q=-Q);const l=Math.sin(Q),n=Math.sin(t*Q),a=Math.sin((1-t)*Q)/l,d=n/l,i=new o(a*this.x+d*U.x,a*this.y+d*U.y,a*this.z+d*U.z,a*this.w+d*U.w);return i.normalizeInPlace(),i}clone(){return new o(this.__data[0],this.__data[1],this.__data[2],this.__data[3])}asArray(){return this.__data}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}toJSON(){return{x:this.x,y:this.y,z:this.z,w:this.w}}fromJSON(U){this.__data[0]=U.x,this.__data[1]=U.y,this.__data[2]=U.z,this.__data[3]=U.w,this.normalizeInPlace()}readBinary(U){this.x=U.loadFloat32(),this.y=U.loadFloat32(),this.z=U.loadFloat32(),this.w=U.loadFloat32()}}class J{static radToDeg(U){return U/(Math.PI/180)}static degToRad(U){return U*(Math.PI/180)}static isNumeric(U){return!isNaN(parseFloat(U))&&isFinite(U)}static randomInt(U,F){return U=Math.ceil(U),F=Math.floor(F),Math.floor(Math.random()*(F-U))+U}static lerp(U,F,e){return U+e*(F-U)}static clamp(U,F,e){return Math.min(Math.max(U,F),e)}static nearestPow2(U){return Math.pow(2,Math.round(Math.log(U)/Math.log(2)))}static nearestPow10(U){return Math.pow(10,Math.round(Math.log10(U)/Math.log10(10)))}static nextPow2(U){if(0==this.fract(Math.log2(U)))return U;let F=0;for(;U>0;)F++,U>>=1;return 1<<F}static fract(U){return 0==U?0:U<0?U>-1?-U:-U%Math.floor(-U):U<1?U:U%Math.floor(U)}static remap(U,F,e,t,Q){return t+(U-F)/(e-F)*(Q-t)}static smoothStep(U,F,e){const t=this.clamp((e-U)/(F-U),0,1);return t*t*(3-2*t)}static linStep(U,F,e){return this.clamp((e-U)/(F-U),0,1)}static decode16BitFloatFrom2xUInt8(U){const F=U[0],e=(120&F)>>3;let t=0==e?0:2048;const Q=t+((7&F)<<8)+U[1];t=0==e?1:0;return(128&F?1:-1)*Q*Math.pow(2,e+t-16)}static encode16BitFloatInto2xUInt8(U){const F=new Uint8Array(2),e=U>=0?128:0;U=Math.abs(U);let t,Q=15,l=1024;for(let F=15;F>0;F--)U<l&&(l/=2,Q--);t=0==Q?U/l/2:(U-l)/l;const n=Math.round(2048*t),a=n/256,d=n-256*a;return F[0]=e+8*Q+a,F[1]=d,U>=2048&&(F[0]=255),F}static encode16BitFloat(U){const F=new Float32Array(1);F[0]=U;return(U=>{let F=U>>16&32768,e=U>>12&2047;const t=U>>23&255;return t<103?F:t>142?(F|=31744,F|=(255==t?0:1)&&8388607&U,F):t<113?(e|=2048,F|=(e>>114-t)+(e>>113-t&1),F):(F|=t-112<<10|e>>1,F+=1&e,F)})(new Int32Array(F.buffer)[0])}static decode16BitFloat(U){const F=(32768&U)>>15,e=(31744&U)>>10,t=1023&U;return 0==e?(F?-1:1)*Math.pow(2,-14)*(t/Math.pow(2,10)):31==e?t?NaN:1/0*(F?-1:1):(F?-1:1)*Math.pow(2,e-15)*(1+t/Math.pow(2,10))}static convertFloat32ArrayToUInt16Array(U){const F=new Uint16Array(U.length),e=new Int32Array(U.buffer),t=U=>{let F=U>>16&32768,e=U>>12&2047;const t=U>>23&255;return t<103?F:t>142?(F|=31744,F|=(255==t?0:1)&&8388607&U,F):t<113?(e|=2048,F|=(e>>114-t)+(e>>113-t&1),F):(F|=t-112<<10|e>>1,F+=1&e,F)};for(let Q=0;Q<U.length;Q++)F[Q]=t(e[Q]);return F}}class Z{constructor(U,F){this.start=U instanceof i?U:new i,this.dir=F instanceof i?F:new i}closestPoint(U){const F=U.subtract(this.start).dot(this.dir);if(F<Number.EPSILON)return 0;const e=this.dir.dot(this.dir);return e<Number.EPSILON?0:F/e}closestPointOnLineSegment(U,F){const e=this.dir,t=F.subtract(U),Q=t.length();t.normalizeInPlace();const l=this.start.subtract(U),n=e.dot(e),a=e.dot(t),d=t.dot(t),i=e.dot(l),s=t.dot(l);if(0==n&&0==d)return[this.start.distanceTo(U),0];if(0==n)return[0,0];if(0==d)return[this.closestPoint(U),0];const R=n*d-a*a;let B,V;return R<.001?(B=0,V=a>d?i/a:s/d):(B=(a*s-d*i)/R,V=(n*s-a*i)/R),[B,J.clamp(V/Q,0,1)]}pointAtDist(U){return this.start.add(this.dir.scale(U))}intersectRayVector(U){const F=this.dir,e=U.dir,t=this.start.subtract(U.start),Q=F.dot(F),l=F.dot(e),n=e.dot(e),a=F.dot(t),d=e.dot(t);if(0==Q&&0==n)return this.start.distanceTo(U.start);if(0==Q)return U.closestPoint(this.start);if(0==n)return this.closestPoint(U.start);const i=Q*n-l*l;let s,R;return i<.001?(s=0,R=l>n?a/l:d/n):(s=(l*d-n*a)/i,R=(Q*d-l*a)/i),[s,R]}intersectRayPlane(U){const F=this.start.subtract(U.start),e=U.dir.dot(this.dir),t=-U.dir.dot(F);if(Math.abs(e)<Number.PRECISION)return-1;const Q=t/e;return Q<-Number.PRECISION?-1:Q}intersectRayBox3(U,F=0){const e=new i(1/this.dir.x,1/this.dir.y,1/this.dir.z),t=[];t[0]=e.x<0?1:0,t[1]=e.y<0?1:0,t[2]=e.z<0?1:0;const Q=[];if(F>0){const e=U.diagonal();e.normalizeInPlace(),e.scaleInPlace(F),Q[0]=U.p0.subtract(e),Q[1]=U.p1.add(e)}else Q[0]=U.p0,Q[1]=U.p1;let l=(Q[t[0]].x-this.start.x)*e.x,n=(Q[1-t[0]].x-this.start.x)*e.x;const a=(Q[t[1]].y-this.start.y)*e.y,d=(Q[1-t[1]].y-this.start.y)*e.y;if(l>d||a>n)return!1;a>l&&(l=a),d<n&&(n=d);const s=(Q[t[2]].z-this.start.z)*e.z,R=(Q[1-t[2]].z-this.start.z)*e.z;return!(l>R||s>n)&&(s>l&&(l=s),R<n&&(n=R),!0)}clone(){return new Z(this.start.clone(),this.dir.clone())}toJSON(){return{start:this.start.toJSON(),dir:this.dir.toJSON()}}fromJSON(U){this.start.fromJSON(U.start),this.dir.fromJSON(U.dir)}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}}class c{constructor(U,F,e){if(U instanceof Float32Array)this.setFromFloat32Array(U);else{if(U instanceof i)this.tr=U;else{if(U instanceof o&&null==F&&null==e)return this.tr=new i,this.ori=U,void(this.sc=new i(1,1,1));this.tr=new i}this.ori=F instanceof o?F:new o,this.sc=e instanceof i?e:new i(1,1,1)}}set(U,F,e){this.tr=U,this.ori=F,e instanceof i&&(this.sc=e)}setFromOther(U){this.tr=U.tr,this.ori=U.ori,this.sc=U.sc}isIdentity(){return this.tr.isNull()&&this.ori.isIdentity()&&this.sc.is111()}isEqual(U){return this.tr.isEqual(U.tr)&&this.ori.isEqual(U.ori)&&this.sc.isEqual(U.sc)}approxEqual(U,F=Number.EPSILON){return(!U.tr||this.tr.approxEqual(U.tr,F))&&(!U.ori||this.ori.approxEqual(U.ori,F))&&(!U.sc||this.sc.approxEqual(U.sc,F))}setLookAt(U,F,e){const t=U.subtract(F);if(t.length()<Number.EPSILON)throw new Error("Invalid dir");this.ori.setFromDirectionAndUpvector(t,e),this.tr=U}multiply(U){let F=this.sc;this.sc.x==this.sc.y&&this.sc.x==this.sc.z||(F=U.ori.rotateVec3(this.sc),Math.sign(F.x)!=Math.sign(this.sc.x)&&(F.x=-F.x),Math.sign(F.y)!=Math.sign(this.sc.y)&&(F.y=-F.y),Math.sign(F.z)!=Math.sign(this.sc.z)&&(F.z=-F.z));return new c(this.tr.add(this.ori.rotateVec3(F.multiply(U.tr))),this.ori.multiply(U.ori),F.multiply(U.sc))}inverse(){const U=new c;return U.ori=this.ori.inverse(),this.sc.x!=this.sc.y||this.sc.x!=this.sc.z?(U.sc=U.ori.rotateVec3(this.sc),Math.sign(U.sc.x)!=Math.sign(this.sc.x)&&(U.sc.x=-U.sc.x),Math.sign(U.sc.y)!=Math.sign(this.sc.y)&&(U.sc.y=-U.sc.y),Math.sign(U.sc.z)!=Math.sign(this.sc.z)&&(U.sc.z=-U.sc.z)):U.sc=this.sc.inverse(),U.tr=U.ori.rotateVec3(this.tr.negate().multiply(U.sc)),U}transformVec3(U){return this.tr.add(this.ori.rotateVec3(this.sc.multiply(U)))}toMat4(){const U=new h(this.sc.x,0,0,0,0,this.sc.y,0,0,0,0,this.sc.z,0,0,0,0,1),F=this.ori.toMat4(),e=new h;return e.translation=this.tr,e.multiply(F).multiply(U)}setFromMat4(U){this.tr=U.translation,this.ori.setFromMat4(U)}setFromFloat32Array(U){if(7==U.length)return this.tr=new i(new Float32Array(U.buffer,U.byteOffset,3)),this.ori=new o(new Float32Array(U.buffer,U.byteOffset+12,4)),void(this.sc=new i(1,1,1));if(8!=U.length){if(10==U.length)return this.tr=new i(new Float32Array(U.buffer,U.byteOffset,3)),this.ori=new o(new Float32Array(U.buffer,U.byteOffset+12,4)),void(this.sc=new i(new Float32Array(U.buffer,U.byteOffset+21,3)));console.warn("unitialized: float32array.length == ",U.length)}else{this.tr=new i(new Float32Array(U.buffer,U.byteOffset,3)),this.ori=new o(new Float32Array(U.buffer,U.byteOffset+12,4));const F=U[7];this.sc=new i(F,F,F)}}clone(){return new c(this.tr.clone(),this.ori.clone(),this.sc.clone())}toJSON(){const U={tr:this.tr.toJSON(),ori:this.ori.toJSON()};return this.sc.is111()||(U.sc=this.sc.toJSON()),U}fromJSON(U){this.tr.fromJSON(U.tr),this.ori.fromJSON(U.ori),U.sc&&this.sc.fromJSON(U.sc)}readBinary(U){this.tr.readBinary(U),this.ori.readBinary(U),this.sc.readBinary(U)}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}}class m{constructor(U,F){this.p0=U instanceof d?U:new d(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),this.p1=F instanceof d?F:new d(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}set(U,F){this.p0=U,this.p1=F}reset(){this.p0.x=Number.POSITIVE_INFINITY,this.p1.x=Number.NEGATIVE_INFINITY,this.p0.y=Number.POSITIVE_INFINITY,this.p1.y=Number.NEGATIVE_INFINITY}isValid(){return this.p0.x!=Number.POSITIVE_INFINITY&&this.p1.x!=Number.NEGATIVE_INFINITY&&this.p0.y!=Number.POSITIVE_INFINITY&&this.p1.y!=Number.NEGATIVE_INFINITY}addPoint(U){(this.p0.x==Number.POSITIVE_INFINITY||U.x<this.p0.x)&&(this.p0.x=U.x),(this.p0.y==Number.POSITIVE_INFINITY||U.y<this.p0.y)&&(this.p0.y=U.y),(this.p1.y==Number.NEGATIVE_INFINITY||U.x>this.p1.x)&&(this.p1.x=U.x),(this.p1.y==Number.NEGATIVE_INFINITY||U.y>this.p1.y)&&(this.p1.y=U.y)}size(){return this.p1.distanceTo(this.p0)}diagonal(){return this.p1.subtract(this.p0)}center(){const U=this.p1.subtract(this.p0);return U.scaleInPlace(.5),U.addInPlace(this.p0),U}toJSON(){return{p0:this.p0.toJSON(),p1:this.p1.toJSON()}}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}}class S{constructor(U=new i,F=0){this.pos=U instanceof i?U:new i,this.radius=F}clone(){return new S(this.pos.clone(),this.radius)}intersectsBox(U){return U.intersectsSphere(this)}toJSON(){return{pos:this.pos.toJSON(),radius:this.radius}}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}}class W{constructor(U,F){U instanceof Float32Array?(this.p0=new i(new Float32Array(U.buffer,U.byteOffset,3)),this.p1=new i(new Float32Array(U.buffer,U.byteOffset+12,3))):(this.p0=U instanceof i?U:new i(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY),this.p1=F instanceof i?F:new i(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY))}get min(){return this.p0}get max(){return this.p1}set(U,F){this.p0=U,this.p1=F}reset(){this.p0.x=Number.POSITIVE_INFINITY,this.p0.y=Number.POSITIVE_INFINITY,this.p0.z=Number.POSITIVE_INFINITY,this.p1.x=Number.NEGATIVE_INFINITY,this.p1.y=Number.NEGATIVE_INFINITY,this.p1.z=Number.NEGATIVE_INFINITY}isValid(){return this.p0.x!=Number.POSITIVE_INFINITY&&this.p1.x!=Number.NEGATIVE_INFINITY&&this.p0.y!=Number.POSITIVE_INFINITY&&this.p1.y!=Number.NEGATIVE_INFINITY&&this.p0.z!=Number.POSITIVE_INFINITY&&this.p1.z!=Number.NEGATIVE_INFINITY}addPoint(U){U.x!=Number.POSITIVE_INFINITY&&U.x!=Number.NEGATIVE_INFINITY&&(U.x<this.p0.x&&(this.p0.x=U.x),U.x>this.p1.x&&(this.p1.x=U.x)),U.y!=Number.POSITIVE_INFINITY&&U.y!=Number.NEGATIVE_INFINITY&&(U.y<this.p0.y&&(this.p0.y=U.y),U.y>this.p1.y&&(this.p1.y=U.y)),U.z!=Number.POSITIVE_INFINITY&&U.z!=Number.NEGATIVE_INFINITY&&(U.z<this.p0.z&&(this.p0.z=U.z),U.z>this.p1.z&&(this.p1.z=U.z))}addBox3(U,F){F?(this.addPoint(F.transformVec3(U.p0)),this.addPoint(F.transformVec3(new i(U.p0.x,U.p0.y,U.p1.z))),this.addPoint(F.transformVec3(new i(U.p0.x,U.p1.y,U.p0.z))),this.addPoint(F.transformVec3(new i(U.p1.x,U.p0.y,U.p0.z))),this.addPoint(F.transformVec3(new i(U.p0.x,U.p1.y,U.p1.z))),this.addPoint(F.transformVec3(new i(U.p1.x,U.p0.y,U.p1.z))),this.addPoint(F.transformVec3(new i(U.p1.x,U.p1.y,U.p0.z))),this.addPoint(F.transformVec3(U.p1))):(this.addPoint(U.p0),this.addPoint(U.p1))}size(){return this.p1.distanceTo(this.p0)}diagonal(){return this.p1.subtract(this.p0)}center(){const U=this.p1.subtract(this.p0);return U.scaleInPlace(.5),U.addInPlace(this.p0),U}toMat4(){const U=this.p1.x-this.p0.x,F=this.p1.y-this.p0.y,e=this.p1.z-this.p0.z;return new h(U,0,0,0,0,F,0,0,0,0,e,0,this.p0.x,this.p0.y,this.p0.z,1)}getBoundingSphere(){return new S(this.center(),.5*this.diagonal().length())}intersectsBox(U){return!(U.max.x<this.min.x||U.min.x>this.max.x||U.max.y<this.min.y||U.min.y>this.max.y||U.max.z<this.min.z||U.min.z>this.max.z)}intersectsSphere(U){return(new i).distanceTo(U.pos)<=U.radius*U.radius}intersectsPlane(U){let F,e;return U.normal.x>0?(F=U.normal.x*this.min.x,e=U.normal.x*this.max.x):(F=U.normal.x*this.max.x,e=U.normal.x*this.min.x),U.normal.y>0?(F+=U.normal.y*this.min.y,e+=U.normal.y*this.max.y):(F+=U.normal.y*this.max.y,e+=U.normal.y*this.min.y),U.normal.z>0?(F+=U.normal.z*this.min.z,e+=U.normal.z*this.max.z):(F+=U.normal.z*this.max.z,e+=U.normal.z*this.min.z),F<=-U.w&&e>=-U.w}clone(){return new W(this.p0.clone(),this.p1.clone())}toJSON(){return{p0:this.p0.toJSON(),p1:this.p1.toJSON()}}fromJSON(U){const F={x:J.isNumeric(U.p0.x)?U.p0.x:Number.POSITIVE_INFINITY,y:J.isNumeric(U.p0.y)?U.p0.y:Number.POSITIVE_INFINITY,z:J.isNumeric(U.p0.z)?U.p0.z:Number.POSITIVE_INFINITY},e={x:J.isNumeric(U.p1.x)?U.p1.x:Number.NEGATIVE_INFINITY,y:J.isNumeric(U.p1.y)?U.p1.y:Number.NEGATIVE_INFINITY,z:J.isNumeric(U.p1.z)?U.p1.z:Number.NEGATIVE_INFINITY};this.p0.fromJSON(F),this.p1.fromJSON(e)}setFromFloat32Array(U){this.p0=new i(U.buffer,U.byteOffset),this.p1=new i(U.buffer,U.byteOffset+12)}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}}class E{constructor(U,F=0){this.normal=U instanceof i?U:new i,this.w=F}set(U,F,e,t){this.normal.set(U,F,e),this.w=t}divideScalar(U){this.normal.scaleInPlace(1/U),this.w/=U}distanceToPoint(U){return U.dot(this.normal)+this.w}normalizeInPlace(){const U=1/this.normal.length();this.normal.scaleInPlace(U),this.w*=U}clone(){return new E(this.normal.clone(),this.w)}toJSON(){return{normal:this.normal.toJSON(),w:this.w}}fromJSON(U){this.normal.fromJSON(U.normal),this.w=U.w}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}}let p=0;class u{constructor(){this.__id=++p}getId(){return this.__id}getClassName(){return n.getClassName(Object.getPrototypeOf(this).constructor)}}class N{constructor(){}}class k extends u{constructor(){super(),this.listeners={}}on(U,F){if(!F)throw new Error("Missing listener.");this.listeners[U]||(this.listeners[U]=[]);const e=this.listeners[U];if(e.includes(F))throw new Error(`Listener "${F.name}" already connected to event "${U}".`);const t=e.length;return e[t]=F,t}once(U,F){const e=t=>{F(t),this.off(U,e)};return this.on(U,e)}off(U,F){if(!F)throw new Error("Missing callback function (listener).");if("number"==typeof F)return console.warn("Deprecated. Un-register using the original listener instead."),void this.removeListenerById(U,F);const e=this.listeners[U]||[],t=[];if(e.forEach(((U,e)=>{U===F&&t.push(e)})),0==t.length)throw new Error(`Listener "${F.name}" is not connected to "${U}" event`);for(const U of t)e[U]=null}removeListenerById(U,F){const e=this.listeners[U];if(e){if(!e[F])throw new Error("Invalid ID");e[F]=null}else console.warn("callback :"+F+" was not connected to this event:"+U)}emit(U,F=new N){(this.listeners[U]||[]).forEach((U=>{U&&U(F)}))}}class b extends N{constructor(U,F){super(),this.width=U,this.height=F}}class C extends k{constructor(U=0,F=0){super(),this.root={x:0,y:0,w:U,h:F}}fit(U){if(0==U.length)return;let F=!1;if(this.root.w<U[0].w&&(this.root.w=U[0].w,F=!0),this.root.h<U[0].h&&(this.root.h=U[0].h,F=!0),F){const U=new b(this.root.w,this.root.h);this.emit("resized",U)}U.forEach((U=>{U.fit=this.__addBlock(U)}))}__addBlock(U){const F=this.findNode(this.root,U.w,U.h);return F?this.splitNode(F,U.w,U.h):this.growNode(U.w,U.h)}addBlock(U){let F=!1;if(this.root.w<U.w&&(this.root.w=U.w,F=!0),this.root.h<U.h&&(this.root.h=U.h,F=!0),F){const U=new b(this.root.w,this.root.h);this.emit("resized",U)}const e=this.findNode(this.root,U.w,U.h);return e?this.splitNode(e,U.w,U.h):this.growNode(U.w,U.h)}findNode(U,F,e){return U.used?this.findNode(U.right,F,e)||this.findNode(U.down,F,e):F<=U.w&&e<=U.h?U:null}splitNode(U,F,e){return U.used=!0,U.down={x:U.x,y:U.y+e,w:U.w,h:U.h-e},U.right={x:U.x+F,y:U.y,w:U.w-F,h:e},U}growNode(U,F){const e=U<=this.root.w,t=F<=this.root.h,Q=t&&this.root.h>=this.root.w+U,l=e&&this.root.w>=this.root.h+F;return Q?this.growRight(U,F):l?this.growDown(U,F):t?this.growRight(U,F):e?this.growDown(U,F):null}growRight(U,F){this.root={used:!0,x:0,y:0,w:this.root.w+U,h:this.root.h,down:this.root,right:{x:this.root.w,y:0,w:U,h:this.root.h}};const e=this.findNode(this.root,U,F);let t;e&&(t=this.splitNode(e,U,F));const Q=new b(this.root.w,this.root.h);return this.emit("resized",Q),t}growDown(U,F){this.root={used:!0,x:0,y:0,w:this.root.w,h:this.root.h+F,down:{x:0,y:this.root.h,w:this.root.w,h:F},right:this.root};const e=this.findNode(this.root,U,F);let t;e&&(t=this.splitNode(e,U,F));const Q=new b(this.root.w,this.root.h);return this.emit("resized",Q),t}}class T{constructor(U=0,F=0){this.start=U,this.size=F}}class G extends k{constructor(){super(),this.freeList=[],this.allocations=[],this.allocationsMap={},this.allocatedSpace=0,this.reservedSpace=0,this.freeSpace=0}getAllocation(U){return this.allocations[this.allocationsMap[U]]}allocate(U,F){if(null!=this.allocationsMap[U]){const e=this.allocationsMap[U],t=this.allocations[e];if(F==t.size)return t;if(F<t.size){const U=t.size-F;return this.addBlock(e+1,new T(t.start+F,U)),this.freeBlock(e+1),t.size=F,t}{const Q=e+1;if(this.freeList.includes(Q)&&t.size+this.allocations[Q].size>=F){const U=this.allocations[Q];if(t.size+U.size==F)return t.size+=U.size,this.freeSpace-=U.size,this.freeList.splice(this.freeList.indexOf(Q),1),this.removeBlock(Q),t;{const e=F-t.size;return t.size+=e,this.freeSpace-=e,U.start+=e,U.size-=e,t}}delete this.allocationsMap[U],t.start+t.size==this.allocatedSpace?(this.removeBlock(e),this.allocatedSpace-=t.size):this.freeBlock(e)}}let e=-1;for(let U=0;U<this.freeList.length;U++){const t=this.freeList[U],Q=this.allocations[t];if(Q.size==F){e=t;break}Q.size>F&&(e=t)}if(-1!=e){const t=this.allocations[e];if(this.freeSpace-=t.size,this.freeList.splice(this.freeList.indexOf(e),1),t.size>F){const U=t.size-F;this.addBlock(e+1,new T(t.start+F,U)),this.freeBlock(e+1),this.freeList.sort(((U,F)=>this.allocations[F].size-this.allocations[U].size)),this.allocations[e].size=F}this.allocationsMap[U]=e}else{const e=this.allocatedSpace,t=this.allocations.length;this.allocatedSpace+=F;const Q=J.nextPow2(this.allocatedSpace);Q!=this.reservedSpace&&(this.reservedSpace=Q,this.emit("resized",{reservedSpace:this.reservedSpace})),this.allocations.push(new T(e,F)),this.allocationsMap[U]=t}return this.allocations[this.allocationsMap[U]]}addBlock(U,F){this.allocations.splice(U,0,F);for(const F in this.allocationsMap)this.allocationsMap[F]>=U&&this.allocationsMap[F]++;for(let F=0;F<this.freeList.length;F++)this.freeList[F]>=U&&this.freeList[F]++}removeBlock(U){this.allocations.splice(U,1);for(const F in this.allocationsMap)this.allocationsMap[F]>U&&this.allocationsMap[F]--;for(let F=0;F<this.freeList.length;F++)this.freeList[F]>U&&this.freeList[F]--}freeBlock(U){const F=this.allocations[U];this.freeSpace+=F.size;const e=U-1;if(this.freeList.includes(e)){return this.allocations[e].size+=F.size,void this.removeBlock(U)}const t=U+1;if(this.freeList.includes(t)){const e=this.allocations[t];return e.start-=F.size,e.size+=F.size,void this.removeBlock(U)}this.freeList.push(U)}deallocate(U){const F=this.allocationsMap[U];if(null==F)throw new Error(`allocation ${U} does not exist.`);this.freeBlock(F),delete this.allocationsMap[U]}getFragmentation(){return this.freeSpace/this.allocatedSpace}defragment(){}verifyConsistency(){if(Object.keys(this.allocationsMap).length+this.freeList.length!=this.allocations.length)throw new Error("number of blocks does not match the number of allocations");for(const U in this.allocationsMap){const F=this.allocationsMap[U];if(this.freeList.includes(F))throw new Error("block of used memory is also on the free list")}let U=0;for(let F=0;F<this.allocations.length;F++){const e=this.allocations[F];if(e.start!=U)throw"blocks of memory are not sequential";U+=e.size}if(U!=this.allocatedSpace)throw`allocated size: ${this.allocatedSpace}  does not match allocated blocks: ${U}`;if(this.reservedSpace<this.allocatedSpace)throw`reserved space: ${this.reservedSpace} is less than allocated space: ${this.allocatedSpace}`}}const X={mouse:"mouse",touch:"touch",xr:"xr"};let g=null;class y extends N{constructor(U){super(),this.propagating=!0,this.pointerType=U}stopPropagation(){this.propagating=!1}setCapture(U){g=U}getCapture(){return g}releaseCapture(){g=null}}class I extends y{constructor(U){super(U)}}class x extends I{constructor(U,F){super(X.mouse),this.sourceEvent=U,this.button=U.button,this.clientX=U.clientX,this.clientY=U.clientY;this.rendererX=1*(this.clientX-F.left),this.rendererY=1*(this.clientY-F.top),this.altKey=U.altKey,this.metaKey=U.metaKey,this.ctrlKey=U.ctrlKey,this.shiftKey=U.shiftKey}stopPropagation(){super.stopPropagation(),this.sourceEvent&&this.sourceEvent.stopPropagation()}preventDefault(){this.sourceEvent&&this.sourceEvent.preventDefault()}}class f{constructor(U,F){this.clientX=0,this.clientY=0,this.screenX=0,this.screenY=0,this.pageX=0,this.pageY=0,this.radiusX=0,this.radiusY=0,this.rotationAngle=0,this.force=0,this.altitudeAngle=0,this.azimuthAngle=0,this.touchType="direct",this.identifier=U.identifier,this.clientX=U.clientX,this.clientY=U.clientY,this.screenX=U.screenX,this.screenY=U.screenY,this.pageX=U.pageX,this.pageY=U.pageY,this.radiusX=U.radiusX,this.radiusY=U.radiusY,this.rotationAngle=U.rotationAngle,this.force=U.force;this.rendererX=1*(this.clientX-F.left),this.rendererY=1*(this.clientY-F.top),this.touchPos=new d,this.touchRay=new Z}}class M extends I{constructor(U,F){super(X.touch),this.touches=[],this.changedTouches=[],this.targetTouches=[],this.altKey=!1,this.metaKey=!1,this.ctrlKey=!1,this.shiftKey=!1,this.sourceEvent=U,this.sourceEvent.stopPropagation(),this.altKey=U.altKey,this.metaKey=U.metaKey,this.ctrlKey=U.ctrlKey,this.shiftKey=U.shiftKey;for(let e=0;e<U.touches.length;e++)this.touches.push(new f(U.touches[e],F));if(U.changedTouches)for(let e=0;e<U.changedTouches.length;e++)this.changedTouches.push(new f(U.changedTouches[e],F));if(U.targetTouches)for(let e=0;e<U.targetTouches.length;e++)this.targetTouches.push(new f(U.targetTouches[e],F))}stopPropagation(){super.stopPropagation(),this.sourceEvent&&this.sourceEvent.stopPropagation()}preventDefault(){}}class v extends x{constructor(U,F){super(U,F),this.wheelDelta=U.wheelDelta,this.deltaMode=U.deltaMode,this.deltaX=U.deltaX,this.deltaY=U.deltaY,this.deltaZ=U.deltaZ}}class D extends y{constructor(U,F){super(X.xr),this.button=U,this.controller=F}}class L extends y{constructor(U,F,e){super(X.xr),this.controllers=[],this.viewport=U,this.viewXfo=F,e.forEach((U=>{this.controllers.push(U)}))}}let Y=0;class _ extends k{constructor(){if(super(),"RefCounted"==this.constructor.name)throw new Error("RefCounted should not be instantiated directly.");this.__id=++Y,this.__refs=[],this.__destroyed=!1}getId(){return this.__id}numRefs(){return this.__refs.length}addRef(U){if(!U)throw new Error("Error in RefCounted.addRef: Must provide a referer");return this.__refs.push(U),!0}removeRef(U){if(!U)throw new Error("Error in RefCounted.removeRef: Must provide a referer");const F=this.__refs.indexOf(U);if(-1==F)throw new Error("Error in RefCounted.removeRef: referer not found in refs list.");this.__refs.splice(F,1),0==this.__refs.length&&this.destroy()}getRefer(U){return this.__refs[U]}getRefIndex(U){return this.__refs.indexOf(U)}isDestroyed(){return this.__destroyed}destroy(){this.__destroyed=!0,this.emit("destructing")}}class w extends N{constructor(U){super(),this.name=U}}class z extends N{constructor(U){super(),this.name=U}}class K extends k{constructor(){super(),this.paramEventListenerIDs={},this.paramMapping={},this.params=[],this.deprecatedParamMapping={}}getNumParameters(){return this.params.length}getParameters(){return this.params}getParameterIndex(U){return this.paramMapping[U]}getParameterByIndex(U){return this.params[U]}hasParameter(U){return U in this.paramMapping}addParameterDeprecationMapping(U,F){this.deprecatedParamMapping[U]=F}getParameter(U){let F=this.paramMapping[U];if(null==F){const e=this.deprecatedParamMapping[U];if(!e)return null;console.warn(`Parameter name ${U} is now deprecated. Please use ${e} instead.`),F=this.paramMapping[e]}return this.params[F]}parameterValueChanged(U){this.emit("parameterValueChanged",U)}addParameter(U){return this.insertParameter(U,this.params.length)}insertParameter(U,F){const e=U.getName();null!=this.paramMapping[e]&&(console.warn("Replacing Parameter:"+e),this.removeParameter(e)),U.setOwner(this),this.paramEventListenerIDs[e]=U.on("valueChanged",(F=>{const e={param:U};for(const U in F)e[U]=F[U];this.parameterValueChanged(e)})),this.params.splice(F,0,U);for(let U=F;U<this.params.length;U++)this.paramMapping[this.params[U].getName()]=U;const t=new w(e);return this.emit("parameterAdded",t),U}removeParameter(U){if(null==this.paramMapping[U])throw new Error("Unable to remove Parameter:"+U);const F=this.paramMapping[U];this.params[this.paramMapping[U]].removeListenerById("valueChanged",this.paramEventListenerIDs[U]),this.params.splice(F,1),delete this.paramMapping[U];for(let U=F;U<this.params.length;U++)this.paramMapping[this.params[U].getName()]=U;const e=new z(U);this.emit("parameterRemoved",e)}replaceParameter(U){const F=U.getName();if(null==this.paramMapping[F])throw new Error("Unable to replace Parameter:"+F);const e=this.paramMapping[F];return this.removeParameter(F),this.insertParameter(U,e),U}toJSON(U){const F={type:this.getClassName()},e={};let t=0;for(const F of this.params){const Q=F.toJSON(U);Q&&(e[F.getName()]=Q,t++)}return t>0&&(F.params=e),F}fromJSON(U,F){if(U.params)for(const e in U.params){const t=U.params[e],Q=this.getParameter(e);Q?t.paramPath?null==F||F.resolvePath(t.paramPath,(U=>{this.replaceParameter(U)}),(()=>{console.warn("Unable to resolve shared parameter:"+t.paramPath)})):Q.fromJSON(t,F):console.warn("Param not found:"+e)}}readBinary(U,F){if((null==F?void 0:F.versions["zea-engine"].compare([0,0,3]))>=0){const e=U.loadUInt32();for(let t=0;t<e;t++){const e=U.loadStr(),t=U.loadStr();let Q=this.getParameter(t);if(!Q){if(Q=n.constructClass(e),!Q){console.error("Unable to construct prop:"+t+" of type:"+e);continue}Q.setName(t),this.addParameter(Q)}Q.readBinary(U,F)}}}toString(U){return JSON.stringify(this.toJSON(),null,2)}copyFrom(U,F){let e=U.getNumParameters();for(;e--;){const F=U.getParameterByIndex(e),t=this.getParameter(F.getName());t?t.loadValue(F.value):this.addParameter(F.clone())}}}class H extends N{constructor(U){super(),this.value=U}}class P extends N{constructor(U){super(),this.selected=U}}let O=0;class j extends N{constructor(U,F){super(),this.oldName=U,this.newName=F}}class A extends K{constructor(U=""){super(),this.__ownerItem=void 0,this.__selectable=!0,this.__selected=!1,this.__metaData={},this.__name=U,this.__path=[this.__name],O++}static getNumBaseItems(){return O}getName(){return this.__name}setName(U){if(this.__name!=U){const F=this.__name;this.__name=U,this.updatePath();const e=new j(F,U);this.emit("nameChanged",e)}}updatePath(){null==this.__ownerItem?this.__path=[this.__name]:this.__path=[...this.__ownerItem.getPath(),this.__name]}getPath(){return this.__path}resolvePath(U,F=0){if(0==F&&("."!=U[0]&&U[0]!=this.__name||F++),F==U.length)return this;if(">"==U[F]&&F==U.length-1)return this.getParameter(U[F+1]);const e=this.getParameter(U[F]);if(e)return e;throw new Error("Invalid path:"+U+"["+F+"] member not found")}getOwner(){return this.__ownerItem}setOwner(U){this.__ownerItem!==U?(this.__ownerItem=U,this.updatePath()):U||(this.__ownerItem=void 0,this.updatePath())}isSelectable(){return this.__selectable}setSelectable(U){if(this.__selectable!=U){this.__selectable=U;let F=new H(this.__selectable);return this.emit("selectabilityChanged",F),!0}return!1}isSelected(){return this.__selected}setSelected(U){this.__selected=U;let F=new P(this.__selected);this.emit("selectedChanged",F)}getMetadata(U){return this.__metaData[U]}hasMetadata(U){return U in this.__metaData}setMetadata(U,F){this.__metaData[U]=F}deleteMetadata(U){delete this.__metaData[U]}toJSON(U){const F=super.toJSON(U);return F.name=this.__name,F}fromJSON(U,F){U.name&&(this.__name=U.name),super.fromJSON(U,F)}readBinary(U,F){U.loadStr(),this.setName(U.loadStr()),super.readBinary(U,F)}clone(U){throw new Error(this.constructor.name+" does not implement its clone method")}copyFrom(U,F){super.copyFrom(U,F),this.setName(U.getName())}}const q=function(U,F,e,t,Q){try{const l=new XMLHttpRequest;l.responseType=F,l.addEventListener("timeout",(F=>{throw new Error("The request for "+U+" timed out.")})),l.addEventListener("error",(F=>{throw new Error("The request for "+U+": xhr.readyState:"+l.readyState)})),l.addEventListener("abort",(F=>{throw new Error("The request for "+U+": xhr.readyState:"+l.readyState)})),l.addEventListener("progress",(U=>{Q&&Q(U.total,U.loaded)})),l.addEventListener("loadend",(U=>{200==l.status?e(l):t(l.statusText)})),l.open("GET",U,!0),l.send()}catch(U){t(U)}},$=function(U,F,e,t){q(U,"text",(U=>{F(U.responseText)}),(F=>{if(null==e)throw new Error("Unable to XHR File:"+U);e(F)}),t)},UU=function(U,F,e,t){q(U,"arraybuffer",(U=>{F(U.response)}),(F=>{if(null==e)throw new Error("Unable to XHR File:"+U);e(F)}),t)};function FU(U,F,e){var t=void 0===F?null:F,Q=function(U,F){var e=atob(U);if(F){for(var t=new Uint8Array(e.length),Q=0,l=e.length;Q<l;++Q)t[Q]=e.charCodeAt(Q);return String.fromCharCode.apply(null,new Uint16Array(t.buffer))}return e}(U,void 0!==e&&e),l=Q.indexOf("\n",10)+1,n=Q.substring(l)+(t?"//# sourceMappingURL="+t:""),a=new Blob([n],{type:"application/javascript"});return URL.createObjectURL(a)}function eU(U,F,e){var t;return function(Q){return t=t||FU(U,F,e),new Worker(t,Q)}}var tU=eU("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y29uc3QgQT17fTt2YXIgQjsoQj1BKS51bnBhY2tCcmlkZ2U9ZnVuY3Rpb24oQSl7cmV0dXJuIGZ1bmN0aW9uKEEpe3ZhciBCPXt9O2Z1bmN0aW9uIEkoZyl7aWYoQltnXSlyZXR1cm4gQltnXS5leHBvcnRzO3ZhciBRPUJbZ109e2k6ZyxsOiExLGV4cG9ydHM6e319O3JldHVybiBBW2ddLmNhbGwoUS5leHBvcnRzLFEsUS5leHBvcnRzLEkpLFEubD0hMCxRLmV4cG9ydHN9cmV0dXJuIEkubT1BLEkuYz1CLEkuZD1mdW5jdGlvbihBLEIsZyl7SS5vKEEsQil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLEIse2VudW1lcmFibGU6ITAsZ2V0Omd9KX0sSS5yPWZ1bmN0aW9uKEEpeyJ1bmRlZmluZWQiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6Ik1vZHVsZSJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSl9LEkudD1mdW5jdGlvbihBLEIpe2lmKDEmQiYmKEE9SShBKSksOCZCKXJldHVybiBBO2lmKDQmQiYmIm9iamVjdCI9PXR5cGVvZiBBJiZBJiZBLl9fZXNNb2R1bGUpcmV0dXJuIEE7dmFyIGc9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihJLnIoZyksT2JqZWN0LmRlZmluZVByb3BlcnR5KGcsImRlZmF1bHQiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOkF9KSwyJkImJiJzdHJpbmciIT10eXBlb2YgQSlmb3IodmFyIFEgaW4gQSlJLmQoZyxRLGZ1bmN0aW9uKEIpe3JldHVybiBBW0JdfS5iaW5kKG51bGwsUSkpO3JldHVybiBnfSxJLm49ZnVuY3Rpb24oQSl7dmFyIEI9QSYmQS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIEEuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gQX07cmV0dXJuIEkuZChCLCJhIixCKSxCfSxJLm89ZnVuY3Rpb24oQSxCKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEEsQil9LEkucD0iIixJKEkucz0yKX0oW2Z1bmN0aW9uKEEsQixJKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoQiwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7Y29uc3QgUT1JKDEpLEU9ezA6IkVSQVJfU1VDQ0VTUyIsMTA6IkVSQVJfRU5EX0FSQ0hJVkUiLDExOiJFUkFSX05PX01FTU9SWSIsMTI6IkVSQVJfQkFEX0RBVEEiLDEzOiJFUkFSX0JBRF9BUkNISVZFIiwxNDoiRVJBUl9VTktOT1dOX0ZPUk1BVCIsMTU6IkVSQVJfRU9QRU4iLDE2OiJFUkFSX0VDUkVBVEUiLDE3OiJFUkFSX0VDTE9TRSIsMTg6IkVSQVJfRVJFQUQiLDE5OiJFUkFSX0VXUklURSIsMjA6IkVSQVJfU01BTExfQlVGIiwyMToiRVJBUl9VTktOT1dOIiwyMjoiRVJBUl9NSVNTSU5HX1BBU1NXT1JEIiwyMzoiRVJBUl9FUkVGRVJFTkNFIiwyNDoiRVJBUl9CQURfUEFTU1dPUkQifSxDPXswOiJTdWNjZXNzIiwxMToiTm90IGVub3VnaCBtZW1vcnkiLDEyOiJBcmNoaXZlIGhlYWRlciBvciBkYXRhIGFyZSBkYW1hZ2VkIiwxMzoiRmlsZSBpcyBub3QgUkFSIGFyY2hpdmUiLDE0OiJVbmtub3duIGFyY2hpdmUgZm9ybWF0IiwxNToiRmlsZSBvcGVuIGVycm9yIiwxNjoiRmlsZSBjcmVhdGUgZXJyb3IiLDE3OiJGaWxlIGNsb3NlIGVycm9yIiwxODoiRmlsZSByZWFkIGVycm9yIiwxOToiRmlsZSB3cml0ZSBlcnJvciIsMjA6IkJ1ZmZlciBmb3IgYXJjaGl2ZSBjb21tZW50IGlzIHRvbyBzbWFsbCwgY29tbWVudCB0cnVuY2F0ZWQiLDIxOiJVbmtub3duIGVycm9yIiwyMjoiUGFzc3dvcmQgZm9yIGVuY3J5cHRlZCBmaWxlIG9yIGhlYWRlciBpcyBub3Qgc3BlY2lmaWVkIiwyMzoiQ2Fubm90IG9wZW4gZmlsZSBzb3VyY2UgZm9yIHJlZmVyZW5jZSByZWNvcmQiLDI0OiJXcm9uZyBwYXNzd29yZCBpcyBzcGVjaWZpZWQifTtjbGFzcyBpe2NvbnN0cnVjdG9yKEE9IiIpe3RoaXMuX3Bhc3N3b3JkPUEsdGhpcy5fYXJjaGl2ZT1udWxsfWdldEZpbGVMaXN0KCl7bGV0IEEsW0IsSV09dGhpcy5vcGVuQXJjKCEwKTtpZigiU1VDQ0VTUyIhPT1CLnN0YXRlKUE9W0IsbnVsbF07ZWxzZXtsZXQgQixnLFE9W107Zm9yKDtbQixnXT10aGlzLnByb2Nlc3NOZXh0RmlsZSgoKCk9PiEwKSksIlNVQ0NFU1MiPT09Qi5zdGF0ZTspUS5wdXNoKGcuZmlsZUhlYWRlcik7QT0iRVJBUl9FTkRfQVJDSElWRSIhPT1CLnJlYXNvbj9bQixudWxsXTpbe3N0YXRlOiJTVUNDRVNTIn0se2FyY0hlYWRlcjpJLGZpbGVIZWFkZXJzOlF9XX1yZXR1cm4gdGhpcy5jbG9zZUFyYygpLEF9ZXh0cmFjdEFsbCgpe2xldCBBLFtCLEldPXRoaXMub3BlbkFyYyghMSk7aWYoIlNVQ0NFU1MiIT09Qi5zdGF0ZSlBPVtCLG51bGxdO2Vsc2V7bGV0IEIsZyxRPVtdO2Zvcig7W0IsZ109dGhpcy5wcm9jZXNzTmV4dEZpbGUoKCgpPT4hMSkpLCJTVUNDRVNTIj09PUIuc3RhdGU7KVEucHVzaChnKTtBPSJFUkFSX0VORF9BUkNISVZFIiE9PUIucmVhc29uP1tCLG51bGxdOlt7c3RhdGU6IlNVQ0NFU1MifSx7YXJjSGVhZGVyOkksZmlsZXM6UX1dfXJldHVybiB0aGlzLmNsb3NlQXJjKCksQX1leHRyYWN0RmlsZXMoQSxCKXtsZXQgSSxbZyxRXT10aGlzLm9wZW5BcmMoITEsQiksRT17fTtmb3IobGV0IEI9MDtCPEEubGVuZ3RoOysrQilFW0FbQl1dPUI7aWYoIlNVQ0NFU1MiIT09Zy5zdGF0ZSlJPVtnLG51bGxdO2Vsc2V7bGV0IEIsZyxDPUFycmF5KEEubGVuZ3RoKS5maWxsKG51bGwpLGk9MDtmb3IoOzspe2xldCBJPSExLFE9bnVsbDtpZihbQixnXT10aGlzLnByb2Nlc3NOZXh0RmlsZSgoQT0+QSBpbiBFPyhRPUVbQV0sITEpOihJPSEwLCEwKSkpLCJTVUNDRVNTIiE9PUIuc3RhdGUpYnJlYWs7aWYoIUkmJihDW1FdPWcsKytpPT09QS5sZW5ndGgpKXtCLnJlYXNvbj0iRVJBUl9FTkRfQVJDSElWRSI7YnJlYWt9fUk9IkVSQVJfRU5EX0FSQ0hJVkUiIT09Qi5yZWFzb24/W0IsbnVsbF06W3tzdGF0ZToiU1VDQ0VTUyJ9LHthcmNIZWFkZXI6USxmaWxlczpDfV19cmV0dXJuIHRoaXMuY2xvc2VBcmMoKSxJfWZpbGVDcmVhdGVkKEEpe31jbG9zZShBKXt0aGlzLl9sYXN0RmlsZUNvbnRlbnQ9dGhpcy5jbG9zZUZpbGUoQSl9b3BlbkFyYyhBLEIpe1EuRXh0LmN1cnJlbnQ9dGhpcyx0aGlzLl9hcmNoaXZlPW5ldyBnLlJhckFyY2hpdmU7bGV0IEksRT10aGlzLl9hcmNoaXZlLm9wZW4odGhpcy5fZmlsZVBhdGgsQnx8dGhpcy5fcGFzc3dvcmQsQSk7cmV0dXJuIEk9MCE9PUUuc3RhdGUuZXJyQ29kZT9bdGhpcy5nZXRGYWlsSW5mbyhFLnN0YXRlLmVyckNvZGUsRS5zdGF0ZS5lcnJUeXBlKSxudWxsXTpbe3N0YXRlOiJTVUNDRVNTIn0se2NvbW1lbnQ6RS5jb21tZW50LGZsYWdzOnt2b2x1bWU6MCE9KDEmRS5mbGFncyksbG9jazowIT0oNCZFLmZsYWdzKSxzb2xpZDowIT0oOCZFLmZsYWdzKSxhdXRoSW5mbzowIT0oMzImRS5mbGFncykscmVjb3ZlcnlSZWNvcmQ6MCE9KDY0JkUuZmxhZ3MpLGhlYWRlckVuY3J5cHRlZDowIT0oMTI4JkUuZmxhZ3MpfX1dLFEuRXh0LmN1cnJlbnQ9bnVsbCxJfXByb2Nlc3NOZXh0RmlsZShBKXtsZXQgQjtRLkV4dC5jdXJyZW50PXRoaXM7bGV0IEk9dGhpcy5fYXJjaGl2ZS5nZXRGaWxlSGVhZGVyKCksZz1be3N0YXRlOiJTVUNDRVNTIn0sbnVsbF07aWYoMD09PUkuc3RhdGUuZXJyQ29kZSl7bGV0IEI9QShJLm5hbWUpO3RoaXMuX2xhc3RGaWxlQ29udGVudD1udWxsO2xldCBRPXRoaXMuX2FyY2hpdmUucmVhZEZpbGUoQik7MD09PVEuZXJyQ29kZXx8Qnx8KGdbMF09dGhpcy5nZXRGYWlsSW5mbyhRLmVyckNvZGUsUS5lcnJUeXBlKSwyMj09PVEuZXJyQ29kZT9RPXRoaXMuX2FyY2hpdmUucmVhZEZpbGUoITApOlEuZXJyQ29kZT0wKSwwPT09US5lcnJDb2RlP2dbMV09dGhpcy5fbGFzdEZpbGVDb250ZW50OihJLnN0YXRlLmVyckNvZGU9US5lcnJDb2RlLEkuc3RhdGUuZXJyVHlwZT1RLmVyclR5cGUpLHRoaXMuX2xhc3RGaWxlQ29udGVudD1udWxsfXJldHVybiBCPTAhPT1JLnN0YXRlLmVyckNvZGU/W3RoaXMuZ2V0RmFpbEluZm8oSS5zdGF0ZS5lcnJDb2RlLEkuc3RhdGUuZXJyVHlwZSksbnVsbF06W3tzdGF0ZToiU1VDQ0VTUyJ9LHtmaWxlSGVhZGVyOntuYW1lOkkubmFtZSxmbGFnczp7ZW5jcnlwdGVkOjAhPSg0JkkuZmxhZ3MpLHNvbGlkOjAhPSgxNiZJLmZsYWdzKSxkaXJlY3Rvcnk6MCE9KDMyJkkuZmxhZ3MpfSxwYWNrU2l6ZTpJLnBhY2tTaXplLHVucFNpemU6SS51bnBTaXplLGNyYzpJLmNyYyx0aW1lOmZ1bmN0aW9uKEEpe2NvbnN0IEI9WzUsNiw1LDUsNCw3XTtsZXQgST1bXTtmb3IobGV0IGcgb2YgQilJLnB1c2goQSYoMTw8ZyktMSksQT4+PWc7bGV0IGc9QT0+QTwxMD8iMCIrQToiIitBO3JldHVybmAkezE5ODArKEk9SS5yZXZlcnNlKCkpWzBdfS0ke2coSVsxXSl9LSR7ZyhJWzJdKX1UJHtnKElbM10pfToke2coSVs0XSl9OiR7ZygyKklbNV0pfS4wMDBgfShJLnRpbWUpLHVucFZlcjpgJHtNYXRoLmZsb29yKEkudW5wVmVyLzEwKX0uJHtJLnVucFZlciUxMH1gLG1ldGhvZDpmdW5jdGlvbihBKXtyZXR1cm57NDg6IlN0b3JpbmciLDQ5OiJGYXN0ZXN0Iiw1MDoiRmFzdCIsNTE6Ik5vcm1hbCIsNTI6Ikdvb2QiLDUzOiJCZXN0In1bQV18fCJVbmtub3duIn0oSS5tZXRob2QpfSxleHRyYWN0Omd9XSxRLkV4dC5jdXJyZW50PW51bGwsQn1jbG9zZUFyYygpe1EuRXh0LmN1cnJlbnQ9dGhpcyx0aGlzLl9hcmNoaXZlLmRlbGV0ZSgpLFEuRXh0LmN1cnJlbnQ9bnVsbCx0aGlzLl9hcmNoaXZlPW51bGx9Z2V0RmFpbEluZm8oQSxCKXtyZXR1cm57c3RhdGU6IkZBSUwiLHJlYXNvbjpFW0FdLG1zZzpDW0FdfX19aS5fY3VycmVudD1udWxsLEIuRXh0cmFjdG9yPWl9LGZ1bmN0aW9uKEEsQixJKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoQiwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksQi5FeHQ9e2N1cnJlbnQ6bnVsbH19LGZ1bmN0aW9uKEEsQixJKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoQiwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksZnVuY3Rpb24oQSl7Zm9yKHZhciBJIGluIEEpQi5oYXNPd25Qcm9wZXJ0eShJKXx8KEJbSV09QVtJXSl9KEkoMykpO3ZhciBnPUkoMSk7Qi5FeHQ9Zy5FeHR9LGZ1bmN0aW9uKEEsQixJKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoQiwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSk7Y29uc3QgZz1JKDQpLFE9SSg2KTtCLmNyZWF0ZUV4dHJhY3RvckZyb21EYXRhPWZ1bmN0aW9uKEEsQj0iIil7cmV0dXJuIG5ldyBnLkRhdGFFeHRyYWN0b3IoQSxCKX0sQi5jcmVhdGVFeHRyYWN0b3JGcm9tRmlsZT1mdW5jdGlvbihBLEI9IiIsST0iIil7cmV0dXJuIG5ldyBRLkZpbGVFeHRyYWN0b3IoQSxCLEkpfX0sZnVuY3Rpb24oQSxCLEkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShCLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtjb25zdCBRPUkoNSksRT1JKDApO0IuRGF0YUV4dHJhY3Rvcj1jbGFzcyBleHRlbmRzIEUuRXh0cmFjdG9ye2NvbnN0cnVjdG9yKEEsQil7c3VwZXIoQiksdGhpcy5kYXRhRmlsZXM9e30sdGhpcy5kYXRhRmlsZU1hcD17fSx0aGlzLmN1cnJlbnRGZD0xO2xldCBJPXtmaWxlOm5ldyBRLkRhdGFGaWxlKG5ldyBVaW50OEFycmF5KEEpKSxmZDp0aGlzLmN1cnJlbnRGZCsrfTt0aGlzLl9maWxlUGF0aD0iX2RlZmF1bHRVbnJhckpTXy5yYXIiLHRoaXMuZGF0YUZpbGVzW3RoaXMuX2ZpbGVQYXRoXT1JLHRoaXMuZGF0YUZpbGVNYXBbSS5mZF09dGhpcy5fZmlsZVBhdGh9b3BlbihBKXtsZXQgQj10aGlzLmRhdGFGaWxlc1tBXTtyZXR1cm4gQj9CLmZkOjB9Y3JlYXRlKEEpe2xldCBCPXRoaXMuY3VycmVudEZkKys7cmV0dXJuIHRoaXMuZGF0YUZpbGVzW0FdPXtmaWxlOm5ldyBRLkRhdGFGaWxlLGZkOnRoaXMuY3VycmVudEZkKyt9LHRoaXMuZGF0YUZpbGVNYXBbQl09QSxCfWNsb3NlRmlsZShBKXtsZXQgQj10aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW0FdXTtpZighQilyZXR1cm4gbnVsbDtsZXQgST1CLmZpbGUucmVhZEFsbCgpO3JldHVybiAxIT09QT8oZGVsZXRlIHRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbQV1dLGRlbGV0ZSB0aGlzLmRhdGFGaWxlTWFwW0FdKTpCLmZpbGUuc2VlaygwLCJTRVQiKSxJfXJlYWQoQSxCLEkpe2xldCBRPXRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbQV1dO2lmKCFRKXJldHVybi0xO2xldCBFPVEuZmlsZS5yZWFkKEkpO3JldHVybiBudWxsPT09RT8tMTooZy5IRUFQVTguc2V0KEUsQiksRS5ieXRlTGVuZ3RoKX13cml0ZShBLEIsSSl7bGV0IFE9dGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFtBXV07cmV0dXJuISFRJiYoUS5maWxlLndyaXRlKGcuSEVBUFU4LnNsaWNlKEIsQitJKSksITApfXRlbGwoQSl7bGV0IEI9dGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFtBXV07cmV0dXJuIEI/Qi5maWxlLnRlbGwoKTotMX1zZWVrKEEsQixJKXtsZXQgZz10aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW0FdXTtyZXR1cm4hIWcmJmcuZmlsZS5zZWVrKEIsSSl9fX0sZnVuY3Rpb24oQSxCLEkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShCLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxCLkRhdGFGaWxlPWNsYXNze2NvbnN0cnVjdG9yKEEpe3RoaXMuYnVmZmVycz1bXSx0aGlzLnBvcz0wLHRoaXMuc2l6ZT0wLEEmJih0aGlzLmJ1ZmZlcnMucHVzaChBKSx0aGlzLnNpemU9QS5ieXRlTGVuZ3RoLHRoaXMucG9zPTApfXJlYWQoQSl7aWYodGhpcy5mbGF0dGVuKCksQSt0aGlzLnBvcz50aGlzLnNpemUpcmV0dXJuIG51bGw7bGV0IEI9dGhpcy5wb3M7cmV0dXJuIHRoaXMucG9zKz1BLHRoaXMuYnVmZmVyc1swXS5zbGljZShCLHRoaXMucG9zKX1yZWFkQWxsKCl7cmV0dXJuIHRoaXMuZmxhdHRlbigpLHRoaXMuYnVmZmVyc1swXX13cml0ZShBKXtyZXR1cm4gdGhpcy5idWZmZXJzLnB1c2goQSksdGhpcy5zaXplKz1BLmJ5dGVMZW5ndGgsdGhpcy5wb3MrPUEuYnl0ZUxlbmd0aCwhMH10ZWxsKCl7cmV0dXJuIHRoaXMucG9zfXNlZWsoQSxCKXtsZXQgST10aGlzLnBvcztyZXR1cm4iU0VUIj09PUI/ST1BOiJDVVIiPT09Qj9JKz1BOkk9dGhpcy5zaXplLUEsIShJPDB8fEk+dGhpcy5zaXplfHwodGhpcy5wb3M9SSwwKSl9ZmxhdHRlbigpe2lmKHRoaXMuYnVmZmVycy5sZW5ndGg8PTEpcmV0dXJuO2xldCBBPW5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSksQj0wO2ZvcihsZXQgSSBvZiB0aGlzLmJ1ZmZlcnMpQS5zZXQoSSxCKSxCKz1JLmJ5dGVMZW5ndGg7dGhpcy5idWZmZXJzPVtBXX19fSxmdW5jdGlvbihBLEIsSSl7KGZ1bmN0aW9uKEEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShCLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KTtjb25zdCBRPUkoMTIpLEU9SSgxMyksQz1JKDApO0IuRmlsZUV4dHJhY3Rvcj1jbGFzcyBleHRlbmRzIEMuRXh0cmFjdG9ye2NvbnN0cnVjdG9yKEEsQixJKXtzdXBlcihJKSx0aGlzLl9maWxlUGF0aD1BLHRoaXMuZmlsZU1hcD17fSx0aGlzLl90YXJnZXQ9Qn1vcGVuKEEpe2xldCBCPVEub3BlblN5bmMoQSwiciIpO3JldHVybiB0aGlzLmZpbGVNYXBbQl09e3NpemU6US5mc3RhdFN5bmMoQikuc2l6ZSxwb3M6MCxuYW1lOkF9LEJ9Y3JlYXRlKEEpe2xldCBCPUUuam9pbih0aGlzLl90YXJnZXQsQSk7RS5wYXJzZShCKS5kaXIuc3BsaXQoIi8iKS5yZWR1Y2UoKChBLEIpPT4oQSs9QisiLyIsUS5leGlzdHNTeW5jKEEpfHxRLm1rZGlyU3luYyhBKSxBKSksIiIpO2xldCBJPVEub3BlblN5bmMoQiwidyIpO3JldHVybiB0aGlzLmZpbGVNYXBbSV09e3NpemU6MCxwb3M6MCxuYW1lOkF9LEl9Y2xvc2VGaWxlKEEpe3JldHVybiBkZWxldGUgdGhpcy5maWxlTWFwW0FdLFEuY2xvc2VTeW5jKEEpLG51bGx9cmVhZChCLEksRSl7bGV0IEM9dGhpcy5maWxlTWFwW0JdLGk9bmV3IEEoRSksbz1RLnJlYWRTeW5jKEIsaSwwLEUsQy5wb3MpO3JldHVybiBnLkhFQVBVOC5zZXQoaSxJKSxDLnBvcys9byxvfXdyaXRlKEIsSSxFKXtsZXQgQz10aGlzLmZpbGVNYXBbQl0saT1RLndyaXRlU3luYyhCLG5ldyBBKGcuSEVBUFU4LnN1YmFycmF5KEksSStFKSksMCxFKTtyZXR1cm4gQy5wb3MrPWksQy5zaXplKz1pLGk9PT1FfXRlbGwoQSl7cmV0dXJuIHRoaXMuZmlsZU1hcFtBXS5wb3N9c2VlayhBLEIsSSl7bGV0IGc9dGhpcy5maWxlTWFwW0FdLFE9Zy5wb3M7cmV0dXJuIlNFVCI9PT1JP1E9MDoiRU5EIj09PUkmJihRPWcuc2l6ZSksISgoUSs9Qik8MHx8UT5nLnNpemV8fChnLnBvcz1RLDApKX19fSkuY2FsbCh0aGlzLEkoNykuQnVmZmVyKX0sZnVuY3Rpb24oQSxCLEkpeyhmdW5jdGlvbihBKXsKLyohCiAgICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuCiAgICoKICAgKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz4KICAgKiBAbGljZW5zZSAgTUlUCiAgICovCnZhciBnPUkoOSksUT1JKDEwKSxFPUkoMTEpO2Z1bmN0aW9uIEMoKXtyZXR1cm4gby5UWVBFRF9BUlJBWV9TVVBQT1JUPzIxNDc0ODM2NDc6MTA3Mzc0MTgyM31mdW5jdGlvbiBpKEEsQil7aWYoQygpPEIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoIik7cmV0dXJuIG8uVFlQRURfQVJSQVlfU1VQUE9SVD8oQT1uZXcgVWludDhBcnJheShCKSkuX19wcm90b19fPW8ucHJvdG90eXBlOihudWxsPT09QSYmKEE9bmV3IG8oQikpLEEubGVuZ3RoPUIpLEF9ZnVuY3Rpb24gbyhBLEIsSSl7aWYoIShvLlRZUEVEX0FSUkFZX1NVUFBPUlR8fHRoaXMgaW5zdGFuY2VvZiBvKSlyZXR1cm4gbmV3IG8oQSxCLEkpO2lmKCJudW1iZXIiPT10eXBlb2YgQSl7aWYoInN0cmluZyI9PXR5cGVvZiBCKXRocm93IG5ldyBFcnJvcigiSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmciKTtyZXR1cm4gcih0aGlzLEEpfXJldHVybiB0KHRoaXMsQSxCLEkpfWZ1bmN0aW9uIHQoQSxCLEksZyl7aWYoIm51bWJlciI9PXR5cGVvZiBCKXRocm93IG5ldyBUeXBlRXJyb3IoJyJ2YWx1ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtyZXR1cm4idW5kZWZpbmVkIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZCIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/ZnVuY3Rpb24oQSxCLEksZyl7aWYoQi5ieXRlTGVuZ3RoLEk8MHx8Qi5ieXRlTGVuZ3RoPEkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIidvZmZzZXQnIGlzIG91dCBvZiBib3VuZHMiKTtpZihCLmJ5dGVMZW5ndGg8SSsoZ3x8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIidsZW5ndGgnIGlzIG91dCBvZiBib3VuZHMiKTtyZXR1cm4gQj12b2lkIDA9PT1JJiZ2b2lkIDA9PT1nP25ldyBVaW50OEFycmF5KEIpOnZvaWQgMD09PWc/bmV3IFVpbnQ4QXJyYXkoQixJKTpuZXcgVWludDhBcnJheShCLEksZyksby5UWVBFRF9BUlJBWV9TVVBQT1JUPyhBPUIpLl9fcHJvdG9fXz1vLnByb3RvdHlwZTpBPWEoQSxCKSxBfShBLEIsSSxnKToic3RyaW5nIj09dHlwZW9mIEI/ZnVuY3Rpb24oQSxCLEkpe2lmKCJzdHJpbmciPT10eXBlb2YgSSYmIiIhPT1JfHwoST0idXRmOCIpLCFvLmlzRW5jb2RpbmcoSSkpdGhyb3cgbmV3IFR5cGVFcnJvcignImVuY29kaW5nIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIGc9MHxzKEIsSSksUT0oQT1pKEEsZykpLndyaXRlKEIsSSk7cmV0dXJuIFEhPT1nJiYoQT1BLnNsaWNlKDAsUSkpLEF9KEEsQixJKTpmdW5jdGlvbihBLEIpe2lmKG8uaXNCdWZmZXIoQikpe3ZhciBJPTB8bihCLmxlbmd0aCk7cmV0dXJuIDA9PT0oQT1pKEEsSSkpLmxlbmd0aHx8Qi5jb3B5KEEsMCwwLEkpLEF9aWYoQil7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmQi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8Imxlbmd0aCJpbiBCKXJldHVybiJudW1iZXIiIT10eXBlb2YgQi5sZW5ndGh8fGZ1bmN0aW9uKEEpe3JldHVybiBBIT1BfShCLmxlbmd0aCk/aShBLDApOmEoQSxCKTtpZigiQnVmZmVyIj09PUIudHlwZSYmRShCLmRhdGEpKXJldHVybiBhKEEsQi5kYXRhKX10aHJvdyBuZXcgVHlwZUVycm9yKCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuIil9KEEsQil9ZnVuY3Rpb24gZShBKXtpZigibnVtYmVyIiE9dHlwZW9mIEEpdGhyb3cgbmV3IFR5cGVFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKTtpZihBPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpfWZ1bmN0aW9uIHIoQSxCKXtpZihlKEIpLEE9aShBLEI8MD8wOjB8bihCKSksIW8uVFlQRURfQVJSQVlfU1VQUE9SVClmb3IodmFyIEk9MDtJPEI7KytJKUFbSV09MDtyZXR1cm4gQX1mdW5jdGlvbiBhKEEsQil7dmFyIEk9Qi5sZW5ndGg8MD8wOjB8bihCLmxlbmd0aCk7QT1pKEEsSSk7Zm9yKHZhciBnPTA7ZzxJO2crPTEpQVtnXT0yNTUmQltnXTtyZXR1cm4gQX1mdW5jdGlvbiBuKEEpe2lmKEE+PUMoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCIrQygpLnRvU3RyaW5nKDE2KSsiIGJ5dGVzIik7cmV0dXJuIDB8QX1mdW5jdGlvbiBzKEEsQil7aWYoby5pc0J1ZmZlcihBKSlyZXR1cm4gQS5sZW5ndGg7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmImZ1bmN0aW9uIj09dHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyYmKEFycmF5QnVmZmVyLmlzVmlldyhBKXx8QSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSlyZXR1cm4gQS5ieXRlTGVuZ3RoOyJzdHJpbmciIT10eXBlb2YgQSYmKEE9IiIrQSk7dmFyIEk9QS5sZW5ndGg7aWYoMD09PUkpcmV0dXJuIDA7Zm9yKHZhciBnPSExOzspc3dpdGNoKEIpe2Nhc2UiYXNjaWkiOmNhc2UibGF0aW4xIjpjYXNlImJpbmFyeSI6cmV0dXJuIEk7Y2FzZSJ1dGY4IjpjYXNlInV0Zi04IjpjYXNlIHZvaWQgMDpyZXR1cm4geChBKS5sZW5ndGg7Y2FzZSJ1Y3MyIjpjYXNlInVjcy0yIjpjYXNlInV0ZjE2bGUiOmNhc2UidXRmLTE2bGUiOnJldHVybiAyKkk7Y2FzZSJoZXgiOnJldHVybiBJPj4+MTtjYXNlImJhc2U2NCI6cmV0dXJuIHYoQSkubGVuZ3RoO2RlZmF1bHQ6aWYoZylyZXR1cm4geChBKS5sZW5ndGg7Qj0oIiIrQikudG9Mb3dlckNhc2UoKSxnPSEwfX1mdW5jdGlvbiBEKEEsQixJKXt2YXIgZz1BW0JdO0FbQl09QVtJXSxBW0ldPWd9ZnVuY3Rpb24gRihBLEIsSSxnLFEpe2lmKDA9PT1BLmxlbmd0aClyZXR1cm4tMTtpZigic3RyaW5nIj09dHlwZW9mIEk/KGc9SSxJPTApOkk+MjE0NzQ4MzY0Nz9JPTIxNDc0ODM2NDc6STwtMjE0NzQ4MzY0OCYmKEk9LTIxNDc0ODM2NDgpLEk9K0ksaXNOYU4oSSkmJihJPVE/MDpBLmxlbmd0aC0xKSxJPDAmJihJPUEubGVuZ3RoK0kpLEk+PUEubGVuZ3RoKXtpZihRKXJldHVybi0xO0k9QS5sZW5ndGgtMX1lbHNlIGlmKEk8MCl7aWYoIVEpcmV0dXJuLTE7ST0wfWlmKCJzdHJpbmciPT10eXBlb2YgQiYmKEI9by5mcm9tKEIsZykpLG8uaXNCdWZmZXIoQikpcmV0dXJuIDA9PT1CLmxlbmd0aD8tMTp3KEEsQixJLGcsUSk7aWYoIm51bWJlciI9PXR5cGVvZiBCKXJldHVybiBCJj0yNTUsby5UWVBFRF9BUlJBWV9TVVBQT1JUJiYiZnVuY3Rpb24iPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj9RP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChBLEIsSSk6VWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChBLEIsSSk6dyhBLFtCXSxJLGcsUSk7dGhyb3cgbmV3IFR5cGVFcnJvcigidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyIil9ZnVuY3Rpb24gdyhBLEIsSSxnLFEpe3ZhciBFLEM9MSxpPUEubGVuZ3RoLG89Qi5sZW5ndGg7aWYodm9pZCAwIT09ZyYmKCJ1Y3MyIj09PShnPVN0cmluZyhnKS50b0xvd2VyQ2FzZSgpKXx8InVjcy0yIj09PWd8fCJ1dGYxNmxlIj09PWd8fCJ1dGYtMTZsZSI9PT1nKSl7aWYoQS5sZW5ndGg8Mnx8Qi5sZW5ndGg8MilyZXR1cm4tMTtDPTIsaS89MixvLz0yLEkvPTJ9ZnVuY3Rpb24gdChBLEIpe3JldHVybiAxPT09Qz9BW0JdOkEucmVhZFVJbnQxNkJFKEIqQyl9aWYoUSl7dmFyIGU9LTE7Zm9yKEU9STtFPGk7RSsrKWlmKHQoQSxFKT09PXQoQiwtMT09PWU/MDpFLWUpKXtpZigtMT09PWUmJihlPUUpLEUtZSsxPT09bylyZXR1cm4gZSpDfWVsc2UtMSE9PWUmJihFLT1FLWUpLGU9LTF9ZWxzZSBmb3IoSStvPmkmJihJPWktbyksRT1JO0U+PTA7RS0tKXtmb3IodmFyIHI9ITAsYT0wO2E8bzthKyspaWYodChBLEUrYSkhPT10KEIsYSkpe3I9ITE7YnJlYWt9aWYocilyZXR1cm4gRX1yZXR1cm4tMX1mdW5jdGlvbiBjKEEsQixJLGcpe0k9TnVtYmVyKEkpfHwwO3ZhciBRPUEubGVuZ3RoLUk7Zz8oZz1OdW1iZXIoZykpPlEmJihnPVEpOmc9UTt2YXIgRT1CLmxlbmd0aDtpZihFJTIhPTApdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBoZXggc3RyaW5nIik7Zz5FLzImJihnPUUvMik7Zm9yKHZhciBDPTA7QzxnOysrQyl7dmFyIGk9cGFyc2VJbnQoQi5zdWJzdHIoMipDLDIpLDE2KTtpZihpc05hTihpKSlyZXR1cm4gQztBW0krQ109aX1yZXR1cm4gQ31mdW5jdGlvbiBoKEEsQixJLGcpe3JldHVybiBiKHgoQixBLmxlbmd0aC1JKSxBLEksZyl9ZnVuY3Rpb24geShBLEIsSSxnKXtyZXR1cm4gYihmdW5jdGlvbihBKXtmb3IodmFyIEI9W10sST0wO0k8QS5sZW5ndGg7KytJKUIucHVzaCgyNTUmQS5jaGFyQ29kZUF0KEkpKTtyZXR1cm4gQn0oQiksQSxJLGcpfWZ1bmN0aW9uIFIoQSxCLEksZyl7cmV0dXJuIHkoQSxCLEksZyl9ZnVuY3Rpb24gVShBLEIsSSxnKXtyZXR1cm4gYih2KEIpLEEsSSxnKX1mdW5jdGlvbiBHKEEsQixJLGcpe3JldHVybiBiKGZ1bmN0aW9uKEEsQil7Zm9yKHZhciBJLGcsUSxFPVtdLEM9MDtDPEEubGVuZ3RoJiYhKChCLT0yKTwwKTsrK0MpZz0oST1BLmNoYXJDb2RlQXQoQykpPj44LFE9SSUyNTYsRS5wdXNoKFEpLEUucHVzaChnKTtyZXR1cm4gRX0oQixBLmxlbmd0aC1JKSxBLEksZyl9ZnVuY3Rpb24gUyhBLEIsSSl7cmV0dXJuIDA9PT1CJiZJPT09QS5sZW5ndGg/Zy5mcm9tQnl0ZUFycmF5KEEpOmcuZnJvbUJ5dGVBcnJheShBLnNsaWNlKEIsSSkpfWZ1bmN0aW9uIGsoQSxCLEkpe0k9TWF0aC5taW4oQS5sZW5ndGgsSSk7Zm9yKHZhciBnPVtdLFE9QjtRPEk7KXt2YXIgRSxDLGksbyx0PUFbUV0sZT1udWxsLHI9dD4yMzk/NDp0PjIyMz8zOnQ+MTkxPzI6MTtpZihRK3I8PUkpc3dpdGNoKHIpe2Nhc2UgMTp0PDEyOCYmKGU9dCk7YnJlYWs7Y2FzZSAyOjEyOD09KDE5MiYoRT1BW1ErMV0pKSYmKG89KDMxJnQpPDw2fDYzJkUpPjEyNyYmKGU9byk7YnJlYWs7Y2FzZSAzOkU9QVtRKzFdLEM9QVtRKzJdLDEyOD09KDE5MiZFKSYmMTI4PT0oMTkyJkMpJiYobz0oMTUmdCk8PDEyfCg2MyZFKTw8Nnw2MyZDKT4yMDQ3JiYobzw1NTI5Nnx8bz41NzM0MykmJihlPW8pO2JyZWFrO2Nhc2UgNDpFPUFbUSsxXSxDPUFbUSsyXSxpPUFbUSszXSwxMjg9PSgxOTImRSkmJjEyOD09KDE5MiZDKSYmMTI4PT0oMTkyJmkpJiYobz0oMTUmdCk8PDE4fCg2MyZFKTw8MTJ8KDYzJkMpPDw2fDYzJmkpPjY1NTM1JiZvPDExMTQxMTImJihlPW8pfW51bGw9PT1lPyhlPTY1NTMzLHI9MSk6ZT42NTUzNSYmKGUtPTY1NTM2LGcucHVzaChlPj4+MTAmMTAyM3w1NTI5NiksZT01NjMyMHwxMDIzJmUpLGcucHVzaChlKSxRKz1yfXJldHVybiBmdW5jdGlvbihBKXt2YXIgQj1BLmxlbmd0aDtpZihCPD1mKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxBKTtmb3IodmFyIEk9IiIsZz0wO2c8QjspSSs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsQS5zbGljZShnLGcrPWYpKTtyZXR1cm4gSX0oZyl9Qi5CdWZmZXI9byxCLlNsb3dCdWZmZXI9ZnVuY3Rpb24oQSl7cmV0dXJuK0EhPUEmJihBPTApLG8uYWxsb2MoK0EpfSxCLklOU1BFQ1RfTUFYX0JZVEVTPTUwLG8uVFlQRURfQVJSQVlfU1VQUE9SVD12b2lkIDAhPT1BLlRZUEVEX0FSUkFZX1NVUFBPUlQ/QS5UWVBFRF9BUlJBWV9TVVBQT1JUOmZ1bmN0aW9uKCl7dHJ5e3ZhciBBPW5ldyBVaW50OEFycmF5KDEpO3JldHVybiBBLl9fcHJvdG9fXz17X19wcm90b19fOlVpbnQ4QXJyYXkucHJvdG90eXBlLGZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19LDQyPT09QS5mb28oKSYmImZ1bmN0aW9uIj09dHlwZW9mIEEuc3ViYXJyYXkmJjA9PT1BLnN1YmFycmF5KDEsMSkuYnl0ZUxlbmd0aH1jYXRjaChBKXtyZXR1cm4hMX19KCksQi5rTWF4TGVuZ3RoPUMoKSxvLnBvb2xTaXplPTgxOTIsby5fYXVnbWVudD1mdW5jdGlvbihBKXtyZXR1cm4gQS5fX3Byb3RvX189by5wcm90b3R5cGUsQX0sby5mcm9tPWZ1bmN0aW9uKEEsQixJKXtyZXR1cm4gdChudWxsLEEsQixJKX0sby5UWVBFRF9BUlJBWV9TVVBQT1JUJiYoby5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLG8uX19wcm90b19fPVVpbnQ4QXJyYXksInVuZGVmaW5lZCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5zcGVjaWVzJiZvW1N5bWJvbC5zcGVjaWVzXT09PW8mJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFN5bWJvbC5zcGVjaWVzLHt2YWx1ZTpudWxsLGNvbmZpZ3VyYWJsZTohMH0pKSxvLmFsbG9jPWZ1bmN0aW9uKEEsQixJKXtyZXR1cm4gZnVuY3Rpb24oQSxCLEksZyl7cmV0dXJuIGUoQiksQjw9MD9pKEEsQik6dm9pZCAwIT09ST8ic3RyaW5nIj09dHlwZW9mIGc/aShBLEIpLmZpbGwoSSxnKTppKEEsQikuZmlsbChJKTppKEEsQil9KG51bGwsQSxCLEkpfSxvLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKEEpe3JldHVybiByKG51bGwsQSl9LG8uYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKEEpe3JldHVybiByKG51bGwsQSl9LG8uaXNCdWZmZXI9ZnVuY3Rpb24oQSl7cmV0dXJuIShudWxsPT1BfHwhQS5faXNCdWZmZXIpfSxvLmNvbXBhcmU9ZnVuY3Rpb24oQSxCKXtpZighby5pc0J1ZmZlcihBKXx8IW8uaXNCdWZmZXIoQikpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycyIpO2lmKEE9PT1CKXJldHVybiAwO2Zvcih2YXIgST1BLmxlbmd0aCxnPUIubGVuZ3RoLFE9MCxFPU1hdGgubWluKEksZyk7UTxFOysrUSlpZihBW1FdIT09QltRXSl7ST1BW1FdLGc9QltRXTticmVha31yZXR1cm4gSTxnPy0xOmc8ST8xOjB9LG8uaXNFbmNvZGluZz1mdW5jdGlvbihBKXtzd2l0Y2goU3RyaW5nKEEpLnRvTG93ZXJDYXNlKCkpe2Nhc2UiaGV4IjpjYXNlInV0ZjgiOmNhc2UidXRmLTgiOmNhc2UiYXNjaWkiOmNhc2UibGF0aW4xIjpjYXNlImJpbmFyeSI6Y2FzZSJiYXNlNjQiOmNhc2UidWNzMiI6Y2FzZSJ1Y3MtMiI6Y2FzZSJ1dGYxNmxlIjpjYXNlInV0Zi0xNmxlIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX0sby5jb25jYXQ9ZnVuY3Rpb24oQSxCKXtpZighRShBKSl0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aWYoMD09PUEubGVuZ3RoKXJldHVybiBvLmFsbG9jKDApO3ZhciBJO2lmKHZvaWQgMD09PUIpZm9yKEI9MCxJPTA7STxBLmxlbmd0aDsrK0kpQis9QVtJXS5sZW5ndGg7dmFyIGc9by5hbGxvY1Vuc2FmZShCKSxRPTA7Zm9yKEk9MDtJPEEubGVuZ3RoOysrSSl7dmFyIEM9QVtJXTtpZighby5pc0J1ZmZlcihDKSl0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7Qy5jb3B5KGcsUSksUSs9Qy5sZW5ndGh9cmV0dXJuIGd9LG8uYnl0ZUxlbmd0aD1zLG8ucHJvdG90eXBlLl9pc0J1ZmZlcj0hMCxvLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24oKXt2YXIgQT10aGlzLmxlbmd0aDtpZihBJTIhPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzIik7Zm9yKHZhciBCPTA7QjxBO0IrPTIpRCh0aGlzLEIsQisxKTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5sZW5ndGg7aWYoQSU0IT0wKXRocm93IG5ldyBSYW5nZUVycm9yKCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cyIpO2Zvcih2YXIgQj0wO0I8QTtCKz00KUQodGhpcyxCLEIrMyksRCh0aGlzLEIrMSxCKzIpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24oKXt2YXIgQT10aGlzLmxlbmd0aDtpZihBJTghPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzIik7Zm9yKHZhciBCPTA7QjxBO0IrPTgpRCh0aGlzLEIsQis3KSxEKHRoaXMsQisxLEIrNiksRCh0aGlzLEIrMixCKzUpLEQodGhpcyxCKzMsQis0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgQT0wfHRoaXMubGVuZ3RoO3JldHVybiAwPT09QT8iIjowPT09YXJndW1lbnRzLmxlbmd0aD9rKHRoaXMsMCxBKTpmdW5jdGlvbihBLEIsSSl7dmFyIGc9ITE7aWYoKHZvaWQgMD09PUJ8fEI8MCkmJihCPTApLEI+dGhpcy5sZW5ndGgpcmV0dXJuIiI7aWYoKHZvaWQgMD09PUl8fEk+dGhpcy5sZW5ndGgpJiYoST10aGlzLmxlbmd0aCksSTw9MClyZXR1cm4iIjtpZigoST4+Pj0wKTw9KEI+Pj49MCkpcmV0dXJuIiI7Zm9yKEF8fChBPSJ1dGY4Iik7Oylzd2l0Y2goQSl7Y2FzZSJoZXgiOnJldHVybiBNKHRoaXMsQixJKTtjYXNlInV0ZjgiOmNhc2UidXRmLTgiOnJldHVybiBrKHRoaXMsQixJKTtjYXNlImFzY2lpIjpyZXR1cm4gTih0aGlzLEIsSSk7Y2FzZSJsYXRpbjEiOmNhc2UiYmluYXJ5IjpyZXR1cm4gZCh0aGlzLEIsSSk7Y2FzZSJiYXNlNjQiOnJldHVybiBTKHRoaXMsQixJKTtjYXNlInVjczIiOmNhc2UidWNzLTIiOmNhc2UidXRmMTZsZSI6Y2FzZSJ1dGYtMTZsZSI6cmV0dXJuIHUodGhpcyxCLEkpO2RlZmF1bHQ6aWYoZyl0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiK0EpO0E9KEErIiIpLnRvTG93ZXJDYXNlKCksZz0hMH19LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sby5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKEEpe2lmKCFvLmlzQnVmZmVyKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIiKTtyZXR1cm4gdGhpcz09PUF8fDA9PT1vLmNvbXBhcmUodGhpcyxBKX0sby5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciBBPSIiLEk9Qi5JTlNQRUNUX01BWF9CWVRFUztyZXR1cm4gdGhpcy5sZW5ndGg+MCYmKEE9dGhpcy50b1N0cmluZygiaGV4IiwwLEkpLm1hdGNoKC8uezJ9L2cpLmpvaW4oIiAiKSx0aGlzLmxlbmd0aD5JJiYoQSs9IiAuLi4gIikpLCI8QnVmZmVyICIrQSsiPiJ9LG8ucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24oQSxCLEksZyxRKXtpZighby5pc0J1ZmZlcihBKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIik7aWYodm9pZCAwPT09QiYmKEI9MCksdm9pZCAwPT09SSYmKEk9QT9BLmxlbmd0aDowKSx2b2lkIDA9PT1nJiYoZz0wKSx2b2lkIDA9PT1RJiYoUT10aGlzLmxlbmd0aCksQjwwfHxJPkEubGVuZ3RofHxnPDB8fFE+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm91dCBvZiByYW5nZSBpbmRleCIpO2lmKGc+PVEmJkI+PUkpcmV0dXJuIDA7aWYoZz49USlyZXR1cm4tMTtpZihCPj1JKXJldHVybiAxO2lmKHRoaXM9PT1BKXJldHVybiAwO2Zvcih2YXIgRT0oUT4+Pj0wKS0oZz4+Pj0wKSxDPShJPj4+PTApLShCPj4+PTApLGk9TWF0aC5taW4oRSxDKSx0PXRoaXMuc2xpY2UoZyxRKSxlPUEuc2xpY2UoQixJKSxyPTA7cjxpOysrcilpZih0W3JdIT09ZVtyXSl7RT10W3JdLEM9ZVtyXTticmVha31yZXR1cm4gRTxDPy0xOkM8RT8xOjB9LG8ucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uKEEsQixJKXtyZXR1cm4tMSE9PXRoaXMuaW5kZXhPZihBLEIsSSl9LG8ucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBGKHRoaXMsQSxCLEksITApfSxvLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbihBLEIsSSl7cmV0dXJuIEYodGhpcyxBLEIsSSwhMSl9LG8ucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKEEsQixJLGcpe2lmKHZvaWQgMD09PUIpZz0idXRmOCIsST10aGlzLmxlbmd0aCxCPTA7ZWxzZSBpZih2b2lkIDA9PT1JJiYic3RyaW5nIj09dHlwZW9mIEIpZz1CLEk9dGhpcy5sZW5ndGgsQj0wO2Vsc2V7aWYoIWlzRmluaXRlKEIpKXRocm93IG5ldyBFcnJvcigiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQiKTtCfD0wLGlzRmluaXRlKEkpPyhJfD0wLHZvaWQgMD09PWcmJihnPSJ1dGY4IikpOihnPUksST12b2lkIDApfXZhciBRPXRoaXMubGVuZ3RoLUI7aWYoKHZvaWQgMD09PUl8fEk+USkmJihJPVEpLEEubGVuZ3RoPjAmJihJPDB8fEI8MCl8fEI+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzIik7Z3x8KGc9InV0ZjgiKTtmb3IodmFyIEU9ITE7Oylzd2l0Y2goZyl7Y2FzZSJoZXgiOnJldHVybiBjKHRoaXMsQSxCLEkpO2Nhc2UidXRmOCI6Y2FzZSJ1dGYtOCI6cmV0dXJuIGgodGhpcyxBLEIsSSk7Y2FzZSJhc2NpaSI6cmV0dXJuIHkodGhpcyxBLEIsSSk7Y2FzZSJsYXRpbjEiOmNhc2UiYmluYXJ5IjpyZXR1cm4gUih0aGlzLEEsQixJKTtjYXNlImJhc2U2NCI6cmV0dXJuIFUodGhpcyxBLEIsSSk7Y2FzZSJ1Y3MyIjpjYXNlInVjcy0yIjpjYXNlInV0ZjE2bGUiOmNhc2UidXRmLTE2bGUiOnJldHVybiBHKHRoaXMsQSxCLEkpO2RlZmF1bHQ6aWYoRSl0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGVuY29kaW5nOiAiK2cpO2c9KCIiK2cpLnRvTG93ZXJDYXNlKCksRT0hMH19LG8ucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt0eXBlOiJCdWZmZXIiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07dmFyIGY9NDA5NjtmdW5jdGlvbiBOKEEsQixJKXt2YXIgZz0iIjtJPU1hdGgubWluKEEubGVuZ3RoLEkpO2Zvcih2YXIgUT1CO1E8STsrK1EpZys9U3RyaW5nLmZyb21DaGFyQ29kZSgxMjcmQVtRXSk7cmV0dXJuIGd9ZnVuY3Rpb24gZChBLEIsSSl7dmFyIGc9IiI7ST1NYXRoLm1pbihBLmxlbmd0aCxJKTtmb3IodmFyIFE9QjtRPEk7KytRKWcrPVN0cmluZy5mcm9tQ2hhckNvZGUoQVtRXSk7cmV0dXJuIGd9ZnVuY3Rpb24gTShBLEIsSSl7dmFyIGc9QS5sZW5ndGg7KCFCfHxCPDApJiYoQj0wKSwoIUl8fEk8MHx8ST5nKSYmKEk9Zyk7Zm9yKHZhciBRPSIiLEU9QjtFPEk7KytFKVErPW0oQVtFXSk7cmV0dXJuIFF9ZnVuY3Rpb24gdShBLEIsSSl7Zm9yKHZhciBnPUEuc2xpY2UoQixJKSxRPSIiLEU9MDtFPGcubGVuZ3RoO0UrPTIpUSs9U3RyaW5nLmZyb21DaGFyQ29kZShnW0VdKzI1NipnW0UrMV0pO3JldHVybiBRfWZ1bmN0aW9uIEwoQSxCLEkpe2lmKEElMSE9MHx8QTwwKXRocm93IG5ldyBSYW5nZUVycm9yKCJvZmZzZXQgaXMgbm90IHVpbnQiKTtpZihBK0I+SSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCIpfWZ1bmN0aW9uIEooQSxCLEksZyxRLEUpe2lmKCFvLmlzQnVmZmVyKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoJyJidWZmZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihCPlF8fEI8RSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignInZhbHVlIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYoSStnPkEubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiBsKEEsQixJLGcpe0I8MCYmKEI9NjU1MzUrQisxKTtmb3IodmFyIFE9MCxFPU1hdGgubWluKEEubGVuZ3RoLUksMik7UTxFOysrUSlBW0krUV09KEImMjU1PDw4KihnP1E6MS1RKSk+Pj44KihnP1E6MS1RKX1mdW5jdGlvbiBIKEEsQixJLGcpe0I8MCYmKEI9NDI5NDk2NzI5NStCKzEpO2Zvcih2YXIgUT0wLEU9TWF0aC5taW4oQS5sZW5ndGgtSSw0KTtRPEU7KytRKUFbSStRXT1CPj4+OCooZz9ROjMtUSkmMjU1fWZ1bmN0aW9uIFkoQSxCLEksZyxRLEUpe2lmKEkrZz5BLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiSW5kZXggb3V0IG9mIHJhbmdlIik7aWYoSTwwKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiBxKEEsQixJLGcsRSl7cmV0dXJuIEV8fFkoQSwwLEksNCksUS53cml0ZShBLEIsSSxnLDIzLDQpLEkrNH1mdW5jdGlvbiBwKEEsQixJLGcsRSl7cmV0dXJuIEV8fFkoQSwwLEksOCksUS53cml0ZShBLEIsSSxnLDUyLDgpLEkrOH1vLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihBLEIpe3ZhciBJLGc9dGhpcy5sZW5ndGg7aWYoKEE9fn5BKTwwPyhBKz1nKTwwJiYoQT0wKTpBPmcmJihBPWcpLChCPXZvaWQgMD09PUI/Zzp+fkIpPDA/KEIrPWcpPDAmJihCPTApOkI+ZyYmKEI9ZyksQjxBJiYoQj1BKSxvLlRZUEVEX0FSUkFZX1NVUFBPUlQpKEk9dGhpcy5zdWJhcnJheShBLEIpKS5fX3Byb3RvX189by5wcm90b3R5cGU7ZWxzZXt2YXIgUT1CLUE7ST1uZXcgbyhRLHZvaWQgMCk7Zm9yKHZhciBFPTA7RTxROysrRSlJW0VdPXRoaXNbRStBXX1yZXR1cm4gSX0sby5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbihBLEIsSSl7QXw9MCxCfD0wLEl8fEwoQSxCLHRoaXMubGVuZ3RoKTtmb3IodmFyIGc9dGhpc1tBXSxRPTEsRT0wOysrRTxCJiYoUSo9MjU2KTspZys9dGhpc1tBK0VdKlE7cmV0dXJuIGd9LG8ucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24oQSxCLEkpe0F8PTAsQnw9MCxJfHxMKEEsQix0aGlzLmxlbmd0aCk7Zm9yKHZhciBnPXRoaXNbQSstLUJdLFE9MTtCPjAmJihRKj0yNTYpOylnKz10aGlzW0ErLS1CXSpRO3JldHVybiBnfSxvLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24oQSxCKXtyZXR1cm4gQnx8TChBLDEsdGhpcy5sZW5ndGgpLHRoaXNbQV19LG8ucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihBLEIpe3JldHVybiBCfHxMKEEsMix0aGlzLmxlbmd0aCksdGhpc1tBXXx0aGlzW0ErMV08PDh9LG8ucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihBLEIpe3JldHVybiBCfHxMKEEsMix0aGlzLmxlbmd0aCksdGhpc1tBXTw8OHx0aGlzW0ErMV19LG8ucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbihBLEIpe3JldHVybiBCfHxMKEEsNCx0aGlzLmxlbmd0aCksKHRoaXNbQV18dGhpc1tBKzFdPDw4fHRoaXNbQSsyXTw8MTYpKzE2Nzc3MjE2KnRoaXNbQSszXX0sby5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uKEEsQil7cmV0dXJuIEJ8fEwoQSw0LHRoaXMubGVuZ3RoKSwxNjc3NzIxNip0aGlzW0FdKyh0aGlzW0ErMV08PDE2fHRoaXNbQSsyXTw8OHx0aGlzW0ErM10pfSxvLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24oQSxCLEkpe0F8PTAsQnw9MCxJfHxMKEEsQix0aGlzLmxlbmd0aCk7Zm9yKHZhciBnPXRoaXNbQV0sUT0xLEU9MDsrK0U8QiYmKFEqPTI1Nik7KWcrPXRoaXNbQStFXSpRO3JldHVybiBnPj0oUSo9MTI4KSYmKGctPU1hdGgucG93KDIsOCpCKSksZ30sby5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uKEEsQixJKXtBfD0wLEJ8PTAsSXx8TChBLEIsdGhpcy5sZW5ndGgpO2Zvcih2YXIgZz1CLFE9MSxFPXRoaXNbQSstLWddO2c+MCYmKFEqPTI1Nik7KUUrPXRoaXNbQSstLWddKlE7cmV0dXJuIEU+PShRKj0xMjgpJiYoRS09TWF0aC5wb3coMiw4KkIpKSxFfSxvLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbihBLEIpe3JldHVybiBCfHxMKEEsMSx0aGlzLmxlbmd0aCksMTI4JnRoaXNbQV0/LTEqKDI1NS10aGlzW0FdKzEpOnRoaXNbQV19LG8ucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uKEEsQil7Qnx8TChBLDIsdGhpcy5sZW5ndGgpO3ZhciBJPXRoaXNbQV18dGhpc1tBKzFdPDw4O3JldHVybiAzMjc2OCZJPzQyOTQ5MDE3NjB8STpJfSxvLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbihBLEIpe0J8fEwoQSwyLHRoaXMubGVuZ3RoKTt2YXIgST10aGlzW0ErMV18dGhpc1tBXTw8ODtyZXR1cm4gMzI3NjgmST80Mjk0OTAxNzYwfEk6SX0sby5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24oQSxCKXtyZXR1cm4gQnx8TChBLDQsdGhpcy5sZW5ndGgpLHRoaXNbQV18dGhpc1tBKzFdPDw4fHRoaXNbQSsyXTw8MTZ8dGhpc1tBKzNdPDwyNH0sby5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24oQSxCKXtyZXR1cm4gQnx8TChBLDQsdGhpcy5sZW5ndGgpLHRoaXNbQV08PDI0fHRoaXNbQSsxXTw8MTZ8dGhpc1tBKzJdPDw4fHRoaXNbQSszXX0sby5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24oQSxCKXtyZXR1cm4gQnx8TChBLDQsdGhpcy5sZW5ndGgpLFEucmVhZCh0aGlzLEEsITAsMjMsNCl9LG8ucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uKEEsQil7cmV0dXJuIEJ8fEwoQSw0LHRoaXMubGVuZ3RoKSxRLnJlYWQodGhpcyxBLCExLDIzLDQpfSxvLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24oQSxCKXtyZXR1cm4gQnx8TChBLDgsdGhpcy5sZW5ndGgpLFEucmVhZCh0aGlzLEEsITAsNTIsOCl9LG8ucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbihBLEIpe3JldHVybiBCfHxMKEEsOCx0aGlzLmxlbmd0aCksUS5yZWFkKHRoaXMsQSwhMSw1Miw4KX0sby5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24oQSxCLEksZyl7QT0rQSxCfD0wLEl8PTAsZ3x8Sih0aGlzLEEsQixJLE1hdGgucG93KDIsOCpJKS0xLDApO3ZhciBRPTEsRT0wO2Zvcih0aGlzW0JdPTI1NSZBOysrRTxJJiYoUSo9MjU2KTspdGhpc1tCK0VdPUEvUSYyNTU7cmV0dXJuIEIrSX0sby5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24oQSxCLEksZyl7QT0rQSxCfD0wLEl8PTAsZ3x8Sih0aGlzLEEsQixJLE1hdGgucG93KDIsOCpJKS0xLDApO3ZhciBRPUktMSxFPTE7Zm9yKHRoaXNbQitRXT0yNTUmQTstLVE+PTAmJihFKj0yNTYpOyl0aGlzW0IrUV09QS9FJjI1NTtyZXR1cm4gQitJfSxvLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uKEEsQixJKXtyZXR1cm4gQT0rQSxCfD0wLEl8fEoodGhpcyxBLEIsMSwyNTUsMCksby5UWVBFRF9BUlJBWV9TVVBQT1JUfHwoQT1NYXRoLmZsb29yKEEpKSx0aGlzW0JdPTI1NSZBLEIrMX0sby5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbihBLEIsSSl7cmV0dXJuIEE9K0EsQnw9MCxJfHxKKHRoaXMsQSxCLDIsNjU1MzUsMCksby5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW0JdPTI1NSZBLHRoaXNbQisxXT1BPj4+OCk6bCh0aGlzLEEsQiwhMCksQisyfSxvLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uKEEsQixJKXtyZXR1cm4gQT0rQSxCfD0wLEl8fEoodGhpcyxBLEIsMiw2NTUzNSwwKSxvLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbQl09QT4+PjgsdGhpc1tCKzFdPTI1NSZBKTpsKHRoaXMsQSxCLCExKSxCKzJ9LG8ucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBBPStBLEJ8PTAsSXx8Sih0aGlzLEEsQiw0LDQyOTQ5NjcyOTUsMCksby5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW0IrM109QT4+PjI0LHRoaXNbQisyXT1BPj4+MTYsdGhpc1tCKzFdPUE+Pj44LHRoaXNbQl09MjU1JkEpOkgodGhpcyxBLEIsITApLEIrNH0sby5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbihBLEIsSSl7cmV0dXJuIEE9K0EsQnw9MCxJfHxKKHRoaXMsQSxCLDQsNDI5NDk2NzI5NSwwKSxvLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbQl09QT4+PjI0LHRoaXNbQisxXT1BPj4+MTYsdGhpc1tCKzJdPUE+Pj44LHRoaXNbQiszXT0yNTUmQSk6SCh0aGlzLEEsQiwhMSksQis0fSxvLnByb3RvdHlwZS53cml0ZUludExFPWZ1bmN0aW9uKEEsQixJLGcpe2lmKEE9K0EsQnw9MCwhZyl7dmFyIFE9TWF0aC5wb3coMiw4KkktMSk7Sih0aGlzLEEsQixJLFEtMSwtUSl9dmFyIEU9MCxDPTEsaT0wO2Zvcih0aGlzW0JdPTI1NSZBOysrRTxJJiYoQyo9MjU2KTspQTwwJiYwPT09aSYmMCE9PXRoaXNbQitFLTFdJiYoaT0xKSx0aGlzW0IrRV09KEEvQz4+MCktaSYyNTU7cmV0dXJuIEIrSX0sby5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbihBLEIsSSxnKXtpZihBPStBLEJ8PTAsIWcpe3ZhciBRPU1hdGgucG93KDIsOCpJLTEpO0oodGhpcyxBLEIsSSxRLTEsLVEpfXZhciBFPUktMSxDPTEsaT0wO2Zvcih0aGlzW0IrRV09MjU1JkE7LS1FPj0wJiYoQyo9MjU2KTspQTwwJiYwPT09aSYmMCE9PXRoaXNbQitFKzFdJiYoaT0xKSx0aGlzW0IrRV09KEEvQz4+MCktaSYyNTU7cmV0dXJuIEIrSX0sby5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKEEsQixJKXtyZXR1cm4gQT0rQSxCfD0wLEl8fEoodGhpcyxBLEIsMSwxMjcsLTEyOCksby5UWVBFRF9BUlJBWV9TVVBQT1JUfHwoQT1NYXRoLmZsb29yKEEpKSxBPDAmJihBPTI1NStBKzEpLHRoaXNbQl09MjU1JkEsQisxfSxvLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBBPStBLEJ8PTAsSXx8Sih0aGlzLEEsQiwyLDMyNzY3LC0zMjc2OCksby5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW0JdPTI1NSZBLHRoaXNbQisxXT1BPj4+OCk6bCh0aGlzLEEsQiwhMCksQisyfSxvLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBBPStBLEJ8PTAsSXx8Sih0aGlzLEEsQiwyLDMyNzY3LC0zMjc2OCksby5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW0JdPUE+Pj44LHRoaXNbQisxXT0yNTUmQSk6bCh0aGlzLEEsQiwhMSksQisyfSxvLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBBPStBLEJ8PTAsSXx8Sih0aGlzLEEsQiw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpLG8uVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tCXT0yNTUmQSx0aGlzW0IrMV09QT4+PjgsdGhpc1tCKzJdPUE+Pj4xNix0aGlzW0IrM109QT4+PjI0KTpIKHRoaXMsQSxCLCEwKSxCKzR9LG8ucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbihBLEIsSSl7cmV0dXJuIEE9K0EsQnw9MCxJfHxKKHRoaXMsQSxCLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksQTwwJiYoQT00Mjk0OTY3Mjk1K0ErMSksby5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW0JdPUE+Pj4yNCx0aGlzW0IrMV09QT4+PjE2LHRoaXNbQisyXT1BPj4+OCx0aGlzW0IrM109MjU1JkEpOkgodGhpcyxBLEIsITEpLEIrNH0sby5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uKEEsQixJKXtyZXR1cm4gcSh0aGlzLEEsQiwhMCxJKX0sby5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uKEEsQixJKXtyZXR1cm4gcSh0aGlzLEEsQiwhMSxJKX0sby5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbihBLEIsSSl7cmV0dXJuIHAodGhpcyxBLEIsITAsSSl9LG8ucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBwKHRoaXMsQSxCLCExLEkpfSxvLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKEEsQixJLGcpe2lmKEl8fChJPTApLGd8fDA9PT1nfHwoZz10aGlzLmxlbmd0aCksQj49QS5sZW5ndGgmJihCPUEubGVuZ3RoKSxCfHwoQj0wKSxnPjAmJmc8SSYmKGc9SSksZz09PUkpcmV0dXJuIDA7aWYoMD09PUEubGVuZ3RofHwwPT09dGhpcy5sZW5ndGgpcmV0dXJuIDA7aWYoQjwwKXRocm93IG5ldyBSYW5nZUVycm9yKCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzIik7aWYoSTwwfHxJPj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigic291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcyIpO2lmKGc8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigic291cmNlRW5kIG91dCBvZiBib3VuZHMiKTtnPnRoaXMubGVuZ3RoJiYoZz10aGlzLmxlbmd0aCksQS5sZW5ndGgtQjxnLUkmJihnPUEubGVuZ3RoLUIrSSk7dmFyIFEsRT1nLUk7aWYodGhpcz09PUEmJkk8QiYmQjxnKWZvcihRPUUtMTtRPj0wOy0tUSlBW1ErQl09dGhpc1tRK0ldO2Vsc2UgaWYoRTwxZTN8fCFvLlRZUEVEX0FSUkFZX1NVUFBPUlQpZm9yKFE9MDtRPEU7KytRKUFbUStCXT10aGlzW1ErSV07ZWxzZSBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChBLHRoaXMuc3ViYXJyYXkoSSxJK0UpLEIpO3JldHVybiBFfSxvLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKEEsQixJLGcpe2lmKCJzdHJpbmciPT10eXBlb2YgQSl7aWYoInN0cmluZyI9PXR5cGVvZiBCPyhnPUIsQj0wLEk9dGhpcy5sZW5ndGgpOiJzdHJpbmciPT10eXBlb2YgSSYmKGc9SSxJPXRoaXMubGVuZ3RoKSwxPT09QS5sZW5ndGgpe3ZhciBRPUEuY2hhckNvZGVBdCgwKTtRPDI1NiYmKEE9USl9aWYodm9pZCAwIT09ZyYmInN0cmluZyIhPXR5cGVvZiBnKXRocm93IG5ldyBUeXBlRXJyb3IoImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmciKTtpZigic3RyaW5nIj09dHlwZW9mIGcmJiFvLmlzRW5jb2RpbmcoZykpdGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBlbmNvZGluZzogIitnKX1lbHNlIm51bWJlciI9PXR5cGVvZiBBJiYoQSY9MjU1KTtpZihCPDB8fHRoaXMubGVuZ3RoPEJ8fHRoaXMubGVuZ3RoPEkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk91dCBvZiByYW5nZSBpbmRleCIpO2lmKEk8PUIpcmV0dXJuIHRoaXM7dmFyIEU7aWYoQj4+Pj0wLEk9dm9pZCAwPT09ST90aGlzLmxlbmd0aDpJPj4+MCxBfHwoQT0wKSwibnVtYmVyIj09dHlwZW9mIEEpZm9yKEU9QjtFPEk7KytFKXRoaXNbRV09QTtlbHNle3ZhciBDPW8uaXNCdWZmZXIoQSk/QTp4KG5ldyBvKEEsZykudG9TdHJpbmcoKSksaT1DLmxlbmd0aDtmb3IoRT0wO0U8SS1COysrRSl0aGlzW0UrQl09Q1tFJWldfXJldHVybiB0aGlzfTt2YXIgSz0vW14rXC8wLTlBLVphLXotX10vZztmdW5jdGlvbiBtKEEpe3JldHVybiBBPDE2PyIwIitBLnRvU3RyaW5nKDE2KTpBLnRvU3RyaW5nKDE2KX1mdW5jdGlvbiB4KEEsQil7dmFyIEk7Qj1CfHwxLzA7Zm9yKHZhciBnPUEubGVuZ3RoLFE9bnVsbCxFPVtdLEM9MDtDPGc7KytDKXtpZigoST1BLmNoYXJDb2RlQXQoQykpPjU1Mjk1JiZJPDU3MzQ0KXtpZighUSl7aWYoST41NjMxOSl7KEItPTMpPi0xJiZFLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWlmKEMrMT09PWcpeyhCLT0zKT4tMSYmRS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1RPUk7Y29udGludWV9aWYoSTw1NjMyMCl7KEItPTMpPi0xJiZFLnB1c2goMjM5LDE5MSwxODkpLFE9STtjb250aW51ZX1JPTY1NTM2KyhRLTU1Mjk2PDwxMHxJLTU2MzIwKX1lbHNlIFEmJihCLT0zKT4tMSYmRS5wdXNoKDIzOSwxOTEsMTg5KTtpZihRPW51bGwsSTwxMjgpe2lmKChCLT0xKTwwKWJyZWFrO0UucHVzaChJKX1lbHNlIGlmKEk8MjA0OCl7aWYoKEItPTIpPDApYnJlYWs7RS5wdXNoKEk+PjZ8MTkyLDYzJkl8MTI4KX1lbHNlIGlmKEk8NjU1MzYpe2lmKChCLT0zKTwwKWJyZWFrO0UucHVzaChJPj4xMnwyMjQsST4+NiY2M3wxMjgsNjMmSXwxMjgpfWVsc2V7aWYoIShJPDExMTQxMTIpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb2RlIHBvaW50Iik7aWYoKEItPTQpPDApYnJlYWs7RS5wdXNoKEk+PjE4fDI0MCxJPj4xMiY2M3wxMjgsST4+NiY2M3wxMjgsNjMmSXwxMjgpfX1yZXR1cm4gRX1mdW5jdGlvbiB2KEEpe3JldHVybiBnLnRvQnl0ZUFycmF5KGZ1bmN0aW9uKEEpe2lmKChBPWZ1bmN0aW9uKEEpe3JldHVybiBBLnRyaW0/QS50cmltKCk6QS5yZXBsYWNlKC9eXHMrfFxzKyQvZywiIil9KEEpLnJlcGxhY2UoSywiIikpLmxlbmd0aDwyKXJldHVybiIiO2Zvcig7QS5sZW5ndGglNCE9MDspQSs9Ij0iO3JldHVybiBBfShBKSl9ZnVuY3Rpb24gYihBLEIsSSxnKXtmb3IodmFyIFE9MDtRPGcmJiEoUStJPj1CLmxlbmd0aHx8UT49QS5sZW5ndGgpOysrUSlCW1ErSV09QVtRXTtyZXR1cm4gUX19KS5jYWxsKHRoaXMsSSg4KSl9LGZ1bmN0aW9uKEEsQil7dmFyIEk7ST1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtJPUl8fEZ1bmN0aW9uKCJyZXR1cm4gdGhpcyIpKCl8fCgwLGV2YWwpKCJ0aGlzIil9Y2F0Y2goQSl7Im9iamVjdCI9PXR5cGVvZiB3aW5kb3cmJihJPXdpbmRvdyl9QS5leHBvcnRzPUl9LGZ1bmN0aW9uKEEsQixJKXtCLmJ5dGVMZW5ndGg9ZnVuY3Rpb24oQSl7dmFyIEI9dChBKSxJPUJbMF0sZz1CWzFdO3JldHVybiAzKihJK2cpLzQtZ30sQi50b0J5dGVBcnJheT1mdW5jdGlvbihBKXtmb3IodmFyIEIsST10KEEpLGc9SVswXSxDPUlbMV0saT1uZXcgRShmdW5jdGlvbihBLEIsSSl7cmV0dXJuIDMqKEIrSSkvNC1JfSgwLGcsQykpLG89MCxlPUM+MD9nLTQ6ZyxyPTA7cjxlO3IrPTQpQj1RW0EuY2hhckNvZGVBdChyKV08PDE4fFFbQS5jaGFyQ29kZUF0KHIrMSldPDwxMnxRW0EuY2hhckNvZGVBdChyKzIpXTw8NnxRW0EuY2hhckNvZGVBdChyKzMpXSxpW28rK109Qj4+MTYmMjU1LGlbbysrXT1CPj44JjI1NSxpW28rK109MjU1JkI7cmV0dXJuIDI9PT1DJiYoQj1RW0EuY2hhckNvZGVBdChyKV08PDJ8UVtBLmNoYXJDb2RlQXQocisxKV0+PjQsaVtvKytdPTI1NSZCKSwxPT09QyYmKEI9UVtBLmNoYXJDb2RlQXQocildPDwxMHxRW0EuY2hhckNvZGVBdChyKzEpXTw8NHxRW0EuY2hhckNvZGVBdChyKzIpXT4+MixpW28rK109Qj4+OCYyNTUsaVtvKytdPTI1NSZCKSxpfSxCLmZyb21CeXRlQXJyYXk9ZnVuY3Rpb24oQSl7Zm9yKHZhciBCLEk9QS5sZW5ndGgsUT1JJTMsRT1bXSxDPTAsaT1JLVE7QzxpO0MrPTE2MzgzKUUucHVzaChyKEEsQyxDKzE2MzgzPmk/aTpDKzE2MzgzKSk7cmV0dXJuIDE9PT1RPyhCPUFbSS0xXSxFLnB1c2goZ1tCPj4yXStnW0I8PDQmNjNdKyI9PSIpKToyPT09USYmKEI9KEFbSS0yXTw8OCkrQVtJLTFdLEUucHVzaChnW0I+PjEwXStnW0I+PjQmNjNdK2dbQjw8MiY2M10rIj0iKSksRS5qb2luKCIiKX07Zm9yKHZhciBnPVtdLFE9W10sRT0idW5kZWZpbmVkIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxDPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIixpPTAsbz1DLmxlbmd0aDtpPG87KytpKWdbaV09Q1tpXSxRW0MuY2hhckNvZGVBdChpKV09aTtmdW5jdGlvbiB0KEEpe3ZhciBCPUEubGVuZ3RoO2lmKEIlND4wKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCIpO3ZhciBJPUEuaW5kZXhPZigiPSIpO3JldHVybi0xPT09SSYmKEk9QiksW0ksST09PUI/MDo0LUklNF19ZnVuY3Rpb24gZShBKXtyZXR1cm4gZ1tBPj4xOCY2M10rZ1tBPj4xMiY2M10rZ1tBPj42JjYzXStnWzYzJkFdfWZ1bmN0aW9uIHIoQSxCLEkpe2Zvcih2YXIgZyxRPVtdLEU9QjtFPEk7RSs9MylnPShBW0VdPDwxNiYxNjcxMTY4MCkrKEFbRSsxXTw8OCY2NTI4MCkrKDI1NSZBW0UrMl0pLFEucHVzaChlKGcpKTtyZXR1cm4gUS5qb2luKCIiKX1RWyItIi5jaGFyQ29kZUF0KDApXT02MixRWyJfIi5jaGFyQ29kZUF0KDApXT02M30sZnVuY3Rpb24oQSxCKXtCLnJlYWQ9ZnVuY3Rpb24oQSxCLEksZyxRKXt2YXIgRSxDLGk9OCpRLWctMSxvPSgxPDxpKS0xLHQ9bz4+MSxlPS03LHI9ST9RLTE6MCxhPUk/LTE6MSxuPUFbQityXTtmb3Iocis9YSxFPW4mKDE8PC1lKS0xLG4+Pj0tZSxlKz1pO2U+MDtFPTI1NipFK0FbQityXSxyKz1hLGUtPTgpO2ZvcihDPUUmKDE8PC1lKS0xLEU+Pj0tZSxlKz1nO2U+MDtDPTI1NipDK0FbQityXSxyKz1hLGUtPTgpO2lmKDA9PT1FKUU9MS10O2Vsc2V7aWYoRT09PW8pcmV0dXJuIEM/TmFOOjEvMCoobj8tMToxKTtDKz1NYXRoLnBvdygyLGcpLEUtPXR9cmV0dXJuKG4/LTE6MSkqQypNYXRoLnBvdygyLEUtZyl9LEIud3JpdGU9ZnVuY3Rpb24oQSxCLEksZyxRLEUpe3ZhciBDLGksbyx0PTgqRS1RLTEsZT0oMTw8dCktMSxyPWU+PjEsYT0yMz09PVE/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowLG49Zz8wOkUtMSxzPWc/MTotMSxEPUI8MHx8MD09PUImJjEvQjwwPzE6MDtmb3IoQj1NYXRoLmFicyhCKSxpc05hTihCKXx8Qj09PTEvMD8oaT1pc05hTihCKT8xOjAsQz1lKTooQz1NYXRoLmZsb29yKE1hdGgubG9nKEIpL01hdGguTE4yKSxCKihvPU1hdGgucG93KDIsLUMpKTwxJiYoQy0tLG8qPTIpLChCKz1DK3I+PTE/YS9vOmEqTWF0aC5wb3coMiwxLXIpKSpvPj0yJiYoQysrLG8vPTIpLEMrcj49ZT8oaT0wLEM9ZSk6QytyPj0xPyhpPShCKm8tMSkqTWF0aC5wb3coMixRKSxDKz1yKTooaT1CKk1hdGgucG93KDIsci0xKSpNYXRoLnBvdygyLFEpLEM9MCkpO1E+PTg7QVtJK25dPTI1NSZpLG4rPXMsaS89MjU2LFEtPTgpO2ZvcihDPUM8PFF8aSx0Kz1RO3Q+MDtBW0krbl09MjU1JkMsbis9cyxDLz0yNTYsdC09OCk7QVtJK24tc118PTEyOCpEfX0sZnVuY3Rpb24oQSxCKXt2YXIgST17fS50b1N0cmluZztBLmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oQSl7cmV0dXJuIltvYmplY3QgQXJyYXldIj09SS5jYWxsKEEpfX0sZnVuY3Rpb24oQixJKXtCLmV4cG9ydHM9QX0sZnVuY3Rpb24oQSxCLEkpeyhmdW5jdGlvbihBKXtmdW5jdGlvbiBJKEEsQil7Zm9yKHZhciBJPTAsZz1BLmxlbmd0aC0xO2c+PTA7Zy0tKXt2YXIgUT1BW2ddOyIuIj09PVE/QS5zcGxpY2UoZywxKToiLi4iPT09UT8oQS5zcGxpY2UoZywxKSxJKyspOkkmJihBLnNwbGljZShnLDEpLEktLSl9aWYoQilmb3IoO0ktLTtJKUEudW5zaGlmdCgiLi4iKTtyZXR1cm4gQX12YXIgZz0vXihcLz98KShbXHNcU10qPykoKD86XC57MSwyfXxbXlwvXSs/fCkoXC5bXi5cL10qfCkpKD86W1wvXSopJC8sUT1mdW5jdGlvbihBKXtyZXR1cm4gZy5leGVjKEEpLnNsaWNlKDEpfTtmdW5jdGlvbiBFKEEsQil7aWYoQS5maWx0ZXIpcmV0dXJuIEEuZmlsdGVyKEIpO2Zvcih2YXIgST1bXSxnPTA7ZzxBLmxlbmd0aDtnKyspQihBW2ddLGcsQSkmJkkucHVzaChBW2ddKTtyZXR1cm4gSX1CLnJlc29sdmU9ZnVuY3Rpb24oKXtmb3IodmFyIEI9IiIsZz0hMSxRPWFyZ3VtZW50cy5sZW5ndGgtMTtRPj0tMSYmIWc7US0tKXt2YXIgQz1RPj0wP2FyZ3VtZW50c1tRXTpBLmN3ZCgpO2lmKCJzdHJpbmciIT10eXBlb2YgQyl0aHJvdyBuZXcgVHlwZUVycm9yKCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncyIpO0MmJihCPUMrIi8iK0IsZz0iLyI9PT1DLmNoYXJBdCgwKSl9cmV0dXJuIEI9SShFKEIuc3BsaXQoIi8iKSwoZnVuY3Rpb24oQSl7cmV0dXJuISFBfSkpLCFnKS5qb2luKCIvIiksKGc/Ii8iOiIiKStCfHwiLiJ9LEIubm9ybWFsaXplPWZ1bmN0aW9uKEEpe3ZhciBnPUIuaXNBYnNvbHV0ZShBKSxRPSIvIj09PUMoQSwtMSk7cmV0dXJuKEE9SShFKEEuc3BsaXQoIi8iKSwoZnVuY3Rpb24oQSl7cmV0dXJuISFBfSkpLCFnKS5qb2luKCIvIikpfHxnfHwoQT0iLiIpLEEmJlEmJihBKz0iLyIpLChnPyIvIjoiIikrQX0sQi5pc0Fic29sdXRlPWZ1bmN0aW9uKEEpe3JldHVybiIvIj09PUEuY2hhckF0KDApfSxCLmpvaW49ZnVuY3Rpb24oKXt2YXIgQT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cmV0dXJuIEIubm9ybWFsaXplKEUoQSwoZnVuY3Rpb24oQSxCKXtpZigic3RyaW5nIiE9dHlwZW9mIEEpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MiKTtyZXR1cm4gQX0pKS5qb2luKCIvIikpfSxCLnJlbGF0aXZlPWZ1bmN0aW9uKEEsSSl7ZnVuY3Rpb24gZyhBKXtmb3IodmFyIEI9MDtCPEEubGVuZ3RoJiYiIj09PUFbQl07QisrKTtmb3IodmFyIEk9QS5sZW5ndGgtMTtJPj0wJiYiIj09PUFbSV07SS0tKTtyZXR1cm4gQj5JP1tdOkEuc2xpY2UoQixJLUIrMSl9QT1CLnJlc29sdmUoQSkuc3Vic3RyKDEpLEk9Qi5yZXNvbHZlKEkpLnN1YnN0cigxKTtmb3IodmFyIFE9ZyhBLnNwbGl0KCIvIikpLEU9ZyhJLnNwbGl0KCIvIikpLEM9TWF0aC5taW4oUS5sZW5ndGgsRS5sZW5ndGgpLGk9QyxvPTA7bzxDO28rKylpZihRW29dIT09RVtvXSl7aT1vO2JyZWFrfXZhciB0PVtdO2ZvcihvPWk7bzxRLmxlbmd0aDtvKyspdC5wdXNoKCIuLiIpO3JldHVybih0PXQuY29uY2F0KEUuc2xpY2UoaSkpKS5qb2luKCIvIil9LEIuc2VwPSIvIixCLmRlbGltaXRlcj0iOiIsQi5kaXJuYW1lPWZ1bmN0aW9uKEEpe3ZhciBCPVEoQSksST1CWzBdLGc9QlsxXTtyZXR1cm4gSXx8Zz8oZyYmKGc9Zy5zdWJzdHIoMCxnLmxlbmd0aC0xKSksSStnKToiLiJ9LEIuYmFzZW5hbWU9ZnVuY3Rpb24oQSxCKXt2YXIgST1RKEEpWzJdO3JldHVybiBCJiZJLnN1YnN0cigtMSpCLmxlbmd0aCk9PT1CJiYoST1JLnN1YnN0cigwLEkubGVuZ3RoLUIubGVuZ3RoKSksSX0sQi5leHRuYW1lPWZ1bmN0aW9uKEEpe3JldHVybiBRKEEpWzNdfTt2YXIgQz0iYiI9PT0iYWIiLnN1YnN0cigtMSk/ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBBLnN1YnN0cihCLEkpfTpmdW5jdGlvbihBLEIsSSl7cmV0dXJuIEI8MCYmKEI9QS5sZW5ndGgrQiksQS5zdWJzdHIoQixJKX19KS5jYWxsKHRoaXMsSSgxNCkpfSxmdW5jdGlvbihBLEIpe3ZhciBJLGcsUT1BLmV4cG9ydHM9e307ZnVuY3Rpb24gRSgpe3Rocm93IG5ldyBFcnJvcigic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfWZ1bmN0aW9uIEMoKXt0aHJvdyBuZXcgRXJyb3IoImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCIpfWZ1bmN0aW9uIGkoQSl7aWYoST09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQoQSwwKTtpZigoST09PUV8fCFJKSYmc2V0VGltZW91dClyZXR1cm4gST1zZXRUaW1lb3V0LHNldFRpbWVvdXQoQSwwKTt0cnl7cmV0dXJuIEkoQSwwKX1jYXRjaChCKXt0cnl7cmV0dXJuIEkuY2FsbChudWxsLEEsMCl9Y2F0Y2goQil7cmV0dXJuIEkuY2FsbCh0aGlzLEEsMCl9fX0hZnVuY3Rpb24oKXt0cnl7ST0iZnVuY3Rpb24iPT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OkV9Y2F0Y2goQSl7ST1FfXRyeXtnPSJmdW5jdGlvbiI9PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0OkN9Y2F0Y2goQSl7Zz1DfX0oKTt2YXIgbyx0PVtdLGU9ITEscj0tMTtmdW5jdGlvbiBhKCl7ZSYmbyYmKGU9ITEsby5sZW5ndGg/dD1vLmNvbmNhdCh0KTpyPS0xLHQubGVuZ3RoJiZuKCkpfWZ1bmN0aW9uIG4oKXtpZighZSl7dmFyIEE9aShhKTtlPSEwO2Zvcih2YXIgQj10Lmxlbmd0aDtCOyl7Zm9yKG89dCx0PVtdOysrcjxCOylvJiZvW3JdLnJ1bigpO3I9LTEsQj10Lmxlbmd0aH1vPW51bGwsZT0hMSxmdW5jdGlvbihBKXtpZihnPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQoQSk7aWYoKGc9PT1DfHwhZykmJmNsZWFyVGltZW91dClyZXR1cm4gZz1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KEEpO3RyeXtnKEEpfWNhdGNoKEIpe3RyeXtyZXR1cm4gZy5jYWxsKG51bGwsQSl9Y2F0Y2goQil7cmV0dXJuIGcuY2FsbCh0aGlzLEEpfX19KEEpfX1mdW5jdGlvbiBzKEEsQil7dGhpcy5mdW49QSx0aGlzLmFycmF5PUJ9ZnVuY3Rpb24gRCgpe31RLm5leHRUaWNrPWZ1bmN0aW9uKEEpe3ZhciBCPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSlmb3IodmFyIEk9MTtJPGFyZ3VtZW50cy5sZW5ndGg7SSsrKUJbSS0xXT1hcmd1bWVudHNbSV07dC5wdXNoKG5ldyBzKEEsQikpLDEhPT10Lmxlbmd0aHx8ZXx8aShuKX0scy5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX0sUS50aXRsZT0iYnJvd3NlciIsUS5icm93c2VyPSEwLFEuZW52PXt9LFEuYXJndj1bXSxRLnZlcnNpb249IiIsUS52ZXJzaW9ucz17fSxRLm9uPUQsUS5hZGRMaXN0ZW5lcj1ELFEub25jZT1ELFEub2ZmPUQsUS5yZW1vdmVMaXN0ZW5lcj1ELFEucmVtb3ZlQWxsTGlzdGVuZXJzPUQsUS5lbWl0PUQsUS5wcmVwZW5kTGlzdGVuZXI9RCxRLnByZXBlbmRPbmNlTGlzdGVuZXI9RCxRLmxpc3RlbmVycz1mdW5jdGlvbihBKXtyZXR1cm5bXX0sUS5iaW5kaW5nPWZ1bmN0aW9uKEEpe3Rocm93IG5ldyBFcnJvcigicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQiKX0sUS5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm4iLyJ9LFEuY2hkaXI9ZnVuY3Rpb24oQSl7dGhyb3cgbmV3IEVycm9yKCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQiKX0sUS51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX1dKX0oQi5mcyk7Y29uc3QgST1BLnVucGFja0JyaWRnZTtsZXQgZzt2YXIgUT1mdW5jdGlvbihBKXtjb25zdCBCPXt9LGc9Im9taXQiO3ZhciBRLEU9dm9pZCAwIT09Qj9COnt9LEM9SS5FeHQsaT17b3BlbjpmdW5jdGlvbigpe3JldHVybiBDLmN1cnJlbnQub3Blbi5hcHBseShDLmN1cnJlbnQsYXJndW1lbnRzKX0sY2xvc2U6ZnVuY3Rpb24oKXtyZXR1cm4gQy5jdXJyZW50LmNsb3NlLmFwcGx5KEMuY3VycmVudCxhcmd1bWVudHMpfSxyZWFkOmZ1bmN0aW9uKCl7cmV0dXJuIEMuY3VycmVudC5yZWFkLmFwcGx5KEMuY3VycmVudCxhcmd1bWVudHMpfSx3cml0ZTpmdW5jdGlvbigpe3JldHVybiBDLmN1cnJlbnQud3JpdGUuYXBwbHkoQy5jdXJyZW50LGFyZ3VtZW50cyl9LHRlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gQy5jdXJyZW50LnRlbGwuYXBwbHkoQy5jdXJyZW50LGFyZ3VtZW50cyl9LHNlZWs6ZnVuY3Rpb24oKXtyZXR1cm4gQy5jdXJyZW50LnNlZWsuYXBwbHkoQy5jdXJyZW50LGFyZ3VtZW50cyl9LGNyZWF0ZTpmdW5jdGlvbigpe3JldHVybiBDLmN1cnJlbnQuY3JlYXRlLmFwcGx5KEMuY3VycmVudCxhcmd1bWVudHMpfX0sbz17fTtmb3IoUSBpbiBFKUUuaGFzT3duUHJvcGVydHkoUSkmJihvW1FdPUVbUV0pO0UuYXJndW1lbnRzPVtdLEUudGhpc1Byb2dyYW09Ii4vdGhpcy5wcm9ncmFtIixFLnF1aXQ9ZnVuY3Rpb24oQSxCKXt0aHJvdyBCfSxFLnByZVJ1bj1bXSxFLnBvc3RSdW49W107dmFyIHQ9ITEsZT0hMSxyPSExO2lmKEUuRU5WSVJPTk1FTlQpe2lmKCJXRUIiPT09RS5FTlZJUk9OTUVOVCl0PSEwO2Vsc2UgaWYoIldPUktFUiI9PT1FLkVOVklST05NRU5UKWU9ITA7ZWxzZSBpZigiTk9ERSI9PT1FLkVOVklST05NRU5UKXI9ITA7ZWxzZSBpZigiU0hFTEwiIT09RS5FTlZJUk9OTUVOVCl0aHJvdyBuZXcgRXJyb3IoIk1vZHVsZVsnRU5WSVJPTk1FTlQnXSB2YWx1ZSBpcyBub3QgdmFsaWQuIG11c3QgYmUgb25lIG9mOiBXRUJ8V09SS0VSfE5PREV8U0hFTEwuIil9ZWxzZSB0PSJvYmplY3QiPT10eXBlb2Ygd2luZG93LGU9ImZ1bmN0aW9uIj09dHlwZW9mIGltcG9ydFNjcmlwdHMscj0ib2JqZWN0Ij09dHlwZW9mIHByb2Nlc3MmJiJmdW5jdGlvbiI9PXR5cGVvZiByZXF1aXJlJiYhdCYmIWU7Zm9yKFEgaW4odHx8ZSkmJihFLnJlYWQ9ZnVuY3Rpb24oQSl7dmFyIEI9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBCLm9wZW4oIkdFVCIsQSwhMSksQi5zZW5kKG51bGwpLEIucmVzcG9uc2VUZXh0fSxlJiYoRS5yZWFkQmluYXJ5PWZ1bmN0aW9uKEEpe3ZhciBCPW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gQi5vcGVuKCJHRVQiLEEsITEpLEIucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciIsQi5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KEIucmVzcG9uc2UpfSksRS5yZWFkQXN5bmM9ZnVuY3Rpb24oQSxCLEkpe3ZhciBnPW5ldyBYTUxIdHRwUmVxdWVzdDtnLm9wZW4oIkdFVCIsQSwhMCksZy5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIixnLm9ubG9hZD1mdW5jdGlvbigpezIwMD09Zy5zdGF0dXN8fDA9PWcuc3RhdHVzJiZnLnJlc3BvbnNlP0IoZy5yZXNwb25zZSk6SSgpfSxnLm9uZXJyb3I9SSxnLnNlbmQobnVsbCl9LEUuc2V0V2luZG93VGl0bGU9ZnVuY3Rpb24oQSl7ZG9jdW1lbnQudGl0bGU9QX0pLEUucHJpbnQ9InVuZGVmaW5lZCIhPXR5cGVvZiBjb25zb2xlP2NvbnNvbGUubG9nLmJpbmQoY29uc29sZSk6InVuZGVmaW5lZCIhPXR5cGVvZiBwcmludD9wcmludDpudWxsLEUucHJpbnRFcnI9InVuZGVmaW5lZCIhPXR5cGVvZiBwcmludEVycj9wcmludEVycjoidW5kZWZpbmVkIiE9dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpfHxFLnByaW50LEUucHJpbnQ9RS5wcmludCxFLnByaW50RXJyPUUucHJpbnRFcnIsbylvLmhhc093blByb3BlcnR5KFEpJiYoRVtRXT1vW1FdKTtvPXZvaWQgMDtmdW5jdGlvbiBhKEEpe3coIW0pO3ZhciBCPUs7cmV0dXJuIEs9SytBKzE1Ji0xNixCfWZ1bmN0aW9uIG4oQSl7dyhXKTt2YXIgQj1IW1c+PjJdLEk9QitBKzE1Ji0xNjtpZigoSFtXPj4yXT1JLEk+PXopJiYhWigpKXJldHVybiBIW1c+PjJdPUIsMDtyZXR1cm4gQn1mdW5jdGlvbiBzKEEsQil7cmV0dXJuIEJ8fChCPTE2KSxBPU1hdGguY2VpbChBL0IpKkJ9ZnVuY3Rpb24gRChBKXtzd2l0Y2goQSl7Y2FzZSJpMSI6Y2FzZSJpOCI6cmV0dXJuIDE7Y2FzZSJpMTYiOnJldHVybiAyO2Nhc2UiaTMyIjpjYXNlImZsb2F0IjpyZXR1cm4gNDtjYXNlImk2NCI6Y2FzZSJkb3VibGUiOnJldHVybiA4O2RlZmF1bHQ6aWYoIioiPT09QVtBLmxlbmd0aC0xXSlyZXR1cm4gNDtpZigiaSI9PT1BWzBdKXt2YXIgQj1wYXJzZUludChBLnN1YnN0cigxKSk7cmV0dXJuIHcoQiU4PT0wKSxCLzh9cmV0dXJuIDB9fW5ldyBBcnJheSgwKTt2YXIgRj0wO2Z1bmN0aW9uIHcoQSxCKXtBfHxpSSgiQXNzZXJ0aW9uIGZhaWxlZDogIitCKX1mdW5jdGlvbiBjKEEsQixJLGcpe3N3aXRjaCgiKiI9PT0oST1JfHwiaTgiKS5jaGFyQXQoSS5sZW5ndGgtMSkmJihJPSJpMzIiKSxJKXtjYXNlImkxIjpjYXNlImk4Ijp1W0E+PjBdPUI7YnJlYWs7Y2FzZSJpMTYiOkpbQT4+MV09QjticmVhaztjYXNlImkzMiI6SFtBPj4yXT1CO2JyZWFrO2Nhc2UiaTY0Ijp0ZW1wSTY0PVtCPj4+MCwodGVtcERvdWJsZT1CLCtDQSh0ZW1wRG91YmxlKT49MT90ZW1wRG91YmxlPjA/KDB8dEEoK29BKHRlbXBEb3VibGUvNDI5NDk2NzI5NiksNDI5NDk2NzI5NSkpPj4+MDp+fitpQSgodGVtcERvdWJsZS0rKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhbQT4+Ml09dGVtcEk2NFswXSxIW0ErND4+Ml09dGVtcEk2NFsxXTticmVhaztjYXNlImZsb2F0IjpxW0E+PjJdPUI7YnJlYWs7Y2FzZSJkb3VibGUiOnBbQT4+M109QjticmVhaztkZWZhdWx0OmlJKCJpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAiK0kpfX1mdW5jdGlvbiBoKEEsQixJLGcpe3ZhciBRLEU7Im51bWJlciI9PXR5cGVvZiBBPyhRPSEwLEU9QSk6KFE9ITEsRT1BLmxlbmd0aCk7dmFyIEMsaT0ic3RyaW5nIj09dHlwZW9mIEI/QjpudWxsO2lmKEM9ND09ST9nOlsiZnVuY3Rpb24iPT10eXBlb2YgSUk/SUk6YSxRSSxhLG5dW3ZvaWQgMD09PUk/MjpJXShNYXRoLm1heChFLGk/MTpCLmxlbmd0aCkpLFEpe3ZhciBvO2ZvcihnPUMsdygwPT0oMyZDKSksbz1DKygtNCZFKTtnPG87Zys9NClIW2c+PjJdPTA7Zm9yKG89QytFO2c8bzspdVtnKys+PjBdPTA7cmV0dXJuIEN9aWYoImk4Ij09PWkpcmV0dXJuIEEuc3ViYXJyYXl8fEEuc2xpY2U/TC5zZXQoQSxDKTpMLnNldChuZXcgVWludDhBcnJheShBKSxDKSxDO2Zvcih2YXIgdCxlLHIscz0wO3M8RTspe3ZhciBGPUFbc107MCE9PSh0PWl8fEJbc10pPygiaTY0Ij09dCYmKHQ9ImkzMiIpLGMoQytzLEYsdCksciE9PXQmJihlPUQodCkscj10KSxzKz1lKTpzKyt9cmV0dXJuIEN9ZnVuY3Rpb24geShBLEIpe2lmKDA9PT1CfHwhQSlyZXR1cm4iIjtmb3IodmFyIEksZz0wLFE9MDtnfD1JPUxbQStRPj4wXSwoMCE9SXx8QikmJihRKyssIUJ8fFEhPUIpOyk7Qnx8KEI9USk7dmFyIEU9IiI7aWYoZzwxMjgpe2Zvcih2YXIgQyxpPTEwMjQ7Qj4wOylDPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLEwuc3ViYXJyYXkoQSxBK01hdGgubWluKEIsaSkpKSxFPUU/RStDOkMsQSs9aSxCLT1pO3JldHVybiBFfXJldHVybiBHKEEpfXZhciBSPSJ1bmRlZmluZWQiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKCJ1dGY4Iik6dm9pZCAwO2Z1bmN0aW9uIFUoQSxCKXtmb3IodmFyIEk9QjtBW0ldOykrK0k7aWYoSS1CPjE2JiZBLnN1YmFycmF5JiZSKXJldHVybiBSLmRlY29kZShBLnN1YmFycmF5KEIsSSkpO2Zvcih2YXIgZyxRLEUsQyxpLG89IiI7Oyl7aWYoIShnPUFbQisrXSkpcmV0dXJuIG87aWYoMTI4JmcpaWYoUT02MyZBW0IrK10sMTkyIT0oMjI0JmcpKWlmKEU9NjMmQVtCKytdLDIyND09KDI0MCZnKT9nPSgxNSZnKTw8MTJ8UTw8NnxFOihDPTYzJkFbQisrXSwyNDA9PSgyNDgmZyk/Zz0oNyZnKTw8MTh8UTw8MTJ8RTw8NnxDOihpPTYzJkFbQisrXSxnPTI0OD09KDI1MiZnKT8oMyZnKTw8MjR8UTw8MTh8RTw8MTJ8Qzw8NnxpOigxJmcpPDwzMHxRPDwyNHxFPDwxOHxDPDwxMnxpPDw2fDYzJkFbQisrXSkpLGc8NjU1MzYpbys9U3RyaW5nLmZyb21DaGFyQ29kZShnKTtlbHNle3ZhciB0PWctNjU1MzY7bys9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx0Pj4xMCw1NjMyMHwxMDIzJnQpfWVsc2Ugbys9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmZyk8PDZ8USk7ZWxzZSBvKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpfX1mdW5jdGlvbiBHKEEpe3JldHVybiBVKEwsQSl9ZnVuY3Rpb24gUyhBLEIsSSxnKXtpZighKGc+MCkpcmV0dXJuIDA7Zm9yKHZhciBRPUksRT1JK2ctMSxDPTA7QzxBLmxlbmd0aDsrK0Mpe3ZhciBpPUEuY2hhckNvZGVBdChDKTtpZihpPj01NTI5NiYmaTw9NTczNDMmJihpPTY1NTM2KygoMTAyMyZpKTw8MTApfDEwMjMmQS5jaGFyQ29kZUF0KCsrQykpLGk8PTEyNyl7aWYoST49RSlicmVhaztCW0krK109aX1lbHNlIGlmKGk8PTIwNDcpe2lmKEkrMT49RSlicmVhaztCW0krK109MTkyfGk+PjYsQltJKytdPTEyOHw2MyZpfWVsc2UgaWYoaTw9NjU1MzUpe2lmKEkrMj49RSlicmVhaztCW0krK109MjI0fGk+PjEyLEJbSSsrXT0xMjh8aT4+NiY2MyxCW0krK109MTI4fDYzJml9ZWxzZSBpZihpPD0yMDk3MTUxKXtpZihJKzM+PUUpYnJlYWs7QltJKytdPTI0MHxpPj4xOCxCW0krK109MTI4fGk+PjEyJjYzLEJbSSsrXT0xMjh8aT4+NiY2MyxCW0krK109MTI4fDYzJml9ZWxzZSBpZihpPD02NzEwODg2Myl7aWYoSSs0Pj1FKWJyZWFrO0JbSSsrXT0yNDh8aT4+MjQsQltJKytdPTEyOHxpPj4xOCY2MyxCW0krK109MTI4fGk+PjEyJjYzLEJbSSsrXT0xMjh8aT4+NiY2MyxCW0krK109MTI4fDYzJml9ZWxzZXtpZihJKzU+PUUpYnJlYWs7QltJKytdPTI1MnxpPj4zMCxCW0krK109MTI4fGk+PjI0JjYzLEJbSSsrXT0xMjh8aT4+MTgmNjMsQltJKytdPTEyOHxpPj4xMiY2MyxCW0krK109MTI4fGk+PjYmNjMsQltJKytdPTEyOHw2MyZpfX1yZXR1cm4gQltJXT0wLEktUX1mdW5jdGlvbiBrKEEsQixJKXtyZXR1cm4gUyhBLEwsQixJKX1mdW5jdGlvbiBmKEEpe2Zvcih2YXIgQj0wLEk9MDtJPEEubGVuZ3RoOysrSSl7dmFyIGc9QS5jaGFyQ29kZUF0KEkpO2c+PTU1Mjk2JiZnPD01NzM0MyYmKGc9NjU1MzYrKCgxMDIzJmcpPDwxMCl8MTAyMyZBLmNoYXJDb2RlQXQoKytJKSksZzw9MTI3PysrQjpCKz1nPD0yMDQ3PzI6Zzw9NjU1MzU/MzpnPD0yMDk3MTUxPzQ6Zzw9NjcxMDg4NjM/NTo2fXJldHVybiBCfWZ1bmN0aW9uIE4oQSl7Zm9yKHZhciBCPTAsST0iIjs7KXt2YXIgZz1IW0ErNCpCPj4yXTtpZigwPT1nKXJldHVybiBJO2lmKCsrQixnPj02NTUzNil7dmFyIFE9Zy02NTUzNjtJKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fFE+PjEwLDU2MzIwfDEwMjMmUSl9ZWxzZSBJKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpfX1mdW5jdGlvbiBkKCl7dmFyIEE9ZnVuY3Rpb24oKXt2YXIgQT1uZXcgRXJyb3I7aWYoIUEuc3RhY2spe3RyeXt0aHJvdyBuZXcgRXJyb3IoMCl9Y2F0Y2goQil7QT1CfWlmKCFBLnN0YWNrKXJldHVybiIobm8gc3RhY2sgdHJhY2UgYXZhaWxhYmxlKSJ9cmV0dXJuIEEuc3RhY2sudG9TdHJpbmcoKX0oKTtyZXR1cm4gRS5leHRyYVN0YWNrVHJhY2UmJihBKz0iXG4iK0UuZXh0cmFTdGFja1RyYWNlKCkpLEEucmVwbGFjZSgvX19aW1x3XGRfXSsvZywoZnVuY3Rpb24oQSl7cmV0dXJuIEE9PUE/QTpBKyIgWyIrQSsiXSJ9KSl9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpO3ZhciBNLHUsTCxKLGwsSCxZLHEscCxLLG0seCx2LGIsVyxYPTY1NTM2LFY9MTY3NzcyMTY7ZnVuY3Rpb24gTyhBLEIpe3JldHVybiBBJUI+MCYmKEErPUItQSVCKSxBfWZ1bmN0aW9uIFQoQSl7RS5idWZmZXI9TT1BfWZ1bmN0aW9uIGooKXtFLkhFQVA4PXU9bmV3IEludDhBcnJheShNKSxFLkhFQVAxNj1KPW5ldyBJbnQxNkFycmF5KE0pLEUuSEVBUDMyPUg9bmV3IEludDMyQXJyYXkoTSksRS5IRUFQVTg9TD1uZXcgVWludDhBcnJheShNKSxFLkhFQVBVMTY9bD1uZXcgVWludDE2QXJyYXkoTSksRS5IRUFQVTMyPVk9bmV3IFVpbnQzMkFycmF5KE0pLEUuSEVBUEYzMj1xPW5ldyBGbG9hdDMyQXJyYXkoTSksRS5IRUFQRjY0PXA9bmV3IEZsb2F0NjRBcnJheShNKX1mdW5jdGlvbiBaKCl7dmFyIEE9RS51c2luZ1dhc20/WDpWLEI9MjE0NzQ4MzY0OC1BO2lmKEhbVz4+Ml0+QilyZXR1cm4hMTt2YXIgST16O2Zvcih6PU1hdGgubWF4KHosMTY3NzcyMTYpO3o8SFtXPj4yXTspej16PD01MzY4NzA5MTI/TygyKnosQSk6TWF0aC5taW4oTygoMyp6KzIxNDc0ODM2NDgpLzQsQSksQik7dmFyIGc9RS5yZWFsbG9jQnVmZmVyKHopO3JldHVybiBnJiZnLmJ5dGVMZW5ndGg9PXo/KFQoZyksaigpLCEwKTooej1JLCExKX1LPXY9Vz0wLG09ITEsRS5yZWFsbG9jQnVmZmVyfHwoRS5yZWFsbG9jQnVmZmVyPWZ1bmN0aW9uKEEpe3ZhciBCO3RyeXtpZihBcnJheUJ1ZmZlci50cmFuc2ZlcilCPUFycmF5QnVmZmVyLnRyYW5zZmVyKE0sQSk7ZWxzZXt2YXIgST11O0I9bmV3IEFycmF5QnVmZmVyKEEpLG5ldyBJbnQ4QXJyYXkoQikuc2V0KEkpfX1jYXRjaChBKXtyZXR1cm4hMX1yZXR1cm4hIUFJKEIpJiZCfSk7dHJ5e0Z1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihBcnJheUJ1ZmZlci5wcm90b3R5cGUsImJ5dGVMZW5ndGgiKS5nZXQpKG5ldyBBcnJheUJ1ZmZlcig0KSl9Y2F0Y2goQSl7KGZ1bmN0aW9uKEEpe3JldHVybiBBLmJ5dGVMZW5ndGh9KX12YXIgUD1FLlRPVEFMX1NUQUNLfHw1MjQyODgwLHo9RS5UT1RBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKHo8UCYmRS5wcmludEVycigiVE9UQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBUT1RBTF9TVEFDSywgd2FzICIreisiISAoVE9UQUxfU1RBQ0s9IitQKyIpIiksRS5idWZmZXI/TT1FLmJ1ZmZlcjooIm9iamVjdCI9PXR5cGVvZiBXZWJBc3NlbWJseSYmImZ1bmN0aW9uIj09dHlwZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeT8oRS53YXNtTWVtb3J5PW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6ei9YfSksTT1FLndhc21NZW1vcnkuYnVmZmVyKTpNPW5ldyBBcnJheUJ1ZmZlcih6KSxFLmJ1ZmZlcj1NKSxqKCksSFswXT0xNjY4NTA5MDI5LEpbMV09MjU0NTksMTE1IT09TFsyXXx8OTkhPT1MWzNdKXRocm93IlJ1bnRpbWUgZXJyb3I6IGV4cGVjdGVkIHRoZSBzeXN0ZW0gdG8gYmUgbGl0dGxlLWVuZGlhbiEiO2Z1bmN0aW9uIF8oQSl7Zm9yKDtBLmxlbmd0aD4wOyl7dmFyIEI9QS5zaGlmdCgpO2lmKCJmdW5jdGlvbiIhPXR5cGVvZiBCKXt2YXIgST1CLmZ1bmM7Im51bWJlciI9PXR5cGVvZiBJP3ZvaWQgMD09PUIuYXJnP0UuZHluQ2FsbF92KEkpOkUuZHluQ2FsbF92aShJLEIuYXJnKTpJKHZvaWQgMD09PUIuYXJnP251bGw6Qi5hcmcpfWVsc2UgQigpfX12YXIgJD1bXSxBQT1bXSxCQT1bXSxJQT1bXSxnQT1bXSxRQT0hMTtmdW5jdGlvbiBFQShBLEIsSSl7Zm9yKHZhciBnPTA7ZzxBLmxlbmd0aDsrK2cpdVtCKys+PjBdPUEuY2hhckNvZGVBdChnKTtJfHwodVtCPj4wXT0wKX12YXIgQ0E9TWF0aC5hYnMsaUE9TWF0aC5jZWlsLG9BPU1hdGguZmxvb3IsdEE9TWF0aC5taW4sZUE9MCxyQT1udWxsO2Z1bmN0aW9uIGFBKEEpe2VBKyssRS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZFLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZUEpfWZ1bmN0aW9uIG5BKEEpe2lmKGVBLS0sRS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZFLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZUEpLDA9PWVBJiZyQSl7dmFyIEI9ckE7ckE9bnVsbCxCKCl9fUUucHJlbG9hZGVkSW1hZ2VzPXt9LEUucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciBzQT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCI7ZnVuY3Rpb24gREEoQSl7cmV0dXJuIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9BLnN0YXJ0c1dpdGgoc0EpOjA9PT1BLmluZGV4T2Yoc0EpfSFmdW5jdGlvbigpe3ZhciBCPSJ1bnBhY2sud2FzdCIsST0idW5wYWNrLnRlbXAuYXNtLmpzIjsiZnVuY3Rpb24iPT10eXBlb2YgRS5sb2NhdGVGaWxlJiYoREEoQil8fChCPUUubG9jYXRlRmlsZShCKSksREEoQSl8fChBPUUubG9jYXRlRmlsZShBKSksREEoSSl8fChJPUUubG9jYXRlRmlsZShJKSkpO3ZhciBRPXtnbG9iYWw6bnVsbCxlbnY6bnVsbCxhc20yd2FzbTp7ImY2NC1yZW0iOmZ1bmN0aW9uKEEsQil7cmV0dXJuIEElQn0sZGVidWdnZXI6ZnVuY3Rpb24oKXt9fSxwYXJlbnQ6RX0sQz1udWxsO2Z1bmN0aW9uIGkoKXt0cnl7aWYoRS53YXNtQmluYXJ5KXJldHVybiBuZXcgVWludDhBcnJheShFLndhc21CaW5hcnkpO2lmKEUucmVhZEJpbmFyeSlyZXR1cm4gRS5yZWFkQmluYXJ5KEEpO3Rocm93Im9uIHRoZSB3ZWIsIHdlIG5lZWQgdGhlIHdhc20gYmluYXJ5IHRvIGJlIHByZWxvYWRlZCBhbmQgc2V0IG9uIE1vZHVsZVsnd2FzbUJpbmFyeSddLiBlbWNjLnB5IHdpbGwgZG8gdGhhdCBmb3IgeW91IHdoZW4gZ2VuZXJhdGluZyBIVE1MIChidXQgbm90IEpTKSJ9Y2F0Y2goQSl7aUkoQSl9fWZ1bmN0aW9uIG8oQixJLG8pe2lmKCJvYmplY3QiIT10eXBlb2YgV2ViQXNzZW1ibHkpcmV0dXJuIEUucHJpbnRFcnIoIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQiKSwhMTtpZighKEUud2FzbU1lbW9yeSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkpcmV0dXJuIEUucHJpbnRFcnIoIm5vIG5hdGl2ZSB3YXNtIE1lbW9yeSBpbiB1c2UiKSwhMTtmdW5jdGlvbiByKEEsQil7KEM9QS5leHBvcnRzKS5tZW1vcnkmJmZ1bmN0aW9uKEEpe3ZhciBCPUUuYnVmZmVyO0EuYnl0ZUxlbmd0aDxCLmJ5dGVMZW5ndGgmJkUucHJpbnRFcnIoInRoZSBuZXcgYnVmZmVyIGluIG1lcmdlTWVtb3J5IGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lLiBpbiBuYXRpdmUgd2FzbSwgd2Ugc2hvdWxkIGdyb3cgbWVtb3J5IGhlcmUiKTt2YXIgST1uZXcgSW50OEFycmF5KEIpO25ldyBJbnQ4QXJyYXkoQSkuc2V0KEkpLFQoQSksaigpfShDLm1lbW9yeSksRS5hc209QyxFLnVzaW5nV2FzbT0hMCxuQSgpfWlmKEkubWVtb3J5PUUud2FzbU1lbW9yeSxRLmdsb2JhbD17TmFOOk5hTixJbmZpbml0eToxLzB9LFFbImdsb2JhbC5NYXRoIl09TWF0aCxRLmVudj1JLGFBKCksRS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBFLmluc3RhbnRpYXRlV2FzbShRLHIpfWNhdGNoKEEpe3JldHVybiBFLnByaW50RXJyKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK0EpLCExfWZ1bmN0aW9uIGEoQSl7cihBLmluc3RhbmNlLEEubW9kdWxlKX1mdW5jdGlvbiBuKEIpeyhFLndhc21CaW5hcnl8fCF0JiYhZXx8ImZ1bmN0aW9uIiE9dHlwZW9mIGZldGNoP25ldyBQcm9taXNlKChmdW5jdGlvbihBLEIpe0EoaSgpKX0pKTpmZXRjaChBLHtjcmVkZW50aWFsczpnfSkudGhlbigoZnVuY3Rpb24oQil7aWYoIUIub2spdGhyb3ciZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnIitBKyInIjtyZXR1cm4gQi5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBpKCl9KSkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShBLFEpfSkpLnRoZW4oQikuY2F0Y2goKGZ1bmN0aW9uKEEpe0UucHJpbnRFcnIoImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICIrQSksaUkoQSl9KSl9cmV0dXJuIEUud2FzbUJpbmFyeXx8ImZ1bmN0aW9uIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxEQShBKXx8ImZ1bmN0aW9uIiE9dHlwZW9mIGZldGNoP24oYSk6V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZmV0Y2goQSx7Y3JlZGVudGlhbHM6Z30pLFEpLnRoZW4oYSkuY2F0Y2goKGZ1bmN0aW9uKEEpe0UucHJpbnRFcnIoIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAiK0EpLEUucHJpbnRFcnIoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIiksbihhKX0pKSx7fX1FLmFzbVByZWxvYWQ9RS5hc207dmFyIHI9RS5yZWFsbG9jQnVmZmVyO0UucmVhbGxvY0J1ZmZlcj1mdW5jdGlvbihBKXtyZXR1cm4iYXNtanMiPT09YT9yKEEpOmZ1bmN0aW9uKEEpe0E9TyhBLEUudXNpbmdXYXNtP1g6Vik7dmFyIEI9RS5idWZmZXIuYnl0ZUxlbmd0aDtpZihFLnVzaW5nV2FzbSl0cnl7cmV0dXJuLTEhPT1FLndhc21NZW1vcnkuZ3JvdygoQS1CKS82NTUzNik/RS5idWZmZXI9RS53YXNtTWVtb3J5LmJ1ZmZlcjpudWxsfWNhdGNoKEEpe3JldHVybiBudWxsfX0oQSl9O3ZhciBhPSIiO0UuYXNtPWZ1bmN0aW9uKEEsQixJKXtpZighKEI9QikudGFibGUpe3ZhciBnPUUud2FzbVRhYmxlU2l6ZTt2b2lkIDA9PT1nJiYoZz0xMDI0KTt2YXIgUT1FLndhc21NYXhUYWJsZVNpemU7Im9iamVjdCI9PXR5cGVvZiBXZWJBc3NlbWJseSYmImZ1bmN0aW9uIj09dHlwZW9mIFdlYkFzc2VtYmx5LlRhYmxlP0IudGFibGU9dm9pZCAwIT09UT9uZXcgV2ViQXNzZW1ibHkuVGFibGUoe2luaXRpYWw6ZyxtYXhpbXVtOlEsZWxlbWVudDoiYW55ZnVuYyJ9KTpuZXcgV2ViQXNzZW1ibHkuVGFibGUoe2luaXRpYWw6ZyxlbGVtZW50OiJhbnlmdW5jIn0pOkIudGFibGU9bmV3IEFycmF5KGcpLEUud2FzbVRhYmxlPUIudGFibGV9dmFyIEM7cmV0dXJuIEIubWVtb3J5QmFzZXx8KEIubWVtb3J5QmFzZT1FLlNUQVRJQ19CQVNFKSxCLnRhYmxlQmFzZXx8KEIudGFibGVCYXNlPTApLChDPW8oMCxCKSl8fGlJKCJubyBiaW5hcnllbiBtZXRob2Qgc3VjY2VlZGVkLiBjb25zaWRlciBlbmFibGluZyBtb3JlIG9wdGlvbnMsIGxpa2UgaW50ZXJwcmV0aW5nLCBpZiB5b3Ugd2FudCB0aGF0OiBodHRwczovL2dpdGh1Yi5jb20va3JpcGtlbi9lbXNjcmlwdGVuL3dpa2kvV2ViQXNzZW1ibHkjYmluYXJ5ZW4tbWV0aG9kcyIpLEN9fSgpLEs9Njc5ODQsQUEucHVzaCh7ZnVuYzpmdW5jdGlvbigpe19CKCl9fSx7ZnVuYzpmdW5jdGlvbigpe3pCKCl9fSx7ZnVuYzpmdW5jdGlvbigpe1BCKCl9fSx7ZnVuYzpmdW5jdGlvbigpe1pCKCl9fSk7RS5TVEFUSUNfQkFTRT0xMDI0LEUuU1RBVElDX0JVTVA9NjY5NjAsSys9MTY7dmFyIEZBPXtsYXN0OjAsY2F1Z2h0OltdLGluZm9zOnt9LGRlQWRqdXN0OmZ1bmN0aW9uKEEpe2lmKCFBfHxGQS5pbmZvc1tBXSlyZXR1cm4gQTtmb3IodmFyIEIgaW4gRkEuaW5mb3Mpe3ZhciBJPStCO2lmKEZBLmluZm9zW0ldLmFkanVzdGVkPT09QSlyZXR1cm4gSX1yZXR1cm4gQX0sYWRkUmVmOmZ1bmN0aW9uKEEpe0EmJkZBLmluZm9zW0FdLnJlZmNvdW50Kyt9LGRlY1JlZjpmdW5jdGlvbihBKXtpZihBKXt2YXIgQj1GQS5pbmZvc1tBXTt3KEIucmVmY291bnQ+MCksQi5yZWZjb3VudC0tLDAhPT1CLnJlZmNvdW50fHxCLnJldGhyb3dufHwoQi5kZXN0cnVjdG9yJiZFLmR5bkNhbGxfdmkoQi5kZXN0cnVjdG9yLEEpLGRlbGV0ZSBGQS5pbmZvc1tBXSx3QShBKSl9fSxjbGVhclJlZjpmdW5jdGlvbihBKXtBJiYoRkEuaW5mb3NbQV0ucmVmY291bnQ9MCl9fTtmdW5jdGlvbiB3QShBKXt0cnl7cmV0dXJuIEJJKEEpfWNhdGNoKEEpe319ZnVuY3Rpb24gY0EoKXt2YXIgQT1GQS5sYXN0O2lmKCFBKXJldHVybiAwfChnSSgwKSwwKTt2YXIgQj1GQS5pbmZvc1tBXSxJPUIudHlwZTtpZighSSlyZXR1cm4gMHwoZ0koMCksQSk7dmFyIGc9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtFLl9fX2N4YV9pc19wb2ludGVyX3R5cGUoSSksY0EuYnVmZmVyfHwoY0EuYnVmZmVyPUlJKDQpKSxIW2NBLmJ1ZmZlcj4+Ml09QSxBPWNBLmJ1ZmZlcjtmb3IodmFyIFE9MDtRPGcubGVuZ3RoO1ErKylpZihnW1FdJiZFLl9fX2N4YV9jYW5fY2F0Y2goZ1tRXSxJLEEpKXJldHVybiBBPUhbQT4+Ml0sQi5hZGp1c3RlZD1BLDB8KGdJKGdbUV0pLEEpO3JldHVybiBBPUhbQT4+Ml0sMHwoZ0koSSksQSl9dmFyIGhBPXtFUEVSTToxLEVOT0VOVDoyLEVTUkNIOjMsRUlOVFI6NCxFSU86NSxFTlhJTzo2LEUyQklHOjcsRU5PRVhFQzo4LEVCQURGOjksRUNISUxEOjEwLEVBR0FJTjoxMSxFV09VTERCTE9DSzoxMSxFTk9NRU06MTIsRUFDQ0VTOjEzLEVGQVVMVDoxNCxFTk9UQkxLOjE1LEVCVVNZOjE2LEVFWElTVDoxNyxFWERFVjoxOCxFTk9ERVY6MTksRU5PVERJUjoyMCxFSVNESVI6MjEsRUlOVkFMOjIyLEVORklMRToyMyxFTUZJTEU6MjQsRU5PVFRZOjI1LEVUWFRCU1k6MjYsRUZCSUc6MjcsRU5PU1BDOjI4LEVTUElQRToyOSxFUk9GUzozMCxFTUxJTks6MzEsRVBJUEU6MzIsRURPTTozMyxFUkFOR0U6MzQsRU5PTVNHOjQyLEVJRFJNOjQzLEVDSFJORzo0NCxFTDJOU1lOQzo0NSxFTDNITFQ6NDYsRUwzUlNUOjQ3LEVMTlJORzo0OCxFVU5BVENIOjQ5LEVOT0NTSTo1MCxFTDJITFQ6NTEsRURFQURMSzozNSxFTk9MQ0s6MzcsRUJBREU6NTIsRUJBRFI6NTMsRVhGVUxMOjU0LEVOT0FOTzo1NSxFQkFEUlFDOjU2LEVCQURTTFQ6NTcsRURFQURMT0NLOjM1LEVCRk9OVDo1OSxFTk9TVFI6NjAsRU5PREFUQTo2MSxFVElNRTo2MixFTk9TUjo2MyxFTk9ORVQ6NjQsRU5PUEtHOjY1LEVSRU1PVEU6NjYsRU5PTElOSzo2NyxFQURWOjY4LEVTUk1OVDo2OSxFQ09NTTo3MCxFUFJPVE86NzEsRU1VTFRJSE9QOjcyLEVET1RET1Q6NzMsRUJBRE1TRzo3NCxFTk9UVU5JUTo3NixFQkFERkQ6NzcsRVJFTUNIRzo3OCxFTElCQUNDOjc5LEVMSUJCQUQ6ODAsRUxJQlNDTjo4MSxFTElCTUFYOjgyLEVMSUJFWEVDOjgzLEVOT1NZUzozOCxFTk9URU1QVFk6MzksRU5BTUVUT09MT05HOjM2LEVMT09QOjQwLEVPUE5PVFNVUFA6OTUsRVBGTk9TVVBQT1JUOjk2LEVDT05OUkVTRVQ6MTA0LEVOT0JVRlM6MTA1LEVBRk5PU1VQUE9SVDo5NyxFUFJPVE9UWVBFOjkxLEVOT1RTT0NLOjg4LEVOT1BST1RPT1BUOjkyLEVTSFVURE9XTjoxMDgsRUNPTk5SRUZVU0VEOjExMSxFQUREUklOVVNFOjk4LEVDT05OQUJPUlRFRDoxMDMsRU5FVFVOUkVBQ0g6MTAxLEVORVRET1dOOjEwMCxFVElNRURPVVQ6MTEwLEVIT1NURE9XTjoxMTIsRUhPU1RVTlJFQUNIOjExMyxFSU5QUk9HUkVTUzoxMTUsRUFMUkVBRFk6MTE0LEVERVNUQUREUlJFUTo4OSxFTVNHU0laRTo5MCxFUFJPVE9OT1NVUFBPUlQ6OTMsRVNPQ0tUTk9TVVBQT1JUOjk0LEVBRERSTk9UQVZBSUw6OTksRU5FVFJFU0VUOjEwMixFSVNDT05OOjEwNixFTk9UQ09OTjoxMDcsRVRPT01BTllSRUZTOjEwOSxFVVNFUlM6ODcsRURRVU9UOjEyMixFU1RBTEU6MTE2LEVOT1RTVVA6OTUsRU5PTUVESVVNOjEyMyxFSUxTRVE6ODQsRU9WRVJGTE9XOjc1LEVDQU5DRUxFRDoxMjUsRU5PVFJFQ09WRVJBQkxFOjEzMSxFT1dORVJERUFEOjEzMCxFU1RSUElQRTo4Nn07ZnVuY3Rpb24geUEoQSl7cmV0dXJuIEUuX19fZXJybm9fbG9jYXRpb24mJihIW0UuX19fZXJybm9fbG9jYXRpb24oKT4+Ml09QSksQX12YXIgUkE9ezA6IlN1Y2Nlc3MiLDE6Ik5vdCBzdXBlci11c2VyIiwyOiJObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5IiwzOiJObyBzdWNoIHByb2Nlc3MiLDQ6IkludGVycnVwdGVkIHN5c3RlbSBjYWxsIiw1OiJJL08gZXJyb3IiLDY6Ik5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MiLDc6IkFyZyBsaXN0IHRvbyBsb25nIiw4OiJFeGVjIGZvcm1hdCBlcnJvciIsOToiQmFkIGZpbGUgbnVtYmVyIiwxMDoiTm8gY2hpbGRyZW4iLDExOiJObyBtb3JlIHByb2Nlc3NlcyIsMTI6Ik5vdCBlbm91Z2ggY29yZSIsMTM6IlBlcm1pc3Npb24gZGVuaWVkIiwxNDoiQmFkIGFkZHJlc3MiLDE1OiJCbG9jayBkZXZpY2UgcmVxdWlyZWQiLDE2OiJNb3VudCBkZXZpY2UgYnVzeSIsMTc6IkZpbGUgZXhpc3RzIiwxODoiQ3Jvc3MtZGV2aWNlIGxpbmsiLDE5OiJObyBzdWNoIGRldmljZSIsMjA6Ik5vdCBhIGRpcmVjdG9yeSIsMjE6IklzIGEgZGlyZWN0b3J5IiwyMjoiSW52YWxpZCBhcmd1bWVudCIsMjM6IlRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtIiwyNDoiVG9vIG1hbnkgb3BlbiBmaWxlcyIsMjU6Ik5vdCBhIHR5cGV3cml0ZXIiLDI2OiJUZXh0IGZpbGUgYnVzeSIsMjc6IkZpbGUgdG9vIGxhcmdlIiwyODoiTm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UiLDI5OiJJbGxlZ2FsIHNlZWsiLDMwOiJSZWFkIG9ubHkgZmlsZSBzeXN0ZW0iLDMxOiJUb28gbWFueSBsaW5rcyIsMzI6IkJyb2tlbiBwaXBlIiwzMzoiTWF0aCBhcmcgb3V0IG9mIGRvbWFpbiBvZiBmdW5jIiwzNDoiTWF0aCByZXN1bHQgbm90IHJlcHJlc2VudGFibGUiLDM1OiJGaWxlIGxvY2tpbmcgZGVhZGxvY2sgZXJyb3IiLDM2OiJGaWxlIG9yIHBhdGggbmFtZSB0b28gbG9uZyIsMzc6Ik5vIHJlY29yZCBsb2NrcyBhdmFpbGFibGUiLDM4OiJGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQiLDM5OiJEaXJlY3Rvcnkgbm90IGVtcHR5Iiw0MDoiVG9vIG1hbnkgc3ltYm9saWMgbGlua3MiLDQyOiJObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZSIsNDM6IklkZW50aWZpZXIgcmVtb3ZlZCIsNDQ6IkNoYW5uZWwgbnVtYmVyIG91dCBvZiByYW5nZSIsNDU6IkxldmVsIDIgbm90IHN5bmNocm9uaXplZCIsNDY6IkxldmVsIDMgaGFsdGVkIiw0NzoiTGV2ZWwgMyByZXNldCIsNDg6IkxpbmsgbnVtYmVyIG91dCBvZiByYW5nZSIsNDk6IlByb3RvY29sIGRyaXZlciBub3QgYXR0YWNoZWQiLDUwOiJObyBDU0kgc3RydWN0dXJlIGF2YWlsYWJsZSIsNTE6IkxldmVsIDIgaGFsdGVkIiw1MjoiSW52YWxpZCBleGNoYW5nZSIsNTM6IkludmFsaWQgcmVxdWVzdCBkZXNjcmlwdG9yIiw1NDoiRXhjaGFuZ2UgZnVsbCIsNTU6Ik5vIGFub2RlIiw1NjoiSW52YWxpZCByZXF1ZXN0IGNvZGUiLDU3OiJJbnZhbGlkIHNsb3QiLDU5OiJCYWQgZm9udCBmaWxlIGZtdCIsNjA6IkRldmljZSBub3QgYSBzdHJlYW0iLDYxOiJObyBkYXRhIChmb3Igbm8gZGVsYXkgaW8pIiw2MjoiVGltZXIgZXhwaXJlZCIsNjM6Ik91dCBvZiBzdHJlYW1zIHJlc291cmNlcyIsNjQ6Ik1hY2hpbmUgaXMgbm90IG9uIHRoZSBuZXR3b3JrIiw2NToiUGFja2FnZSBub3QgaW5zdGFsbGVkIiw2NjoiVGhlIG9iamVjdCBpcyByZW1vdGUiLDY3OiJUaGUgbGluayBoYXMgYmVlbiBzZXZlcmVkIiw2ODoiQWR2ZXJ0aXNlIGVycm9yIiw2OToiU3Jtb3VudCBlcnJvciIsNzA6IkNvbW11bmljYXRpb24gZXJyb3Igb24gc2VuZCIsNzE6IlByb3RvY29sIGVycm9yIiw3MjoiTXVsdGlob3AgYXR0ZW1wdGVkIiw3MzoiQ3Jvc3MgbW91bnQgcG9pbnQgKG5vdCByZWFsbHkgZXJyb3IpIiw3NDoiVHJ5aW5nIHRvIHJlYWQgdW5yZWFkYWJsZSBtZXNzYWdlIiw3NToiVmFsdWUgdG9vIGxhcmdlIGZvciBkZWZpbmVkIGRhdGEgdHlwZSIsNzY6IkdpdmVuIGxvZy4gbmFtZSBub3QgdW5pcXVlIiw3NzoiZi5kLiBpbnZhbGlkIGZvciB0aGlzIG9wZXJhdGlvbiIsNzg6IlJlbW90ZSBhZGRyZXNzIGNoYW5nZWQiLDc5OiJDYW4gICBhY2Nlc3MgYSBuZWVkZWQgc2hhcmVkIGxpYiIsODA6IkFjY2Vzc2luZyBhIGNvcnJ1cHRlZCBzaGFyZWQgbGliIiw4MToiLmxpYiBzZWN0aW9uIGluIGEub3V0IGNvcnJ1cHRlZCIsODI6IkF0dGVtcHRpbmcgdG8gbGluayBpbiB0b28gbWFueSBsaWJzIiw4MzoiQXR0ZW1wdGluZyB0byBleGVjIGEgc2hhcmVkIGxpYnJhcnkiLDg0OiJJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UiLDg2OiJTdHJlYW1zIHBpcGUgZXJyb3IiLDg3OiJUb28gbWFueSB1c2VycyIsODg6IlNvY2tldCBvcGVyYXRpb24gb24gbm9uLXNvY2tldCIsODk6IkRlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQiLDkwOiJNZXNzYWdlIHRvbyBsb25nIiw5MToiUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0Iiw5MjoiUHJvdG9jb2wgbm90IGF2YWlsYWJsZSIsOTM6IlVua25vd24gcHJvdG9jb2wiLDk0OiJTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkIiw5NToiTm90IHN1cHBvcnRlZCIsOTY6IlByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkIiw5NzoiQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbCBmYW1pbHkiLDk4OiJBZGRyZXNzIGFscmVhZHkgaW4gdXNlIiw5OToiQWRkcmVzcyBub3QgYXZhaWxhYmxlIiwxMDA6Ik5ldHdvcmsgaW50ZXJmYWNlIGlzIG5vdCBjb25maWd1cmVkIiwxMDE6Ik5ldHdvcmsgaXMgdW5yZWFjaGFibGUiLDEwMjoiQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrIiwxMDM6IkNvbm5lY3Rpb24gYWJvcnRlZCIsMTA0OiJDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIiLDEwNToiTm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZSIsMTA2OiJTb2NrZXQgaXMgYWxyZWFkeSBjb25uZWN0ZWQiLDEwNzoiU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQiLDEwODoiQ2FuJ3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24iLDEwOToiVG9vIG1hbnkgcmVmZXJlbmNlcyIsMTEwOiJDb25uZWN0aW9uIHRpbWVkIG91dCIsMTExOiJDb25uZWN0aW9uIHJlZnVzZWQiLDExMjoiSG9zdCBpcyBkb3duIiwxMTM6Ikhvc3QgaXMgdW5yZWFjaGFibGUiLDExNDoiU29ja2V0IGFscmVhZHkgY29ubmVjdGVkIiwxMTU6IkNvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcyIsMTE2OiJTdGFsZSBmaWxlIGhhbmRsZSIsMTIyOiJRdW90YSBleGNlZWRlZCIsMTIzOiJObyBtZWRpdW0gKGluIHRhcGUgZHJpdmUpIiwxMjU6Ik9wZXJhdGlvbiBjYW5jZWxlZCIsMTMwOiJQcmV2aW91cyBvd25lciBkaWVkIiwxMzE6IlN0YXRlIG5vdCByZWNvdmVyYWJsZSJ9LFVBPXtzcGxpdFBhdGg6ZnVuY3Rpb24oQSl7cmV0dXJuL14oXC8/fCkoW1xzXFNdKj8pKCg/OlwuezEsMn18W15cL10rP3wpKFwuW14uXC9dKnwpKSg/OltcL10qKSQvLmV4ZWMoQSkuc2xpY2UoMSl9LG5vcm1hbGl6ZUFycmF5OmZ1bmN0aW9uKEEsQil7Zm9yKHZhciBJPTAsZz1BLmxlbmd0aC0xO2c+PTA7Zy0tKXt2YXIgUT1BW2ddOyIuIj09PVE/QS5zcGxpY2UoZywxKToiLi4iPT09UT8oQS5zcGxpY2UoZywxKSxJKyspOkkmJihBLnNwbGljZShnLDEpLEktLSl9aWYoQilmb3IoO0k7SS0tKUEudW5zaGlmdCgiLi4iKTtyZXR1cm4gQX0sbm9ybWFsaXplOmZ1bmN0aW9uKEEpe3ZhciBCPSIvIj09PUEuY2hhckF0KDApLEk9Ii8iPT09QS5zdWJzdHIoLTEpO3JldHVybihBPVVBLm5vcm1hbGl6ZUFycmF5KEEuc3BsaXQoIi8iKS5maWx0ZXIoKGZ1bmN0aW9uKEEpe3JldHVybiEhQX0pKSwhQikuam9pbigiLyIpKXx8Qnx8KEE9Ii4iKSxBJiZJJiYoQSs9Ii8iKSwoQj8iLyI6IiIpK0F9LGRpcm5hbWU6ZnVuY3Rpb24oQSl7dmFyIEI9VUEuc3BsaXRQYXRoKEEpLEk9QlswXSxnPUJbMV07cmV0dXJuIEl8fGc/KGcmJihnPWcuc3Vic3RyKDAsZy5sZW5ndGgtMSkpLEkrZyk6Ii4ifSxiYXNlbmFtZTpmdW5jdGlvbihBKXtpZigiLyI9PT1BKXJldHVybiIvIjt2YXIgQj1BLmxhc3RJbmRleE9mKCIvIik7cmV0dXJuLTE9PT1CP0E6QS5zdWJzdHIoQisxKX0sZXh0bmFtZTpmdW5jdGlvbihBKXtyZXR1cm4gVUEuc3BsaXRQYXRoKEEpWzNdfSxqb2luOmZ1bmN0aW9uKCl7dmFyIEE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO3JldHVybiBVQS5ub3JtYWxpemUoQS5qb2luKCIvIikpfSxqb2luMjpmdW5jdGlvbihBLEIpe3JldHVybiBVQS5ub3JtYWxpemUoQSsiLyIrQil9LHJlc29sdmU6ZnVuY3Rpb24oKXtmb3IodmFyIEE9IiIsQj0hMSxJPWFyZ3VtZW50cy5sZW5ndGgtMTtJPj0tMSYmIUI7SS0tKXt2YXIgZz1JPj0wP2FyZ3VtZW50c1tJXTpkQS5jd2QoKTtpZigic3RyaW5nIiE9dHlwZW9mIGcpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MiKTtpZighZylyZXR1cm4iIjtBPWcrIi8iK0EsQj0iLyI9PT1nLmNoYXJBdCgwKX1yZXR1cm4oQj8iLyI6IiIpKyhBPVVBLm5vcm1hbGl6ZUFycmF5KEEuc3BsaXQoIi8iKS5maWx0ZXIoKGZ1bmN0aW9uKEEpe3JldHVybiEhQX0pKSwhQikuam9pbigiLyIpKXx8Ii4ifSxyZWxhdGl2ZTpmdW5jdGlvbihBLEIpe2Z1bmN0aW9uIEkoQSl7Zm9yKHZhciBCPTA7QjxBLmxlbmd0aCYmIiI9PT1BW0JdO0IrKyk7Zm9yKHZhciBJPUEubGVuZ3RoLTE7ST49MCYmIiI9PT1BW0ldO0ktLSk7cmV0dXJuIEI+ST9bXTpBLnNsaWNlKEIsSS1CKzEpfUE9VUEucmVzb2x2ZShBKS5zdWJzdHIoMSksQj1VQS5yZXNvbHZlKEIpLnN1YnN0cigxKTtmb3IodmFyIGc9SShBLnNwbGl0KCIvIikpLFE9SShCLnNwbGl0KCIvIikpLEU9TWF0aC5taW4oZy5sZW5ndGgsUS5sZW5ndGgpLEM9RSxpPTA7aTxFO2krKylpZihnW2ldIT09UVtpXSl7Qz1pO2JyZWFrfXZhciBvPVtdO2ZvcihpPUM7aTxnLmxlbmd0aDtpKyspby5wdXNoKCIuLiIpO3JldHVybihvPW8uY29uY2F0KFEuc2xpY2UoQykpKS5qb2luKCIvIil9fSxHQT17dHR5czpbXSxpbml0OmZ1bmN0aW9uKCl7fSxzaHV0ZG93bjpmdW5jdGlvbigpe30scmVnaXN0ZXI6ZnVuY3Rpb24oQSxCKXtHQS50dHlzW0FdPXtpbnB1dDpbXSxvdXRwdXQ6W10sb3BzOkJ9LGRBLnJlZ2lzdGVyRGV2aWNlKEEsR0Euc3RyZWFtX29wcyl9LHN0cmVhbV9vcHM6e29wZW46ZnVuY3Rpb24oQSl7dmFyIEI9R0EudHR5c1tBLm5vZGUucmRldl07aWYoIUIpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5PREVWKTtBLnR0eT1CLEEuc2Vla2FibGU9ITF9LGNsb3NlOmZ1bmN0aW9uKEEpe0EudHR5Lm9wcy5mbHVzaChBLnR0eSl9LGZsdXNoOmZ1bmN0aW9uKEEpe0EudHR5Lm9wcy5mbHVzaChBLnR0eSl9LHJlYWQ6ZnVuY3Rpb24oQSxCLEksZyxRKXtpZighQS50dHl8fCFBLnR0eS5vcHMuZ2V0X2NoYXIpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5YSU8pO2Zvcih2YXIgRT0wLEM9MDtDPGc7QysrKXt2YXIgaTt0cnl7aT1BLnR0eS5vcHMuZ2V0X2NoYXIoQS50dHkpfWNhdGNoKEEpe3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVJTyl9aWYodm9pZCAwPT09aSYmMD09PUUpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUFHQUlOKTtpZihudWxsPT1pKWJyZWFrO0UrKyxCW0krQ109aX1yZXR1cm4gRSYmKEEubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKSksRX0sd3JpdGU6ZnVuY3Rpb24oQSxCLEksZyxRKXtpZighQS50dHl8fCFBLnR0eS5vcHMucHV0X2NoYXIpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5YSU8pO2Zvcih2YXIgRT0wO0U8ZztFKyspdHJ5e0EudHR5Lm9wcy5wdXRfY2hhcihBLnR0eSxCW0krRV0pfWNhdGNoKEEpe3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVJTyl9cmV0dXJuIGcmJihBLm5vZGUudGltZXN0YW1wPURhdGUubm93KCkpLEV9fSxkZWZhdWx0X3R0eV9vcHM6e2dldF9jaGFyOmZ1bmN0aW9uKEEpe2lmKCFBLmlucHV0Lmxlbmd0aCl7dmFyIEI9bnVsbDtpZihyKXt2YXIgST1uZXcgQnVmZmVyKDI1NiksZz0wLFE9IndpbjMyIiE9cHJvY2Vzcy5wbGF0Zm9ybSxFPXByb2Nlc3Muc3RkaW4uZmQ7aWYoUSl7dmFyIEM9ITE7dHJ5e0U9ZnMub3BlblN5bmMoIi9kZXYvc3RkaW4iLCJyIiksQz0hMH1jYXRjaChBKXt9fXRyeXtnPWZzLnJlYWRTeW5jKEUsSSwwLDI1NixudWxsKX1jYXRjaChBKXtpZigtMT09QS50b1N0cmluZygpLmluZGV4T2YoIkVPRiIpKXRocm93IEE7Zz0wfUMmJmZzLmNsb3NlU3luYyhFKSxCPWc+MD9JLnNsaWNlKDAsZykudG9TdHJpbmcoInV0Zi04Iik6bnVsbH1lbHNlInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJiJmdW5jdGlvbiI9PXR5cGVvZiB3aW5kb3cucHJvbXB0P251bGwhPT0oQj13aW5kb3cucHJvbXB0KCJJbnB1dDogIikpJiYoQis9IlxuIik6ImZ1bmN0aW9uIj09dHlwZW9mIHJlYWRsaW5lJiZudWxsIT09KEI9cmVhZGxpbmUoKSkmJihCKz0iXG4iKTtpZighQilyZXR1cm4gbnVsbDtBLmlucHV0PVRCKEIsITApfXJldHVybiBBLmlucHV0LnNoaWZ0KCl9LHB1dF9jaGFyOmZ1bmN0aW9uKEEsQil7bnVsbD09PUJ8fDEwPT09Qj8oRS5wcmludChVKEEub3V0cHV0LDApKSxBLm91dHB1dD1bXSk6MCE9QiYmQS5vdXRwdXQucHVzaChCKX0sZmx1c2g6ZnVuY3Rpb24oQSl7QS5vdXRwdXQmJkEub3V0cHV0Lmxlbmd0aD4wJiYoRS5wcmludChVKEEub3V0cHV0LDApKSxBLm91dHB1dD1bXSl9fSxkZWZhdWx0X3R0eTFfb3BzOntwdXRfY2hhcjpmdW5jdGlvbihBLEIpe251bGw9PT1CfHwxMD09PUI/KEUucHJpbnRFcnIoVShBLm91dHB1dCwwKSksQS5vdXRwdXQ9W10pOjAhPUImJkEub3V0cHV0LnB1c2goQil9LGZsdXNoOmZ1bmN0aW9uKEEpe0Eub3V0cHV0JiZBLm91dHB1dC5sZW5ndGg+MCYmKEUucHJpbnRFcnIoVShBLm91dHB1dCwwKSksQS5vdXRwdXQ9W10pfX19LFNBPXtvcHNfdGFibGU6bnVsbCxtb3VudDpmdW5jdGlvbihBKXtyZXR1cm4gU0EuY3JlYXRlTm9kZShudWxsLCIvIiwxNjg5NSwwKX0sY3JlYXRlTm9kZTpmdW5jdGlvbihBLEIsSSxnKXtpZihkQS5pc0Jsa2RldihJKXx8ZEEuaXNGSUZPKEkpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKTtTQS5vcHNfdGFibGV8fChTQS5vcHNfdGFibGU9e2Rpcjp7bm9kZTp7Z2V0YXR0cjpTQS5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6U0Eubm9kZV9vcHMuc2V0YXR0cixsb29rdXA6U0Eubm9kZV9vcHMubG9va3VwLG1rbm9kOlNBLm5vZGVfb3BzLm1rbm9kLHJlbmFtZTpTQS5ub2RlX29wcy5yZW5hbWUsdW5saW5rOlNBLm5vZGVfb3BzLnVubGluayxybWRpcjpTQS5ub2RlX29wcy5ybWRpcixyZWFkZGlyOlNBLm5vZGVfb3BzLnJlYWRkaXIsc3ltbGluazpTQS5ub2RlX29wcy5zeW1saW5rfSxzdHJlYW06e2xsc2VlazpTQS5zdHJlYW1fb3BzLmxsc2Vla319LGZpbGU6e25vZGU6e2dldGF0dHI6U0Eubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOlNBLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTp7bGxzZWVrOlNBLnN0cmVhbV9vcHMubGxzZWVrLHJlYWQ6U0Euc3RyZWFtX29wcy5yZWFkLHdyaXRlOlNBLnN0cmVhbV9vcHMud3JpdGUsYWxsb2NhdGU6U0Euc3RyZWFtX29wcy5hbGxvY2F0ZSxtbWFwOlNBLnN0cmVhbV9vcHMubW1hcCxtc3luYzpTQS5zdHJlYW1fb3BzLm1zeW5jfX0sbGluazp7bm9kZTp7Z2V0YXR0cjpTQS5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6U0Eubm9kZV9vcHMuc2V0YXR0cixyZWFkbGluazpTQS5ub2RlX29wcy5yZWFkbGlua30sc3RyZWFtOnt9fSxjaHJkZXY6e25vZGU6e2dldGF0dHI6U0Eubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOlNBLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTpkQS5jaHJkZXZfc3RyZWFtX29wc319KTt2YXIgUT1kQS5jcmVhdGVOb2RlKEEsQixJLGcpO3JldHVybiBkQS5pc0RpcihRLm1vZGUpPyhRLm5vZGVfb3BzPVNBLm9wc190YWJsZS5kaXIubm9kZSxRLnN0cmVhbV9vcHM9U0Eub3BzX3RhYmxlLmRpci5zdHJlYW0sUS5jb250ZW50cz17fSk6ZEEuaXNGaWxlKFEubW9kZSk/KFEubm9kZV9vcHM9U0Eub3BzX3RhYmxlLmZpbGUubm9kZSxRLnN0cmVhbV9vcHM9U0Eub3BzX3RhYmxlLmZpbGUuc3RyZWFtLFEudXNlZEJ5dGVzPTAsUS5jb250ZW50cz1udWxsKTpkQS5pc0xpbmsoUS5tb2RlKT8oUS5ub2RlX29wcz1TQS5vcHNfdGFibGUubGluay5ub2RlLFEuc3RyZWFtX29wcz1TQS5vcHNfdGFibGUubGluay5zdHJlYW0pOmRBLmlzQ2hyZGV2KFEubW9kZSkmJihRLm5vZGVfb3BzPVNBLm9wc190YWJsZS5jaHJkZXYubm9kZSxRLnN0cmVhbV9vcHM9U0Eub3BzX3RhYmxlLmNocmRldi5zdHJlYW0pLFEudGltZXN0YW1wPURhdGUubm93KCksQSYmKEEuY29udGVudHNbQl09USksUX0sZ2V0RmlsZURhdGFBc1JlZ3VsYXJBcnJheTpmdW5jdGlvbihBKXtpZihBLmNvbnRlbnRzJiZBLmNvbnRlbnRzLnN1YmFycmF5KXtmb3IodmFyIEI9W10sST0wO0k8QS51c2VkQnl0ZXM7KytJKUIucHVzaChBLmNvbnRlbnRzW0ldKTtyZXR1cm4gQn1yZXR1cm4gQS5jb250ZW50c30sZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXk6ZnVuY3Rpb24oQSl7cmV0dXJuIEEuY29udGVudHM/QS5jb250ZW50cy5zdWJhcnJheT9BLmNvbnRlbnRzLnN1YmFycmF5KDAsQS51c2VkQnl0ZXMpOm5ldyBVaW50OEFycmF5KEEuY29udGVudHMpOm5ldyBVaW50OEFycmF5fSxleHBhbmRGaWxlU3RvcmFnZTpmdW5jdGlvbihBLEIpe2lmKEEuY29udGVudHMmJkEuY29udGVudHMuc3ViYXJyYXkmJkI+QS5jb250ZW50cy5sZW5ndGgmJihBLmNvbnRlbnRzPVNBLmdldEZpbGVEYXRhQXNSZWd1bGFyQXJyYXkoQSksQS51c2VkQnl0ZXM9QS5jb250ZW50cy5sZW5ndGgpLCFBLmNvbnRlbnRzfHxBLmNvbnRlbnRzLnN1YmFycmF5KXt2YXIgST1BLmNvbnRlbnRzP0EuY29udGVudHMubGVuZ3RoOjA7aWYoST49QilyZXR1cm47Qj1NYXRoLm1heChCLEkqKEk8MTA0ODU3Nj8yOjEuMTI1KXwwKSwwIT1JJiYoQj1NYXRoLm1heChCLDI1NikpO3ZhciBnPUEuY29udGVudHM7cmV0dXJuIEEuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkoQiksdm9pZChBLnVzZWRCeXRlcz4wJiZBLmNvbnRlbnRzLnNldChnLnN1YmFycmF5KDAsQS51c2VkQnl0ZXMpLDApKX1mb3IoIUEuY29udGVudHMmJkI+MCYmKEEuY29udGVudHM9W10pO0EuY29udGVudHMubGVuZ3RoPEI7KUEuY29udGVudHMucHVzaCgwKX0scmVzaXplRmlsZVN0b3JhZ2U6ZnVuY3Rpb24oQSxCKXtpZihBLnVzZWRCeXRlcyE9Qil7aWYoMD09QilyZXR1cm4gQS5jb250ZW50cz1udWxsLHZvaWQoQS51c2VkQnl0ZXM9MCk7aWYoIUEuY29udGVudHN8fEEuY29udGVudHMuc3ViYXJyYXkpe3ZhciBJPUEuY29udGVudHM7cmV0dXJuIEEuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKEIpKSxJJiZBLmNvbnRlbnRzLnNldChJLnN1YmFycmF5KDAsTWF0aC5taW4oQixBLnVzZWRCeXRlcykpKSx2b2lkKEEudXNlZEJ5dGVzPUIpfWlmKEEuY29udGVudHN8fChBLmNvbnRlbnRzPVtdKSxBLmNvbnRlbnRzLmxlbmd0aD5CKUEuY29udGVudHMubGVuZ3RoPUI7ZWxzZSBmb3IoO0EuY29udGVudHMubGVuZ3RoPEI7KUEuY29udGVudHMucHVzaCgwKTtBLnVzZWRCeXRlcz1CfX0sbm9kZV9vcHM6e2dldGF0dHI6ZnVuY3Rpb24oQSl7dmFyIEI9e307cmV0dXJuIEIuZGV2PWRBLmlzQ2hyZGV2KEEubW9kZSk/QS5pZDoxLEIuaW5vPUEuaWQsQi5tb2RlPUEubW9kZSxCLm5saW5rPTEsQi51aWQ9MCxCLmdpZD0wLEIucmRldj1BLnJkZXYsZEEuaXNEaXIoQS5tb2RlKT9CLnNpemU9NDA5NjpkQS5pc0ZpbGUoQS5tb2RlKT9CLnNpemU9QS51c2VkQnl0ZXM6ZEEuaXNMaW5rKEEubW9kZSk/Qi5zaXplPUEubGluay5sZW5ndGg6Qi5zaXplPTAsQi5hdGltZT1uZXcgRGF0ZShBLnRpbWVzdGFtcCksQi5tdGltZT1uZXcgRGF0ZShBLnRpbWVzdGFtcCksQi5jdGltZT1uZXcgRGF0ZShBLnRpbWVzdGFtcCksQi5ibGtzaXplPTQwOTYsQi5ibG9ja3M9TWF0aC5jZWlsKEIuc2l6ZS9CLmJsa3NpemUpLEJ9LHNldGF0dHI6ZnVuY3Rpb24oQSxCKXt2b2lkIDAhPT1CLm1vZGUmJihBLm1vZGU9Qi5tb2RlKSx2b2lkIDAhPT1CLnRpbWVzdGFtcCYmKEEudGltZXN0YW1wPUIudGltZXN0YW1wKSx2b2lkIDAhPT1CLnNpemUmJlNBLnJlc2l6ZUZpbGVTdG9yYWdlKEEsQi5zaXplKX0sbG9va3VwOmZ1bmN0aW9uKEEsQil7dGhyb3cgZEEuZ2VuZXJpY0Vycm9yc1toQS5FTk9FTlRdfSxta25vZDpmdW5jdGlvbihBLEIsSSxnKXtyZXR1cm4gU0EuY3JlYXRlTm9kZShBLEIsSSxnKX0scmVuYW1lOmZ1bmN0aW9uKEEsQixJKXtpZihkQS5pc0RpcihBLm1vZGUpKXt2YXIgZzt0cnl7Zz1kQS5sb29rdXBOb2RlKEIsSSl9Y2F0Y2goQSl7fWlmKGcpZm9yKHZhciBRIGluIGcuY29udGVudHMpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5PVEVNUFRZKX1kZWxldGUgQS5wYXJlbnQuY29udGVudHNbQS5uYW1lXSxBLm5hbWU9SSxCLmNvbnRlbnRzW0ldPUEsQS5wYXJlbnQ9Qn0sdW5saW5rOmZ1bmN0aW9uKEEsQil7ZGVsZXRlIEEuY29udGVudHNbQl19LHJtZGlyOmZ1bmN0aW9uKEEsQil7dmFyIEk9ZEEubG9va3VwTm9kZShBLEIpO2Zvcih2YXIgZyBpbiBJLmNvbnRlbnRzKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT1RFTVBUWSk7ZGVsZXRlIEEuY29udGVudHNbQl19LHJlYWRkaXI6ZnVuY3Rpb24oQSl7dmFyIEI9WyIuIiwiLi4iXTtmb3IodmFyIEkgaW4gQS5jb250ZW50cylBLmNvbnRlbnRzLmhhc093blByb3BlcnR5KEkpJiZCLnB1c2goSSk7cmV0dXJuIEJ9LHN5bWxpbms6ZnVuY3Rpb24oQSxCLEkpe3ZhciBnPVNBLmNyZWF0ZU5vZGUoQSxCLDQxNDcxLDApO3JldHVybiBnLmxpbms9SSxnfSxyZWFkbGluazpmdW5jdGlvbihBKXtpZighZEEuaXNMaW5rKEEubW9kZSkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTtyZXR1cm4gQS5saW5rfX0sc3RyZWFtX29wczp7cmVhZDpmdW5jdGlvbihBLEIsSSxnLFEpe3ZhciBFPUEubm9kZS5jb250ZW50cztpZihRPj1BLm5vZGUudXNlZEJ5dGVzKXJldHVybiAwO3ZhciBDPU1hdGgubWluKEEubm9kZS51c2VkQnl0ZXMtUSxnKTtpZih3KEM+PTApLEM+OCYmRS5zdWJhcnJheSlCLnNldChFLnN1YmFycmF5KFEsUStDKSxJKTtlbHNlIGZvcih2YXIgaT0wO2k8QztpKyspQltJK2ldPUVbUStpXTtyZXR1cm4gQ30sd3JpdGU6ZnVuY3Rpb24oQSxCLEksZyxRLEUpe2lmKCFnKXJldHVybiAwO3ZhciBDPUEubm9kZTtpZihDLnRpbWVzdGFtcD1EYXRlLm5vdygpLEIuc3ViYXJyYXkmJighQy5jb250ZW50c3x8Qy5jb250ZW50cy5zdWJhcnJheSkpe2lmKEUpcmV0dXJuIEMuY29udGVudHM9Qi5zdWJhcnJheShJLEkrZyksQy51c2VkQnl0ZXM9ZyxnO2lmKDA9PT1DLnVzZWRCeXRlcyYmMD09PVEpcmV0dXJuIEMuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkoQi5zdWJhcnJheShJLEkrZykpLEMudXNlZEJ5dGVzPWcsZztpZihRK2c8PUMudXNlZEJ5dGVzKXJldHVybiBDLmNvbnRlbnRzLnNldChCLnN1YmFycmF5KEksSStnKSxRKSxnfWlmKFNBLmV4cGFuZEZpbGVTdG9yYWdlKEMsUStnKSxDLmNvbnRlbnRzLnN1YmFycmF5JiZCLnN1YmFycmF5KUMuY29udGVudHMuc2V0KEIuc3ViYXJyYXkoSSxJK2cpLFEpO2Vsc2UgZm9yKHZhciBpPTA7aTxnO2krKylDLmNvbnRlbnRzW1EraV09QltJK2ldO3JldHVybiBDLnVzZWRCeXRlcz1NYXRoLm1heChDLnVzZWRCeXRlcyxRK2cpLGd9LGxsc2VlazpmdW5jdGlvbihBLEIsSSl7dmFyIGc9QjtpZigxPT09ST9nKz1BLnBvc2l0aW9uOjI9PT1JJiZkQS5pc0ZpbGUoQS5ub2RlLm1vZGUpJiYoZys9QS5ub2RlLnVzZWRCeXRlcyksZzwwKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVJTlZBTCk7cmV0dXJuIGd9LGFsbG9jYXRlOmZ1bmN0aW9uKEEsQixJKXtTQS5leHBhbmRGaWxlU3RvcmFnZShBLm5vZGUsQitJKSxBLm5vZGUudXNlZEJ5dGVzPU1hdGgubWF4KEEubm9kZS51c2VkQnl0ZXMsQitJKX0sbW1hcDpmdW5jdGlvbihBLEIsSSxnLFEsRSxDKXtpZighZEEuaXNGaWxlKEEubm9kZS5tb2RlKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FTk9ERVYpO3ZhciBpLG8sdD1BLm5vZGUuY29udGVudHM7aWYoMiZDfHx0LmJ1ZmZlciE9PUImJnQuYnVmZmVyIT09Qi5idWZmZXIpe2lmKChRPjB8fFErZzxBLm5vZGUudXNlZEJ5dGVzKSYmKHQ9dC5zdWJhcnJheT90LnN1YmFycmF5KFEsUStnKTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LFEsUStnKSksbz0hMCwhKGk9SUkoZykpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT01FTSk7Qi5zZXQodCxpKX1lbHNlIG89ITEsaT10LmJ5dGVPZmZzZXQ7cmV0dXJue3B0cjppLGFsbG9jYXRlZDpvfX0sbXN5bmM6ZnVuY3Rpb24oQSxCLEksZyxRKXtpZighZEEuaXNGaWxlKEEubm9kZS5tb2RlKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FTk9ERVYpO3JldHVybiAyJlF8fFNBLnN0cmVhbV9vcHMud3JpdGUoQSxCLDAsZyxJLCExKSwwfX19LGtBPXtkYnM6e30saW5kZXhlZERCOmZ1bmN0aW9uKCl7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBpbmRleGVkREIpcmV0dXJuIGluZGV4ZWREQjt2YXIgQT1udWxsO3JldHVybiJvYmplY3QiPT10eXBlb2Ygd2luZG93JiYoQT13aW5kb3cuaW5kZXhlZERCfHx3aW5kb3cubW96SW5kZXhlZERCfHx3aW5kb3cud2Via2l0SW5kZXhlZERCfHx3aW5kb3cubXNJbmRleGVkREIpLHcoQSwiSURCRlMgdXNlZCwgYnV0IGluZGV4ZWREQiBub3Qgc3VwcG9ydGVkIiksQX0sREJfVkVSU0lPTjoyMSxEQl9TVE9SRV9OQU1FOiJGSUxFX0RBVEEiLG1vdW50OmZ1bmN0aW9uKEEpe3JldHVybiBTQS5tb3VudC5hcHBseShudWxsLGFyZ3VtZW50cyl9LHN5bmNmczpmdW5jdGlvbihBLEIsSSl7a0EuZ2V0TG9jYWxTZXQoQSwoZnVuY3Rpb24oZyxRKXtpZihnKXJldHVybiBJKGcpO2tBLmdldFJlbW90ZVNldChBLChmdW5jdGlvbihBLGcpe2lmKEEpcmV0dXJuIEkoQSk7dmFyIEU9Qj9nOlEsQz1CP1E6ZztrQS5yZWNvbmNpbGUoRSxDLEkpfSkpfSkpfSxnZXREQjpmdW5jdGlvbihBLEIpe3ZhciBJLGc9a0EuZGJzW0FdO2lmKGcpcmV0dXJuIEIobnVsbCxnKTt0cnl7ST1rQS5pbmRleGVkREIoKS5vcGVuKEEsa0EuREJfVkVSU0lPTil9Y2F0Y2goQSl7cmV0dXJuIEIoQSl9aWYoIUkpcmV0dXJuIEIoIlVuYWJsZSB0byBjb25uZWN0IHRvIEluZGV4ZWREQiIpO0kub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKEEpe3ZhciBCLEk9QS50YXJnZXQucmVzdWx0LGc9QS50YXJnZXQudHJhbnNhY3Rpb247KEI9SS5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGtBLkRCX1NUT1JFX05BTUUpP2cub2JqZWN0U3RvcmUoa0EuREJfU1RPUkVfTkFNRSk6SS5jcmVhdGVPYmplY3RTdG9yZShrQS5EQl9TVE9SRV9OQU1FKSkuaW5kZXhOYW1lcy5jb250YWlucygidGltZXN0YW1wIil8fEIuY3JlYXRlSW5kZXgoInRpbWVzdGFtcCIsInRpbWVzdGFtcCIse3VuaXF1ZTohMX0pfSxJLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2c9SS5yZXN1bHQsa0EuZGJzW0FdPWcsQihudWxsLGcpfSxJLm9uZXJyb3I9ZnVuY3Rpb24oQSl7Qih0aGlzLmVycm9yKSxBLnByZXZlbnREZWZhdWx0KCl9fSxnZXRMb2NhbFNldDpmdW5jdGlvbihBLEIpe3ZhciBJPXt9O2Z1bmN0aW9uIGcoQSl7cmV0dXJuIi4iIT09QSYmIi4uIiE9PUF9ZnVuY3Rpb24gUShBKXtyZXR1cm4gZnVuY3Rpb24oQil7cmV0dXJuIFVBLmpvaW4yKEEsQil9fWZvcih2YXIgRT1kQS5yZWFkZGlyKEEubW91bnRwb2ludCkuZmlsdGVyKGcpLm1hcChRKEEubW91bnRwb2ludCkpO0UubGVuZ3RoOyl7dmFyIEMsaT1FLnBvcCgpO3RyeXtDPWRBLnN0YXQoaSl9Y2F0Y2goQSl7cmV0dXJuIEIoQSl9ZEEuaXNEaXIoQy5tb2RlKSYmRS5wdXNoLmFwcGx5KEUsZEEucmVhZGRpcihpKS5maWx0ZXIoZykubWFwKFEoaSkpKSxJW2ldPXt0aW1lc3RhbXA6Qy5tdGltZX19cmV0dXJuIEIobnVsbCx7dHlwZToibG9jYWwiLGVudHJpZXM6SX0pfSxnZXRSZW1vdGVTZXQ6ZnVuY3Rpb24oQSxCKXt2YXIgST17fTtrQS5nZXREQihBLm1vdW50cG9pbnQsKGZ1bmN0aW9uKEEsZyl7aWYoQSlyZXR1cm4gQihBKTt0cnl7dmFyIFE9Zy50cmFuc2FjdGlvbihba0EuREJfU1RPUkVfTkFNRV0sInJlYWRvbmx5Iik7US5vbmVycm9yPWZ1bmN0aW9uKEEpe0IodGhpcy5lcnJvciksQS5wcmV2ZW50RGVmYXVsdCgpfSxRLm9iamVjdFN0b3JlKGtBLkRCX1NUT1JFX05BTUUpLmluZGV4KCJ0aW1lc3RhbXAiKS5vcGVuS2V5Q3Vyc29yKCkub25zdWNjZXNzPWZ1bmN0aW9uKEEpe3ZhciBRPUEudGFyZ2V0LnJlc3VsdDtpZighUSlyZXR1cm4gQihudWxsLHt0eXBlOiJyZW1vdGUiLGRiOmcsZW50cmllczpJfSk7SVtRLnByaW1hcnlLZXldPXt0aW1lc3RhbXA6US5rZXl9LFEuY29udGludWUoKX19Y2F0Y2goQSl7cmV0dXJuIEIoQSl9fSkpfSxsb2FkTG9jYWxFbnRyeTpmdW5jdGlvbihBLEIpe3ZhciBJLGc7dHJ5e2c9ZEEubG9va3VwUGF0aChBKS5ub2RlLEk9ZEEuc3RhdChBKX1jYXRjaChBKXtyZXR1cm4gQihBKX1yZXR1cm4gZEEuaXNEaXIoSS5tb2RlKT9CKG51bGwse3RpbWVzdGFtcDpJLm10aW1lLG1vZGU6SS5tb2RlfSk6ZEEuaXNGaWxlKEkubW9kZSk/KGcuY29udGVudHM9U0EuZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkoZyksQihudWxsLHt0aW1lc3RhbXA6SS5tdGltZSxtb2RlOkkubW9kZSxjb250ZW50czpnLmNvbnRlbnRzfSkpOkIobmV3IEVycm9yKCJub2RlIHR5cGUgbm90IHN1cHBvcnRlZCIpKX0sc3RvcmVMb2NhbEVudHJ5OmZ1bmN0aW9uKEEsQixJKXt0cnl7aWYoZEEuaXNEaXIoQi5tb2RlKSlkQS5ta2RpcihBLEIubW9kZSk7ZWxzZXtpZighZEEuaXNGaWxlKEIubW9kZSkpcmV0dXJuIEkobmV3IEVycm9yKCJub2RlIHR5cGUgbm90IHN1cHBvcnRlZCIpKTtkQS53cml0ZUZpbGUoQSxCLmNvbnRlbnRzLHtjYW5Pd246ITB9KX1kQS5jaG1vZChBLEIubW9kZSksZEEudXRpbWUoQSxCLnRpbWVzdGFtcCxCLnRpbWVzdGFtcCl9Y2F0Y2goQSl7cmV0dXJuIEkoQSl9SShudWxsKX0scmVtb3ZlTG9jYWxFbnRyeTpmdW5jdGlvbihBLEIpe3RyeXtkQS5sb29rdXBQYXRoKEEpO3ZhciBJPWRBLnN0YXQoQSk7ZEEuaXNEaXIoSS5tb2RlKT9kQS5ybWRpcihBKTpkQS5pc0ZpbGUoSS5tb2RlKSYmZEEudW5saW5rKEEpfWNhdGNoKEEpe3JldHVybiBCKEEpfUIobnVsbCl9LGxvYWRSZW1vdGVFbnRyeTpmdW5jdGlvbihBLEIsSSl7dmFyIGc9QS5nZXQoQik7Zy5vbnN1Y2Nlc3M9ZnVuY3Rpb24oQSl7SShudWxsLEEudGFyZ2V0LnJlc3VsdCl9LGcub25lcnJvcj1mdW5jdGlvbihBKXtJKHRoaXMuZXJyb3IpLEEucHJldmVudERlZmF1bHQoKX19LHN0b3JlUmVtb3RlRW50cnk6ZnVuY3Rpb24oQSxCLEksZyl7dmFyIFE9QS5wdXQoSSxCKTtRLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2cobnVsbCl9LFEub25lcnJvcj1mdW5jdGlvbihBKXtnKHRoaXMuZXJyb3IpLEEucHJldmVudERlZmF1bHQoKX19LHJlbW92ZVJlbW90ZUVudHJ5OmZ1bmN0aW9uKEEsQixJKXt2YXIgZz1BLmRlbGV0ZShCKTtnLm9uc3VjY2Vzcz1mdW5jdGlvbigpe0kobnVsbCl9LGcub25lcnJvcj1mdW5jdGlvbihBKXtJKHRoaXMuZXJyb3IpLEEucHJldmVudERlZmF1bHQoKX19LHJlY29uY2lsZTpmdW5jdGlvbihBLEIsSSl7dmFyIGc9MCxRPVtdO09iamVjdC5rZXlzKEEuZW50cmllcykuZm9yRWFjaCgoZnVuY3Rpb24oSSl7dmFyIEU9QS5lbnRyaWVzW0ldLEM9Qi5lbnRyaWVzW0ldOyghQ3x8RS50aW1lc3RhbXA+Qy50aW1lc3RhbXApJiYoUS5wdXNoKEkpLGcrKyl9KSk7dmFyIEU9W107aWYoT2JqZWN0LmtleXMoQi5lbnRyaWVzKS5mb3JFYWNoKChmdW5jdGlvbihJKXtCLmVudHJpZXNbSV0sQS5lbnRyaWVzW0ldfHwoRS5wdXNoKEkpLGcrKyl9KSksIWcpcmV0dXJuIEkobnVsbCk7dmFyIEM9MCxpPSgicmVtb3RlIj09PUEudHlwZT9BLmRiOkIuZGIpLnRyYW5zYWN0aW9uKFtrQS5EQl9TVE9SRV9OQU1FXSwicmVhZHdyaXRlIiksbz1pLm9iamVjdFN0b3JlKGtBLkRCX1NUT1JFX05BTUUpO2Z1bmN0aW9uIHQoQSl7cmV0dXJuIEE/dC5lcnJvcmVkP3ZvaWQgMDoodC5lcnJvcmVkPSEwLEkoQSkpOisrQz49Zz9JKG51bGwpOnZvaWQgMH1pLm9uZXJyb3I9ZnVuY3Rpb24oQSl7dCh0aGlzLmVycm9yKSxBLnByZXZlbnREZWZhdWx0KCl9LFEuc29ydCgpLmZvckVhY2goKGZ1bmN0aW9uKEEpeyJsb2NhbCI9PT1CLnR5cGU/a0EubG9hZFJlbW90ZUVudHJ5KG8sQSwoZnVuY3Rpb24oQixJKXtpZihCKXJldHVybiB0KEIpO2tBLnN0b3JlTG9jYWxFbnRyeShBLEksdCl9KSk6a0EubG9hZExvY2FsRW50cnkoQSwoZnVuY3Rpb24oQixJKXtpZihCKXJldHVybiB0KEIpO2tBLnN0b3JlUmVtb3RlRW50cnkobyxBLEksdCl9KSl9KSksRS5zb3J0KCkucmV2ZXJzZSgpLmZvckVhY2goKGZ1bmN0aW9uKEEpeyJsb2NhbCI9PT1CLnR5cGU/a0EucmVtb3ZlTG9jYWxFbnRyeShBLHQpOmtBLnJlbW92ZVJlbW90ZUVudHJ5KG8sQSx0KX0pKX19LGZBPXtpc1dpbmRvd3M6ITEsc3RhdGljSW5pdDpmdW5jdGlvbigpe2ZBLmlzV2luZG93cz0hIXByb2Nlc3MucGxhdGZvcm0ubWF0Y2goL153aW4vKTt2YXIgQT1wcm9jZXNzLmJpbmRpbmcoImNvbnN0YW50cyIpO0EuZnMmJihBPUEuZnMpLGZBLmZsYWdzRm9yTm9kZU1hcD17MTAyNDpBLk9fQVBQRU5ELDY0OkEuT19DUkVBVCwxMjg6QS5PX0VYQ0wsMDpBLk9fUkRPTkxZLDI6QS5PX1JEV1IsNDA5NjpBLk9fU1lOQyw1MTI6QS5PX1RSVU5DLDE6QS5PX1dST05MWX19LGJ1ZmZlckZyb206ZnVuY3Rpb24oQSl7cmV0dXJuIEJ1ZmZlci5hbGxvYz9CdWZmZXIuZnJvbShBKTpuZXcgQnVmZmVyKEEpfSxtb3VudDpmdW5jdGlvbihBKXtyZXR1cm4gdyhyKSxmQS5jcmVhdGVOb2RlKG51bGwsIi8iLGZBLmdldE1vZGUoQS5vcHRzLnJvb3QpLDApfSxjcmVhdGVOb2RlOmZ1bmN0aW9uKEEsQixJLGcpe2lmKCFkQS5pc0RpcihJKSYmIWRBLmlzRmlsZShJKSYmIWRBLmlzTGluayhJKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FSU5WQUwpO3ZhciBRPWRBLmNyZWF0ZU5vZGUoQSxCLEkpO3JldHVybiBRLm5vZGVfb3BzPWZBLm5vZGVfb3BzLFEuc3RyZWFtX29wcz1mQS5zdHJlYW1fb3BzLFF9LGdldE1vZGU6ZnVuY3Rpb24oQSl7dmFyIEI7dHJ5e0I9ZnMubHN0YXRTeW5jKEEpLGZBLmlzV2luZG93cyYmKEIubW9kZT1CLm1vZGV8KDI5MiZCLm1vZGUpPj4yKX1jYXRjaChBKXtpZighQS5jb2RlKXRocm93IEE7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEFbQS5jb2RlXSl9cmV0dXJuIEIubW9kZX0scmVhbFBhdGg6ZnVuY3Rpb24oQSl7Zm9yKHZhciBCPVtdO0EucGFyZW50IT09QTspQi5wdXNoKEEubmFtZSksQT1BLnBhcmVudDtyZXR1cm4gQi5wdXNoKEEubW91bnQub3B0cy5yb290KSxCLnJldmVyc2UoKSxVQS5qb2luLmFwcGx5KG51bGwsQil9LGZsYWdzRm9yTm9kZTpmdW5jdGlvbihBKXtBJj0tMjA5NzE1MyxBJj0tMjA0OSxBJj0tMzI3NjksQSY9LTUyNDI4OTt2YXIgQj0wO2Zvcih2YXIgSSBpbiBmQS5mbGFnc0Zvck5vZGVNYXApQSZJJiYoQnw9ZkEuZmxhZ3NGb3JOb2RlTWFwW0ldLEFePUkpO2lmKEEpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTtyZXR1cm4gQn0sbm9kZV9vcHM6e2dldGF0dHI6ZnVuY3Rpb24oQSl7dmFyIEIsST1mQS5yZWFsUGF0aChBKTt0cnl7Qj1mcy5sc3RhdFN5bmMoSSl9Y2F0Y2goQSl7aWYoIUEuY29kZSl0aHJvdyBBO3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBW0EuY29kZV0pfXJldHVybiBmQS5pc1dpbmRvd3MmJiFCLmJsa3NpemUmJihCLmJsa3NpemU9NDA5NiksZkEuaXNXaW5kb3dzJiYhQi5ibG9ja3MmJihCLmJsb2Nrcz0oQi5zaXplK0IuYmxrc2l6ZS0xKS9CLmJsa3NpemV8MCkse2RldjpCLmRldixpbm86Qi5pbm8sbW9kZTpCLm1vZGUsbmxpbms6Qi5ubGluayx1aWQ6Qi51aWQsZ2lkOkIuZ2lkLHJkZXY6Qi5yZGV2LHNpemU6Qi5zaXplLGF0aW1lOkIuYXRpbWUsbXRpbWU6Qi5tdGltZSxjdGltZTpCLmN0aW1lLGJsa3NpemU6Qi5ibGtzaXplLGJsb2NrczpCLmJsb2Nrc319LHNldGF0dHI6ZnVuY3Rpb24oQSxCKXt2YXIgST1mQS5yZWFsUGF0aChBKTt0cnl7aWYodm9pZCAwIT09Qi5tb2RlJiYoZnMuY2htb2RTeW5jKEksQi5tb2RlKSxBLm1vZGU9Qi5tb2RlKSx2b2lkIDAhPT1CLnRpbWVzdGFtcCl7dmFyIGc9bmV3IERhdGUoQi50aW1lc3RhbXApO2ZzLnV0aW1lc1N5bmMoSSxnLGcpfXZvaWQgMCE9PUIuc2l6ZSYmZnMudHJ1bmNhdGVTeW5jKEksQi5zaXplKX1jYXRjaChBKXtpZighQS5jb2RlKXRocm93IEE7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEFbQS5jb2RlXSl9fSxsb29rdXA6ZnVuY3Rpb24oQSxCKXt2YXIgST1VQS5qb2luMihmQS5yZWFsUGF0aChBKSxCKSxnPWZBLmdldE1vZGUoSSk7cmV0dXJuIGZBLmNyZWF0ZU5vZGUoQSxCLGcpfSxta25vZDpmdW5jdGlvbihBLEIsSSxnKXt2YXIgUT1mQS5jcmVhdGVOb2RlKEEsQixJLGcpLEU9ZkEucmVhbFBhdGgoUSk7dHJ5e2RBLmlzRGlyKFEubW9kZSk/ZnMubWtkaXJTeW5jKEUsUS5tb2RlKTpmcy53cml0ZUZpbGVTeW5jKEUsIiIse21vZGU6US5tb2RlfSl9Y2F0Y2goQSl7aWYoIUEuY29kZSl0aHJvdyBBO3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBW0EuY29kZV0pfXJldHVybiBRfSxyZW5hbWU6ZnVuY3Rpb24oQSxCLEkpe3ZhciBnPWZBLnJlYWxQYXRoKEEpLFE9VUEuam9pbjIoZkEucmVhbFBhdGgoQiksSSk7dHJ5e2ZzLnJlbmFtZVN5bmMoZyxRKX1jYXRjaChBKXtpZighQS5jb2RlKXRocm93IEE7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEFbQS5jb2RlXSl9fSx1bmxpbms6ZnVuY3Rpb24oQSxCKXt2YXIgST1VQS5qb2luMihmQS5yZWFsUGF0aChBKSxCKTt0cnl7ZnMudW5saW5rU3luYyhJKX1jYXRjaChBKXtpZighQS5jb2RlKXRocm93IEE7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEFbQS5jb2RlXSl9fSxybWRpcjpmdW5jdGlvbihBLEIpe3ZhciBJPVVBLmpvaW4yKGZBLnJlYWxQYXRoKEEpLEIpO3RyeXtmcy5ybWRpclN5bmMoSSl9Y2F0Y2goQSl7aWYoIUEuY29kZSl0aHJvdyBBO3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBW0EuY29kZV0pfX0scmVhZGRpcjpmdW5jdGlvbihBKXt2YXIgQj1mQS5yZWFsUGF0aChBKTt0cnl7cmV0dXJuIGZzLnJlYWRkaXJTeW5jKEIpfWNhdGNoKEEpe2lmKCFBLmNvZGUpdGhyb3cgQTt0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQVtBLmNvZGVdKX19LHN5bWxpbms6ZnVuY3Rpb24oQSxCLEkpe3ZhciBnPVVBLmpvaW4yKGZBLnJlYWxQYXRoKEEpLEIpO3RyeXtmcy5zeW1saW5rU3luYyhJLGcpfWNhdGNoKEEpe2lmKCFBLmNvZGUpdGhyb3cgQTt0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQVtBLmNvZGVdKX19LHJlYWRsaW5rOmZ1bmN0aW9uKEEpe3ZhciBCPWZBLnJlYWxQYXRoKEEpO3RyeXtyZXR1cm4gQj1mcy5yZWFkbGlua1N5bmMoQiksQj1OT0RFSlNfUEFUSC5yZWxhdGl2ZShOT0RFSlNfUEFUSC5yZXNvbHZlKEEubW91bnQub3B0cy5yb290KSxCKX1jYXRjaChBKXtpZighQS5jb2RlKXRocm93IEE7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEFbQS5jb2RlXSl9fX0sc3RyZWFtX29wczp7b3BlbjpmdW5jdGlvbihBKXt2YXIgQj1mQS5yZWFsUGF0aChBLm5vZGUpO3RyeXtkQS5pc0ZpbGUoQS5ub2RlLm1vZGUpJiYoQS5uZmQ9ZnMub3BlblN5bmMoQixmQS5mbGFnc0Zvck5vZGUoQS5mbGFncykpKX1jYXRjaChBKXtpZighQS5jb2RlKXRocm93IEE7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEFbQS5jb2RlXSl9fSxjbG9zZTpmdW5jdGlvbihBKXt0cnl7ZEEuaXNGaWxlKEEubm9kZS5tb2RlKSYmQS5uZmQmJmZzLmNsb3NlU3luYyhBLm5mZCl9Y2F0Y2goQSl7aWYoIUEuY29kZSl0aHJvdyBBO3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBW0EuY29kZV0pfX0scmVhZDpmdW5jdGlvbihBLEIsSSxnLFEpe2lmKDA9PT1nKXJldHVybiAwO3RyeXtyZXR1cm4gZnMucmVhZFN5bmMoQS5uZmQsZkEuYnVmZmVyRnJvbShCLmJ1ZmZlciksSSxnLFEpfWNhdGNoKEEpe3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBW0EuY29kZV0pfX0sd3JpdGU6ZnVuY3Rpb24oQSxCLEksZyxRKXt0cnl7cmV0dXJuIGZzLndyaXRlU3luYyhBLm5mZCxmQS5idWZmZXJGcm9tKEIuYnVmZmVyKSxJLGcsUSl9Y2F0Y2goQSl7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEFbQS5jb2RlXSl9fSxsbHNlZWs6ZnVuY3Rpb24oQSxCLEkpe3ZhciBnPUI7aWYoMT09PUkpZys9QS5wb3NpdGlvbjtlbHNlIGlmKDI9PT1JJiZkQS5pc0ZpbGUoQS5ub2RlLm1vZGUpKXRyeXtnKz1mcy5mc3RhdFN5bmMoQS5uZmQpLnNpemV9Y2F0Y2goQSl7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEFbQS5jb2RlXSl9aWYoZzwwKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVJTlZBTCk7cmV0dXJuIGd9fX0sTkE9e0RJUl9NT0RFOjE2ODk1LEZJTEVfTU9ERTozMzI3OSxyZWFkZXI6bnVsbCxtb3VudDpmdW5jdGlvbihBKXt3KGUpLE5BLnJlYWRlcnx8KE5BLnJlYWRlcj1uZXcgRmlsZVJlYWRlclN5bmMpO3ZhciBCPU5BLmNyZWF0ZU5vZGUobnVsbCwiLyIsTkEuRElSX01PREUsMCksST17fTtmdW5jdGlvbiBnKEEpe2Zvcih2YXIgZz1BLnNwbGl0KCIvIiksUT1CLEU9MDtFPGcubGVuZ3RoLTE7RSsrKXt2YXIgQz1nLnNsaWNlKDAsRSsxKS5qb2luKCIvIik7SVtDXXx8KElbQ109TkEuY3JlYXRlTm9kZShRLGdbRV0sTkEuRElSX01PREUsMCkpLFE9SVtDXX1yZXR1cm4gUX1mdW5jdGlvbiBRKEEpe3ZhciBCPUEuc3BsaXQoIi8iKTtyZXR1cm4gQltCLmxlbmd0aC0xXX1yZXR1cm4gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChBLm9wdHMuZmlsZXN8fFtdLChmdW5jdGlvbihBKXtOQS5jcmVhdGVOb2RlKGcoQS5uYW1lKSxRKEEubmFtZSksTkEuRklMRV9NT0RFLDAsQSxBLmxhc3RNb2RpZmllZERhdGUpfSkpLChBLm9wdHMuYmxvYnN8fFtdKS5mb3JFYWNoKChmdW5jdGlvbihBKXtOQS5jcmVhdGVOb2RlKGcoQS5uYW1lKSxRKEEubmFtZSksTkEuRklMRV9NT0RFLDAsQS5kYXRhKX0pKSwoQS5vcHRzLnBhY2thZ2VzfHxbXSkuZm9yRWFjaCgoZnVuY3Rpb24oQSl7QS5tZXRhZGF0YS5maWxlcy5mb3JFYWNoKChmdW5jdGlvbihCKXt2YXIgST1CLmZpbGVuYW1lLnN1YnN0cigxKTtOQS5jcmVhdGVOb2RlKGcoSSksUShJKSxOQS5GSUxFX01PREUsMCxBLmJsb2Iuc2xpY2UoQi5zdGFydCxCLmVuZCkpfSkpfSkpLEJ9LGNyZWF0ZU5vZGU6ZnVuY3Rpb24oQSxCLEksZyxRLEUpe3ZhciBDPWRBLmNyZWF0ZU5vZGUoQSxCLEkpO3JldHVybiBDLm1vZGU9SSxDLm5vZGVfb3BzPU5BLm5vZGVfb3BzLEMuc3RyZWFtX29wcz1OQS5zdHJlYW1fb3BzLEMudGltZXN0YW1wPShFfHxuZXcgRGF0ZSkuZ2V0VGltZSgpLHcoTkEuRklMRV9NT0RFIT09TkEuRElSX01PREUpLEk9PT1OQS5GSUxFX01PREU/KEMuc2l6ZT1RLnNpemUsQy5jb250ZW50cz1RKTooQy5zaXplPTQwOTYsQy5jb250ZW50cz17fSksQSYmKEEuY29udGVudHNbQl09QyksQ30sbm9kZV9vcHM6e2dldGF0dHI6ZnVuY3Rpb24oQSl7cmV0dXJue2RldjoxLGlubzp2b2lkIDAsbW9kZTpBLm1vZGUsbmxpbms6MSx1aWQ6MCxnaWQ6MCxyZGV2OnZvaWQgMCxzaXplOkEuc2l6ZSxhdGltZTpuZXcgRGF0ZShBLnRpbWVzdGFtcCksbXRpbWU6bmV3IERhdGUoQS50aW1lc3RhbXApLGN0aW1lOm5ldyBEYXRlKEEudGltZXN0YW1wKSxibGtzaXplOjQwOTYsYmxvY2tzOk1hdGguY2VpbChBLnNpemUvNDA5Nil9fSxzZXRhdHRyOmZ1bmN0aW9uKEEsQil7dm9pZCAwIT09Qi5tb2RlJiYoQS5tb2RlPUIubW9kZSksdm9pZCAwIT09Qi50aW1lc3RhbXAmJihBLnRpbWVzdGFtcD1CLnRpbWVzdGFtcCl9LGxvb2t1cDpmdW5jdGlvbihBLEIpe3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT0VOVCl9LG1rbm9kOmZ1bmN0aW9uKEEsQixJLGcpe3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKX0scmVuYW1lOmZ1bmN0aW9uKEEsQixJKXt0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FUEVSTSl9LHVubGluazpmdW5jdGlvbihBLEIpe3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKX0scm1kaXI6ZnVuY3Rpb24oQSxCKXt0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FUEVSTSl9LHJlYWRkaXI6ZnVuY3Rpb24oQSl7dmFyIEI9WyIuIiwiLi4iXTtmb3IodmFyIEkgaW4gQS5jb250ZW50cylBLmNvbnRlbnRzLmhhc093blByb3BlcnR5KEkpJiZCLnB1c2goSSk7cmV0dXJuIEJ9LHN5bWxpbms6ZnVuY3Rpb24oQSxCLEkpe3Rocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKX0scmVhZGxpbms6ZnVuY3Rpb24oQSl7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRVBFUk0pfX0sc3RyZWFtX29wczp7cmVhZDpmdW5jdGlvbihBLEIsSSxnLFEpe2lmKFE+PUEubm9kZS5zaXplKXJldHVybiAwO3ZhciBFPUEubm9kZS5jb250ZW50cy5zbGljZShRLFErZyksQz1OQS5yZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoRSk7cmV0dXJuIEIuc2V0KG5ldyBVaW50OEFycmF5KEMpLEkpLEUuc2l6ZX0sd3JpdGU6ZnVuY3Rpb24oQSxCLEksZyxRKXt0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FSU8pfSxsbHNlZWs6ZnVuY3Rpb24oQSxCLEkpe3ZhciBnPUI7aWYoMT09PUk/Zys9QS5wb3NpdGlvbjoyPT09SSYmZEEuaXNGaWxlKEEubm9kZS5tb2RlKSYmKGcrPUEubm9kZS5zaXplKSxnPDApdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTtyZXR1cm4gZ319fTtLKz0xNixLKz0xNjt2YXIgZEE9e3Jvb3Q6bnVsbCxtb3VudHM6W10sZGV2aWNlczp7fSxzdHJlYW1zOltdLG5leHRJbm9kZToxLG5hbWVUYWJsZTpudWxsLGN1cnJlbnRQYXRoOiIvIixpbml0aWFsaXplZDohMSxpZ25vcmVQZXJtaXNzaW9uczohMCx0cmFja2luZ0RlbGVnYXRlOnt9LHRyYWNraW5nOntvcGVuRmxhZ3M6e1JFQUQ6MSxXUklURToyfX0sRXJybm9FcnJvcjpudWxsLGdlbmVyaWNFcnJvcnM6e30sZmlsZXN5c3RlbXM6bnVsbCxzeW5jRlNSZXF1ZXN0czowLGhhbmRsZUZTRXJyb3I6ZnVuY3Rpb24oQSl7aWYoIShBIGluc3RhbmNlb2YgZEEuRXJybm9FcnJvcikpdGhyb3cgQSsiIDogIitkKCk7cmV0dXJuIHlBKEEuZXJybm8pfSxsb29rdXBQYXRoOmZ1bmN0aW9uKEEsQil7aWYoQj1CfHx7fSwhKEE9VUEucmVzb2x2ZShkQS5jd2QoKSxBKSkpcmV0dXJue3BhdGg6IiIsbm9kZTpudWxsfTt2YXIgST17Zm9sbG93X21vdW50OiEwLHJlY3Vyc2VfY291bnQ6MH07Zm9yKHZhciBnIGluIEkpdm9pZCAwPT09QltnXSYmKEJbZ109SVtnXSk7aWYoQi5yZWN1cnNlX2NvdW50PjgpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUxPT1ApO2Zvcih2YXIgUT1VQS5ub3JtYWxpemVBcnJheShBLnNwbGl0KCIvIikuZmlsdGVyKChmdW5jdGlvbihBKXtyZXR1cm4hIUF9KSksITEpLEU9ZEEucm9vdCxDPSIvIixpPTA7aTxRLmxlbmd0aDtpKyspe3ZhciBvPWk9PT1RLmxlbmd0aC0xO2lmKG8mJkIucGFyZW50KWJyZWFrO2lmKEU9ZEEubG9va3VwTm9kZShFLFFbaV0pLEM9VUEuam9pbjIoQyxRW2ldKSxkQS5pc01vdW50cG9pbnQoRSkmJighb3x8byYmQi5mb2xsb3dfbW91bnQpJiYoRT1FLm1vdW50ZWQucm9vdCksIW98fEIuZm9sbG93KWZvcih2YXIgdD0wO2RBLmlzTGluayhFLm1vZGUpOyl7dmFyIGU9ZEEucmVhZGxpbmsoQyk7aWYoQz1VQS5yZXNvbHZlKFVBLmRpcm5hbWUoQyksZSksRT1kQS5sb29rdXBQYXRoKEMse3JlY3Vyc2VfY291bnQ6Qi5yZWN1cnNlX2NvdW50fSkubm9kZSx0Kys+NDApdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUxPT1ApfX1yZXR1cm57cGF0aDpDLG5vZGU6RX19LGdldFBhdGg6ZnVuY3Rpb24oQSl7Zm9yKHZhciBCOzspe2lmKGRBLmlzUm9vdChBKSl7dmFyIEk9QS5tb3VudC5tb3VudHBvaW50O3JldHVybiBCPyIvIiE9PUlbSS5sZW5ndGgtMV0/SSsiLyIrQjpJK0I6SX1CPUI/QS5uYW1lKyIvIitCOkEubmFtZSxBPUEucGFyZW50fX0saGFzaE5hbWU6ZnVuY3Rpb24oQSxCKXtmb3IodmFyIEk9MCxnPTA7ZzxCLmxlbmd0aDtnKyspST0oSTw8NSktSStCLmNoYXJDb2RlQXQoZyl8MDtyZXR1cm4oQStJPj4+MCklZEEubmFtZVRhYmxlLmxlbmd0aH0saGFzaEFkZE5vZGU6ZnVuY3Rpb24oQSl7dmFyIEI9ZEEuaGFzaE5hbWUoQS5wYXJlbnQuaWQsQS5uYW1lKTtBLm5hbWVfbmV4dD1kQS5uYW1lVGFibGVbQl0sZEEubmFtZVRhYmxlW0JdPUF9LGhhc2hSZW1vdmVOb2RlOmZ1bmN0aW9uKEEpe3ZhciBCPWRBLmhhc2hOYW1lKEEucGFyZW50LmlkLEEubmFtZSk7aWYoZEEubmFtZVRhYmxlW0JdPT09QSlkQS5uYW1lVGFibGVbQl09QS5uYW1lX25leHQ7ZWxzZSBmb3IodmFyIEk9ZEEubmFtZVRhYmxlW0JdO0k7KXtpZihJLm5hbWVfbmV4dD09PUEpe0kubmFtZV9uZXh0PUEubmFtZV9uZXh0O2JyZWFrfUk9SS5uYW1lX25leHR9fSxsb29rdXBOb2RlOmZ1bmN0aW9uKEEsQil7dmFyIEk9ZEEubWF5TG9va3VwKEEpO2lmKEkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoSSxBKTtmb3IodmFyIGc9ZEEuaGFzaE5hbWUoQS5pZCxCKSxRPWRBLm5hbWVUYWJsZVtnXTtRO1E9US5uYW1lX25leHQpe3ZhciBFPVEubmFtZTtpZihRLnBhcmVudC5pZD09PUEuaWQmJkU9PT1CKXJldHVybiBRfXJldHVybiBkQS5sb29rdXAoQSxCKX0sY3JlYXRlTm9kZTpmdW5jdGlvbihBLEIsSSxnKXtpZighZEEuRlNOb2RlKXtkQS5GU05vZGU9ZnVuY3Rpb24oQSxCLEksZyl7QXx8KEE9dGhpcyksdGhpcy5wYXJlbnQ9QSx0aGlzLm1vdW50PUEubW91bnQsdGhpcy5tb3VudGVkPW51bGwsdGhpcy5pZD1kQS5uZXh0SW5vZGUrKyx0aGlzLm5hbWU9Qix0aGlzLm1vZGU9SSx0aGlzLm5vZGVfb3BzPXt9LHRoaXMuc3RyZWFtX29wcz17fSx0aGlzLnJkZXY9Z30sZEEuRlNOb2RlLnByb3RvdHlwZT17fTt2YXIgUT0zNjUsRT0xNDY7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZEEuRlNOb2RlLnByb3RvdHlwZSx7cmVhZDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubW9kZSZRKT09PVF9LHNldDpmdW5jdGlvbihBKXtBP3RoaXMubW9kZXw9UTp0aGlzLm1vZGUmPS0zNjZ9fSx3cml0ZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubW9kZSZFKT09PUV9LHNldDpmdW5jdGlvbihBKXtBP3RoaXMubW9kZXw9RTp0aGlzLm1vZGUmPS0xNDd9fSxpc0ZvbGRlcjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGRBLmlzRGlyKHRoaXMubW9kZSl9fSxpc0RldmljZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGRBLmlzQ2hyZGV2KHRoaXMubW9kZSl9fX0pfXZhciBDPW5ldyBkQS5GU05vZGUoQSxCLEksZyk7cmV0dXJuIGRBLmhhc2hBZGROb2RlKEMpLEN9LGRlc3Ryb3lOb2RlOmZ1bmN0aW9uKEEpe2RBLmhhc2hSZW1vdmVOb2RlKEEpfSxpc1Jvb3Q6ZnVuY3Rpb24oQSl7cmV0dXJuIEE9PT1BLnBhcmVudH0saXNNb3VudHBvaW50OmZ1bmN0aW9uKEEpe3JldHVybiEhQS5tb3VudGVkfSxpc0ZpbGU6ZnVuY3Rpb24oQSl7cmV0dXJuIDMyNzY4PT0oNjE0NDAmQSl9LGlzRGlyOmZ1bmN0aW9uKEEpe3JldHVybiAxNjM4ND09KDYxNDQwJkEpfSxpc0xpbms6ZnVuY3Rpb24oQSl7cmV0dXJuIDQwOTYwPT0oNjE0NDAmQSl9LGlzQ2hyZGV2OmZ1bmN0aW9uKEEpe3JldHVybiA4MTkyPT0oNjE0NDAmQSl9LGlzQmxrZGV2OmZ1bmN0aW9uKEEpe3JldHVybiAyNDU3Nj09KDYxNDQwJkEpfSxpc0ZJRk86ZnVuY3Rpb24oQSl7cmV0dXJuIDQwOTY9PSg2MTQ0MCZBKX0saXNTb2NrZXQ6ZnVuY3Rpb24oQSl7cmV0dXJuIDQ5MTUyPT0oNDkxNTImQSl9LGZsYWdNb2Rlczp7cjowLHJzOjEwNTI2NzIsInIrIjoyLHc6NTc3LHd4OjcwNSx4dzo3MDUsIncrIjo1NzgsInd4KyI6NzA2LCJ4dysiOjcwNixhOjEwODksYXg6MTIxNyx4YToxMjE3LCJhKyI6MTA5MCwiYXgrIjoxMjE4LCJ4YSsiOjEyMTh9LG1vZGVTdHJpbmdUb0ZsYWdzOmZ1bmN0aW9uKEEpe3ZhciBCPWRBLmZsYWdNb2Rlc1tBXTtpZih2b2lkIDA9PT1CKXRocm93IG5ldyBFcnJvcigiVW5rbm93biBmaWxlIG9wZW4gbW9kZTogIitBKTtyZXR1cm4gQn0sZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmc6ZnVuY3Rpb24oQSl7dmFyIEI9WyJyIiwidyIsInJ3Il1bMyZBXTtyZXR1cm4gNTEyJkEmJihCKz0idyIpLEJ9LG5vZGVQZXJtaXNzaW9uczpmdW5jdGlvbihBLEIpe3JldHVybiBkQS5pZ25vcmVQZXJtaXNzaW9uc3x8KC0xPT09Qi5pbmRleE9mKCJyIil8fDI5MiZBLm1vZGUpJiYoLTE9PT1CLmluZGV4T2YoInciKXx8MTQ2JkEubW9kZSkmJigtMT09PUIuaW5kZXhPZigieCIpfHw3MyZBLm1vZGUpPzA6aEEuRUFDQ0VTfSxtYXlMb29rdXA6ZnVuY3Rpb24oQSl7dmFyIEI9ZEEubm9kZVBlcm1pc3Npb25zKEEsIngiKTtyZXR1cm4gQnx8KEEubm9kZV9vcHMubG9va3VwPzA6aEEuRUFDQ0VTKX0sbWF5Q3JlYXRlOmZ1bmN0aW9uKEEsQil7dHJ5e2RBLmxvb2t1cE5vZGUoQSxCKTtyZXR1cm4gaEEuRUVYSVNUfWNhdGNoKEEpe31yZXR1cm4gZEEubm9kZVBlcm1pc3Npb25zKEEsInd4Iil9LG1heURlbGV0ZTpmdW5jdGlvbihBLEIsSSl7dmFyIGc7dHJ5e2c9ZEEubG9va3VwTm9kZShBLEIpfWNhdGNoKEEpe3JldHVybiBBLmVycm5vfXZhciBRPWRBLm5vZGVQZXJtaXNzaW9ucyhBLCJ3eCIpO2lmKFEpcmV0dXJuIFE7aWYoSSl7aWYoIWRBLmlzRGlyKGcubW9kZSkpcmV0dXJuIGhBLkVOT1RESVI7aWYoZEEuaXNSb290KGcpfHxkQS5nZXRQYXRoKGcpPT09ZEEuY3dkKCkpcmV0dXJuIGhBLkVCVVNZfWVsc2UgaWYoZEEuaXNEaXIoZy5tb2RlKSlyZXR1cm4gaEEuRUlTRElSO3JldHVybiAwfSxtYXlPcGVuOmZ1bmN0aW9uKEEsQil7cmV0dXJuIEE/ZEEuaXNMaW5rKEEubW9kZSk/aEEuRUxPT1A6ZEEuaXNEaXIoQS5tb2RlKSYmKCJyIiE9PWRBLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKEIpfHw1MTImQik/aEEuRUlTRElSOmRBLm5vZGVQZXJtaXNzaW9ucyhBLGRBLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKEIpKTpoQS5FTk9FTlR9LE1BWF9PUEVOX0ZEUzo0MDk2LG5leHRmZDpmdW5jdGlvbihBLEIpe0E9QXx8MCxCPUJ8fGRBLk1BWF9PUEVOX0ZEUztmb3IodmFyIEk9QTtJPD1CO0krKylpZighZEEuc3RyZWFtc1tJXSlyZXR1cm4gSTt0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FTUZJTEUpfSxnZXRTdHJlYW06ZnVuY3Rpb24oQSl7cmV0dXJuIGRBLnN0cmVhbXNbQV19LGNyZWF0ZVN0cmVhbTpmdW5jdGlvbihBLEIsSSl7ZEEuRlNTdHJlYW18fChkQS5GU1N0cmVhbT1mdW5jdGlvbigpe30sZEEuRlNTdHJlYW0ucHJvdG90eXBlPXt9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRBLkZTU3RyZWFtLnByb3RvdHlwZSx7b2JqZWN0OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlfSxzZXQ6ZnVuY3Rpb24oQSl7dGhpcy5ub2RlPUF9fSxpc1JlYWQ6e2dldDpmdW5jdGlvbigpe3JldHVybiAxIT0oMjA5NzE1NSZ0aGlzLmZsYWdzKX19LGlzV3JpdGU6e2dldDpmdW5jdGlvbigpe3JldHVybiAwIT0oMjA5NzE1NSZ0aGlzLmZsYWdzKX19LGlzQXBwZW5kOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMTAyNCZ0aGlzLmZsYWdzfX19KSk7dmFyIGc9bmV3IGRBLkZTU3RyZWFtO2Zvcih2YXIgUSBpbiBBKWdbUV09QVtRXTtBPWc7dmFyIEU9ZEEubmV4dGZkKEIsSSk7cmV0dXJuIEEuZmQ9RSxkQS5zdHJlYW1zW0VdPUEsQX0sY2xvc2VTdHJlYW06ZnVuY3Rpb24oQSl7ZEEuc3RyZWFtc1tBXT1udWxsfSxjaHJkZXZfc3RyZWFtX29wczp7b3BlbjpmdW5jdGlvbihBKXt2YXIgQj1kQS5nZXREZXZpY2UoQS5ub2RlLnJkZXYpO0Euc3RyZWFtX29wcz1CLnN0cmVhbV9vcHMsQS5zdHJlYW1fb3BzLm9wZW4mJkEuc3RyZWFtX29wcy5vcGVuKEEpfSxsbHNlZWs6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FU1BJUEUpfX0sbWFqb3I6ZnVuY3Rpb24oQSl7cmV0dXJuIEE+Pjh9LG1pbm9yOmZ1bmN0aW9uKEEpe3JldHVybiAyNTUmQX0sbWFrZWRldjpmdW5jdGlvbihBLEIpe3JldHVybiBBPDw4fEJ9LHJlZ2lzdGVyRGV2aWNlOmZ1bmN0aW9uKEEsQil7ZEEuZGV2aWNlc1tBXT17c3RyZWFtX29wczpCfX0sZ2V0RGV2aWNlOmZ1bmN0aW9uKEEpe3JldHVybiBkQS5kZXZpY2VzW0FdfSxnZXRNb3VudHM6ZnVuY3Rpb24oQSl7Zm9yKHZhciBCPVtdLEk9W0FdO0kubGVuZ3RoOyl7dmFyIGc9SS5wb3AoKTtCLnB1c2goZyksSS5wdXNoLmFwcGx5KEksZy5tb3VudHMpfXJldHVybiBCfSxzeW5jZnM6ZnVuY3Rpb24oQSxCKXsiZnVuY3Rpb24iPT10eXBlb2YgQSYmKEI9QSxBPSExKSxkQS5zeW5jRlNSZXF1ZXN0cysrLGRBLnN5bmNGU1JlcXVlc3RzPjEmJmNvbnNvbGUubG9nKCJ3YXJuaW5nOiAiK2RBLnN5bmNGU1JlcXVlc3RzKyIgRlMuc3luY2ZzIG9wZXJhdGlvbnMgaW4gZmxpZ2h0IGF0IG9uY2UsIHByb2JhYmx5IGp1c3QgZG9pbmcgZXh0cmEgd29yayIpO3ZhciBJPWRBLmdldE1vdW50cyhkQS5yb290Lm1vdW50KSxnPTA7ZnVuY3Rpb24gUShBKXtyZXR1cm4gdyhkQS5zeW5jRlNSZXF1ZXN0cz4wKSxkQS5zeW5jRlNSZXF1ZXN0cy0tLEIoQSl9ZnVuY3Rpb24gRShBKXtpZihBKXJldHVybiBFLmVycm9yZWQ/dm9pZCAwOihFLmVycm9yZWQ9ITAsUShBKSk7KytnPj1JLmxlbmd0aCYmUShudWxsKX1JLmZvckVhY2goKGZ1bmN0aW9uKEIpe2lmKCFCLnR5cGUuc3luY2ZzKXJldHVybiBFKG51bGwpO0IudHlwZS5zeW5jZnMoQixBLEUpfSkpfSxtb3VudDpmdW5jdGlvbihBLEIsSSl7dmFyIGcsUT0iLyI9PT1JLEU9IUk7aWYoUSYmZEEucm9vdCl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQlVTWSk7aWYoIVEmJiFFKXt2YXIgQz1kQS5sb29rdXBQYXRoKEkse2ZvbGxvd19tb3VudDohMX0pO2lmKEk9Qy5wYXRoLGc9Qy5ub2RlLGRBLmlzTW91bnRwb2ludChnKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQlVTWSk7aWYoIWRBLmlzRGlyKGcubW9kZSkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5PVERJUil9dmFyIGk9e3R5cGU6QSxvcHRzOkIsbW91bnRwb2ludDpJLG1vdW50czpbXX0sbz1BLm1vdW50KGkpO3JldHVybiBvLm1vdW50PWksaS5yb290PW8sUT9kQS5yb290PW86ZyYmKGcubW91bnRlZD1pLGcubW91bnQmJmcubW91bnQubW91bnRzLnB1c2goaSkpLG99LHVubW91bnQ6ZnVuY3Rpb24oQSl7dmFyIEI9ZEEubG9va3VwUGF0aChBLHtmb2xsb3dfbW91bnQ6ITF9KTtpZighZEEuaXNNb3VudHBvaW50KEIubm9kZSkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTt2YXIgST1CLm5vZGUsZz1JLm1vdW50ZWQsUT1kQS5nZXRNb3VudHMoZyk7T2JqZWN0LmtleXMoZEEubmFtZVRhYmxlKS5mb3JFYWNoKChmdW5jdGlvbihBKXtmb3IodmFyIEI9ZEEubmFtZVRhYmxlW0FdO0I7KXt2YXIgST1CLm5hbWVfbmV4dDstMSE9PVEuaW5kZXhPZihCLm1vdW50KSYmZEEuZGVzdHJveU5vZGUoQiksQj1JfX0pKSxJLm1vdW50ZWQ9bnVsbDt2YXIgRT1JLm1vdW50Lm1vdW50cy5pbmRleE9mKGcpO3coLTEhPT1FKSxJLm1vdW50Lm1vdW50cy5zcGxpY2UoRSwxKX0sbG9va3VwOmZ1bmN0aW9uKEEsQil7cmV0dXJuIEEubm9kZV9vcHMubG9va3VwKEEsQil9LG1rbm9kOmZ1bmN0aW9uKEEsQixJKXt2YXIgZz1kQS5sb29rdXBQYXRoKEEse3BhcmVudDohMH0pLm5vZGUsUT1VQS5iYXNlbmFtZShBKTtpZighUXx8Ii4iPT09UXx8Ii4uIj09PVEpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTt2YXIgRT1kQS5tYXlDcmVhdGUoZyxRKTtpZihFKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKEUpO2lmKCFnLm5vZGVfb3BzLm1rbm9kKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKTtyZXR1cm4gZy5ub2RlX29wcy5ta25vZChnLFEsQixJKX0sY3JlYXRlOmZ1bmN0aW9uKEEsQil7cmV0dXJuIEI9dm9pZCAwIT09Qj9COjQzOCxCJj00MDk1LEJ8PTMyNzY4LGRBLm1rbm9kKEEsQiwwKX0sbWtkaXI6ZnVuY3Rpb24oQSxCKXtyZXR1cm4gQj12b2lkIDAhPT1CP0I6NTExLEImPTEwMjMsQnw9MTYzODQsZEEubWtub2QoQSxCLDApfSxta2RpclRyZWU6ZnVuY3Rpb24oQSxCKXtmb3IodmFyIEk9QS5zcGxpdCgiLyIpLGc9IiIsUT0wO1E8SS5sZW5ndGg7KytRKWlmKElbUV0pe2crPSIvIitJW1FdO3RyeXtkQS5ta2RpcihnLEIpfWNhdGNoKEEpe2lmKEEuZXJybm8hPWhBLkVFWElTVCl0aHJvdyBBfX19LG1rZGV2OmZ1bmN0aW9uKEEsQixJKXtyZXR1cm4gdm9pZCAwPT09SSYmKEk9QixCPTQzOCksQnw9ODE5MixkQS5ta25vZChBLEIsSSl9LHN5bWxpbms6ZnVuY3Rpb24oQSxCKXtpZighVUEucmVzb2x2ZShBKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FTk9FTlQpO3ZhciBJPWRBLmxvb2t1cFBhdGgoQix7cGFyZW50OiEwfSkubm9kZTtpZighSSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FTk9FTlQpO3ZhciBnPVVBLmJhc2VuYW1lKEIpLFE9ZEEubWF5Q3JlYXRlKEksZyk7aWYoUSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihRKTtpZighSS5ub2RlX29wcy5zeW1saW5rKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKTtyZXR1cm4gSS5ub2RlX29wcy5zeW1saW5rKEksZyxBKX0scmVuYW1lOmZ1bmN0aW9uKEEsQil7dmFyIEksZyxRPVVBLmRpcm5hbWUoQSksRT1VQS5kaXJuYW1lKEIpLEM9VUEuYmFzZW5hbWUoQSksaT1VQS5iYXNlbmFtZShCKTt0cnl7ST1kQS5sb29rdXBQYXRoKEEse3BhcmVudDohMH0pLm5vZGUsZz1kQS5sb29rdXBQYXRoKEIse3BhcmVudDohMH0pLm5vZGV9Y2F0Y2goQSl7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUJVU1kpfWlmKCFJfHwhZyl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FTk9FTlQpO2lmKEkubW91bnQhPT1nLm1vdW50KXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVYREVWKTt2YXIgbyx0PWRBLmxvb2t1cE5vZGUoSSxDKSxlPVVBLnJlbGF0aXZlKEEsRSk7aWYoIi4iIT09ZS5jaGFyQXQoMCkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTtpZigiLiIhPT0oZT1VQS5yZWxhdGl2ZShCLFEpKS5jaGFyQXQoMCkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5PVEVNUFRZKTt0cnl7bz1kQS5sb29rdXBOb2RlKGcsaSl9Y2F0Y2goQSl7fWlmKHQhPT1vKXt2YXIgcj1kQS5pc0Rpcih0Lm1vZGUpLGE9ZEEubWF5RGVsZXRlKEksQyxyKTtpZihhKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGEpO2lmKGE9bz9kQS5tYXlEZWxldGUoZyxpLHIpOmRBLm1heUNyZWF0ZShnLGkpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGEpO2lmKCFJLm5vZGVfb3BzLnJlbmFtZSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FUEVSTSk7aWYoZEEuaXNNb3VudHBvaW50KHQpfHxvJiZkQS5pc01vdW50cG9pbnQobykpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUJVU1kpO2lmKGchPT1JJiYoYT1kQS5ub2RlUGVybWlzc2lvbnMoSSwidyIpKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihhKTt0cnl7ZEEudHJhY2tpbmdEZWxlZ2F0ZS53aWxsTW92ZVBhdGh9Y2F0Y2goSSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxNb3ZlUGF0aCddKCciK0ErIicsICciK0IrIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIitJLm1lc3NhZ2UpfWRBLmhhc2hSZW1vdmVOb2RlKHQpO3RyeXtJLm5vZGVfb3BzLnJlbmFtZSh0LGcsaSl9Y2F0Y2goQSl7dGhyb3cgQX1maW5hbGx5e2RBLmhhc2hBZGROb2RlKHQpfXRyeXtkQS50cmFja2luZ0RlbGVnYXRlLm9uTW92ZVBhdGh9Y2F0Y2goSSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uTW92ZVBhdGgnXSgnIitBKyInLCAnIitCKyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrSS5tZXNzYWdlKX19fSxybWRpcjpmdW5jdGlvbihBKXt2YXIgQj1kQS5sb29rdXBQYXRoKEEse3BhcmVudDohMH0pLm5vZGUsST1VQS5iYXNlbmFtZShBKSxnPWRBLmxvb2t1cE5vZGUoQixJKSxRPWRBLm1heURlbGV0ZShCLEksITApO2lmKFEpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoUSk7aWYoIUIubm9kZV9vcHMucm1kaXIpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRVBFUk0pO2lmKGRBLmlzTW91bnRwb2ludChnKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQlVTWSk7dHJ5e2RBLnRyYWNraW5nRGVsZWdhdGUud2lsbERlbGV0ZVBhdGh9Y2F0Y2goQil7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxEZWxldGVQYXRoJ10oJyIrQSsiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK0IubWVzc2FnZSl9Qi5ub2RlX29wcy5ybWRpcihCLEkpLGRBLmRlc3Ryb3lOb2RlKGcpO3RyeXtkQS50cmFja2luZ0RlbGVnYXRlLm9uRGVsZXRlUGF0aH1jYXRjaChCKXtjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10oJyIrQSsiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK0IubWVzc2FnZSl9fSxyZWFkZGlyOmZ1bmN0aW9uKEEpe3ZhciBCPWRBLmxvb2t1cFBhdGgoQSx7Zm9sbG93OiEwfSkubm9kZTtpZighQi5ub2RlX29wcy5yZWFkZGlyKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT1RESVIpO3JldHVybiBCLm5vZGVfb3BzLnJlYWRkaXIoQil9LHVubGluazpmdW5jdGlvbihBKXt2YXIgQj1kQS5sb29rdXBQYXRoKEEse3BhcmVudDohMH0pLm5vZGUsST1VQS5iYXNlbmFtZShBKSxnPWRBLmxvb2t1cE5vZGUoQixJKSxRPWRBLm1heURlbGV0ZShCLEksITEpO2lmKFEpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoUSk7aWYoIUIubm9kZV9vcHMudW5saW5rKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKTtpZihkQS5pc01vdW50cG9pbnQoZykpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUJVU1kpO3RyeXtkQS50cmFja2luZ0RlbGVnYXRlLndpbGxEZWxldGVQYXRofWNhdGNoKEIpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsRGVsZXRlUGF0aCddKCciK0ErIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIitCLm1lc3NhZ2UpfUIubm9kZV9vcHMudW5saW5rKEIsSSksZEEuZGVzdHJveU5vZGUoZyk7dHJ5e2RBLnRyYWNraW5nRGVsZWdhdGUub25EZWxldGVQYXRofWNhdGNoKEIpe2NvbnNvbGUubG9nKCJGUy50cmFja2luZ0RlbGVnYXRlWydvbkRlbGV0ZVBhdGgnXSgnIitBKyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrQi5tZXNzYWdlKX19LHJlYWRsaW5rOmZ1bmN0aW9uKEEpe3ZhciBCPWRBLmxvb2t1cFBhdGgoQSkubm9kZTtpZighQil0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FTk9FTlQpO2lmKCFCLm5vZGVfb3BzLnJlYWRsaW5rKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVJTlZBTCk7cmV0dXJuIFVBLnJlc29sdmUoZEEuZ2V0UGF0aChCLnBhcmVudCksQi5ub2RlX29wcy5yZWFkbGluayhCKSl9LHN0YXQ6ZnVuY3Rpb24oQSxCKXt2YXIgST1kQS5sb29rdXBQYXRoKEEse2ZvbGxvdzohQn0pLm5vZGU7aWYoIUkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5PRU5UKTtpZighSS5ub2RlX29wcy5nZXRhdHRyKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKTtyZXR1cm4gSS5ub2RlX29wcy5nZXRhdHRyKEkpfSxsc3RhdDpmdW5jdGlvbihBKXtyZXR1cm4gZEEuc3RhdChBLCEwKX0sY2htb2Q6ZnVuY3Rpb24oQSxCLEkpe3ZhciBnOyJzdHJpbmciPT10eXBlb2YgQT9nPWRBLmxvb2t1cFBhdGgoQSx7Zm9sbG93OiFJfSkubm9kZTpnPUE7aWYoIWcubm9kZV9vcHMuc2V0YXR0cil0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FUEVSTSk7Zy5ub2RlX29wcy5zZXRhdHRyKGcse21vZGU6NDA5NSZCfC00MDk2JmcubW9kZSx0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfSxsY2htb2Q6ZnVuY3Rpb24oQSxCKXtkQS5jaG1vZChBLEIsITApfSxmY2htb2Q6ZnVuY3Rpb24oQSxCKXt2YXIgST1kQS5nZXRTdHJlYW0oQSk7aWYoIUkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUJBREYpO2RBLmNobW9kKEkubm9kZSxCKX0sY2hvd246ZnVuY3Rpb24oQSxCLEksZyl7dmFyIFE7InN0cmluZyI9PXR5cGVvZiBBP1E9ZEEubG9va3VwUGF0aChBLHtmb2xsb3c6IWd9KS5ub2RlOlE9QTtpZighUS5ub2RlX29wcy5zZXRhdHRyKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVQRVJNKTtRLm5vZGVfb3BzLnNldGF0dHIoUSx7dGltZXN0YW1wOkRhdGUubm93KCl9KX0sbGNob3duOmZ1bmN0aW9uKEEsQixJKXtkQS5jaG93bihBLEIsSSwhMCl9LGZjaG93bjpmdW5jdGlvbihBLEIsSSl7dmFyIGc9ZEEuZ2V0U3RyZWFtKEEpO2lmKCFnKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVCQURGKTtkQS5jaG93bihnLm5vZGUsQixJKX0sdHJ1bmNhdGU6ZnVuY3Rpb24oQSxCKXtpZihCPDApdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTt2YXIgSTsic3RyaW5nIj09dHlwZW9mIEE/ST1kQS5sb29rdXBQYXRoKEEse2ZvbGxvdzohMH0pLm5vZGU6ST1BO2lmKCFJLm5vZGVfb3BzLnNldGF0dHIpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRVBFUk0pO2lmKGRBLmlzRGlyKEkubW9kZSkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlTRElSKTtpZighZEEuaXNGaWxlKEkubW9kZSkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTt2YXIgZz1kQS5ub2RlUGVybWlzc2lvbnMoSSwidyIpO2lmKGcpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoZyk7SS5ub2RlX29wcy5zZXRhdHRyKEkse3NpemU6Qix0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfSxmdHJ1bmNhdGU6ZnVuY3Rpb24oQSxCKXt2YXIgST1kQS5nZXRTdHJlYW0oQSk7aWYoIUkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUJBREYpO2lmKDA9PSgyMDk3MTU1JkkuZmxhZ3MpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVJTlZBTCk7ZEEudHJ1bmNhdGUoSS5ub2RlLEIpfSx1dGltZTpmdW5jdGlvbihBLEIsSSl7dmFyIGc9ZEEubG9va3VwUGF0aChBLHtmb2xsb3c6ITB9KS5ub2RlO2cubm9kZV9vcHMuc2V0YXR0cihnLHt0aW1lc3RhbXA6TWF0aC5tYXgoQixJKX0pfSxvcGVuOmZ1bmN0aW9uKEEsQixJLGcsUSl7aWYoIiI9PT1BKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT0VOVCk7dmFyIEM7aWYoST12b2lkIDA9PT1JPzQzODpJLEk9NjQmKEI9InN0cmluZyI9PXR5cGVvZiBCP2RBLm1vZGVTdHJpbmdUb0ZsYWdzKEIpOkIpPzQwOTUmSXwzMjc2ODowLCJvYmplY3QiPT10eXBlb2YgQSlDPUE7ZWxzZXtBPVVBLm5vcm1hbGl6ZShBKTt0cnl7Qz1kQS5sb29rdXBQYXRoKEEse2ZvbGxvdzohKDEzMTA3MiZCKX0pLm5vZGV9Y2F0Y2goQSl7fX12YXIgaT0hMTtpZig2NCZCKWlmKEMpe2lmKDEyOCZCKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVFWElTVCl9ZWxzZSBDPWRBLm1rbm9kKEEsSSwwKSxpPSEwO2lmKCFDKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT0VOVCk7aWYoZEEuaXNDaHJkZXYoQy5tb2RlKSYmKEImPS01MTMpLDY1NTM2JkImJiFkQS5pc0RpcihDLm1vZGUpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT1RESVIpO2lmKCFpKXt2YXIgbz1kQS5tYXlPcGVuKEMsQik7aWYobyl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihvKX01MTImQiYmZEEudHJ1bmNhdGUoQywwKSxCJj0tNjQxO3ZhciB0PWRBLmNyZWF0ZVN0cmVhbSh7bm9kZTpDLHBhdGg6ZEEuZ2V0UGF0aChDKSxmbGFnczpCLHNlZWthYmxlOiEwLHBvc2l0aW9uOjAsc3RyZWFtX29wczpDLnN0cmVhbV9vcHMsdW5nb3R0ZW46W10sZXJyb3I6ITF9LGcsUSk7dC5zdHJlYW1fb3BzLm9wZW4mJnQuc3RyZWFtX29wcy5vcGVuKHQpLCFFLmxvZ1JlYWRGaWxlc3x8MSZCfHwoZEEucmVhZEZpbGVzfHwoZEEucmVhZEZpbGVzPXt9KSxBIGluIGRBLnJlYWRGaWxlc3x8KGRBLnJlYWRGaWxlc1tBXT0xLEUucHJpbnRFcnIoInJlYWQgZmlsZTogIitBKSkpO3RyeXtkQS50cmFja2luZ0RlbGVnYXRlLm9uT3BlbkZpbGV9Y2F0Y2goQil7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uT3BlbkZpbGUnXSgnIitBKyInLCBmbGFncykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiK0IubWVzc2FnZSl9cmV0dXJuIHR9LGNsb3NlOmZ1bmN0aW9uKEEpe2lmKGRBLmlzQ2xvc2VkKEEpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVCQURGKTtBLmdldGRlbnRzJiYoQS5nZXRkZW50cz1udWxsKTt0cnl7QS5zdHJlYW1fb3BzLmNsb3NlJiZBLnN0cmVhbV9vcHMuY2xvc2UoQSl9Y2F0Y2goQSl7dGhyb3cgQX1maW5hbGx5e2RBLmNsb3NlU3RyZWFtKEEuZmQpfUEuZmQ9bnVsbH0saXNDbG9zZWQ6ZnVuY3Rpb24oQSl7cmV0dXJuIG51bGw9PT1BLmZkfSxsbHNlZWs6ZnVuY3Rpb24oQSxCLEkpe2lmKGRBLmlzQ2xvc2VkKEEpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVCQURGKTtpZighQS5zZWVrYWJsZXx8IUEuc3RyZWFtX29wcy5sbHNlZWspdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRVNQSVBFKTtyZXR1cm4gQS5wb3NpdGlvbj1BLnN0cmVhbV9vcHMubGxzZWVrKEEsQixJKSxBLnVuZ290dGVuPVtdLEEucG9zaXRpb259LHJlYWQ6ZnVuY3Rpb24oQSxCLEksZyxRKXtpZihnPDB8fFE8MCl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FSU5WQUwpO2lmKGRBLmlzQ2xvc2VkKEEpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVCQURGKTtpZigxPT0oMjA5NzE1NSZBLmZsYWdzKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQkFERik7aWYoZEEuaXNEaXIoQS5ub2RlLm1vZGUpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVJU0RJUik7aWYoIUEuc3RyZWFtX29wcy5yZWFkKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVJTlZBTCk7dmFyIEU9dm9pZCAwIT09UTtpZihFKXtpZighQS5zZWVrYWJsZSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FU1BJUEUpfWVsc2UgUT1BLnBvc2l0aW9uO3ZhciBDPUEuc3RyZWFtX29wcy5yZWFkKEEsQixJLGcsUSk7cmV0dXJuIEV8fChBLnBvc2l0aW9uKz1DKSxDfSx3cml0ZTpmdW5jdGlvbihBLEIsSSxnLFEsRSl7aWYoZzwwfHxRPDApdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTtpZihkQS5pc0Nsb3NlZChBKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQkFERik7aWYoMD09KDIwOTcxNTUmQS5mbGFncykpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUJBREYpO2lmKGRBLmlzRGlyKEEubm9kZS5tb2RlKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FSVNESVIpO2lmKCFBLnN0cmVhbV9vcHMud3JpdGUpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTsxMDI0JkEuZmxhZ3MmJmRBLmxsc2VlayhBLDAsMik7dmFyIEM9dm9pZCAwIT09UTtpZihDKXtpZighQS5zZWVrYWJsZSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FU1BJUEUpfWVsc2UgUT1BLnBvc2l0aW9uO3ZhciBpPUEuc3RyZWFtX29wcy53cml0ZShBLEIsSSxnLFEsRSk7Q3x8KEEucG9zaXRpb24rPWkpO3RyeXtBLnBhdGgmJmRBLnRyYWNraW5nRGVsZWdhdGUub25Xcml0ZVRvRmlsZSYmZEEudHJhY2tpbmdEZWxlZ2F0ZS5vbldyaXRlVG9GaWxlKEEucGF0aCl9Y2F0Y2goQSl7Y29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uV3JpdGVUb0ZpbGUnXSgnIitwYXRoKyInKSB0aHJldyBhbiBleGNlcHRpb246ICIrQS5tZXNzYWdlKX1yZXR1cm4gaX0sYWxsb2NhdGU6ZnVuY3Rpb24oQSxCLEkpe2lmKGRBLmlzQ2xvc2VkKEEpKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVCQURGKTtpZihCPDB8fEk8PTApdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlOVkFMKTtpZigwPT0oMjA5NzE1NSZBLmZsYWdzKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQkFERik7aWYoIWRBLmlzRmlsZShBLm5vZGUubW9kZSkmJiFkQS5pc0RpcihBLm5vZGUubW9kZSkpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5PREVWKTtpZighQS5zdHJlYW1fb3BzLmFsbG9jYXRlKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVPUE5PVFNVUFApO0Euc3RyZWFtX29wcy5hbGxvY2F0ZShBLEIsSSl9LG1tYXA6ZnVuY3Rpb24oQSxCLEksZyxRLEUsQyl7aWYoMT09KDIwOTcxNTUmQS5mbGFncykpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUFDQ0VTKTtpZighQS5zdHJlYW1fb3BzLm1tYXApdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRU5PREVWKTtyZXR1cm4gQS5zdHJlYW1fb3BzLm1tYXAoQSxCLEksZyxRLEUsQyl9LG1zeW5jOmZ1bmN0aW9uKEEsQixJLGcsUSl7cmV0dXJuIEEmJkEuc3RyZWFtX29wcy5tc3luYz9BLnN0cmVhbV9vcHMubXN5bmMoQSxCLEksZyxRKTowfSxtdW5tYXA6ZnVuY3Rpb24oQSl7cmV0dXJuIDB9LGlvY3RsOmZ1bmN0aW9uKEEsQixJKXtpZighQS5zdHJlYW1fb3BzLmlvY3RsKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT1RUWSk7cmV0dXJuIEEuc3RyZWFtX29wcy5pb2N0bChBLEIsSSl9LHJlYWRGaWxlOmZ1bmN0aW9uKEEsQil7aWYoKEI9Qnx8e30pLmZsYWdzPUIuZmxhZ3N8fCJyIixCLmVuY29kaW5nPUIuZW5jb2Rpbmd8fCJiaW5hcnkiLCJ1dGY4IiE9PUIuZW5jb2RpbmcmJiJiaW5hcnkiIT09Qi5lbmNvZGluZyl0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSAiJytCLmVuY29kaW5nKyciJyk7dmFyIEksZz1kQS5vcGVuKEEsQi5mbGFncyksUT1kQS5zdGF0KEEpLnNpemUsRT1uZXcgVWludDhBcnJheShRKTtyZXR1cm4gZEEucmVhZChnLEUsMCxRLDApLCJ1dGY4Ij09PUIuZW5jb2Rpbmc/ST1VKEUsMCk6ImJpbmFyeSI9PT1CLmVuY29kaW5nJiYoST1FKSxkQS5jbG9zZShnKSxJfSx3cml0ZUZpbGU6ZnVuY3Rpb24oQSxCLEkpeyhJPUl8fHt9KS5mbGFncz1JLmZsYWdzfHwidyI7dmFyIGc9ZEEub3BlbihBLEkuZmxhZ3MsSS5tb2RlKTtpZigic3RyaW5nIj09dHlwZW9mIEIpe3ZhciBRPW5ldyBVaW50OEFycmF5KGYoQikrMSksRT1TKEIsUSwwLFEubGVuZ3RoKTtkQS53cml0ZShnLFEsMCxFLHZvaWQgMCxJLmNhbk93bil9ZWxzZXtpZighQXJyYXlCdWZmZXIuaXNWaWV3KEIpKXRocm93IG5ldyBFcnJvcigiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIik7ZEEud3JpdGUoZyxCLDAsQi5ieXRlTGVuZ3RoLHZvaWQgMCxJLmNhbk93bil9ZEEuY2xvc2UoZyl9LGN3ZDpmdW5jdGlvbigpe3JldHVybiBkQS5jdXJyZW50UGF0aH0sY2hkaXI6ZnVuY3Rpb24oQSl7dmFyIEI9ZEEubG9va3VwUGF0aChBLHtmb2xsb3c6ITB9KTtpZihudWxsPT09Qi5ub2RlKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGhBLkVOT0VOVCk7aWYoIWRBLmlzRGlyKEIubm9kZS5tb2RlKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FTk9URElSKTt2YXIgST1kQS5ub2RlUGVybWlzc2lvbnMoQi5ub2RlLCJ4Iik7aWYoSSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihJKTtkQS5jdXJyZW50UGF0aD1CLnBhdGh9LGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczpmdW5jdGlvbigpe2RBLm1rZGlyKCIvdG1wIiksZEEubWtkaXIoIi9ob21lIiksZEEubWtkaXIoIi9ob21lL3dlYl91c2VyIil9LGNyZWF0ZURlZmF1bHREZXZpY2VzOmZ1bmN0aW9uKCl7dmFyIEE7aWYoZEEubWtkaXIoIi9kZXYiKSxkQS5yZWdpc3RlckRldmljZShkQS5tYWtlZGV2KDEsMykse3JlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sd3JpdGU6ZnVuY3Rpb24oQSxCLEksZyxRKXtyZXR1cm4gZ319KSxkQS5ta2RldigiL2Rldi9udWxsIixkQS5tYWtlZGV2KDEsMykpLEdBLnJlZ2lzdGVyKGRBLm1ha2VkZXYoNSwwKSxHQS5kZWZhdWx0X3R0eV9vcHMpLEdBLnJlZ2lzdGVyKGRBLm1ha2VkZXYoNiwwKSxHQS5kZWZhdWx0X3R0eTFfb3BzKSxkQS5ta2RldigiL2Rldi90dHkiLGRBLm1ha2VkZXYoNSwwKSksZEEubWtkZXYoIi9kZXYvdHR5MSIsZEEubWFrZWRldig2LDApKSwidW5kZWZpbmVkIiE9dHlwZW9mIGNyeXB0byl7dmFyIEI9bmV3IFVpbnQ4QXJyYXkoMSk7QT1mdW5jdGlvbigpe3JldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKEIpLEJbMF19fWVsc2UgQT1yP2Z1bmN0aW9uKCl7cmV0dXJuIHJlcXVpcmUoImNyeXB0byIpLnJhbmRvbUJ5dGVzKDEpWzBdfTpmdW5jdGlvbigpe3JldHVybiAyNTYqTWF0aC5yYW5kb20oKXwwfTtkQS5jcmVhdGVEZXZpY2UoIi9kZXYiLCJyYW5kb20iLEEpLGRBLmNyZWF0ZURldmljZSgiL2RldiIsInVyYW5kb20iLEEpLGRBLm1rZGlyKCIvZGV2L3NobSIpLGRBLm1rZGlyKCIvZGV2L3NobS90bXAiKX0sY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOmZ1bmN0aW9uKCl7ZEEubWtkaXIoIi9wcm9jIiksZEEubWtkaXIoIi9wcm9jL3NlbGYiKSxkQS5ta2RpcigiL3Byb2Mvc2VsZi9mZCIpLGRBLm1vdW50KHttb3VudDpmdW5jdGlvbigpe3ZhciBBPWRBLmNyZWF0ZU5vZGUoIi9wcm9jL3NlbGYiLCJmZCIsMTY4OTUsNzMpO3JldHVybiBBLm5vZGVfb3BzPXtsb29rdXA6ZnVuY3Rpb24oQSxCKXt2YXIgST0rQixnPWRBLmdldFN0cmVhbShJKTtpZighZyl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQkFERik7dmFyIFE9e3BhcmVudDpudWxsLG1vdW50Onttb3VudHBvaW50OiJmYWtlIn0sbm9kZV9vcHM6e3JlYWRsaW5rOmZ1bmN0aW9uKCl7cmV0dXJuIGcucGF0aH19fTtyZXR1cm4gUS5wYXJlbnQ9USxRfX0sQX19LHt9LCIvcHJvYy9zZWxmL2ZkIil9LGNyZWF0ZVN0YW5kYXJkU3RyZWFtczpmdW5jdGlvbigpe0Uuc3RkaW4/ZEEuY3JlYXRlRGV2aWNlKCIvZGV2Iiwic3RkaW4iLEUuc3RkaW4pOmRBLnN5bWxpbmsoIi9kZXYvdHR5IiwiL2Rldi9zdGRpbiIpLEUuc3Rkb3V0P2RBLmNyZWF0ZURldmljZSgiL2RldiIsInN0ZG91dCIsbnVsbCxFLnN0ZG91dCk6ZEEuc3ltbGluaygiL2Rldi90dHkiLCIvZGV2L3N0ZG91dCIpLEUuc3RkZXJyP2RBLmNyZWF0ZURldmljZSgiL2RldiIsInN0ZGVyciIsbnVsbCxFLnN0ZGVycik6ZEEuc3ltbGluaygiL2Rldi90dHkxIiwiL2Rldi9zdGRlcnIiKTt2YXIgQT1kQS5vcGVuKCIvZGV2L3N0ZGluIiwiciIpO3coMD09PUEuZmQsImludmFsaWQgaGFuZGxlIGZvciBzdGRpbiAoIitBLmZkKyIpIik7dmFyIEI9ZEEub3BlbigiL2Rldi9zdGRvdXQiLCJ3Iik7dygxPT09Qi5mZCwiaW52YWxpZCBoYW5kbGUgZm9yIHN0ZG91dCAoIitCLmZkKyIpIik7dmFyIEk9ZEEub3BlbigiL2Rldi9zdGRlcnIiLCJ3Iik7dygyPT09SS5mZCwiaW52YWxpZCBoYW5kbGUgZm9yIHN0ZGVyciAoIitJLmZkKyIpIil9LGVuc3VyZUVycm5vRXJyb3I6ZnVuY3Rpb24oKXtkQS5FcnJub0Vycm9yfHwoZEEuRXJybm9FcnJvcj1mdW5jdGlvbihBLEIpe3RoaXMubm9kZT1CLHRoaXMuc2V0RXJybm89ZnVuY3Rpb24oQSl7Zm9yKHZhciBCIGluIHRoaXMuZXJybm89QSxoQSlpZihoQVtCXT09PUEpe3RoaXMuY29kZT1CO2JyZWFrfX0sdGhpcy5zZXRFcnJubyhBKSx0aGlzLm1lc3NhZ2U9UkFbQV0sdGhpcy5zdGFjayYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN0YWNrIix7dmFsdWU6KG5ldyBFcnJvcikuc3RhY2ssd3JpdGFibGU6ITB9KX0sZEEuRXJybm9FcnJvci5wcm90b3R5cGU9bmV3IEVycm9yLGRBLkVycm5vRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPWRBLkVycm5vRXJyb3IsW2hBLkVOT0VOVF0uZm9yRWFjaCgoZnVuY3Rpb24oQSl7ZEEuZ2VuZXJpY0Vycm9yc1tBXT1uZXcgZEEuRXJybm9FcnJvcihBKSxkQS5nZW5lcmljRXJyb3JzW0FdLnN0YWNrPSI8Z2VuZXJpYyBlcnJvciwgbm8gc3RhY2s+In0pKSl9LHN0YXRpY0luaXQ6ZnVuY3Rpb24oKXtkQS5lbnN1cmVFcnJub0Vycm9yKCksZEEubmFtZVRhYmxlPW5ldyBBcnJheSg0MDk2KSxkQS5tb3VudChTQSx7fSwiLyIpLGRBLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpLGRBLmNyZWF0ZURlZmF1bHREZXZpY2VzKCksZEEuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCksZEEuZmlsZXN5c3RlbXM9e01FTUZTOlNBLElEQkZTOmtBLE5PREVGUzpmQSxXT1JLRVJGUzpOQX19LGluaXQ6ZnVuY3Rpb24oQSxCLEkpe3coIWRBLmluaXQuaW5pdGlhbGl6ZWQsIkZTLmluaXQgd2FzIHByZXZpb3VzbHkgY2FsbGVkLiBJZiB5b3Ugd2FudCB0byBpbml0aWFsaXplIGxhdGVyIHdpdGggY3VzdG9tIHBhcmFtZXRlcnMsIHJlbW92ZSBhbnkgZWFybGllciBjYWxscyAobm90ZSB0aGF0IG9uZSBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoZSBnZW5lcmF0ZWQgY29kZSkiKSxkQS5pbml0LmluaXRpYWxpemVkPSEwLGRBLmVuc3VyZUVycm5vRXJyb3IoKSxFLnN0ZGluPUF8fEUuc3RkaW4sRS5zdGRvdXQ9Qnx8RS5zdGRvdXQsRS5zdGRlcnI9SXx8RS5zdGRlcnIsZEEuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCl9LHF1aXQ6ZnVuY3Rpb24oKXtkQS5pbml0LmluaXRpYWxpemVkPSExO3ZhciBBPUUuX2ZmbHVzaDtBJiZBKDApO2Zvcih2YXIgQj0wO0I8ZEEuc3RyZWFtcy5sZW5ndGg7QisrKXt2YXIgST1kQS5zdHJlYW1zW0JdO0kmJmRBLmNsb3NlKEkpfX0sZ2V0TW9kZTpmdW5jdGlvbihBLEIpe3ZhciBJPTA7cmV0dXJuIEEmJihJfD0zNjUpLEImJihJfD0xNDYpLEl9LGpvaW5QYXRoOmZ1bmN0aW9uKEEsQil7dmFyIEk9VUEuam9pbi5hcHBseShudWxsLEEpO3JldHVybiBCJiYiLyI9PUlbMF0mJihJPUkuc3Vic3RyKDEpKSxJfSxhYnNvbHV0ZVBhdGg6ZnVuY3Rpb24oQSxCKXtyZXR1cm4gVUEucmVzb2x2ZShCLEEpfSxzdGFuZGFyZGl6ZVBhdGg6ZnVuY3Rpb24oQSl7cmV0dXJuIFVBLm5vcm1hbGl6ZShBKX0sZmluZE9iamVjdDpmdW5jdGlvbihBLEIpe3ZhciBJPWRBLmFuYWx5emVQYXRoKEEsQik7cmV0dXJuIEkuZXhpc3RzP0kub2JqZWN0Oih5QShJLmVycm9yKSxudWxsKX0sYW5hbHl6ZVBhdGg6ZnVuY3Rpb24oQSxCKXt0cnl7QT0oZz1kQS5sb29rdXBQYXRoKEEse2ZvbGxvdzohQn0pKS5wYXRofWNhdGNoKEEpe312YXIgST17aXNSb290OiExLGV4aXN0czohMSxlcnJvcjowLG5hbWU6bnVsbCxwYXRoOm51bGwsb2JqZWN0Om51bGwscGFyZW50RXhpc3RzOiExLHBhcmVudFBhdGg6bnVsbCxwYXJlbnRPYmplY3Q6bnVsbH07dHJ5e3ZhciBnPWRBLmxvb2t1cFBhdGgoQSx7cGFyZW50OiEwfSk7SS5wYXJlbnRFeGlzdHM9ITAsSS5wYXJlbnRQYXRoPWcucGF0aCxJLnBhcmVudE9iamVjdD1nLm5vZGUsSS5uYW1lPVVBLmJhc2VuYW1lKEEpLGc9ZEEubG9va3VwUGF0aChBLHtmb2xsb3c6IUJ9KSxJLmV4aXN0cz0hMCxJLnBhdGg9Zy5wYXRoLEkub2JqZWN0PWcubm9kZSxJLm5hbWU9Zy5ub2RlLm5hbWUsSS5pc1Jvb3Q9Ii8iPT09Zy5wYXRofWNhdGNoKEEpe0kuZXJyb3I9QS5lcnJub31yZXR1cm4gSX0sY3JlYXRlRm9sZGVyOmZ1bmN0aW9uKEEsQixJLGcpe3ZhciBRPVVBLmpvaW4yKCJzdHJpbmciPT10eXBlb2YgQT9BOmRBLmdldFBhdGgoQSksQiksRT1kQS5nZXRNb2RlKEksZyk7cmV0dXJuIGRBLm1rZGlyKFEsRSl9LGNyZWF0ZVBhdGg6ZnVuY3Rpb24oQSxCLEksZyl7QT0ic3RyaW5nIj09dHlwZW9mIEE/QTpkQS5nZXRQYXRoKEEpO2Zvcih2YXIgUT1CLnNwbGl0KCIvIikucmV2ZXJzZSgpO1EubGVuZ3RoOyl7dmFyIEU9US5wb3AoKTtpZihFKXt2YXIgQz1VQS5qb2luMihBLEUpO3RyeXtkQS5ta2RpcihDKX1jYXRjaChBKXt9QT1DfX1yZXR1cm4gQ30sY3JlYXRlRmlsZTpmdW5jdGlvbihBLEIsSSxnLFEpe3ZhciBFPVVBLmpvaW4yKCJzdHJpbmciPT10eXBlb2YgQT9BOmRBLmdldFBhdGgoQSksQiksQz1kQS5nZXRNb2RlKGcsUSk7cmV0dXJuIGRBLmNyZWF0ZShFLEMpfSxjcmVhdGVEYXRhRmlsZTpmdW5jdGlvbihBLEIsSSxnLFEsRSl7dmFyIEM9Qj9VQS5qb2luMigic3RyaW5nIj09dHlwZW9mIEE/QTpkQS5nZXRQYXRoKEEpLEIpOkEsaT1kQS5nZXRNb2RlKGcsUSksbz1kQS5jcmVhdGUoQyxpKTtpZihJKXtpZigic3RyaW5nIj09dHlwZW9mIEkpe2Zvcih2YXIgdD1uZXcgQXJyYXkoSS5sZW5ndGgpLGU9MCxyPUkubGVuZ3RoO2U8cjsrK2UpdFtlXT1JLmNoYXJDb2RlQXQoZSk7ST10fWRBLmNobW9kKG8sMTQ2fGkpO3ZhciBhPWRBLm9wZW4obywidyIpO2RBLndyaXRlKGEsSSwwLEkubGVuZ3RoLDAsRSksZEEuY2xvc2UoYSksZEEuY2htb2QobyxpKX1yZXR1cm4gb30sY3JlYXRlRGV2aWNlOmZ1bmN0aW9uKEEsQixJLGcpe3ZhciBRPVVBLmpvaW4yKCJzdHJpbmciPT10eXBlb2YgQT9BOmRBLmdldFBhdGgoQSksQiksRT1kQS5nZXRNb2RlKCEhSSwhIWcpO2RBLmNyZWF0ZURldmljZS5tYWpvcnx8KGRBLmNyZWF0ZURldmljZS5tYWpvcj02NCk7dmFyIEM9ZEEubWFrZWRldihkQS5jcmVhdGVEZXZpY2UubWFqb3IrKywwKTtyZXR1cm4gZEEucmVnaXN0ZXJEZXZpY2UoQyx7b3BlbjpmdW5jdGlvbihBKXtBLnNlZWthYmxlPSExfSxjbG9zZTpmdW5jdGlvbihBKXtnJiZnLmJ1ZmZlciYmZy5idWZmZXIubGVuZ3RoJiZnKDEwKX0scmVhZDpmdW5jdGlvbihBLEIsZyxRLEUpe2Zvcih2YXIgQz0wLGk9MDtpPFE7aSsrKXt2YXIgbzt0cnl7bz1JKCl9Y2F0Y2goQSl7dGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlPKX1pZih2b2lkIDA9PT1vJiYwPT09Qyl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQUdBSU4pO2lmKG51bGw9PW8pYnJlYWs7QysrLEJbZytpXT1vfXJldHVybiBDJiYoQS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpKSxDfSx3cml0ZTpmdW5jdGlvbihBLEIsSSxRLEUpe2Zvcih2YXIgQz0wO0M8UTtDKyspdHJ5e2coQltJK0NdKX1jYXRjaChBKXt0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FSU8pfXJldHVybiBRJiYoQS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpKSxDfX0pLGRBLm1rZGV2KFEsRSxDKX0sY3JlYXRlTGluazpmdW5jdGlvbihBLEIsSSxnLFEpe3ZhciBFPVVBLmpvaW4yKCJzdHJpbmciPT10eXBlb2YgQT9BOmRBLmdldFBhdGgoQSksQik7cmV0dXJuIGRBLnN5bWxpbmsoSSxFKX0sZm9yY2VMb2FkRmlsZTpmdW5jdGlvbihBKXtpZihBLmlzRGV2aWNlfHxBLmlzRm9sZGVyfHxBLmxpbmt8fEEuY29udGVudHMpcmV0dXJuITA7dmFyIEI9ITA7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBYTUxIdHRwUmVxdWVzdCl0aHJvdyBuZXcgRXJyb3IoIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLiIpO2lmKCFFLnJlYWQpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4iKTt0cnl7QS5jb250ZW50cz1UQihFLnJlYWQoQS51cmwpLCEwKSxBLnVzZWRCeXRlcz1BLmNvbnRlbnRzLmxlbmd0aH1jYXRjaChBKXtCPSExfXJldHVybiBCfHx5QShoQS5FSU8pLEJ9LGNyZWF0ZUxhenlGaWxlOmZ1bmN0aW9uKEEsQixJLGcsUSl7ZnVuY3Rpb24gRSgpe3RoaXMubGVuZ3RoS25vd249ITEsdGhpcy5jaHVua3M9W119aWYoRS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKEEpe2lmKCEoQT50aGlzLmxlbmd0aC0xfHxBPDApKXt2YXIgQj1BJXRoaXMuY2h1bmtTaXplLEk9QS90aGlzLmNodW5rU2l6ZXwwO3JldHVybiB0aGlzLmdldHRlcihJKVtCXX19LEUucHJvdG90eXBlLnNldERhdGFHZXR0ZXI9ZnVuY3Rpb24oQSl7dGhpcy5nZXR0ZXI9QX0sRS5wcm90b3R5cGUuY2FjaGVMZW5ndGg9ZnVuY3Rpb24oKXt2YXIgQT1uZXcgWE1MSHR0cFJlcXVlc3Q7aWYoQS5vcGVuKCJIRUFEIixJLCExKSxBLnNlbmQobnVsbCksIShBLnN0YXR1cz49MjAwJiZBLnN0YXR1czwzMDB8fDMwND09PUEuc3RhdHVzKSl0aHJvdyBuZXcgRXJyb3IoIkNvdWxkbid0IGxvYWQgIitJKyIuIFN0YXR1czogIitBLnN0YXR1cyk7dmFyIEIsZz1OdW1iZXIoQS5nZXRSZXNwb25zZUhlYWRlcigiQ29udGVudC1sZW5ndGgiKSksUT0oQj1BLmdldFJlc3BvbnNlSGVhZGVyKCJBY2NlcHQtUmFuZ2VzIikpJiYiYnl0ZXMiPT09QixFPShCPUEuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtRW5jb2RpbmciKSkmJiJnemlwIj09PUIsQz0xMDQ4NTc2O1F8fChDPWcpO3ZhciBpPXRoaXM7aS5zZXREYXRhR2V0dGVyKChmdW5jdGlvbihBKXt2YXIgQj1BKkMsUT0oQSsxKSpDLTE7aWYoUT1NYXRoLm1pbihRLGctMSksdm9pZCAwPT09aS5jaHVua3NbQV0mJihpLmNodW5rc1tBXT1mdW5jdGlvbihBLEIpe2lmKEE+Qil0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgcmFuZ2UgKCIrQSsiLCAiK0IrIikgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkISIpO2lmKEI+Zy0xKXRocm93IG5ldyBFcnJvcigib25seSAiK2crIiBieXRlcyBhdmFpbGFibGUhIHByb2dyYW1tZXIgZXJyb3IhIik7dmFyIFE9bmV3IFhNTEh0dHBSZXF1ZXN0O2lmKFEub3BlbigiR0VUIixJLCExKSxnIT09QyYmUS5zZXRSZXF1ZXN0SGVhZGVyKCJSYW5nZSIsImJ5dGVzPSIrQSsiLSIrQiksInVuZGVmaW5lZCIhPXR5cGVvZiBVaW50OEFycmF5JiYoUS5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIiksUS5vdmVycmlkZU1pbWVUeXBlJiZRLm92ZXJyaWRlTWltZVR5cGUoInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQiKSxRLnNlbmQobnVsbCksIShRLnN0YXR1cz49MjAwJiZRLnN0YXR1czwzMDB8fDMwND09PVEuc3RhdHVzKSl0aHJvdyBuZXcgRXJyb3IoIkNvdWxkbid0IGxvYWQgIitJKyIuIFN0YXR1czogIitRLnN0YXR1cyk7cmV0dXJuIHZvaWQgMCE9PVEucmVzcG9uc2U/bmV3IFVpbnQ4QXJyYXkoUS5yZXNwb25zZXx8W10pOlRCKFEucmVzcG9uc2VUZXh0fHwiIiwhMCl9KEIsUSkpLHZvaWQgMD09PWkuY2h1bmtzW0FdKXRocm93IG5ldyBFcnJvcigiZG9YSFIgZmFpbGVkISIpO3JldHVybiBpLmNodW5rc1tBXX0pKSwhRSYmZ3x8KEM9Zz0xLGc9dGhpcy5nZXR0ZXIoMCkubGVuZ3RoLEM9Zyxjb25zb2xlLmxvZygiTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkIikpLHRoaXMuX2xlbmd0aD1nLHRoaXMuX2NodW5rU2l6ZT1DLHRoaXMubGVuZ3RoS25vd249ITB9LCJ1bmRlZmluZWQiIT10eXBlb2YgWE1MSHR0cFJlcXVlc3Qpe2lmKCFlKXRocm93IkNhbm5vdCBkbyBzeW5jaHJvbm91cyBiaW5hcnkgWEhScyBvdXRzaWRlIHdlYndvcmtlcnMgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2MiO3ZhciBDPW5ldyBFO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEMse2xlbmd0aDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RoS25vd258fHRoaXMuY2FjaGVMZW5ndGgoKSx0aGlzLl9sZW5ndGh9fSxjaHVua1NpemU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aEtub3dufHx0aGlzLmNhY2hlTGVuZ3RoKCksdGhpcy5fY2h1bmtTaXplfX19KTt2YXIgaT17aXNEZXZpY2U6ITEsY29udGVudHM6Q319ZWxzZSBpPXtpc0RldmljZTohMSx1cmw6SX07dmFyIG89ZEEuY3JlYXRlRmlsZShBLEIsaSxnLFEpO2kuY29udGVudHM/by5jb250ZW50cz1pLmNvbnRlbnRzOmkudXJsJiYoby5jb250ZW50cz1udWxsLG8udXJsPWkudXJsKSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvLHt1c2VkQnl0ZXM6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aH19fSk7dmFyIHQ9e307cmV0dXJuIE9iamVjdC5rZXlzKG8uc3RyZWFtX29wcykuZm9yRWFjaCgoZnVuY3Rpb24oQSl7dmFyIEI9by5zdHJlYW1fb3BzW0FdO3RbQV09ZnVuY3Rpb24oKXtpZighZEEuZm9yY2VMb2FkRmlsZShvKSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FSU8pO3JldHVybiBCLmFwcGx5KG51bGwsYXJndW1lbnRzKX19KSksdC5yZWFkPWZ1bmN0aW9uKEEsQixJLGcsUSl7aWYoIWRBLmZvcmNlTG9hZEZpbGUobykpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUlPKTt2YXIgRT1BLm5vZGUuY29udGVudHM7aWYoUT49RS5sZW5ndGgpcmV0dXJuIDA7dmFyIEM9TWF0aC5taW4oRS5sZW5ndGgtUSxnKTtpZih3KEM+PTApLEUuc2xpY2UpZm9yKHZhciBpPTA7aTxDO2krKylCW0kraV09RVtRK2ldO2Vsc2UgZm9yKGk9MDtpPEM7aSsrKUJbSStpXT1FLmdldChRK2kpO3JldHVybiBDfSxvLnN0cmVhbV9vcHM9dCxvfSxjcmVhdGVQcmVsb2FkZWRGaWxlOmZ1bmN0aW9uKEEsQixJLGcsUSxDLGksbyx0LGUpe0Jyb3dzZXIuaW5pdCgpO3ZhciByPUI/VUEucmVzb2x2ZShVQS5qb2luMihBLEIpKTpBO2Z1bmN0aW9uIGEoSSl7ZnVuY3Rpb24gYShJKXtlJiZlKCksb3x8ZEEuY3JlYXRlRGF0YUZpbGUoQSxCLEksZyxRLHQpLEMmJkMoKSxuQSgpfXZhciBuPSExO0UucHJlbG9hZFBsdWdpbnMuZm9yRWFjaCgoZnVuY3Rpb24oQSl7bnx8QS5jYW5IYW5kbGUocikmJihBLmhhbmRsZShJLHIsYSwoZnVuY3Rpb24oKXtpJiZpKCksbkEoKX0pKSxuPSEwKX0pKSxufHxhKEkpfWFBKCksInN0cmluZyI9PXR5cGVvZiBJP0Jyb3dzZXIuYXN5bmNMb2FkKEksKGZ1bmN0aW9uKEEpe2EoQSl9KSxpKTphKEkpfSxpbmRleGVkREI6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmluZGV4ZWREQnx8d2luZG93Lm1vekluZGV4ZWREQnx8d2luZG93LndlYmtpdEluZGV4ZWREQnx8d2luZG93Lm1zSW5kZXhlZERCfSxEQl9OQU1FOmZ1bmN0aW9uKCl7cmV0dXJuIkVNX0ZTXyIrd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfSxEQl9WRVJTSU9OOjIwLERCX1NUT1JFX05BTUU6IkZJTEVfREFUQSIsc2F2ZUZpbGVzVG9EQjpmdW5jdGlvbihBLEIsSSl7Qj1CfHxmdW5jdGlvbigpe30sST1JfHxmdW5jdGlvbigpe307dmFyIGc9ZEEuaW5kZXhlZERCKCk7dHJ5e3ZhciBRPWcub3BlbihkQS5EQl9OQU1FKCksZEEuREJfVkVSU0lPTil9Y2F0Y2goQSl7cmV0dXJuIEkoQSl9US5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZygiY3JlYXRpbmcgZGIiKSxRLnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZShkQS5EQl9TVE9SRV9OQU1FKX0sUS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgZz1RLnJlc3VsdC50cmFuc2FjdGlvbihbZEEuREJfU1RPUkVfTkFNRV0sInJlYWR3cml0ZSIpLEU9Zy5vYmplY3RTdG9yZShkQS5EQl9TVE9SRV9OQU1FKSxDPTAsaT0wLG89QS5sZW5ndGg7ZnVuY3Rpb24gdCgpezA9PWk/QigpOkkoKX1BLmZvckVhY2goKGZ1bmN0aW9uKEEpe3ZhciBCPUUucHV0KGRBLmFuYWx5emVQYXRoKEEpLm9iamVjdC5jb250ZW50cyxBKTtCLm9uc3VjY2Vzcz1mdW5jdGlvbigpeysrQytpPT1vJiZ0KCl9LEIub25lcnJvcj1mdW5jdGlvbigpe2krKyxDK2k9PW8mJnQoKX19KSksZy5vbmVycm9yPUl9LFEub25lcnJvcj1JfSxsb2FkRmlsZXNGcm9tREI6ZnVuY3Rpb24oQSxCLEkpe0I9Qnx8ZnVuY3Rpb24oKXt9LEk9SXx8ZnVuY3Rpb24oKXt9O3ZhciBnPWRBLmluZGV4ZWREQigpO3RyeXt2YXIgUT1nLm9wZW4oZEEuREJfTkFNRSgpLGRBLkRCX1ZFUlNJT04pfWNhdGNoKEEpe3JldHVybiBJKEEpfVEub251cGdyYWRlbmVlZGVkPUksUS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgZz1RLnJlc3VsdDt0cnl7dmFyIEU9Zy50cmFuc2FjdGlvbihbZEEuREJfU1RPUkVfTkFNRV0sInJlYWRvbmx5Iil9Y2F0Y2goQSl7cmV0dXJuIHZvaWQgSShBKX12YXIgQz1FLm9iamVjdFN0b3JlKGRBLkRCX1NUT1JFX05BTUUpLGk9MCxvPTAsdD1BLmxlbmd0aDtmdW5jdGlvbiBlKCl7MD09bz9CKCk6SSgpfUEuZm9yRWFjaCgoZnVuY3Rpb24oQSl7dmFyIEI9Qy5nZXQoQSk7Qi5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtkQS5hbmFseXplUGF0aChBKS5leGlzdHMmJmRBLnVubGluayhBKSxkQS5jcmVhdGVEYXRhRmlsZShVQS5kaXJuYW1lKEEpLFVBLmJhc2VuYW1lKEEpLEIucmVzdWx0LCEwLCEwLCEwKSwrK2krbz09dCYmZSgpfSxCLm9uZXJyb3I9ZnVuY3Rpb24oKXtvKyssaStvPT10JiZlKCl9fSkpLEUub25lcnJvcj1JfSxRLm9uZXJyb3I9SX19LE1BPXtERUZBVUxUX1BPTExNQVNLOjUsbWFwcGluZ3M6e30sdW1hc2s6NTExLGNhbGN1bGF0ZUF0OmZ1bmN0aW9uKEEsQil7aWYoIi8iIT09QlswXSl7dmFyIEk7aWYoLTEwMD09PUEpST1kQS5jd2QoKTtlbHNle3ZhciBnPWRBLmdldFN0cmVhbShBKTtpZighZyl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQkFERik7ST1nLnBhdGh9Qj1VQS5qb2luMihJLEIpfXJldHVybiBCfSxkb1N0YXQ6ZnVuY3Rpb24oQSxCLEkpe3RyeXt2YXIgZz1BKEIpfWNhdGNoKEEpe2lmKEEmJkEubm9kZSYmVUEubm9ybWFsaXplKEIpIT09VUEubm9ybWFsaXplKGRBLmdldFBhdGgoQS5ub2RlKSkpcmV0dXJuLWhBLkVOT1RESVI7dGhyb3cgQX1yZXR1cm4gSFtJPj4yXT1nLmRldixIW0krND4+Ml09MCxIW0krOD4+Ml09Zy5pbm8sSFtJKzEyPj4yXT1nLm1vZGUsSFtJKzE2Pj4yXT1nLm5saW5rLEhbSSsyMD4+Ml09Zy51aWQsSFtJKzI0Pj4yXT1nLmdpZCxIW0krMjg+PjJdPWcucmRldixIW0krMzI+PjJdPTAsSFtJKzM2Pj4yXT1nLnNpemUsSFtJKzQwPj4yXT00MDk2LEhbSSs0ND4+Ml09Zy5ibG9ja3MsSFtJKzQ4Pj4yXT1nLmF0aW1lLmdldFRpbWUoKS8xZTN8MCxIW0krNTI+PjJdPTAsSFtJKzU2Pj4yXT1nLm10aW1lLmdldFRpbWUoKS8xZTN8MCxIW0krNjA+PjJdPTAsSFtJKzY0Pj4yXT1nLmN0aW1lLmdldFRpbWUoKS8xZTN8MCxIW0krNjg+PjJdPTAsSFtJKzcyPj4yXT1nLmlubywwfSxkb01zeW5jOmZ1bmN0aW9uKEEsQixJLGcpe3ZhciBRPW5ldyBVaW50OEFycmF5KEwuc3ViYXJyYXkoQSxBK0kpKTtkQS5tc3luYyhCLFEsMCxJLGcpfSxkb01rZGlyOmZ1bmN0aW9uKEEsQil7cmV0dXJuIi8iPT09KEE9VUEubm9ybWFsaXplKEEpKVtBLmxlbmd0aC0xXSYmKEE9QS5zdWJzdHIoMCxBLmxlbmd0aC0xKSksZEEubWtkaXIoQSxCLDApLDB9LGRvTWtub2Q6ZnVuY3Rpb24oQSxCLEkpe3N3aXRjaCg2MTQ0MCZCKXtjYXNlIDMyNzY4OmNhc2UgODE5MjpjYXNlIDI0NTc2OmNhc2UgNDA5NjpjYXNlIDQ5MTUyOmJyZWFrO2RlZmF1bHQ6cmV0dXJuLWhBLkVJTlZBTH1yZXR1cm4gZEEubWtub2QoQSxCLEkpLDB9LGRvUmVhZGxpbms6ZnVuY3Rpb24oQSxCLEkpe2lmKEk8PTApcmV0dXJuLWhBLkVJTlZBTDt2YXIgZz1kQS5yZWFkbGluayhBKSxRPU1hdGgubWluKEksZihnKSksRT11W0IrUV07cmV0dXJuIGsoZyxCLEkrMSksdVtCK1FdPUUsUX0sZG9BY2Nlc3M6ZnVuY3Rpb24oQSxCKXtpZigtOCZCKXJldHVybi1oQS5FSU5WQUw7dmFyIEk7ST1kQS5sb29rdXBQYXRoKEEse2ZvbGxvdzohMH0pLm5vZGU7dmFyIGc9IiI7cmV0dXJuIDQmQiYmKGcrPSJyIiksMiZCJiYoZys9InciKSwxJkImJihnKz0ieCIpLGcmJmRBLm5vZGVQZXJtaXNzaW9ucyhJLGcpPy1oQS5FQUNDRVM6MH0sZG9EdXA6ZnVuY3Rpb24oQSxCLEkpe3ZhciBnPWRBLmdldFN0cmVhbShJKTtyZXR1cm4gZyYmZEEuY2xvc2UoZyksZEEub3BlbihBLEIsMCxJLEkpLmZkfSxkb1JlYWR2OmZ1bmN0aW9uKEEsQixJLGcpe2Zvcih2YXIgUT0wLEU9MDtFPEk7RSsrKXt2YXIgQz1IW0IrOCpFPj4yXSxpPUhbQisoOCpFKzQpPj4yXSxvPWRBLnJlYWQoQSx1LEMsaSxnKTtpZihvPDApcmV0dXJuLTE7aWYoUSs9byxvPGkpYnJlYWt9cmV0dXJuIFF9LGRvV3JpdGV2OmZ1bmN0aW9uKEEsQixJLGcpe2Zvcih2YXIgUT0wLEU9MDtFPEk7RSsrKXt2YXIgQz1IW0IrOCpFPj4yXSxpPUhbQisoOCpFKzQpPj4yXSxvPWRBLndyaXRlKEEsdSxDLGksZyk7aWYobzwwKXJldHVybi0xO1ErPW99cmV0dXJuIFF9LHZhcmFyZ3M6MCxnZXQ6ZnVuY3Rpb24oQSl7cmV0dXJuIE1BLnZhcmFyZ3MrPTQsSFtNQS52YXJhcmdzLTQ+PjJdfSxnZXRTdHI6ZnVuY3Rpb24oKXtyZXR1cm4geShNQS5nZXQoKSl9LGdldFN0cmVhbUZyb21GRDpmdW5jdGlvbigpe3ZhciBBPWRBLmdldFN0cmVhbShNQS5nZXQoKSk7aWYoIUEpdGhyb3cgbmV3IGRBLkVycm5vRXJyb3IoaEEuRUJBREYpO3JldHVybiBBfSxnZXRTb2NrZXRGcm9tRkQ6ZnVuY3Rpb24oKXt2YXIgQT1TT0NLRlMuZ2V0U29ja2V0KE1BLmdldCgpKTtpZighQSl0aHJvdyBuZXcgZEEuRXJybm9FcnJvcihoQS5FQkFERik7cmV0dXJuIEF9LGdldFNvY2tldEFkZHJlc3M6ZnVuY3Rpb24oQSl7dmFyIEI9TUEuZ2V0KCksST1NQS5nZXQoKTtpZihBJiYwPT09QilyZXR1cm4gbnVsbDt2YXIgZz1fX3JlYWRfc29ja2FkZHIoQixJKTtpZihnLmVycm5vKXRocm93IG5ldyBkQS5FcnJub0Vycm9yKGcuZXJybm8pO3JldHVybiBnLmFkZHI9RE5TLmxvb2t1cF9hZGRyKGcuYWRkcil8fGcuYWRkcixnfSxnZXQ2NDpmdW5jdGlvbigpe3ZhciBBPU1BLmdldCgpLEI9TUEuZ2V0KCk7cmV0dXJuIHcoQT49MD8wPT09QjotMT09PUIpLEF9LGdldFplcm86ZnVuY3Rpb24oKXt3KDA9PT1NQS5nZXQoKSl9fTt2YXIgdUE9NDI7dmFyIExBPXt9O2Z1bmN0aW9uIEpBKEEpe2Zvcig7QS5sZW5ndGg7KXt2YXIgQj1BLnBvcCgpO0EucG9wKCkoQil9fWZ1bmN0aW9uIGxBKEEpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShZW0E+PjJdKX12YXIgSEE9e30sWUE9e30scUE9e307ZnVuY3Rpb24gcEEoQSl7aWYodm9pZCAwPT09QSlyZXR1cm4iX3Vua25vd24iO3ZhciBCPShBPUEucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCIkIikpLmNoYXJDb2RlQXQoMCk7cmV0dXJuIEI+PTQ4JiZCPD01Nz8iXyIrQTpBfWZ1bmN0aW9uIEtBKEEsQil7cmV0dXJuIEE9cEEoQSksbmV3IEZ1bmN0aW9uKCJib2R5IiwicmV0dXJuIGZ1bmN0aW9uICIrQSsnKCkge1xuICAgICJ1c2Ugc3RyaWN0IjsgICAgcmV0dXJuIGJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4nKShCKX1mdW5jdGlvbiBtQShBLEIpe3ZhciBJPUtBKEIsKGZ1bmN0aW9uKEEpe3RoaXMubmFtZT1CLHRoaXMubWVzc2FnZT1BO3ZhciBJPW5ldyBFcnJvcihBKS5zdGFjazt2b2lkIDAhPT1JJiYodGhpcy5zdGFjaz10aGlzLnRvU3RyaW5nKCkrIlxuIitJLnJlcGxhY2UoL15FcnJvcig6W15cbl0qKT9cbi8sIiIpKX0pKTtyZXR1cm4gSS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShBLnByb3RvdHlwZSksSS5wcm90b3R5cGUuY29uc3RydWN0b3I9SSxJLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT10aGlzLm1lc3NhZ2U/dGhpcy5uYW1lOnRoaXMubmFtZSsiOiAiK3RoaXMubWVzc2FnZX0sSX12YXIgeEE9dm9pZCAwO2Z1bmN0aW9uIHZBKEEpe3Rocm93IG5ldyB4QShBKX1mdW5jdGlvbiBiQShBLEIsSSl7ZnVuY3Rpb24gZyhCKXt2YXIgZz1JKEIpO2cubGVuZ3RoIT09QS5sZW5ndGgmJnZBKCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50Iik7Zm9yKHZhciBRPTA7UTxBLmxlbmd0aDsrK1EpakEoQVtRXSxnW1FdKX1BLmZvckVhY2goKGZ1bmN0aW9uKEEpe3FBW0FdPUJ9KSk7dmFyIFE9bmV3IEFycmF5KEIubGVuZ3RoKSxFPVtdLEM9MDtCLmZvckVhY2goKGZ1bmN0aW9uKEEsQil7WUEuaGFzT3duUHJvcGVydHkoQSk/UVtCXT1ZQVtBXTooRS5wdXNoKEEpLEhBLmhhc093blByb3BlcnR5KEEpfHwoSEFbQV09W10pLEhBW0FdLnB1c2goKGZ1bmN0aW9uKCl7UVtCXT1ZQVtBXSwrK0M9PT1FLmxlbmd0aCYmZyhRKX0pKSl9KSksMD09PUUubGVuZ3RoJiZnKFEpfWZ1bmN0aW9uIFdBKEEpe3N3aXRjaChBKXtjYXNlIDE6cmV0dXJuIDA7Y2FzZSAyOnJldHVybiAxO2Nhc2UgNDpyZXR1cm4gMjtjYXNlIDg6cmV0dXJuIDM7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIHR5cGUgc2l6ZTogIitBKX19dmFyIFhBPXZvaWQgMDtmdW5jdGlvbiBWQShBKXtmb3IodmFyIEI9IiIsST1BO0xbSV07KUIrPVhBW0xbSSsrXV07cmV0dXJuIEJ9dmFyIE9BPXZvaWQgMDtmdW5jdGlvbiBUQShBKXt0aHJvdyBuZXcgT0EoQSl9ZnVuY3Rpb24gakEoQSxCLEkpe2lmKEk9SXx8e30sISgiYXJnUGFja0FkdmFuY2UiaW4gQikpdGhyb3cgbmV3IFR5cGVFcnJvcigicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZSIpO3ZhciBnPUIubmFtZTtpZihBfHxUQSgndHlwZSAiJytnKyciIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXInKSxZQS5oYXNPd25Qcm9wZXJ0eShBKSl7aWYoSS5pZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zKXJldHVybjtUQSgiQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyIrZysiJyB0d2ljZSIpfWlmKFlBW0FdPUIsZGVsZXRlIHFBW0FdLEhBLmhhc093blByb3BlcnR5KEEpKXt2YXIgUT1IQVtBXTtkZWxldGUgSEFbQV0sUS5mb3JFYWNoKChmdW5jdGlvbihBKXtBKCl9KSl9fWZ1bmN0aW9uIFpBKEEpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFFCKSlyZXR1cm4hMTtpZighKEEgaW5zdGFuY2VvZiBRQikpcmV0dXJuITE7Zm9yKHZhciBCPXRoaXMuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MsST10aGlzLiQkLnB0cixnPUEuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MsUT1BLiQkLnB0cjtCLmJhc2VDbGFzczspST1CLnVwY2FzdChJKSxCPUIuYmFzZUNsYXNzO2Zvcig7Zy5iYXNlQ2xhc3M7KVE9Zy51cGNhc3QoUSksZz1nLmJhc2VDbGFzcztyZXR1cm4gQj09PWcmJkk9PT1RfWZ1bmN0aW9uIFBBKEEpe1RBKEEuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MubmFtZSsiIGluc3RhbmNlIGFscmVhZHkgZGVsZXRlZCIpfWZ1bmN0aW9uIHpBKCl7aWYodGhpcy4kJC5wdHJ8fFBBKHRoaXMpLHRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpcmV0dXJuIHRoaXMuJCQuY291bnQudmFsdWUrPTEsdGhpczt2YXIgQSxCPU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLHskJDp7dmFsdWU6KEE9dGhpcy4kJCx7Y291bnQ6QS5jb3VudCxkZWxldGVTY2hlZHVsZWQ6QS5kZWxldGVTY2hlZHVsZWQscHJlc2VydmVQb2ludGVyT25EZWxldGU6QS5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSxwdHI6QS5wdHIscHRyVHlwZTpBLnB0clR5cGUsc21hcnRQdHI6QS5zbWFydFB0cixzbWFydFB0clR5cGU6QS5zbWFydFB0clR5cGV9KX19KTtyZXR1cm4gQi4kJC5jb3VudC52YWx1ZSs9MSxCLiQkLmRlbGV0ZVNjaGVkdWxlZD0hMSxCfWZ1bmN0aW9uIF9BKCl7dmFyIEE7dGhpcy4kJC5wdHJ8fFBBKHRoaXMpLHRoaXMuJCQuZGVsZXRlU2NoZWR1bGVkJiYhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSYmVEEoIk9iamVjdCBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgZGVsZXRpb24iKSx0aGlzLiQkLmNvdW50LnZhbHVlLT0xLDA9PT10aGlzLiQkLmNvdW50LnZhbHVlJiYoKEE9dGhpcy4kJCkuc21hcnRQdHI/QS5zbWFydFB0clR5cGUucmF3RGVzdHJ1Y3RvcihBLnNtYXJ0UHRyKTpBLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLnJhd0Rlc3RydWN0b3IoQS5wdHIpKSx0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlfHwodGhpcy4kJC5zbWFydFB0cj12b2lkIDAsdGhpcy4kJC5wdHI9dm9pZCAwKX1mdW5jdGlvbiAkQSgpe3JldHVybiF0aGlzLiQkLnB0cn12YXIgQUI9dm9pZCAwLEJCPVtdO2Z1bmN0aW9uIElCKCl7Zm9yKDtCQi5sZW5ndGg7KXt2YXIgQT1CQi5wb3AoKTtBLiQkLmRlbGV0ZVNjaGVkdWxlZD0hMSxBLmRlbGV0ZSgpfX1mdW5jdGlvbiBnQigpe3JldHVybiB0aGlzLiQkLnB0cnx8UEEodGhpcyksdGhpcy4kJC5kZWxldGVTY2hlZHVsZWQmJiF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlJiZUQSgiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbiIpLEJCLnB1c2godGhpcyksMT09PUJCLmxlbmd0aCYmQUImJkFCKElCKSx0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZD0hMCx0aGlzfWZ1bmN0aW9uIFFCKCl7fXZhciBFQj17fTtmdW5jdGlvbiBDQihBLEIsSSl7aWYodm9pZCAwPT09QVtCXS5vdmVybG9hZFRhYmxlKXt2YXIgZz1BW0JdO0FbQl09ZnVuY3Rpb24oKXtyZXR1cm4gQVtCXS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KGFyZ3VtZW50cy5sZW5ndGgpfHxUQSgiRnVuY3Rpb24gJyIrSSsiJyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCIrYXJndW1lbnRzLmxlbmd0aCsiKSAtIGV4cGVjdHMgb25lIG9mICgiK0FbQl0ub3ZlcmxvYWRUYWJsZSsiKSEiKSxBW0JdLm92ZXJsb2FkVGFibGVbYXJndW1lbnRzLmxlbmd0aF0uYXBwbHkodGhpcyxhcmd1bWVudHMpfSxBW0JdLm92ZXJsb2FkVGFibGU9W10sQVtCXS5vdmVybG9hZFRhYmxlW2cuYXJnQ291bnRdPWd9fWZ1bmN0aW9uIGlCKEEsQixJLGcsUSxFLEMsaSl7dGhpcy5uYW1lPUEsdGhpcy5jb25zdHJ1Y3Rvcj1CLHRoaXMuaW5zdGFuY2VQcm90b3R5cGU9SSx0aGlzLnJhd0Rlc3RydWN0b3I9Zyx0aGlzLmJhc2VDbGFzcz1RLHRoaXMuZ2V0QWN0dWFsVHlwZT1FLHRoaXMudXBjYXN0PUMsdGhpcy5kb3duY2FzdD1pLHRoaXMucHVyZVZpcnR1YWxGdW5jdGlvbnM9W119ZnVuY3Rpb24gb0IoQSxCLEkpe2Zvcig7QiE9PUk7KUIudXBjYXN0fHxUQSgiRXhwZWN0ZWQgbnVsbCBvciBpbnN0YW5jZSBvZiAiK0kubmFtZSsiLCBnb3QgYW4gaW5zdGFuY2Ugb2YgIitCLm5hbWUpLEE9Qi51cGNhc3QoQSksQj1CLmJhc2VDbGFzcztyZXR1cm4gQX1mdW5jdGlvbiB0QihBLEIpe2lmKG51bGw9PT1CKXJldHVybiB0aGlzLmlzUmVmZXJlbmNlJiZUQSgibnVsbCBpcyBub3QgYSB2YWxpZCAiK3RoaXMubmFtZSksMDtCLiQkfHxUQSgnQ2Fubm90IHBhc3MgIicrWUIoQikrJyIgYXMgYSAnK3RoaXMubmFtZSksQi4kJC5wdHJ8fFRBKCJDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAiK3RoaXMubmFtZSk7dmFyIEk9Qi4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcztyZXR1cm4gb0IoQi4kJC5wdHIsSSx0aGlzLnJlZ2lzdGVyZWRDbGFzcyl9ZnVuY3Rpb24gZUIoQSxCKXt2YXIgSTtpZihudWxsPT09QilyZXR1cm4gdGhpcy5pc1JlZmVyZW5jZSYmVEEoIm51bGwgaXMgbm90IGEgdmFsaWQgIit0aGlzLm5hbWUpLHRoaXMuaXNTbWFydFBvaW50ZXI/KEk9dGhpcy5yYXdDb25zdHJ1Y3RvcigpLG51bGwhPT1BJiZBLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLEkpLEkpOjA7Qi4kJHx8VEEoJ0Nhbm5vdCBwYXNzICInK1lCKEIpKyciIGFzIGEgJyt0aGlzLm5hbWUpLEIuJCQucHRyfHxUQSgiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgIit0aGlzLm5hbWUpLCF0aGlzLmlzQ29uc3QmJkIuJCQucHRyVHlwZS5pc0NvbnN0JiZUQSgiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAiKyhCLiQkLnNtYXJ0UHRyVHlwZT9CLiQkLnNtYXJ0UHRyVHlwZS5uYW1lOkIuJCQucHRyVHlwZS5uYW1lKSsiIHRvIHBhcmFtZXRlciB0eXBlICIrdGhpcy5uYW1lKTt2YXIgZz1CLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO2lmKEk9b0IoQi4kJC5wdHIsZyx0aGlzLnJlZ2lzdGVyZWRDbGFzcyksdGhpcy5pc1NtYXJ0UG9pbnRlcilzd2l0Y2godm9pZCAwPT09Qi4kJC5zbWFydFB0ciYmVEEoIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsIiksdGhpcy5zaGFyaW5nUG9saWN5KXtjYXNlIDA6Qi4kJC5zbWFydFB0clR5cGU9PT10aGlzP0k9Qi4kJC5zbWFydFB0cjpUQSgiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAiKyhCLiQkLnNtYXJ0UHRyVHlwZT9CLiQkLnNtYXJ0UHRyVHlwZS5uYW1lOkIuJCQucHRyVHlwZS5uYW1lKSsiIHRvIHBhcmFtZXRlciB0eXBlICIrdGhpcy5uYW1lKTticmVhaztjYXNlIDE6ST1CLiQkLnNtYXJ0UHRyO2JyZWFrO2Nhc2UgMjppZihCLiQkLnNtYXJ0UHRyVHlwZT09PXRoaXMpST1CLiQkLnNtYXJ0UHRyO2Vsc2V7dmFyIFE9Qi5jbG9uZSgpO0k9dGhpcy5yYXdTaGFyZShJLEhCKChmdW5jdGlvbigpe1EuZGVsZXRlKCl9KSkpLG51bGwhPT1BJiZBLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLEkpfWJyZWFrO2RlZmF1bHQ6VEEoIlVuc3VwcG9ydGluZyBzaGFyaW5nIHBvbGljeSIpfXJldHVybiBJfWZ1bmN0aW9uIHJCKEEsQil7aWYobnVsbD09PUIpcmV0dXJuIHRoaXMuaXNSZWZlcmVuY2UmJlRBKCJudWxsIGlzIG5vdCBhIHZhbGlkICIrdGhpcy5uYW1lKSwwO0IuJCR8fFRBKCdDYW5ub3QgcGFzcyAiJytZQihCKSsnIiBhcyBhICcrdGhpcy5uYW1lKSxCLiQkLnB0cnx8VEEoIkNhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICIrdGhpcy5uYW1lKSxCLiQkLnB0clR5cGUuaXNDb25zdCYmVEEoIkNhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgIitCLiQkLnB0clR5cGUubmFtZSsiIHRvIHBhcmFtZXRlciB0eXBlICIrdGhpcy5uYW1lKTt2YXIgST1CLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO3JldHVybiBvQihCLiQkLnB0cixJLHRoaXMucmVnaXN0ZXJlZENsYXNzKX1mdW5jdGlvbiBhQihBKXtyZXR1cm4gdGhpcy5yYXdHZXRQb2ludGVlJiYoQT10aGlzLnJhd0dldFBvaW50ZWUoQSkpLEF9ZnVuY3Rpb24gbkIoQSl7dGhpcy5yYXdEZXN0cnVjdG9yJiZ0aGlzLnJhd0Rlc3RydWN0b3IoQSl9ZnVuY3Rpb24gc0IoQSl7bnVsbCE9PUEmJkEuZGVsZXRlKCl9ZnVuY3Rpb24gREIoQSxCLEkpe2lmKEI9PT1JKXJldHVybiBBO2lmKHZvaWQgMD09PUkuYmFzZUNsYXNzKXJldHVybiBudWxsO3ZhciBnPURCKEEsQixJLmJhc2VDbGFzcyk7cmV0dXJuIG51bGw9PT1nP251bGw6SS5kb3duY2FzdChnKX1mdW5jdGlvbiBGQigpe3JldHVybiBPYmplY3Qua2V5cyhoQikubGVuZ3RofWZ1bmN0aW9uIHdCKCl7dmFyIEE9W107Zm9yKHZhciBCIGluIGhCKWhCLmhhc093blByb3BlcnR5KEIpJiZBLnB1c2goaEJbQl0pO3JldHVybiBBfWZ1bmN0aW9uIGNCKEEpe0FCPUEsQkIubGVuZ3RoJiZBQiYmQUIoSUIpfXZhciBoQj17fTtmdW5jdGlvbiB5QihBLEIpe3JldHVybiBCPWZ1bmN0aW9uKEEsQil7Zm9yKHZvaWQgMD09PUImJlRBKCJwdHIgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQiKTtBLmJhc2VDbGFzczspQj1BLnVwY2FzdChCKSxBPUEuYmFzZUNsYXNzO3JldHVybiBCfShBLEIpLGhCW0JdfWZ1bmN0aW9uIFJCKEEsQil7cmV0dXJuIEIucHRyVHlwZSYmQi5wdHJ8fHZBKCJtYWtlQ2xhc3NIYW5kbGUgcmVxdWlyZXMgcHRyIGFuZCBwdHJUeXBlIiksISFCLnNtYXJ0UHRyVHlwZSE9PSEhQi5zbWFydFB0ciYmdkEoIkJvdGggc21hcnRQdHJUeXBlIGFuZCBzbWFydFB0ciBtdXN0IGJlIHNwZWNpZmllZCIpLEIuY291bnQ9e3ZhbHVlOjF9LE9iamVjdC5jcmVhdGUoQSx7JCQ6e3ZhbHVlOkJ9fSl9ZnVuY3Rpb24gVUIoQSl7dmFyIEI9dGhpcy5nZXRQb2ludGVlKEEpO2lmKCFCKXJldHVybiB0aGlzLmRlc3RydWN0b3IoQSksbnVsbDt2YXIgST15Qih0aGlzLnJlZ2lzdGVyZWRDbGFzcyxCKTtpZih2b2lkIDAhPT1JKXtpZigwPT09SS4kJC5jb3VudC52YWx1ZSlyZXR1cm4gSS4kJC5wdHI9QixJLiQkLnNtYXJ0UHRyPUEsSS5jbG9uZSgpO3ZhciBnPUkuY2xvbmUoKTtyZXR1cm4gdGhpcy5kZXN0cnVjdG9yKEEpLGd9ZnVuY3Rpb24gUSgpe3JldHVybiB0aGlzLmlzU21hcnRQb2ludGVyP1JCKHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLHtwdHJUeXBlOnRoaXMucG9pbnRlZVR5cGUscHRyOkIsc21hcnRQdHJUeXBlOnRoaXMsc21hcnRQdHI6QX0pOlJCKHRoaXMucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLHtwdHJUeXBlOnRoaXMscHRyOkF9KX12YXIgRSxDPXRoaXMucmVnaXN0ZXJlZENsYXNzLmdldEFjdHVhbFR5cGUoQiksaT1FQltDXTtpZighaSlyZXR1cm4gUS5jYWxsKHRoaXMpO0U9dGhpcy5pc0NvbnN0P2kuY29uc3RQb2ludGVyVHlwZTppLnBvaW50ZXJUeXBlO3ZhciBvPURCKEIsdGhpcy5yZWdpc3RlcmVkQ2xhc3MsRS5yZWdpc3RlcmVkQ2xhc3MpO3JldHVybiBudWxsPT09bz9RLmNhbGwodGhpcyk6dGhpcy5pc1NtYXJ0UG9pbnRlcj9SQihFLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTpFLHB0cjpvLHNtYXJ0UHRyVHlwZTp0aGlzLHNtYXJ0UHRyOkF9KTpSQihFLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTpFLHB0cjpvfSl9ZnVuY3Rpb24gR0IoQSxCLEksZyxRLEUsQyxpLG8sdCxlKXt0aGlzLm5hbWU9QSx0aGlzLnJlZ2lzdGVyZWRDbGFzcz1CLHRoaXMuaXNSZWZlcmVuY2U9SSx0aGlzLmlzQ29uc3Q9Zyx0aGlzLmlzU21hcnRQb2ludGVyPVEsdGhpcy5wb2ludGVlVHlwZT1FLHRoaXMuc2hhcmluZ1BvbGljeT1DLHRoaXMucmF3R2V0UG9pbnRlZT1pLHRoaXMucmF3Q29uc3RydWN0b3I9byx0aGlzLnJhd1NoYXJlPXQsdGhpcy5yYXdEZXN0cnVjdG9yPWUsUXx8dm9pZCAwIT09Qi5iYXNlQ2xhc3M/dGhpcy50b1dpcmVUeXBlPWVCOmc/KHRoaXMudG9XaXJlVHlwZT10Qix0aGlzLmRlc3RydWN0b3JGdW5jdGlvbj1udWxsKToodGhpcy50b1dpcmVUeXBlPXJCLHRoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uPW51bGwpfWZ1bmN0aW9uIFNCKEEsQil7dmFyIEk7aWYoQT1WQShBKSx2b2lkIDAhPT1FWyJGVU5DVElPTl9UQUJMRV8iK0FdKUk9RVsiRlVOQ1RJT05fVEFCTEVfIitBXVtCXTtlbHNlIGlmKCJ1bmRlZmluZWQiIT10eXBlb2YgRlVOQ1RJT05fVEFCTEUpST1GVU5DVElPTl9UQUJMRVtCXTtlbHNle3ZhciBnPUUuYXNtWyJkeW5DYWxsXyIrQV07dm9pZCAwPT09ZyYmdm9pZCAwPT09KGc9RS5hc21bImR5bkNhbGxfIitBLnJlcGxhY2UoL2YvZywiZCIpXSkmJlRBKCJObyBkeW5DYWxsIGludm9rZXIgZm9yIHNpZ25hdHVyZTogIitBKSxJPWZ1bmN0aW9uKEkpe2Zvcih2YXIgZz1bXSxRPTE7UTxBLmxlbmd0aDsrK1EpZy5wdXNoKCJhIitRKTt2YXIgRT0icmV0dXJuIGZ1bmN0aW9uIGR5bkNhbGxfIitBKyJfIitCKyIoIitnLmpvaW4oIiwgIikrIikge1xuIjtyZXR1cm4gRSs9IiAgICByZXR1cm4gZHluQ2FsbChyYXdGdW5jdGlvbiIrKGcubGVuZ3RoPyIsICI6IiIpK2cuam9pbigiLCAiKSsiKTtcbiIsRSs9In07XG4iLG5ldyBGdW5jdGlvbigiZHluQ2FsbCIsInJhd0Z1bmN0aW9uIixFKShJLEIpfShnKX1yZXR1cm4iZnVuY3Rpb24iIT10eXBlb2YgSSYmVEEoInVua25vd24gZnVuY3Rpb24gcG9pbnRlciB3aXRoIHNpZ25hdHVyZSAiK0ErIjogIitCKSxJfXZhciBrQj12b2lkIDA7ZnVuY3Rpb24gZkIoQSl7dmFyIEI9JEIoQSksST1WQShCKTtyZXR1cm4gQkkoQiksSX1mdW5jdGlvbiBOQihBLEIpe3ZhciBJPVtdLGc9e307dGhyb3cgQi5mb3JFYWNoKChmdW5jdGlvbiBBKEIpe2dbQl18fFlBW0JdfHwocUFbQl0/cUFbQl0uZm9yRWFjaChBKTooSS5wdXNoKEIpLGdbQl09ITApKX0pKSxuZXcga0IoQSsiOiAiK0kubWFwKGZCKS5qb2luKFsiLCAiXSkpfWZ1bmN0aW9uIGRCKEEsQil7Zm9yKHZhciBJPVtdLGc9MDtnPEE7ZysrKUkucHVzaChIWyhCPj4yKStnXSk7cmV0dXJuIEl9ZnVuY3Rpb24gTUIoQSxCLEksZyxRKXt2YXIgRT1CLmxlbmd0aDtFPDImJlRBKCJhcmdUeXBlcyBhcnJheSBzaXplIG1pc21hdGNoISBNdXN0IGF0IGxlYXN0IGdldCByZXR1cm4gdmFsdWUgYW5kICd0aGlzJyB0eXBlcyEiKTtmb3IodmFyIEM9bnVsbCE9PUJbMV0mJm51bGwhPT1JLGk9ITEsbz0xO288Qi5sZW5ndGg7KytvKWlmKG51bGwhPT1CW29dJiZ2b2lkIDA9PT1CW29dLmRlc3RydWN0b3JGdW5jdGlvbil7aT0hMDticmVha312YXIgdD0idm9pZCIhPT1CWzBdLm5hbWUsZT0iIixyPSIiO2ZvcihvPTA7bzxFLTI7KytvKWUrPSgwIT09bz8iLCAiOiIiKSsiYXJnIitvLHIrPSgwIT09bz8iLCAiOiIiKSsiYXJnIitvKyJXaXJlZCI7dmFyIGE9InJldHVybiBmdW5jdGlvbiAiK3BBKEEpKyIoIitlKyIpIHtcbmlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAiKyhFLTIpKyIpIHtcbnRocm93QmluZGluZ0Vycm9yKCdmdW5jdGlvbiAiK0ErIiBjYWxsZWQgd2l0aCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLCBleHBlY3RlZCAiKyhFLTIpKyIgYXJncyEnKTtcbn1cbiI7aSYmKGErPSJ2YXIgZGVzdHJ1Y3RvcnMgPSBbXTtcbiIpO3ZhciBuPWk/ImRlc3RydWN0b3JzIjoibnVsbCIscz1bInRocm93QmluZGluZ0Vycm9yIiwiaW52b2tlciIsImZuIiwicnVuRGVzdHJ1Y3RvcnMiLCJyZXRUeXBlIiwiY2xhc3NQYXJhbSJdLEQ9W1RBLGcsUSxKQSxCWzBdLEJbMV1dO0MmJihhKz0idmFyIHRoaXNXaXJlZCA9IGNsYXNzUGFyYW0udG9XaXJlVHlwZSgiK24rIiwgdGhpcyk7XG4iKTtmb3Iobz0wO288RS0yOysrbylhKz0idmFyIGFyZyIrbysiV2lyZWQgPSBhcmdUeXBlIitvKyIudG9XaXJlVHlwZSgiK24rIiwgYXJnIitvKyIpOyAvLyAiK0JbbysyXS5uYW1lKyJcbiIscy5wdXNoKCJhcmdUeXBlIitvKSxELnB1c2goQltvKzJdKTtpZihDJiYocj0idGhpc1dpcmVkIisoci5sZW5ndGg+MD8iLCAiOiIiKStyKSxhKz0odD8idmFyIHJ2ID0gIjoiIikrImludm9rZXIoZm4iKyhyLmxlbmd0aD4wPyIsICI6IiIpK3IrIik7XG4iLGkpYSs9InJ1bkRlc3RydWN0b3JzKGRlc3RydWN0b3JzKTtcbiI7ZWxzZSBmb3Iobz1DPzE6MjtvPEIubGVuZ3RoOysrbyl7dmFyIEY9MT09PW8/InRoaXNXaXJlZCI6ImFyZyIrKG8tMikrIldpcmVkIjtudWxsIT09QltvXS5kZXN0cnVjdG9yRnVuY3Rpb24mJihhKz1GKyJfZHRvcigiK0YrIik7IC8vICIrQltvXS5uYW1lKyJcbiIscy5wdXNoKEYrIl9kdG9yIiksRC5wdXNoKEJbb10uZGVzdHJ1Y3RvckZ1bmN0aW9uKSl9cmV0dXJuIHQmJihhKz0idmFyIHJldCA9IHJldFR5cGUuZnJvbVdpcmVUeXBlKHJ2KTtcbnJldHVybiByZXQ7XG4iKSxhKz0ifVxuIixzLnB1c2goYSksZnVuY3Rpb24oQSxCKXtpZighKEEgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcigibmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICIrdHlwZW9mIEErIiB3aGljaCBpcyBub3QgYSBmdW5jdGlvbiIpO3ZhciBJPUtBKEEubmFtZXx8InVua25vd25GdW5jdGlvbk5hbWUiLChmdW5jdGlvbigpe30pKTtJLnByb3RvdHlwZT1BLnByb3RvdHlwZTt2YXIgZz1uZXcgSSxRPUEuYXBwbHkoZyxCKTtyZXR1cm4gUSBpbnN0YW5jZW9mIE9iamVjdD9ROmd9KEZ1bmN0aW9uLHMpLmFwcGx5KG51bGwsRCl9dmFyIHVCPVtdLExCPVt7fSx7dmFsdWU6dm9pZCAwfSx7dmFsdWU6bnVsbH0se3ZhbHVlOiEwfSx7dmFsdWU6ITF9XTtmdW5jdGlvbiBKQigpe2Zvcih2YXIgQT0wLEI9NTtCPExCLmxlbmd0aDsrK0Ipdm9pZCAwIT09TEJbQl0mJisrQTtyZXR1cm4gQX1mdW5jdGlvbiBsQigpe2Zvcih2YXIgQT01O0E8TEIubGVuZ3RoOysrQSlpZih2b2lkIDAhPT1MQltBXSlyZXR1cm4gTEJbQV07cmV0dXJuIG51bGx9ZnVuY3Rpb24gSEIoQSl7c3dpdGNoKEEpe2Nhc2Ugdm9pZCAwOnJldHVybiAxO2Nhc2UgbnVsbDpyZXR1cm4gMjtjYXNlITA6cmV0dXJuIDM7Y2FzZSExOnJldHVybiA0O2RlZmF1bHQ6dmFyIEI9dUIubGVuZ3RoP3VCLnBvcCgpOkxCLmxlbmd0aDtyZXR1cm4gTEJbQl09e3JlZmNvdW50OjEsdmFsdWU6QX0sQn19ZnVuY3Rpb24gWUIoQSl7aWYobnVsbD09PUEpcmV0dXJuIm51bGwiO3ZhciBCPXR5cGVvZiBBO3JldHVybiJvYmplY3QiPT09Qnx8ImFycmF5Ij09PUJ8fCJmdW5jdGlvbiI9PT1CP0EudG9TdHJpbmcoKToiIitBfWZ1bmN0aW9uIHFCKEEsQil7c3dpdGNoKEIpe2Nhc2UgMjpyZXR1cm4gZnVuY3Rpb24oQSl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHFbQT4+Ml0pfTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKEEpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShwW0E+PjNdKX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGZsb2F0IHR5cGU6ICIrQSl9fWZ1bmN0aW9uIHBCKEEsQixJKXtzd2l0Y2goQil7Y2FzZSAwOnJldHVybiBJP2Z1bmN0aW9uKEEpe3JldHVybiB1W0FdfTpmdW5jdGlvbihBKXtyZXR1cm4gTFtBXX07Y2FzZSAxOnJldHVybiBJP2Z1bmN0aW9uKEEpe3JldHVybiBKW0E+PjFdfTpmdW5jdGlvbihBKXtyZXR1cm4gbFtBPj4xXX07Y2FzZSAyOnJldHVybiBJP2Z1bmN0aW9uKEEpe3JldHVybiBIW0E+PjJdfTpmdW5jdGlvbihBKXtyZXR1cm4gWVtBPj4yXX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGludGVnZXIgdHlwZTogIitBKX19dmFyIEtCPUsrPTE2O3ZhciBtQj17fTt2YXIgeEI9Sys9MTY7Sys9NDgsaChUQigiR01UIiksImk4IiwyKTt2YXIgdkI9SyxiQj1LKz0xNixXQj1LKz0xNjtmdW5jdGlvbiBYQigpe2lmKCFYQi5jYWxsZWQpe1hCLmNhbGxlZD0hMCxIW1dCPj4yXT02MCoobmV3IERhdGUpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEE9bmV3IERhdGUoMmUzLDAsMSksQj1uZXcgRGF0ZSgyZTMsNiwxKTtIW2JCPj4yXT1OdW1iZXIoQS5nZXRUaW1lem9uZU9mZnNldCgpIT1CLmdldFRpbWV6b25lT2Zmc2V0KCkpO3ZhciBJPUMoQSksZz1DKEIpLFE9aChUQihJKSwiaTgiLDApLEU9aChUQihnKSwiaTgiLDApO0IuZ2V0VGltZXpvbmVPZmZzZXQoKTxBLmdldFRpbWV6b25lT2Zmc2V0KCk/KEhbdkI+PjJdPVEsSFt2Qis0Pj4yXT1FKTooSFt2Qj4+Ml09RSxIW3ZCKzQ+PjJdPVEpfWZ1bmN0aW9uIEMoQSl7dmFyIEI9QS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXCgoW0EtWmEteiBdKylcKSQvKTtyZXR1cm4gQj9CWzFdOiJHTVQifX1LKz0xNjt2YXIgVkI9e307dmFyIE9CPTE7ZnVuY3Rpb24gVEIoQSxCLEkpe3ZhciBnPUk+MD9JOmYoQSkrMSxRPW5ldyBBcnJheShnKSxFPVMoQSxRLDAsUS5sZW5ndGgpO3JldHVybiBCJiYoUS5sZW5ndGg9RSksUX1kQS5zdGF0aWNJbml0KCksQUEudW5zaGlmdCgoZnVuY3Rpb24oKXtFLm5vRlNJbml0fHxkQS5pbml0LmluaXRpYWxpemVkfHxkQS5pbml0KCl9KSksQkEucHVzaCgoZnVuY3Rpb24oKXtkQS5pZ25vcmVQZXJtaXNzaW9ucz0hMX0pKSxJQS5wdXNoKChmdW5jdGlvbigpe2RBLnF1aXQoKX0pKSxBQS51bnNoaWZ0KChmdW5jdGlvbigpe30pKSxJQS5wdXNoKChmdW5jdGlvbigpe30pKSx4QT1FLkludGVybmFsRXJyb3I9bUEoRXJyb3IsIkludGVybmFsRXJyb3IiKSxmdW5jdGlvbigpe2Zvcih2YXIgQT1uZXcgQXJyYXkoMjU2KSxCPTA7QjwyNTY7KytCKUFbQl09U3RyaW5nLmZyb21DaGFyQ29kZShCKTtYQT1BfSgpLE9BPUUuQmluZGluZ0Vycm9yPW1BKEVycm9yLCJCaW5kaW5nRXJyb3IiKSxRQi5wcm90b3R5cGUuaXNBbGlhc09mPVpBLFFCLnByb3RvdHlwZS5jbG9uZT16QSxRQi5wcm90b3R5cGUuZGVsZXRlPV9BLFFCLnByb3RvdHlwZS5pc0RlbGV0ZWQ9JEEsUUIucHJvdG90eXBlLmRlbGV0ZUxhdGVyPWdCLEdCLnByb3RvdHlwZS5nZXRQb2ludGVlPWFCLEdCLnByb3RvdHlwZS5kZXN0cnVjdG9yPW5CLEdCLnByb3RvdHlwZS5hcmdQYWNrQWR2YW5jZT04LEdCLnByb3RvdHlwZS5yZWFkVmFsdWVGcm9tUG9pbnRlcj1sQSxHQi5wcm90b3R5cGUuZGVsZXRlT2JqZWN0PXNCLEdCLnByb3RvdHlwZS5mcm9tV2lyZVR5cGU9VUIsRS5nZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50PUZCLEUuZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcz13QixFLmZsdXNoUGVuZGluZ0RlbGV0ZXM9SUIsRS5zZXREZWxheUZ1bmN0aW9uPWNCLGtCPUUuVW5ib3VuZFR5cGVFcnJvcj1tQShFcnJvciwiVW5ib3VuZFR5cGVFcnJvciIpLEUuY291bnRfZW12YWxfaGFuZGxlcz1KQixFLmdldF9maXJzdF9lbXZhbD1sQixmdW5jdGlvbiBBKEIpe3ZhciBJLGc7QS5jYWxsZWQ/KGc9SFtLQj4+Ml0sST1IW2c+PjJdKTooQS5jYWxsZWQ9ITAsbUIuVVNFUj1tQi5MT0dOQU1FPSJ3ZWJfdXNlciIsbUIuUEFUSD0iLyIsbUIuUFdEPSIvIixtQi5IT01FPSIvaG9tZS93ZWJfdXNlciIsbUIuTEFORz0iQy5VVEYtOCIsbUIuXz1FLnRoaXNQcm9ncmFtLEk9YSgxMDI0KSxnPWEoMjU2KSxIW2c+PjJdPUksSFtLQj4+Ml09Zyk7dmFyIFE9W10sQz0wO2Zvcih2YXIgaSBpbiBCKWlmKCJzdHJpbmciPT10eXBlb2YgQltpXSl7dmFyIG89aSsiPSIrQltpXTtRLnB1c2gobyksQys9by5sZW5ndGh9aWYoQz4xMDI0KXRocm93IG5ldyBFcnJvcigiRW52aXJvbm1lbnQgc2l6ZSBleGNlZWRlZCBUT1RBTF9FTlZfU0laRSEiKTtmb3IodmFyIHQ9MDt0PFEubGVuZ3RoO3QrKyl7RUEobz1RW3RdLEkpLEhbZys0KnQ+PjJdPUksSSs9by5sZW5ndGgrMX1IW2crNCpRLmxlbmd0aD4+Ml09MH0obUIpLFc9YSg0KSx4PXY9cyhLKSxiPXMoeCtQKSxIW1c+PjJdPWIsbT0hMCxFLndhc21UYWJsZVNpemU9MzE2LEUud2FzbU1heFRhYmxlU2l6ZT0zMTYsRS5hc21HbG9iYWxBcmc9e30sRS5hc21MaWJyYXJ5QXJnPXthYm9ydDppSSxlbmxhcmdlTWVtb3J5OlosZ2V0VG90YWxNZW1vcnk6ZnVuY3Rpb24oKXtyZXR1cm4gen0sYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnk6ZnVuY3Rpb24oKXtpSSgiQ2Fubm90IGVubGFyZ2UgbWVtb3J5IGFycmF5cy4gRWl0aGVyICgxKSBjb21waWxlIHdpdGggIC1zIFRPVEFMX01FTU9SWT1YICB3aXRoIFggaGlnaGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgIit6KyIsICgyKSBjb21waWxlIHdpdGggIC1zIEFMTE9XX01FTU9SWV9HUk9XVEg9MSAgd2hpY2ggYWxsb3dzIGluY3JlYXNpbmcgdGhlIHNpemUgYXQgcnVudGltZSwgb3IgKDMpIGlmIHlvdSB3YW50IG1hbGxvYyB0byByZXR1cm4gTlVMTCAoMCkgaW5zdGVhZCBvZiB0aGlzIGFib3J0LCBjb21waWxlIHdpdGggIC1zIEFCT1JUSU5HX01BTExPQz0wICIpfSxpbnZva2VfaTpmdW5jdGlvbihBKXt0cnl7cmV0dXJuIEUuZHluQ2FsbF9pKEEpfWNhdGNoKEEpe2lmKCJudW1iZXIiIT10eXBlb2YgQSYmImxvbmdqbXAiIT09QSl0aHJvdyBBO0Uuc2V0VGhyZXcoMSwwKX19LGludm9rZV9paTpmdW5jdGlvbihBLEIpe3RyeXtyZXR1cm4gRS5keW5DYWxsX2lpKEEsQil9Y2F0Y2goQSl7aWYoIm51bWJlciIhPXR5cGVvZiBBJiYibG9uZ2ptcCIhPT1BKXRocm93IEE7RS5zZXRUaHJldygxLDApfX0saW52b2tlX2lpaTpmdW5jdGlvbihBLEIsSSl7dHJ5e3JldHVybiBFLmR5bkNhbGxfaWlpKEEsQixJKX1jYXRjaChBKXtpZigibnVtYmVyIiE9dHlwZW9mIEEmJiJsb25nam1wIiE9PUEpdGhyb3cgQTtFLnNldFRocmV3KDEsMCl9fSxpbnZva2VfaWlpaTpmdW5jdGlvbihBLEIsSSxnKXt0cnl7cmV0dXJuIEUuZHluQ2FsbF9paWlpKEEsQixJLGcpfWNhdGNoKEEpe2lmKCJudW1iZXIiIT10eXBlb2YgQSYmImxvbmdqbXAiIT09QSl0aHJvdyBBO0Uuc2V0VGhyZXcoMSwwKX19LGludm9rZV9paWlpaTpmdW5jdGlvbihBLEIsSSxnLFEpe3RyeXtyZXR1cm4gRS5keW5DYWxsX2lpaWlpKEEsQixJLGcsUSl9Y2F0Y2goQSl7aWYoIm51bWJlciIhPXR5cGVvZiBBJiYibG9uZ2ptcCIhPT1BKXRocm93IEE7RS5zZXRUaHJldygxLDApfX0saW52b2tlX2lpaWlpaWk6ZnVuY3Rpb24oQSxCLEksZyxRLEMsaSl7dHJ5e3JldHVybiBFLmR5bkNhbGxfaWlpaWlpaShBLEIsSSxnLFEsQyxpKX1jYXRjaChBKXtpZigibnVtYmVyIiE9dHlwZW9mIEEmJiJsb25nam1wIiE9PUEpdGhyb3cgQTtFLnNldFRocmV3KDEsMCl9fSxpbnZva2VfaWlpaWlpaWlpaTpmdW5jdGlvbihBLEIsSSxnLFEsQyxpLG8sdCxlKXt0cnl7cmV0dXJuIEUuZHluQ2FsbF9paWlpaWlpaWlpKEEsQixJLGcsUSxDLGksbyx0LGUpfWNhdGNoKEEpe2lmKCJudW1iZXIiIT10eXBlb2YgQSYmImxvbmdqbXAiIT09QSl0aHJvdyBBO0Uuc2V0VGhyZXcoMSwwKX19LGludm9rZV9paWlpaWlqaWk6ZnVuY3Rpb24oQSxCLEksZyxRLEMsaSxvLHQsZSl7dHJ5e3JldHVybiBFLmR5bkNhbGxfaWlpaWlpamlpKEEsQixJLGcsUSxDLGksbyx0LGUpfWNhdGNoKEEpe2lmKCJudW1iZXIiIT10eXBlb2YgQSYmImxvbmdqbXAiIT09QSl0aHJvdyBBO0Uuc2V0VGhyZXcoMSwwKX19LGludm9rZV9pamo6ZnVuY3Rpb24oQSxCLEksZyxRKXt0cnl7cmV0dXJuIEUuZHluQ2FsbF9pamooQSxCLEksZyxRKX1jYXRjaChBKXtpZigibnVtYmVyIiE9dHlwZW9mIEEmJiJsb25nam1wIiE9PUEpdGhyb3cgQTtFLnNldFRocmV3KDEsMCl9fSxpbnZva2Vfamk6ZnVuY3Rpb24oQSxCKXt0cnl7cmV0dXJuIEUuZHluQ2FsbF9qaShBLEIpfWNhdGNoKEEpe2lmKCJudW1iZXIiIT10eXBlb2YgQSYmImxvbmdqbXAiIT09QSl0aHJvdyBBO0Uuc2V0VGhyZXcoMSwwKX19LGludm9rZV92OmZ1bmN0aW9uKEEpe3RyeXtFLmR5bkNhbGxfdihBKX1jYXRjaChBKXtpZigibnVtYmVyIiE9dHlwZW9mIEEmJiJsb25nam1wIiE9PUEpdGhyb3cgQTtFLnNldFRocmV3KDEsMCl9fSxpbnZva2Vfdmk6ZnVuY3Rpb24oQSxCKXt0cnl7RS5keW5DYWxsX3ZpKEEsQil9Y2F0Y2goQSl7aWYoIm51bWJlciIhPXR5cGVvZiBBJiYibG9uZ2ptcCIhPT1BKXRocm93IEE7RS5zZXRUaHJldygxLDApfX0saW52b2tlX3ZpaTpmdW5jdGlvbihBLEIsSSl7dHJ5e0UuZHluQ2FsbF92aWkoQSxCLEkpfWNhdGNoKEEpe2lmKCJudW1iZXIiIT10eXBlb2YgQSYmImxvbmdqbXAiIT09QSl0aHJvdyBBO0Uuc2V0VGhyZXcoMSwwKX19LGludm9rZV92aWlpOmZ1bmN0aW9uKEEsQixJLGcpe3RyeXtFLmR5bkNhbGxfdmlpaShBLEIsSSxnKX1jYXRjaChBKXtpZigibnVtYmVyIiE9dHlwZW9mIEEmJiJsb25nam1wIiE9PUEpdGhyb3cgQTtFLnNldFRocmV3KDEsMCl9fSxpbnZva2VfdmlpaWk6ZnVuY3Rpb24oQSxCLEksZyxRKXt0cnl7RS5keW5DYWxsX3ZpaWlpKEEsQixJLGcsUSl9Y2F0Y2goQSl7aWYoIm51bWJlciIhPXR5cGVvZiBBJiYibG9uZ2ptcCIhPT1BKXRocm93IEE7RS5zZXRUaHJldygxLDApfX0saW52b2tlX3ZpaWlpaTpmdW5jdGlvbihBLEIsSSxnLFEsQyl7dHJ5e0UuZHluQ2FsbF92aWlpaWkoQSxCLEksZyxRLEMpfWNhdGNoKEEpe2lmKCJudW1iZXIiIT10eXBlb2YgQSYmImxvbmdqbXAiIT09QSl0aHJvdyBBO0Uuc2V0VGhyZXcoMSwwKX19LGludm9rZV92aWlpaWlpOmZ1bmN0aW9uKEEsQixJLGcsUSxDLGkpe3RyeXtFLmR5bkNhbGxfdmlpaWlpaShBLEIsSSxnLFEsQyxpKX1jYXRjaChBKXtpZigibnVtYmVyIiE9dHlwZW9mIEEmJiJsb25nam1wIiE9PUEpdGhyb3cgQTtFLnNldFRocmV3KDEsMCl9fSxpbnZva2VfdmlpaWlpaWlpaTpmdW5jdGlvbihBLEIsSSxnLFEsQyxpLG8sdCxlKXt0cnl7RS5keW5DYWxsX3ZpaWlpaWlpaWkoQSxCLEksZyxRLEMsaSxvLHQsZSl9Y2F0Y2goQSl7aWYoIm51bWJlciIhPXR5cGVvZiBBJiYibG9uZ2ptcCIhPT1BKXRocm93IEE7RS5zZXRUaHJldygxLDApfX0saW52b2tlX3ZpaWlpaWlpaWlpOmZ1bmN0aW9uKEEsQixJLGcsUSxDLGksbyx0LGUscil7dHJ5e0UuZHluQ2FsbF92aWlpaWlpaWlpaShBLEIsSSxnLFEsQyxpLG8sdCxlLHIpfWNhdGNoKEEpe2lmKCJudW1iZXIiIT10eXBlb2YgQSYmImxvbmdqbXAiIT09QSl0aHJvdyBBO0Uuc2V0VGhyZXcoMSwwKX19LGludm9rZV92aWo6ZnVuY3Rpb24oQSxCLEksZyl7dHJ5e0UuZHluQ2FsbF92aWooQSxCLEksZyl9Y2F0Y2goQSl7aWYoIm51bWJlciIhPXR5cGVvZiBBJiYibG9uZ2ptcCIhPT1BKXRocm93IEE7RS5zZXRUaHJldygxLDApfX0saW52b2tlX3Zpamk6ZnVuY3Rpb24oQSxCLEksZyxRKXt0cnl7RS5keW5DYWxsX3ZpamkoQSxCLEksZyxRKX1jYXRjaChBKXtpZigibnVtYmVyIiE9dHlwZW9mIEEmJiJsb25nam1wIiE9PUEpdGhyb3cgQTtFLnNldFRocmV3KDEsMCl9fSxfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uOmZ1bmN0aW9uKEEpe3JldHVybiBJSShBKX0sX19fY3hhX2JlZ2luX2NhdGNoOmZ1bmN0aW9uKEEpe3ZhciBCPUZBLmluZm9zW0FdO3JldHVybiBCJiYhQi5jYXVnaHQmJihCLmNhdWdodD0hMCksQiYmKEIucmV0aHJvd249ITEpLEZBLmNhdWdodC5wdXNoKEEpLEZBLmFkZFJlZihGQS5kZUFkanVzdChBKSksQX0sX19fY3hhX2VuZF9jYXRjaDpmdW5jdGlvbigpe0Uuc2V0VGhyZXcoMCk7dmFyIEE9RkEuY2F1Z2h0LnBvcCgpO0EmJihGQS5kZWNSZWYoRkEuZGVBZGp1c3QoQSkpLEZBLmxhc3Q9MCl9LF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzI6ZnVuY3Rpb24oKXtyZXR1cm4gY0EuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8zOmZ1bmN0aW9uKCl7cmV0dXJuIGNBLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfNDpmdW5jdGlvbigpe3JldHVybiBjQS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF9fX2N4YV9mcmVlX2V4Y2VwdGlvbjp3QSxfX19jeGFfdGhyb3c6ZnVuY3Rpb24oQSxCLEkpe3Rocm93IEZBLmluZm9zW0FdPXtwdHI6QSxhZGp1c3RlZDpBLHR5cGU6QixkZXN0cnVjdG9yOkkscmVmY291bnQ6MCxjYXVnaHQ6ITEscmV0aHJvd246ITF9LEZBLmxhc3Q9QSxBfSxfX19sb2NrOmZ1bmN0aW9uKCl7fSxfX19tYXBfZmlsZTpmdW5jdGlvbihBLEIpe3JldHVybiB5QShoQS5FUEVSTSksLTF9LF9fX3Jlc3VtZUV4Y2VwdGlvbjpmdW5jdGlvbihBKXt0aHJvdyBGQS5sYXN0fHwoRkEubGFzdD1BKSxBfSxfX19zZXRFcnJObzp5QSxfX19zeXNjYWxsMTQwOmZ1bmN0aW9uKEEsQil7TUEudmFyYXJncz1CO3RyeXt2YXIgST1NQS5nZXRTdHJlYW1Gcm9tRkQoKSxnPShNQS5nZXQoKSxNQS5nZXQoKSksUT1NQS5nZXQoKSxFPU1BLmdldCgpLEM9ZztyZXR1cm4gZEEubGxzZWVrKEksQyxFKSxIW1E+PjJdPUkucG9zaXRpb24sSS5nZXRkZW50cyYmMD09PUMmJjA9PT1FJiYoSS5nZXRkZW50cz1udWxsKSwwfWNhdGNoKEEpe3JldHVybiB2b2lkIDAhPT1kQSYmQSBpbnN0YW5jZW9mIGRBLkVycm5vRXJyb3J8fGlJKEEpLC1BLmVycm5vfX0sX19fc3lzY2FsbDE0NTpmdW5jdGlvbihBLEIpe01BLnZhcmFyZ3M9Qjt0cnl7dmFyIEk9TUEuZ2V0U3RyZWFtRnJvbUZEKCksZz1NQS5nZXQoKSxRPU1BLmdldCgpO3JldHVybiBNQS5kb1JlYWR2KEksZyxRKX1jYXRjaChBKXtyZXR1cm4gdm9pZCAwIT09ZEEmJkEgaW5zdGFuY2VvZiBkQS5FcnJub0Vycm9yfHxpSShBKSwtQS5lcnJub319LF9fX3N5c2NhbGwxNDY6ZnVuY3Rpb24oQSxCKXtNQS52YXJhcmdzPUI7dHJ5e3ZhciBJPU1BLmdldFN0cmVhbUZyb21GRCgpLGc9TUEuZ2V0KCksUT1NQS5nZXQoKTtyZXR1cm4gTUEuZG9Xcml0ZXYoSSxnLFEpfWNhdGNoKEEpe3JldHVybiB2b2lkIDAhPT1kQSYmQSBpbnN0YW5jZW9mIGRBLkVycm5vRXJyb3J8fGlJKEEpLC1BLmVycm5vfX0sX19fc3lzY2FsbDE4MzpmdW5jdGlvbihBLEIpe01BLnZhcmFyZ3M9Qjt0cnl7dmFyIEk9TUEuZ2V0KCksZz1NQS5nZXQoKTtpZigwPT09ZylyZXR1cm4taEEuRUlOVkFMO3ZhciBRPWRBLmN3ZCgpO3JldHVybiBnPGYoUSkrMT8taEEuRVJBTkdFOihrKFEsSSxnKSxJKX1jYXRjaChBKXtyZXR1cm4gdm9pZCAwIT09ZEEmJkEgaW5zdGFuY2VvZiBkQS5FcnJub0Vycm9yfHxpSShBKSwtQS5lcnJub319LF9fX3N5c2NhbGwxOTg6ZnVuY3Rpb24oQSxCKXtNQS52YXJhcmdzPUI7dHJ5e3ZhciBJPU1BLmdldFN0cigpLGc9TUEuZ2V0KCksUT1NQS5nZXQoKTtyZXR1cm4gZEEuY2hvd24oSSxnLFEpLDB9Y2F0Y2goQSl7cmV0dXJuIHZvaWQgMCE9PWRBJiZBIGluc3RhbmNlb2YgZEEuRXJybm9FcnJvcnx8aUkoQSksLUEuZXJybm99fSxfX19zeXNjYWxsMjA6ZnVuY3Rpb24oQSxCKXtNQS52YXJhcmdzPUI7dHJ5e3JldHVybiB1QX1jYXRjaChBKXtyZXR1cm4gdm9pZCAwIT09ZEEmJkEgaW5zdGFuY2VvZiBkQS5FcnJub0Vycm9yfHxpSShBKSwtQS5lcnJub319LF9fX3N5c2NhbGw2OmZ1bmN0aW9uKEEsQil7TUEudmFyYXJncz1CO3RyeXt2YXIgST1NQS5nZXRTdHJlYW1Gcm9tRkQoKTtyZXR1cm4gZEEuY2xvc2UoSSksMH1jYXRjaChBKXtyZXR1cm4gdm9pZCAwIT09ZEEmJkEgaW5zdGFuY2VvZiBkQS5FcnJub0Vycm9yfHxpSShBKSwtQS5lcnJub319LF9fX3N5c2NhbGw2MDpmdW5jdGlvbihBLEIpe01BLnZhcmFyZ3M9Qjt0cnl7dmFyIEk9TUEuZ2V0KCksZz1NQS51bWFzaztyZXR1cm4gTUEudW1hc2s9SSxnfWNhdGNoKEEpe3JldHVybiB2b2lkIDAhPT1kQSYmQSBpbnN0YW5jZW9mIGRBLkVycm5vRXJyb3J8fGlJKEEpLC1BLmVycm5vfX0sX19fc3lzY2FsbDgzOmZ1bmN0aW9uKEEsQil7TUEudmFyYXJncz1CO3RyeXt2YXIgST1NQS5nZXRTdHIoKSxnPU1BLmdldFN0cigpO3JldHVybiBkQS5zeW1saW5rKEksZyksMH1jYXRjaChBKXtyZXR1cm4gdm9pZCAwIT09ZEEmJkEgaW5zdGFuY2VvZiBkQS5FcnJub0Vycm9yfHxpSShBKSwtQS5lcnJub319LF9fX3N5c2NhbGw5MTpmdW5jdGlvbihBLEIpe01BLnZhcmFyZ3M9Qjt0cnl7dmFyIEk9TUEuZ2V0KCksZz1NQS5nZXQoKSxRPU1BLm1hcHBpbmdzW0ldO2lmKCFRKXJldHVybiAwO2lmKGc9PT1RLmxlbil7dmFyIEU9ZEEuZ2V0U3RyZWFtKFEuZmQpO01BLmRvTXN5bmMoSSxFLGcsUS5mbGFncyksZEEubXVubWFwKEUpLE1BLm1hcHBpbmdzW0ldPW51bGwsUS5hbGxvY2F0ZWQmJkJJKFEubWFsbG9jKX1yZXR1cm4gMH1jYXRjaChBKXtyZXR1cm4gdm9pZCAwIT09ZEEmJkEgaW5zdGFuY2VvZiBkQS5FcnJub0Vycm9yfHxpSShBKSwtQS5lcnJub319LF9fX3VubG9jazpmdW5jdGlvbigpe30sX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0OmZ1bmN0aW9uKEEpe3ZhciBCPUxBW0FdO2RlbGV0ZSBMQVtBXTt2YXIgST1CLnJhd0NvbnN0cnVjdG9yLGc9Qi5yYXdEZXN0cnVjdG9yLFE9Qi5maWVsZHM7YkEoW0FdLFEubWFwKChmdW5jdGlvbihBKXtyZXR1cm4gQS5nZXR0ZXJSZXR1cm5UeXBlfSkpLmNvbmNhdChRLm1hcCgoZnVuY3Rpb24oQSl7cmV0dXJuIEEuc2V0dGVyQXJndW1lbnRUeXBlfSkpKSwoZnVuY3Rpb24oQSl7dmFyIEU9e307cmV0dXJuIFEuZm9yRWFjaCgoZnVuY3Rpb24oQixJKXt2YXIgZz1CLmZpZWxkTmFtZSxDPUFbSV0saT1CLmdldHRlcixvPUIuZ2V0dGVyQ29udGV4dCx0PUFbSStRLmxlbmd0aF0sZT1CLnNldHRlcixyPUIuc2V0dGVyQ29udGV4dDtFW2ddPXtyZWFkOmZ1bmN0aW9uKEEpe3JldHVybiBDLmZyb21XaXJlVHlwZShpKG8sQSkpfSx3cml0ZTpmdW5jdGlvbihBLEIpe3ZhciBJPVtdO2UocixBLHQudG9XaXJlVHlwZShJLEIpKSxKQShJKX19fSkpLFt7bmFtZTpCLm5hbWUsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKEEpe3ZhciBCPXt9O2Zvcih2YXIgSSBpbiBFKUJbSV09RVtJXS5yZWFkKEEpO3JldHVybiBnKEEpLEJ9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oQSxCKXtmb3IodmFyIFEgaW4gRSlpZighKFEgaW4gQikpdGhyb3cgbmV3IFR5cGVFcnJvcigiTWlzc2luZyBmaWVsZCIpO3ZhciBDPUkoKTtmb3IoUSBpbiBFKUVbUV0ud3JpdGUoQyxCW1FdKTtyZXR1cm4gbnVsbCE9PUEmJkEucHVzaChnLEMpLEN9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6bEEsZGVzdHJ1Y3RvckZ1bmN0aW9uOmd9XX0pKX0sX19lbWJpbmRfcmVnaXN0ZXJfYm9vbDpmdW5jdGlvbihBLEIsSSxnLFEpe3ZhciBFPVdBKEkpO2pBKEEse25hbWU6Qj1WQShCKSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oQSl7cmV0dXJuISFBfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKEEsQil7cmV0dXJuIEI/ZzpRfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZ1bmN0aW9uKEEpe3ZhciBnO2lmKDE9PT1JKWc9dTtlbHNlIGlmKDI9PT1JKWc9SjtlbHNle2lmKDQhPT1JKXRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gYm9vbGVhbiB0eXBlIHNpemU6ICIrQik7Zz1IfXJldHVybiB0aGlzLmZyb21XaXJlVHlwZShnW0E+PkVdKX0sZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KX0sX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3M6ZnVuY3Rpb24oQSxCLEksZyxRLEMsaSxvLHQsZSxyLGEsbil7cj1WQShyKSxDPVNCKFEsQyksbyYmKG89U0IoaSxvKSksZSYmKGU9U0IodCxlKSksbj1TQihhLG4pO3ZhciBzPXBBKHIpOyFmdW5jdGlvbihBLEIsSSl7RS5oYXNPd25Qcm9wZXJ0eShBKT8oKHZvaWQgMD09PUl8fHZvaWQgMCE9PUVbQV0ub3ZlcmxvYWRUYWJsZSYmdm9pZCAwIT09RVtBXS5vdmVybG9hZFRhYmxlW0ldKSYmVEEoIkNhbm5vdCByZWdpc3RlciBwdWJsaWMgbmFtZSAnIitBKyInIHR3aWNlIiksQ0IoRSxBLEEpLEUuaGFzT3duUHJvcGVydHkoSSkmJlRBKCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgb3ZlcmxvYWRzIG9mIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzICgiK0krIikhIiksRVtBXS5vdmVybG9hZFRhYmxlW0ldPUIpOihFW0FdPUIsdm9pZCAwIT09SSYmKEVbQV0ubnVtQXJndW1lbnRzPUkpKX0ocywoZnVuY3Rpb24oKXtOQigiQ2Fubm90IGNvbnN0cnVjdCAiK3IrIiBkdWUgdG8gdW5ib3VuZCB0eXBlcyIsW2ddKX0pKSxiQShbQSxCLEldLGc/W2ddOltdLChmdW5jdGlvbihCKXt2YXIgSSxRO0I9QlswXSxRPWc/KEk9Qi5yZWdpc3RlcmVkQ2xhc3MpLmluc3RhbmNlUHJvdG90eXBlOlFCLnByb3RvdHlwZTt2YXIgaT1LQShzLChmdW5jdGlvbigpe2lmKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSE9PXQpdGhyb3cgbmV3IE9BKCJVc2UgJ25ldycgdG8gY29uc3RydWN0ICIrcik7aWYodm9pZCAwPT09YS5jb25zdHJ1Y3Rvcl9ib2R5KXRocm93IG5ldyBPQShyKyIgaGFzIG5vIGFjY2Vzc2libGUgY29uc3RydWN0b3IiKTt2YXIgQT1hLmNvbnN0cnVjdG9yX2JvZHlbYXJndW1lbnRzLmxlbmd0aF07aWYodm9pZCAwPT09QSl0aHJvdyBuZXcgT0EoIlRyaWVkIHRvIGludm9rZSBjdG9yIG9mICIrcisiIHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoIithcmd1bWVudHMubGVuZ3RoKyIpIC0gZXhwZWN0ZWQgKCIrT2JqZWN0LmtleXMoYS5jb25zdHJ1Y3Rvcl9ib2R5KS50b1N0cmluZygpKyIpIHBhcmFtZXRlcnMgaW5zdGVhZCEiKTtyZXR1cm4gQS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSksdD1PYmplY3QuY3JlYXRlKFEse2NvbnN0cnVjdG9yOnt2YWx1ZTppfX0pO2kucHJvdG90eXBlPXQ7dmFyIGE9bmV3IGlCKHIsaSx0LG4sSSxDLG8sZSksRD1uZXcgR0IocixhLCEwLCExLCExKSxGPW5ldyBHQihyKyIqIixhLCExLCExLCExKSx3PW5ldyBHQihyKyIgY29uc3QqIixhLCExLCEwLCExKTtyZXR1cm4gRUJbQV09e3BvaW50ZXJUeXBlOkYsY29uc3RQb2ludGVyVHlwZTp3fSxmdW5jdGlvbihBLEIsSSl7RS5oYXNPd25Qcm9wZXJ0eShBKXx8dkEoIlJlcGxhY2luZyBub25leGlzdGFudCBwdWJsaWMgc3ltYm9sIiksdm9pZCAwIT09RVtBXS5vdmVybG9hZFRhYmxlJiZ2b2lkIDAhPT1JP0VbQV0ub3ZlcmxvYWRUYWJsZVtJXT1COihFW0FdPUIsRVtBXS5hcmdDb3VudD1JKX0ocyxpKSxbRCxGLHddfSkpfSxfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcjpmdW5jdGlvbihBLEIsSSxnLFEsRSl7dmFyIEM9ZEIoQixJKTtRPVNCKGcsUSksYkEoW10sW0FdLChmdW5jdGlvbihBKXt2YXIgST0iY29uc3RydWN0b3IgIisoQT1BWzBdKS5uYW1lO2lmKHZvaWQgMD09PUEucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkmJihBLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5PVtdKSx2b2lkIDAhPT1BLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W0ItMV0pdGhyb3cgbmV3IE9BKCJDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzICgiKyhCLTEpKyIpIGZvciBjbGFzcyAnIitBLm5hbWUrIichIE92ZXJsb2FkIHJlc29sdXRpb24gaXMgY3VycmVudGx5IG9ubHkgcGVyZm9ybWVkIHVzaW5nIHRoZSBwYXJhbWV0ZXIgY291bnQsIG5vdCBhY3R1YWwgdHlwZSBpbmZvISIpO3JldHVybiBBLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W0ItMV09ZnVuY3Rpb24oKXtOQigiQ2Fubm90IGNvbnN0cnVjdCAiK0EubmFtZSsiIGR1ZSB0byB1bmJvdW5kIHR5cGVzIixDKX0sYkEoW10sQywoZnVuY3Rpb24oZyl7cmV0dXJuIEEucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbQi0xXT1mdW5jdGlvbigpe2FyZ3VtZW50cy5sZW5ndGghPT1CLTEmJlRBKEkrIiBjYWxsZWQgd2l0aCAiK2FyZ3VtZW50cy5sZW5ndGgrIiBhcmd1bWVudHMsIGV4cGVjdGVkICIrKEItMSkpO3ZhciBBPVtdLEM9bmV3IEFycmF5KEIpO0NbMF09RTtmb3IodmFyIGk9MTtpPEI7KytpKUNbaV09Z1tpXS50b1dpcmVUeXBlKEEsYXJndW1lbnRzW2ktMV0pO3ZhciBvPVEuYXBwbHkobnVsbCxDKTtyZXR1cm4gSkEoQSksZ1swXS5mcm9tV2lyZVR5cGUobyl9LFtdfSkpLFtdfSkpfSxfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbjpmdW5jdGlvbihBLEIsSSxnLFEsRSxDLGkpe3ZhciBvPWRCKEksZyk7Qj1WQShCKSxFPVNCKFEsRSksYkEoW10sW0FdLChmdW5jdGlvbihBKXt2YXIgZz0oQT1BWzBdKS5uYW1lKyIuIitCO2Z1bmN0aW9uIFEoKXtOQigiQ2Fubm90IGNhbGwgIitnKyIgZHVlIHRvIHVuYm91bmQgdHlwZXMiLG8pfWkmJkEucmVnaXN0ZXJlZENsYXNzLnB1cmVWaXJ0dWFsRnVuY3Rpb25zLnB1c2goQik7dmFyIHQ9QS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsZT10W0JdO3JldHVybiB2b2lkIDA9PT1lfHx2b2lkIDA9PT1lLm92ZXJsb2FkVGFibGUmJmUuY2xhc3NOYW1lIT09QS5uYW1lJiZlLmFyZ0NvdW50PT09SS0yPyhRLmFyZ0NvdW50PUktMixRLmNsYXNzTmFtZT1BLm5hbWUsdFtCXT1RKTooQ0IodCxCLGcpLHRbQl0ub3ZlcmxvYWRUYWJsZVtJLTJdPVEpLGJBKFtdLG8sKGZ1bmN0aW9uKFEpe3ZhciBpPU1CKGcsUSxBLEUsQyk7cmV0dXJuIHZvaWQgMD09PXRbQl0ub3ZlcmxvYWRUYWJsZT8oaS5hcmdDb3VudD1JLTIsdFtCXT1pKTp0W0JdLm92ZXJsb2FkVGFibGVbSS0yXT1pLFtdfSkpLFtdfSkpfSxfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbDpmdW5jdGlvbihBLEIpe2pBKEEse25hbWU6Qj1WQShCKSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oQSl7dmFyIEI9TEJbQV0udmFsdWU7cmV0dXJuIGZ1bmN0aW9uKEEpe0E+NCYmMD09LS1MQltBXS5yZWZjb3VudCYmKExCW0FdPXZvaWQgMCx1Qi5wdXNoKEEpKX0oQSksQn0sdG9XaXJlVHlwZTpmdW5jdGlvbihBLEIpe3JldHVybiBIQihCKX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpsQSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfSxfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdDpmdW5jdGlvbihBLEIsSSl7dmFyIGc9V0EoSSk7akEoQSx7bmFtZTpCPVZBKEIpLGZyb21XaXJlVHlwZTpmdW5jdGlvbihBKXtyZXR1cm4gQX0sdG9XaXJlVHlwZTpmdW5jdGlvbihBLEIpe2lmKCJudW1iZXIiIT10eXBlb2YgQiYmImJvb2xlYW4iIT10eXBlb2YgQil0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCAiJytZQihCKSsnIiB0byAnK3RoaXMubmFtZSk7cmV0dXJuIEJ9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6cUIoQixnKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfSxfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyOmZ1bmN0aW9uKEEsQixJLGcsUSl7Qj1WQShCKSwtMT09PVEmJihRPTQyOTQ5NjcyOTUpO3ZhciBFPVdBKEkpLEM9ZnVuY3Rpb24oQSl7cmV0dXJuIEF9O2lmKDA9PT1nKXt2YXIgaT0zMi04Kkk7Qz1mdW5jdGlvbihBKXtyZXR1cm4gQTw8aT4+Pml9fXZhciBvPS0xIT1CLmluZGV4T2YoInVuc2lnbmVkIik7akEoQSx7bmFtZTpCLGZyb21XaXJlVHlwZTpDLHRvV2lyZVR5cGU6ZnVuY3Rpb24oQSxJKXtpZigibnVtYmVyIiE9dHlwZW9mIEkmJiJib29sZWFuIiE9dHlwZW9mIEkpdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgIicrWUIoSSkrJyIgdG8gJyt0aGlzLm5hbWUpO2lmKEk8Z3x8ST5RKXRocm93IG5ldyBUeXBlRXJyb3IoJ1Bhc3NpbmcgYSBudW1iZXIgIicrWUIoSSkrJyIgZnJvbSBKUyBzaWRlIHRvIEMvQysrIHNpZGUgdG8gYW4gYXJndW1lbnQgb2YgdHlwZSAiJytCKyciLCB3aGljaCBpcyBvdXRzaWRlIHRoZSB2YWxpZCByYW5nZSBbJytnKyIsICIrUSsiXSEiKTtyZXR1cm4gbz9JPj4+MDowfEl9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6cEIoQixFLDAhPT1nKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfSxfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldzpmdW5jdGlvbihBLEIsSSl7dmFyIGc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5XVtCXTtmdW5jdGlvbiBRKEEpe3ZhciBCPVksST1CW0E+Pj0yXSxRPUJbQSsxXTtyZXR1cm4gbmV3IGcoQi5idWZmZXIsUSxJKX1qQShBLHtuYW1lOkk9VkEoSSksZnJvbVdpcmVUeXBlOlEsYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpRfSx7aWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9uczohMH0pfSxfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nOmZ1bmN0aW9uKEEsQil7akEoQSx7bmFtZTpCPVZBKEIpLGZyb21XaXJlVHlwZTpmdW5jdGlvbihBKXtmb3IodmFyIEI9WVtBPj4yXSxJPW5ldyBBcnJheShCKSxnPTA7ZzxCOysrZylJW2ddPVN0cmluZy5mcm9tQ2hhckNvZGUoTFtBKzQrZ10pO3JldHVybiBCSShBKSxJLmpvaW4oIiIpfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKEEsQil7ZnVuY3Rpb24gSShBLEIpe3JldHVybiBBW0JdfXZhciBnO0IgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKEI9bmV3IFVpbnQ4QXJyYXkoQikpLEIgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxCIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fEIgaW5zdGFuY2VvZiBJbnQ4QXJyYXk/Zz1JOiJzdHJpbmciPT10eXBlb2YgQj9nPWZ1bmN0aW9uKEEsQil7cmV0dXJuIEEuY2hhckNvZGVBdChCKX06VEEoIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmciKTt2YXIgUT1CLmxlbmd0aCxFPUlJKDQrUSk7WVtFPj4yXT1RO2Zvcih2YXIgQz0wO0M8UTsrK0Mpe3ZhciBpPWcoQixDKTtpPjI1NSYmKEJJKEUpLFRBKCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHMiKSksTFtFKzQrQ109aX1yZXR1cm4gbnVsbCE9PUEmJkEucHVzaChCSSxFKSxFfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmxBLGRlc3RydWN0b3JGdW5jdGlvbjpmdW5jdGlvbihBKXtCSShBKX19KX0sX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmc6ZnVuY3Rpb24oQSxCLEkpe3ZhciBnLFE7ST1WQShJKSwyPT09Qj8oZz1mdW5jdGlvbigpe3JldHVybiBsfSxRPTEpOjQ9PT1CJiYoZz1mdW5jdGlvbigpe3JldHVybiBZfSxRPTIpLGpBKEEse25hbWU6SSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oQSl7Zm9yKHZhciBCPWcoKSxJPVlbQT4+Ml0sRT1uZXcgQXJyYXkoSSksQz1BKzQ+PlEsaT0wO2k8STsrK2kpRVtpXT1TdHJpbmcuZnJvbUNoYXJDb2RlKEJbQytpXSk7cmV0dXJuIEJJKEEpLEUuam9pbigiIil9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oQSxJKXt2YXIgRT1nKCksQz1JLmxlbmd0aCxpPUlJKDQrQypCKTtZW2k+PjJdPUM7Zm9yKHZhciBvPWkrND4+USx0PTA7dDxDOysrdClFW28rdF09SS5jaGFyQ29kZUF0KHQpO3JldHVybiBudWxsIT09QSYmQS5wdXNoKEJJLGkpLGl9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6bEEsZGVzdHJ1Y3RvckZ1bmN0aW9uOmZ1bmN0aW9uKEEpe0JJKEEpfX0pfSxfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3Q6ZnVuY3Rpb24oQSxCLEksZyxRLEUpe0xBW0FdPXtuYW1lOlZBKEIpLHJhd0NvbnN0cnVjdG9yOlNCKEksZykscmF3RGVzdHJ1Y3RvcjpTQihRLEUpLGZpZWxkczpbXX19LF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZDpmdW5jdGlvbihBLEIsSSxnLFEsRSxDLGksbyx0KXtMQVtBXS5maWVsZHMucHVzaCh7ZmllbGROYW1lOlZBKEIpLGdldHRlclJldHVyblR5cGU6SSxnZXR0ZXI6U0IoZyxRKSxnZXR0ZXJDb250ZXh0OkUsc2V0dGVyQXJndW1lbnRUeXBlOkMsc2V0dGVyOlNCKGksbyksc2V0dGVyQ29udGV4dDp0fSl9LF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQ6ZnVuY3Rpb24oQSxCKXtqQShBLHtpc1ZvaWQ6ITAsbmFtZTpCPVZBKEIpLGFyZ1BhY2tBZHZhbmNlOjAsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKCl7fSx0b1dpcmVUeXBlOmZ1bmN0aW9uKEEsQil7fX0pfSxfYWJvcnQ6ZnVuY3Rpb24oKXtFLmFib3J0KCl9LF9lbXNjcmlwdGVuX21lbWNweV9iaWc6ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBMLnNldChMLnN1YmFycmF5KEIsQitJKSxBKSxBfSxfZ2V0ZW52OmZ1bmN0aW9uIEEoQil7cmV0dXJuIDA9PT1CPzA6KEI9eShCKSxtQi5oYXNPd25Qcm9wZXJ0eShCKT8oQS5yZXQmJkJJKEEucmV0KSxBLnJldD0oST1tQltCXSxnPWYoSSkrMSwoUT1JSShnKSkmJlMoSSx1LFEsZyksUSkpOjApO3ZhciBJLGcsUX0sX2dldGdybmFtOmZ1bmN0aW9uKCl7RS5wcmludEVycigibWlzc2luZyBmdW5jdGlvbjogZ2V0Z3JuYW0iKSxpSSgtMSl9LF9nZXRwd25hbTpmdW5jdGlvbigpe3Rocm93ImdldHB3bmFtOiBUT0RPIn0sX2pzQ2xvc2U6ZnVuY3Rpb24oKXtyZXR1cm4gaS5jbG9zZS5hcHBseShudWxsLGFyZ3VtZW50cyl9LF9qc0NyZWF0ZTpmdW5jdGlvbihBKXtyZXR1cm4gaS5jcmVhdGUuY2FsbChudWxsLE4oQSkpfSxfanNPcGVuOmZ1bmN0aW9uKEEpe3JldHVybiBpLm9wZW4uY2FsbChudWxsLE4oQSkpfSxfanNSZWFkOmZ1bmN0aW9uKCl7cmV0dXJuIGkucmVhZC5hcHBseShudWxsLGFyZ3VtZW50cyl9LF9qc1NlZWs6ZnVuY3Rpb24oQSxCLEkpe3JldHVybiBpLnNlZWsuY2FsbChudWxsLEEsQixHKEkpKX0sX2pzVGVsbDpmdW5jdGlvbigpe3JldHVybiBpLnRlbGwuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfanNXcml0ZTpmdW5jdGlvbigpe3JldHVybiBpLndyaXRlLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sX2xsdm1fZWhfdHlwZWlkX2ZvcjpmdW5jdGlvbihBKXtyZXR1cm4gQX0sX2xvY2FsdGltZTpmdW5jdGlvbihBKXtyZXR1cm4gZnVuY3Rpb24oQSxCKXtYQigpO3ZhciBJPW5ldyBEYXRlKDFlMypIW0E+PjJdKTtIW0I+PjJdPUkuZ2V0U2Vjb25kcygpLEhbQis0Pj4yXT1JLmdldE1pbnV0ZXMoKSxIW0IrOD4+Ml09SS5nZXRIb3VycygpLEhbQisxMj4+Ml09SS5nZXREYXRlKCksSFtCKzE2Pj4yXT1JLmdldE1vbnRoKCksSFtCKzIwPj4yXT1JLmdldEZ1bGxZZWFyKCktMTkwMCxIW0IrMjQ+PjJdPUkuZ2V0RGF5KCk7dmFyIGc9bmV3IERhdGUoSS5nZXRGdWxsWWVhcigpLDAsMSksUT0oSS5nZXRUaW1lKCktZy5nZXRUaW1lKCkpLzg2NGU1fDA7SFtCKzI4Pj4yXT1RLEhbQiszNj4+Ml09LTYwKkkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgRT1uZXcgRGF0ZSgyZTMsNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEM9Zy5nZXRUaW1lem9uZU9mZnNldCgpLGk9MHwoRSE9QyYmSS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbihDLEUpKTtIW0IrMzI+PjJdPWk7dmFyIG89SFt2QisoaT80OjApPj4yXTtyZXR1cm4gSFtCKzQwPj4yXT1vLEJ9KEEseEIpfSxfbWt0aW1lOmZ1bmN0aW9uKEEpe1hCKCk7dmFyIEI9bmV3IERhdGUoSFtBKzIwPj4yXSsxOTAwLEhbQSsxNj4+Ml0sSFtBKzEyPj4yXSxIW0ErOD4+Ml0sSFtBKzQ+PjJdLEhbQT4+Ml0sMCksST1IW0ErMzI+PjJdLGc9Qi5nZXRUaW1lem9uZU9mZnNldCgpLFE9bmV3IERhdGUoQi5nZXRGdWxsWWVhcigpLDAsMSksRT1uZXcgRGF0ZSgyZTMsNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEM9US5nZXRUaW1lem9uZU9mZnNldCgpLGk9TWF0aC5taW4oQyxFKTtpZihJPDApSFtBKzMyPj4yXT1OdW1iZXIoRSE9QyYmaT09Zyk7ZWxzZSBpZihJPjAhPShpPT1nKSl7dmFyIG89TWF0aC5tYXgoQyxFKSx0PUk+MD9pOm87Qi5zZXRUaW1lKEIuZ2V0VGltZSgpKzZlNCoodC1nKSl9SFtBKzI0Pj4yXT1CLmdldERheSgpO3ZhciBlPShCLmdldFRpbWUoKS1RLmdldFRpbWUoKSkvODY0ZTV8MDtyZXR1cm4gSFtBKzI4Pj4yXT1lLEIuZ2V0VGltZSgpLzFlM3wwfSxfcHRocmVhZF9nZXRzcGVjaWZpYzpmdW5jdGlvbihBKXtyZXR1cm4gVkJbQV18fDB9LF9wdGhyZWFkX2tleV9jcmVhdGU6ZnVuY3Rpb24oQSxCKXtyZXR1cm4gMD09QT9oQS5FSU5WQUw6KEhbQT4+Ml09T0IsVkJbT0JdPTAsT0IrKywwKX0sX3B0aHJlYWRfb25jZTpmdW5jdGlvbiBBKEIsSSl7QS5zZWVufHwoQS5zZWVuPXt9KSxCIGluIEEuc2Vlbnx8KEUuZHluQ2FsbF92KEkpLEEuc2VlbltCXT0xKX0sX3B0aHJlYWRfc2V0c3BlY2lmaWM6ZnVuY3Rpb24oQSxCKXtyZXR1cm4gQSBpbiBWQj8oVkJbQV09QiwwKTpoQS5FSU5WQUx9LF90aW1lOmZ1bmN0aW9uKEEpe3ZhciBCPURhdGUubm93KCkvMWUzfDA7cmV0dXJuIEEmJihIW0E+PjJdPUIpLEJ9LERZTkFNSUNUT1BfUFRSOlcsU1RBQ0tUT1A6dn07dmFyIGpCPUUuYXNtKEUuYXNtR2xvYmFsQXJnLEUuYXNtTGlicmFyeUFyZyxNKTtFLmFzbT1qQjt2YXIgWkI9RS5fX0dMT0JBTF9fc3ViX0lfYmluZF9jcHA9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sUEI9RS5fX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcD1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5fX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcC5hcHBseShudWxsLGFyZ3VtZW50cyl9LHpCPUUuX19HTE9CQUxfX3N1Yl9JX2NyY19jcHA9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uX19HTE9CQUxfX3N1Yl9JX2NyY19jcHAuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxfQj1FLl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwLmFwcGx5KG51bGwsYXJndW1lbnRzKX07RS5fX19jeGFfY2FuX2NhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLl9fX2N4YV9jYW5fY2F0Y2guYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLl9fX2N4YV9pc19wb2ludGVyX3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uX19fY3hhX2lzX3BvaW50ZXJfdHlwZS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEUuX19fZXJybm9fbG9jYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uX19fZXJybm9fbG9jYXRpb24uYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgJEI9RS5fX19nZXRUeXBlTmFtZT1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5fX19nZXRUeXBlTmFtZS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEFJPUUuX2Vtc2NyaXB0ZW5fcmVwbGFjZV9tZW1vcnk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uX2Vtc2NyaXB0ZW5fcmVwbGFjZV9tZW1vcnkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxCST1FLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLl9mcmVlLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sSUk9RS5fbWFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLl9tYWxsb2MuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxnST1FLnNldFRlbXBSZXQwPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLnNldFRlbXBSZXQwLmFwcGx5KG51bGwsYXJndW1lbnRzKX07RS5zZXRUaHJldz1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5zZXRUaHJldy5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBRST1FLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uc3RhY2tBbGxvYy5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIEVJKEEpe3RoaXMubmFtZT0iRXhpdFN0YXR1cyIsdGhpcy5tZXNzYWdlPSJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCIrQSsiKSIsdGhpcy5zdGF0dXM9QX1mdW5jdGlvbiBDSShBKXtmdW5jdGlvbiBCKCl7RS5jYWxsZWRSdW58fChFLmNhbGxlZFJ1bj0hMCxGfHwoUUF8fChRQT0hMCxfKEFBKSksXyhCQSksRS5vblJ1bnRpbWVJbml0aWFsaXplZCYmRS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGZ1bmN0aW9uKCl7aWYoRS5wb3N0UnVuKWZvcigiZnVuY3Rpb24iPT10eXBlb2YgRS5wb3N0UnVuJiYoRS5wb3N0UnVuPVtFLnBvc3RSdW5dKTtFLnBvc3RSdW4ubGVuZ3RoOylBPUUucG9zdFJ1bi5zaGlmdCgpLGdBLnVuc2hpZnQoQSk7dmFyIEE7XyhnQSl9KCkpKX1BPUF8fEUuYXJndW1lbnRzLGVBPjB8fCghZnVuY3Rpb24oKXtpZihFLnByZVJ1bilmb3IoImZ1bmN0aW9uIj09dHlwZW9mIEUucHJlUnVuJiYoRS5wcmVSdW49W0UucHJlUnVuXSk7RS5wcmVSdW4ubGVuZ3RoOylBPUUucHJlUnVuLnNoaWZ0KCksJC51bnNoaWZ0KEEpO3ZhciBBO18oJCl9KCksZUE+MHx8RS5jYWxsZWRSdW58fChFLnNldFN0YXR1cz8oRS5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7RS5zZXRTdGF0dXMoIiIpfSksMSksQigpfSksMSkpOkIoKSkpfWZ1bmN0aW9uIGlJKEEpe3Rocm93IEUub25BYm9ydCYmRS5vbkFib3J0KEEpLHZvaWQgMCE9PUE/KEUucHJpbnQoQSksRS5wcmludEVycihBKSxBPUpTT04uc3RyaW5naWZ5KEEpKTpBPSIiLEY9ITAsImFib3J0KCIrQSsiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby4ifWlmKEUuZHluQ2FsbF9kaWk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF9kaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfaT1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5keW5DYWxsX2kuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfaWk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF9paS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEUuZHluQ2FsbF9paWk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF9paWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfaWlpaT1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5keW5DYWxsX2lpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfaWlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF9paWlpaS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEUuZHluQ2FsbF9paWlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF9paWlpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfaWlpaWlpaT1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5keW5DYWxsX2lpaWlpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfaWlpaWlpaWlpaT1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5keW5DYWxsX2lpaWlpaWlpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfaWlpaWlpamlpPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLmR5bkNhbGxfaWlpaWlpamlpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX2lqaj1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5keW5DYWxsX2lqai5hcHBseShudWxsLGFyZ3VtZW50cyl9LEUuZHluQ2FsbF9qaT1mdW5jdGlvbigpe3JldHVybiBFLmFzbS5keW5DYWxsX2ppLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3Y9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF92LmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3ZpPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLmR5bkNhbGxfdmkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfdmlpPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLmR5bkNhbGxfdmlpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3ZpaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF92aWlkLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3ZpaWk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF92aWlpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3ZpaWlpPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLmR5bkNhbGxfdmlpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfdmlpaWlpPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLmR5bkNhbGxfdmlpaWlpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3ZpaWlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF92aWlpaWlpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3ZpaWlpaWlpaWk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF92aWlpaWlpaWlpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3ZpaWlpaWlpaWlpPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLmR5bkNhbGxfdmlpaWlpaWlpaWkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxFLmR5bkNhbGxfdmlqPWZ1bmN0aW9uKCl7cmV0dXJuIEUuYXNtLmR5bkNhbGxfdmlqLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5keW5DYWxsX3Zpamk9ZnVuY3Rpb24oKXtyZXR1cm4gRS5hc20uZHluQ2FsbF92aWppLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sRS5hc209akIsRUkucHJvdG90eXBlPW5ldyBFcnJvcixFSS5wcm90b3R5cGUuY29uc3RydWN0b3I9RUksckE9ZnVuY3Rpb24gQSgpe0UuY2FsbGVkUnVufHxDSSgpLEUuY2FsbGVkUnVufHwockE9QSl9LEUucnVuPUNJLEUuZXhpdD1mdW5jdGlvbihBLEIpe0ImJkUubm9FeGl0UnVudGltZSYmMD09PUF8fChFLm5vRXhpdFJ1bnRpbWV8fChGPSEwLHY9dW5kZWZpbmVkLF8oSUEpLEUub25FeGl0JiZFLm9uRXhpdChBKSksciYmcHJvY2Vzcy5leGl0KEEpLEUucXVpdChBLG5ldyBFSShBKSkpfSxFLmFib3J0PWlJLEUucHJlSW5pdClmb3IoImZ1bmN0aW9uIj09dHlwZW9mIEUucHJlSW5pdCYmKEUucHJlSW5pdD1bRS5wcmVJbml0XSk7RS5wcmVJbml0Lmxlbmd0aD4wOylFLnByZUluaXQucG9wKCkoKTtyZXR1cm4gRS5ub0V4aXRSdW50aW1lPSEwLENJKCksQn07ZnVuY3Rpb24gRSh7cmVzb3VyY2VJZDpBLHVybDpCfSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihBLFEpe2lmKCFJKXRocm93IG5ldyBFcnJvcigidW5wYWNrQnJpZGdlIG5vdCBkZXRlY3RlZCIpO2lmKCFnKXRocm93IG5ldyBFcnJvcigidW5wYWNrIG5vdCBkZXRlY3RlZCIpOyhmdW5jdGlvbihBKXtyZXR1cm4gZmV0Y2gobmV3IFJlcXVlc3QoQSkpLnRoZW4oKEE9PntpZihBLm9rKXJldHVybiBBLmFycmF5QnVmZmVyKCk7dGhyb3cgbmV3IEVycm9yKCI0MDQgRXJyb3I6IEZpbGUgbm90IGZvdW5kLiIpfSkpLnRoZW4oKEE9PkkuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGEoQSkpKX0pKEIpLnRoZW4oKEI9PntBKEIuZXh0cmFjdEFsbCgpKX0pLChBPT57UShBKX0pKX0pKX1mdW5jdGlvbiBDKEEsQil7Y29uc3RbSSxnXT1CO2lmKCJGQUlMIj09SS5zdGF0ZSl7Y29uc3QgQj17dHlwZToiRVJST1IiLHJlYXNvbjpJLnJlYXNvbixtc2c6SS5tc2cscmVzb3VyY2VJZDpBLmRhdGEucmVzb3VyY2VJZCx1cmw6QS5kYXRhLnVybH07cmV0dXJuIHZvaWQgc2VsZi5wb3N0TWVzc2FnZShCKX1jb25zdCBRPXt0eXBlOiJGSU5JU0hFRCIscmVzb3VyY2VJZDpBLmRhdGEucmVzb3VyY2VJZCxlbnRyaWVzOnt9fSxFPVtdO2lmKGcmJmcuZmlsZXMpZm9yKGNvbnN0IEEgb2YgZy5maWxlcylRLmVudHJpZXNbQS5maWxlSGVhZGVyLm5hbWVdPUEuZXh0cmFjdFsxXSxFLnB1c2goQS5leHRyYWN0WzFdLmJ1ZmZlcik7c2VsZi5wb3N0TWVzc2FnZShRLEUpfW9ubWVzc2FnZT1mdW5jdGlvbihBKXtpZigiaW5pdCI9PUEuZGF0YS50eXBlKWc9USgiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFHRnpiUUVBQUFBQnJnSWxZQUYvQVg1Z0EzOS9md0YvWUFOL2ZuOEFZQVIvZjM5L0FYOWdBbjkvQVg5Z0FBRi9ZQUovZndCZ0EzOS9md0JnQUFCZ0FYOEJmMkFFZjM5L2Z3QmdCbjkvZjM5L2Z3QmdCWDkvZjM5L0FHQUNmMzhCZkdBRmYzOS9mMzhCZjJBR2YzOS9mMzkvQVg5Z0NYOS9mMzkvZjM5L2Z3Ri9ZQWgvZjM5L2YzNS9md0YvWUFKK2ZnRi9ZQUYvQUdBRGYzOThBR0FKZjM5L2YzOS9mMzkvQUdBS2YzOS9mMzkvZjM5L2Z3QmdBbjkrQUdBSGYzOS9mMzkvZndGL1lBcC9mMzkvZjM5L2YzOS9BWDlnQjM5L2YzOS9mMzhBWUF0L2YzOS9mMzkvZjM5L2Z3QmdEWDkvZjM5L2YzOS9mMzkvZjM4QVlBaC9mMzkvZjM5L2Z3QmdBMzkrZndGL1lBTitmMzhCZjJBQ2ZuOEJmMkFHZjN4L2YzOS9BWDlnQW54L0FYeGdBMzkvZndGOFlBUi9mMzk4QUFLSUQxY0RaVzUyQm0xbGJXOXllUUlBZ0FJRFpXNTJCWFJoWW14bEFYQUJ2QUs4QWdObGJuWUpkR0ZpYkdWQ1lYTmxBMzhBQTJWdWRnNUVXVTVCVFVsRFZFOVFYMUJVVWdOL0FBTmxibllJVTFSQlEwdFVUMUFEZndBRFpXNTJCV0ZpYjNKMEFCTURaVzUyRFdWdWJHRnlaMlZOWlcxdmNua0FCUU5sYm5ZT1oyVjBWRzkwWVd4TlpXMXZjbmtBQlFObGJuWVhZV0p2Y25SUGJrTmhibTV2ZEVkeWIzZE5aVzF2Y25rQUJRTmxibllJYVc1MmIydGxYMmtBQ1FObGJuWUphVzUyYjJ0bFgybHBBQVFEWlc1MkNtbHVkbTlyWlY5cGFXa0FBUU5sYm5ZTGFXNTJiMnRsWDJscGFXa0FBd05sYm5ZTWFXNTJiMnRsWDJscGFXbHBBQTREWlc1MkRtbHVkbTlyWlY5cGFXbHBhV2xwQUJnRFpXNTJFV2x1ZG05clpWOXBhV2xwYVdscGFXbHBBQmtEWlc1MkNHbHVkbTlyWlY5MkFCTURaVzUyQ1dsdWRtOXJaVjkyYVFBR0EyVnVkZ3BwYm5admEyVmZkbWxwQUFjRFpXNTJDMmx1ZG05clpWOTJhV2xwQUFvRFpXNTJER2x1ZG05clpWOTJhV2xwYVFBTUEyVnVkZzFwYm5admEyVmZkbWxwYVdscEFBc0RaVzUyRG1sdWRtOXJaVjkyYVdscGFXbHBBQm9EWlc1MkVXbHVkbTlyWlY5MmFXbHBhV2xwYVdscEFCWURaVzUyRW1sdWRtOXJaVjkyYVdscGFXbHBhV2xwYVFBYkEyVnVkaGxmWDE5amVHRmZZV3hzYjJOaGRHVmZaWGhqWlhCMGFXOXVBQWtEWlc1MkVsOWZYMk40WVY5aVpXZHBibDlqWVhSamFBQUpBMlZ1ZGhCZlgxOWplR0ZmWlc1a1gyTmhkR05vQUFnRFpXNTJIRjlmWDJONFlWOW1hVzVrWDIxaGRHTm9hVzVuWDJOaGRHTm9YeklBQlFObGJuWWNYMTlmWTNoaFgyWnBibVJmYldGMFkyaHBibWRmWTJGMFkyaGZNd0FKQTJWdWRoeGZYMTlqZUdGZlptbHVaRjl0WVhSamFHbHVaMTlqWVhSamFGODBBQVFEWlc1MkZWOWZYMk40WVY5bWNtVmxYMlY0WTJWd2RHbHZiZ0FUQTJWdWRneGZYMTlqZUdGZmRHaHliM2NBQndObGJuWUhYMTlmYkc5amF3QVRBMlZ1ZGd0ZlgxOXRZWEJmWm1sc1pRQUVBMlZ1ZGhKZlgxOXlaWE4xYldWRmVHTmxjSFJwYjI0QUV3TmxibllMWDE5ZmMyVjBSWEp5VG04QUV3TmxibllOWDE5ZmMzbHpZMkZzYkRFME1BQUVBMlZ1ZGcxZlgxOXplWE5qWVd4c01UUTFBQVFEWlc1MkRWOWZYM041YzJOaGJHd3hORFlBQkFObGJuWU5YMTlmYzNselkyRnNiREU0TXdBRUEyVnVkZzFmWDE5emVYTmpZV3hzTVRrNEFBUURaVzUyREY5ZlgzTjVjMk5oYkd3eU1BQUVBMlZ1ZGd0ZlgxOXplWE5qWVd4c05nQUVBMlZ1ZGd4ZlgxOXplWE5qWVd4c05qQUFCQU5sYm5ZTVgxOWZjM2x6WTJGc2JEZ3pBQVFEWlc1MkRGOWZYM041YzJOaGJHdzVNUUFFQTJWdWRnbGZYMTkxYm14dlkyc0FFd05sYm5ZZVgxOWxiV0pwYm1SZlptbHVZV3hwZW1WZmRtRnNkV1ZmYjJKcVpXTjBBQk1EWlc1MkZsOWZaVzFpYVc1a1gzSmxaMmx6ZEdWeVgySnZiMndBREFObGJuWVhYMTlsYldKcGJtUmZjbVZuYVhOMFpYSmZZMnhoYzNNQUhBTmxibllqWDE5bGJXSnBibVJmY21WbmFYTjBaWEpmWTJ4aGMzTmZZMjl1YzNSeWRXTjBiM0lBQ3dObGJuWWdYMTlsYldKcGJtUmZjbVZuYVhOMFpYSmZZMnhoYzNOZlpuVnVZM1JwYjI0QUhRTmxibllYWDE5bGJXSnBibVJmY21WbmFYTjBaWEpmWlcxMllXd0FCZ05sYm5ZWFgxOWxiV0pwYm1SZmNtVm5hWE4wWlhKZlpteHZZWFFBQndObGJuWVpYMTlsYldKcGJtUmZjbVZuYVhOMFpYSmZhVzUwWldkbGNnQU1BMlZ1ZGgxZlgyVnRZbWx1WkY5eVpXZHBjM1JsY2w5dFpXMXZjbmxmZG1sbGR3QUhBMlZ1ZGh4ZlgyVnRZbWx1WkY5eVpXZHBjM1JsY2w5emRHUmZjM1J5YVc1bkFBWURaVzUySFY5ZlpXMWlhVzVrWDNKbFoybHpkR1Z5WDNOMFpGOTNjM1J5YVc1bkFBY0RaVzUySGw5ZlpXMWlhVzVrWDNKbFoybHpkR1Z5WDNaaGJIVmxYMjlpYW1WamRBQUxBMlZ1ZGlSZlgyVnRZbWx1WkY5eVpXZHBjM1JsY2w5MllXeDFaVjl2WW1wbFkzUmZabWxsYkdRQUZnTmxibllXWDE5bGJXSnBibVJmY21WbmFYTjBaWEpmZG05cFpBQUdBMlZ1ZGdaZllXSnZjblFBQ0FObGJuWVdYMlZ0YzJOeWFYQjBaVzVmYldWdFkzQjVYMkpwWndBQkEyVnVkZ2RmWjJWMFpXNTJBQWtEWlc1MkNWOW5aWFJuY201aGJRQUpBMlZ1ZGdsZloyVjBjSGR1WVcwQUNRTmxibllJWDJwelEyeHZjMlVBRXdObGJuWUpYMnB6UTNKbFlYUmxBQWtEWlc1MkIxOXFjMDl3Wlc0QUNRTmxibllIWDJwelVtVmhaQUFCQTJWdWRnZGZhbk5UWldWckFBRURaVzUyQ0Y5cWMxZHlhWFJsQUFFRFpXNTJFMTlzYkhadFgyVm9YM1I1Y0dWcFpGOW1iM0lBQ1FObGJuWUtYMnh2WTJGc2RHbHRaUUFKQTJWdWRnZGZiV3QwYVcxbEFBa0RaVzUyRkY5d2RHaHlaV0ZrWDJkbGRITndaV05wWm1sakFBa0RaVzUyRTE5d2RHaHlaV0ZrWDJ0bGVWOWpjbVZoZEdVQUJBTmxibllOWDNCMGFISmxZV1JmYjI1alpRQUVBMlZ1ZGhSZmNIUm9jbVZoWkY5elpYUnpjR1ZqYVdacFl3QUVBMlZ1ZGdWZmRHbHRaUUFKQTJWdWRoQnBiblp2YTJWZmFXbHBhV2xwYW1scEFCa0RaVzUyQ21sdWRtOXJaVjlwYW1vQURnTmxibllKYVc1MmIydGxYMnBwQUFRRFpXNTJDbWx1ZG05clpWOTJhV29BQ2dObGJuWUxhVzUyYjJ0bFgzWnBhbWtBREFObGJuWUhYMnB6VkdWc2JBQUpBNFFFZ2dRVEFRRUdFd1FKQ1JNR0V3RUJDUWNBRXdjR0J3d0pDZ0VFQVFrR0NRRVRDUWtFQkFRSEJBRVRBUUVKQnhNSEF3a0dCaE1JQmdrVEFSTUVCQk1UQVFFQklBa0pFeE1HRXdFRENRSUVFd2NFRXhNS0JnRUpEQXNJQkF3RUJBRUVCQWNKQndrRENoTUdFQUVSREFBRkN3d0tCd01CQndFRUJnRUpBUUVPQVFrRUFCTUFBUVlIQkJNVEFRa1RFd1lUQmhNSkNnWU1DZ0VBQndjR0JBY1RCQVFFQWhjS0R3UUhCd29CRXhNVEJRRURCQWNKRGdRRUNRRUJBd1FKQVNJSkFRUUpCQWtHQ1FFQkJ3UUhCQk1CQ1E0SkJnTUJFd1lUQVF3QkJ3Y0hCaE1YQmhNSEJoTVRFd2tQQkFrVEV3UUdGUjBNQmdZR0J3a1RDUWtKQVFFSkFRQUpCQW9UQ1FrSkV3WUdCQk1FQUFJQkFSTU1DZ1FPR1JZVkNCUVNFUklHRUE0QkRSc1dHZ3NNQ2lRSEJoTVpHQThPQXdFRUl3a0JDZ3dMQndFVENRa0lFd1lJQ2d3TENnd0xBUWdFQmgwQkFRa0VCaDBFQmdZR0NRTUVCQUVFQVFFQkFRRUVCQVFKQXdNSEJBRWhJQjhEQXdRQkJBUUJCQWtCQlFFQkNRUUpFd2dFQ1FFRUhoTURGQTBGQ2dVSEJCTUZBUWNFQmc0TUJSTUpFd2NJQXdZUEV4TVRCZ2NIQmdNRUFRWUJCZ01KQ1FZVEJBWVRCaE1FQmdRVEFSTVRCaDRHRnc4QkJ3a0RCZ1FEQndjQkJBUUdCZ1lCQ1FrR0V3WUdBd2NURXdvVEJoTVRCd29HRXdjR0J3WVRCd2NURlFjSEV4TVRCZ2tHQmdRTEV3UUpCQU1CRXdnSkJob0Zmd0VqQVF0L0FTTUNDMzhCUVFBTGZ3RkJBQXQvQVVFQUN3ZVhCU1VZWDE5SFRFOUNRVXhmWDNOMVlsOUpYMkpwYm1SZlkzQndBTkVER2w5ZlIweFBRa0ZNWDE5emRXSmZTVjlpY21sa1oyVmZZM0J3QU8wREYxOWZSMHhQUWtGTVgxOXpkV0pmU1Y5amNtTmZZM0J3QU5JRUdsOWZSMHhQUWtGTVgxOXpkV0pmU1Y5bmJHOWlZV3hmWTNCd0FPb0NFRjlmWDJONFlWOWpZVzVmWTJGMFkyZ0Fod01XWDE5ZlkzaGhYMmx6WDNCdmFXNTBaWEpmZEhsd1pRQ0dBeEZmWDE5bGNuSnViMTlzYjJOaGRHbHZiZ0RLQXc1ZlgxOW5aWFJVZVhCbFRtRnRaUURQQXdWZlpuSmxaUUJTQjE5dFlXeHNiMk1BYkF0a2VXNURZV3hzWDJScGFRQ0ZBd2xrZVc1RFlXeHNYMmtBbndJS1pIbHVRMkZzYkY5cGFRQ0VBd3RrZVc1RFlXeHNYMmxwYVFDREF3eGtlVzVEWVd4c1gybHBhV2tBZ2dNTlpIbHVRMkZzYkY5cGFXbHBhUUNCQXc1a2VXNURZV3hzWDJscGFXbHBhUUNBQXc5a2VXNURZV3hzWDJscGFXbHBhV2tBL3dJU1pIbHVRMkZzYkY5cGFXbHBhV2xwYVdscEFQNENFV1I1YmtOaGJHeGZhV2xwYVdscGFtbHBBT2NDQzJSNWJrTmhiR3hmYVdwcUFPWUNDbVI1YmtOaGJHeGZhbWtBNVFJSlpIbHVRMkZzYkY5MkFQMENDbVI1YmtOaGJHeGZkbWtBL0FJTFpIbHVRMkZzYkY5MmFXa0Erd0lNWkhsdVEyRnNiRjkyYVdsa0FQb0NER1I1YmtOaGJHeGZkbWxwYVFENUFnMWtlVzVEWVd4c1gzWnBhV2xwQVBnQ0RtUjVia05oYkd4ZmRtbHBhV2xwQVBjQ0QyUjVia05oYkd4ZmRtbHBhV2xwYVFEMkFoSmtlVzVEWVd4c1gzWnBhV2xwYVdscGFXa0E5UUlUWkhsdVEyRnNiRjkyYVdscGFXbHBhV2xwYVFEMEFndGtlVzVEWVd4c1gzWnBhZ0RrQWd4a2VXNURZV3hzWDNacGFta0E0d0lMYzJWMFZHVnRjRkpsZERBQTNBSUljMlYwVkdoeVpYY0E3d0lLYzNSaFkydEJiR3h2WXdEVEJBbktCQUVBSXdBTHZBTHpBdG9EdmdIb0ErRUQzUVBiQS80QnZnRytBWUVCelFPUEE0NERYOFlFZktrRDB3T2xCTTBFdXdLbUFjb0N5d0s0QXBZQzBRS1dBcklCY1ZqcUE1OEN4d0tCQVlFQmdRR0JBWUVCZ1FHQkFhb0I4UUhkQXU4QnZnSnFjNWtFMGdMYkFzNEU4QUhNQkxvQ3lRVFNBOVVENUFQWEFkOERuQUthQXRjQm5BS2FBdGNCdXdPaUE1d0RxZ0dxQWFvQjhnTGhBdUFDbUFMVUFjd0R5d1BKQTd3RG1nUDZBWXdEK2dHZUFtbXVBVzk3ZXBrQnp3SzZBY3dDcWdLVUJLTUUxQU5lNGdPSkFzUUJyd09BQWNNQnRRR1hCTzREbWdUK0E5Z0R6d1NBQVlBQmdBR0FBWUFCZ0FHQUFmRUM1Z1AxQWJrQ2t3VDFBZkFDdVFIdEFyc0I3QUx1QXIwQjNnTFRBV0hRQXRFQnZRRzlBYWtCbXdPRkFaTURGcWtCcVFHcEFXSis0Z0p3MXdPM0FZZ0J0d0czQVlnQnR3R0lBZndCK3dIN0FZZ0JpQUdJQVlnQjhnTlcyQUszQXI0RXZRTEVCTFlDOHdQVUFzc0VvZ0d2QXJJRXB3VFNBWllCdGdTTEJQRUQ2UVBnQXl1ZEFwMENQcEVEWW1KaVltSmlZbUppWW1KaVltSmlZbUppaGdIYUFwZ0VwZ0x2QTVFRXlBR2lBdlFEeFFSa3lBVEhCSmNCVzZBRVZlUUI1UVBWQWFNRHBnT2RBNmNEcUFPQ0FZWUJoZ0dHQVlZQmhnR0dBZXNDMlFOLzZnRmd3UVNzQXZZRDlRUEFCT3dEZmIwRXZBU1ZCTGtFWmVNRDFnSGVBNXNDbVFMV0Fac0NtUUxXQVJ0L2YzOS9mMzkvOUFHWEE1UURpQVBjQTlNQ3RBVDBBYndCbUFPVkE0a0RxUUxuQTd3QnZBR29BWmtEbGdPS0E4b0VxQUdvQWFnQjZRSy9CT2dDTi9NQnNBS1NCUE1COGdIZkFwd0I4Z0VLN0lzTmdnVG9EUUVJZnlBQVJRUkFEd3RCMExjREtBSUFJUUlnQUVGNGFpSUVJQUJCZkdvb0FnQWlBRUY0Y1NJQmFpRUdBbjhnQUVFQmNRUi9JQVFpQUFVZ0JDZ0NBQ0VESUFCQkEzRkZCRUFQQ3lBRUlBTnJJZ0FnQWtrRVFBOExJQU1nQVdvaEFVSFV0d01vQWdBZ0FFWUVRQ0FBSUFaQkJHb2lBaWdDQUNJRVFRTnhRUU5IRFFJYVFjaTNBeUFCTmdJQUlBSWdCRUYrY1RZQ0FDQUFJQUZCQVhJMkFnUWdBQ0FCYWlBQk5nSUFEd3NnQTBFRGRpRUVJQU5CZ0FKSkJFQWdBQ2dDRENJRElBQW9BZ2dpQWtZRVFFSEF0d05Cd0xjREtBSUFRUUVnQkhSQmYzTnhOZ0lBQlNBQ0lBTTJBZ3dnQXlBQ05nSUlDeUFBREFJTElBQW9BaGdoQndKQUlBQW9BZ3dpQkNBQVJnUkFJQUJCRUdvaUEwRUVhaUlDS0FJQUlnUkZCRUFnQXlnQ0FDSUVCRUFnQXlFQ0JVRUFJUVFNQXdzTEEwQWdCRUVVYWlJRktBSUFJZ01FUUNBRElRUWdCU0VDREFFTElBUkJFR29pQlNnQ0FDSURCRUFnQXlFRUlBVWhBZ3dCQ3dzZ0FrRUFOZ0lBQlNBQUtBSUlJZ0lnQkRZQ0RDQUVJQUkyQWdnTEN5QUhCSDhnQUNnQ0hDSURRUUowUWZDNUEyb2lBaWdDQUNBQVJnUkFJQUlnQkRZQ0FDQUVSUVJBUWNTM0EwSEV0d01vQWdCQkFTQURkRUYvYzNFMkFnQWdBQXdFQ3dVZ0IwRVFhaUFIS0FJUUlBQkhRUUowYWlBRU5nSUFJQUFnQkVVTkF4b0xJQVFnQnpZQ0dDQUFRUkJxSWdJb0FnQWlBd1JBSUFRZ0F6WUNFQ0FESUFRMkFoZ0xJQUlvQWdRaUFnUkFJQVFnQWpZQ0ZDQUNJQVEyQWhnTElBQUZJQUFMQ3dzaUJDQUdUd1JBRHdzZ0JrRUVhaUlDS0FJQUlnTkJBWEZGQkVBUEN5QURRUUp4QkVBZ0FpQURRWDV4TmdJQUlBQWdBVUVCY2pZQ0JDQUVJQUZxSUFFMkFnQWdBU0VFQlVIWXR3TW9BZ0FnQmtZRVFFSE10d05CekxjREtBSUFJQUZxSWdFMkFnQkIyTGNESUFBMkFnQWdBQ0FCUVFGeU5nSUVJQUJCMUxjREtBSUFSd1JBRHd0QjFMY0RRUUEyQWdCQnlMY0RRUUEyQWdBUEMwSFV0d01vQWdBZ0JrWUVRRUhJdHdOQnlMY0RLQUlBSUFGcUlnRTJBZ0JCMUxjRElBUTJBZ0FnQUNBQlFRRnlOZ0lFSUFRZ0FXb2dBVFlDQUE4TElBTkJlSEVnQVdvaEJ5QURRUU4ySVFFQ1FDQURRWUFDU1FSQUlBWW9BZ3dpQXlBR0tBSUlJZ0pHQkVCQndMY0RRY0MzQXlnQ0FFRUJJQUYwUVg5emNUWUNBQVVnQWlBRE5nSU1JQU1nQWpZQ0NBc0ZJQVlvQWhnaENBSkFJQVlvQWd3aUFTQUdSZ1JBSUFaQkVHb2lBMEVFYWlJQ0tBSUFJZ0ZGQkVBZ0F5Z0NBQ0lCQkVBZ0F5RUNCVUVBSVFFTUF3c0xBMEFnQVVFVWFpSUZLQUlBSWdNRVFDQURJUUVnQlNFQ0RBRUxJQUZCRUdvaUJTZ0NBQ0lEQkVBZ0F5RUJJQVVoQWd3QkN3c2dBa0VBTmdJQUJTQUdLQUlJSWdJZ0FUWUNEQ0FCSUFJMkFnZ0xDeUFJQkVBZ0JpZ0NIQ0lEUVFKMFFmQzVBMm9pQWlnQ0FDQUdSZ1JBSUFJZ0FUWUNBQ0FCUlFSQVFjUzNBMEhFdHdNb0FnQkJBU0FEZEVGL2MzRTJBZ0FNQkFzRklBaEJFR29nQ0NnQ0VDQUdSMEVDZEdvZ0FUWUNBQ0FCUlEwREN5QUJJQWcyQWhnZ0JrRVFhaUlDS0FJQUlnTUVRQ0FCSUFNMkFoQWdBeUFCTmdJWUN5QUNLQUlFSWdJRVFDQUJJQUkyQWhRZ0FpQUJOZ0lZQ3dzTEN5QUFJQWRCQVhJMkFnUWdCQ0FIYWlBSE5nSUFJQUJCMUxjREtBSUFSZ1JBUWNpM0F5QUhOZ0lBRHdVZ0J5RUVDd3NnQkVFRGRpRUJJQVJCZ0FKSkJFQWdBVUVEZEVIb3R3TnFJUUpCd0xjREtBSUFJZ1JCQVNBQmRDSUJjUVIvSUFKQkNHb2lBU2dDQUFWQndMY0RJQVFnQVhJMkFnQWdBa0VJYWlFQklBSUxJUVFnQVNBQU5nSUFJQVFnQURZQ0RDQUFJQVEyQWdnZ0FDQUNOZ0lNRHdzZ0JFRUlkaUlCQkg4Z0JFSC8vLzhIU3dSL1FSOEZJQVJCRGlBQklBRkJnUDQvYWtFUWRrRUljU0lEZENJQ1FZRGdIMnBCRUhaQkJIRWlBU0FEY2lBQ0lBRjBJZ0pCZ0lBUGFrRVFka0VDY1NJQmNtc2dBaUFCZEVFUGRtb2lBVUVIYW5aQkFYRWdBVUVCZEhJTEJVRUFDeUlGUVFKMFFmQzVBMm9oQXlBQUlBVTJBaHdnQUVFQU5nSVVJQUJCQURZQ0VBSkFRY1MzQXlnQ0FDSUNRUUVnQlhRaUFYRUVRQ0FES0FJQUlRRkJHU0FGUVFGMmF5RUNJQVFnQlVFZlJnUi9RUUFGSUFJTGRDRUZBa0FEUUNBQktBSUVRWGh4SUFSR0RRRWdCVUVCZENFRElBRkJFR29nQlVFZmRrRUNkR29pQlNnQ0FDSUNCRUFnQXlFRklBSWhBUXdCQ3dzZ0JTQUFOZ0lBSUFBZ0FUWUNHQ0FBSUFBMkFnd2dBQ0FBTmdJSURBSUxJQUZCQ0dvaUFpZ0NBQ0lFSUFBMkFnd2dBaUFBTmdJQUlBQWdCRFlDQ0NBQUlBRTJBZ3dnQUVFQU5nSVlCVUhFdHdNZ0FpQUJjallDQUNBRElBQTJBZ0FnQUNBRE5nSVlJQUFnQURZQ0RDQUFJQUEyQWdnTEMwSGd0d05CNExjREtBSUFRWDlxSWdBMkFnQWdBQVJBRHdWQmlMc0RJUUFMQTBBZ0FDZ0NBQ0lCUVFocUlRQWdBUTBBQzBIZ3R3TkJmellDQUF2REF3RURmeUFDUVlEQUFFNEVRQ0FBSUFFZ0FoQTZEd3NnQUNFRUlBQWdBbW9oQXlBQVFRTnhJQUZCQTNGR0JFQURRQ0FBUVFOeEJFQWdBa1VFUUNBRUR3c2dBQ0FCTEFBQU9nQUFJQUJCQVdvaEFDQUJRUUZxSVFFZ0FrRUJheUVDREFFTEN5QURRWHh4SWdKQlFHb2hCUU5BSUFBZ0JVd0VRQ0FBSUFFb0FnQTJBZ0FnQUNBQktBSUVOZ0lFSUFBZ0FTZ0NDRFlDQ0NBQUlBRW9BZ3cyQWd3Z0FDQUJLQUlRTmdJUUlBQWdBU2dDRkRZQ0ZDQUFJQUVvQWhnMkFoZ2dBQ0FCS0FJY05nSWNJQUFnQVNnQ0lEWUNJQ0FBSUFFb0FpUTJBaVFnQUNBQktBSW9OZ0lvSUFBZ0FTZ0NMRFlDTENBQUlBRW9BakEyQWpBZ0FDQUJLQUkwTmdJMElBQWdBU2dDT0RZQ09DQUFJQUVvQWp3MkFqd2dBRUZBYXlFQUlBRkJRR3NoQVF3QkN3c0RRQ0FBSUFKSUJFQWdBQ0FCS0FJQU5nSUFJQUJCQkdvaEFDQUJRUVJxSVFFTUFRc0xCU0FEUVFScklRSURRQ0FBSUFKSUJFQWdBQ0FCTEFBQU9nQUFJQUFnQVN3QUFUb0FBU0FBSUFFc0FBSTZBQUlnQUNBQkxBQURPZ0FESUFCQkJHb2hBQ0FCUVFScUlRRU1BUXNMQ3dOQUlBQWdBMGdFUUNBQUlBRXNBQUE2QUFBZ0FFRUJhaUVBSUFGQkFXb2hBUXdCQ3dzZ0JBdVlBZ0VFZnlBQUlBSnFJUVFnQVVIL0FYRWhBU0FDUWNNQVRnUkFBMEFnQUVFRGNRUkFJQUFnQVRvQUFDQUFRUUZxSVFBTUFRc0xJQVJCZkhFaUJVRkFhaUVHSUFFZ0FVRUlkSElnQVVFUWRISWdBVUVZZEhJaEF3TkFJQUFnQmt3RVFDQUFJQU0yQWdBZ0FDQUROZ0lFSUFBZ0F6WUNDQ0FBSUFNMkFnd2dBQ0FETmdJUUlBQWdBellDRkNBQUlBTTJBaGdnQUNBRE5nSWNJQUFnQXpZQ0lDQUFJQU0yQWlRZ0FDQUROZ0lvSUFBZ0F6WUNMQ0FBSUFNMkFqQWdBQ0FETmdJMElBQWdBellDT0NBQUlBTTJBandnQUVGQWF5RUFEQUVMQ3dOQUlBQWdCVWdFUUNBQUlBTTJBZ0FnQUVFRWFpRUFEQUVMQ3dzRFFDQUFJQVJJQkVBZ0FDQUJPZ0FBSUFCQkFXb2hBQXdCQ3dzZ0JDQUNhd3NyQVFGL0lBQWdBRUVFYWlJQ0tBSUFJQUZxSWdGQkEzWWdBQ2dDQUdvMkFnQWdBaUFCUVFkeE5nSUFDMmtCQVg4akJDRUJJd1JCMEFCcUpBUWdBVUZBYTBFQU5nSUFJQUZCQURZQ1JDQUJRUWMyQWtnZ0FFRUlOZ0lBSUFCQkJHb2lBU0FCS0FJQVFRRnFOZ0lBSUFCQkNEWUNBQ0FCSUFFb0FnQkJBV28yQWdCQkJCQVVJZ0JCQ0RZQ0FDQUFRWUFJUVFBUUd3dVFBUUVDZnlBQVJRUkFJQUVRYkE4TElBRkJ2MzlMQkVCQmlMd0RRUXcyQWdCQkFBOExJQUZCQzJwQmVIRWhBaUFBUVhocUlBRkJDMGtFZjBFUUJTQUNDeERPQXlJQ0JFQWdBa0VJYWc4TElBRVFiQ0lDUlFSQVFRQVBDeUFDSUFBZ0FFRjhhaWdDQUNJRFFYaHhJQU5CQTNFRWYwRUVCVUVJQzJzaUF5QUJTUVIvSUFNRklBRUxFRk1hSUFBUVVpQUNDMElCQW44Z0FDZ0NEQ0lCSUFBb0FnQWlBa0VCYW1vdEFBQkJDSFFnQVNBQ2FpMEFBRUVRZEhJZ0FTQUNRUUpxYWkwQUFISkJDQ0FBS0FJRWEzWkIvLzhEY1Fzb0FRSi9JQUFoQVFOQUlBRkJCR29oQWlBQktBSUFCRUFnQWlFQkRBRUxDeUFCSUFCclFRSjFDd29BSUFBUUZSb1FrQU1MSkFFQmZ5QUJSUVJBRHdzRFFDQUFJQUpxUVFBNkFBQWdBa0VCYWlJQ0lBRkhEUUFMQ3lZQkFYOGdBRUVBT2dDQUJBTkFJQUFnQVdwQkFEb0FBQ0FCUVFGcUlnRkJnQVJIRFFBTEMxMEJBWDhnQVNBQVNDQUFJQUVnQW1wSWNRUkFJQUVnQW1vaEFTQUFJZ01nQW1vaEFBTkFJQUpCQUVvRVFDQUNRUUZySVFJZ0FFRUJheUlBSUFGQkFXc2lBU3dBQURvQUFBd0JDd3NnQXlFQUJTQUFJQUVnQWhCVEdnc2dBQXVQQlFJUWZ3TitJQUpCY0hFaEJDQUJJUVVnQUVHMUFXb2lDU3dBQUVVRVFDQUNJUVFMSUFCQkxHb2hEU0FBUVNCcUlRb2dBRUhSQUdvaERpQUFRVGhxSVE4Z0FFR1FBV29oRUNBQVFmQUFhaUVMSUFCQnpBQnFJUkVnQUVFSWFpRVNJQUJCQkdvaERBSkFBa0FEUUNBRVJRUkFJQU1oQWd3Q0N5QU5LQUlBSVFjZ0FDd0FBQVJBSUFFZ0VpZ0NBQ0FNS0FJQUVGTWFJQXdvQWdBaEFpQU1RUUEyQWdBRklBb3BBd0FpRXlBRXJWTWhDQ0FUcHlFQ0lBZ0VmeUFDQlNBRUlnSUxCRUFnRGl3QUFBUkFJQWtzQUFBRVFDQUNJQUlnQm1wQkQzRnJJZ05CQUVvRVFDQURJUUlMSUFoRkJFQWdCQ0VDQ3dzTElBY29BZ1JGRFFRZ0J5QUZJQUlnQnlnQ0FDZ0NERUVmY1VIS0FHb1JBUUFoQWlBSFFiQ25BV29oQ0NBUEtBSUFJZ01FZnlBREJTQUlDMEdKd1FCcUxBQUFCRUFnRUNBRklBSVFxd0lMQlNBRElRSUxDeUFMSUFzcEF3QWdBcXdpRTN3M0F3QWdBaUFHYWlFR0lBb2dDaWtEQUNBVGZTSVROd01BSUJOQ0FGRWdEaXdBQUVFQVIzRkZEUUVnQWdSQUlBWkJEM0ZGSUFrc0FBQkZjZzBDQ3lBRklBSnFJUVVnQkNBQ2F5RUVJQWNnQUVFQklCRW9BZ0FRdFFFRVFDQUNJUU1NQVFzTElBQkJBVG9BVWtGL0R3c2dEU2dDQUNJREJFQWdDeWtEQUNBRFFZaThBMm9wQXdCOElSUWdBQ3dBS0FSQUlBQXBBMWdoRlNBQUtRT0lBU0lUUWdCUkJFQWdGU0VUQlNBQUtRT0FBU0FVZkNFVUN5QURRYXp6QUdvb0FnQWhBeUFUSUJSVEJIOUI1QUFGSUJOQ0FGRUVmMEVBQlNBVVF1UUFmaUFUZjZjTEN5RUZJQU5CeklRRGFpd0FBRVVFUUNBRklBQkJ5QUJxSWdNb0FnQkhCRUFnQXlBRk5nSUFDd3NMQ3lBQ1FYOUdCRUJCZnlFR0JTQUpMQUFBQkVBZ0FDZ0NSQ0FCSUFZUTZnRUxDeENGQVNBR0R3dEJmd3RpQVFGL0lBQkZCRUJCQVNFQUN3SkFBa0FDUUFOQUlBQVFiQ0lCRFFKQnNMd0RRYkM4QXlnQ0FDSUJOZ0lBSUFGRkRRRWdBVUVIY1VHT0FXb1JDQUFNQUFzQUMwRUVFQlFpQUVIRUpUWUNBQ0FBUWRnS1FRb1FHd3dCQ3lBQkR3dEJBQXRUQVFGL0l3UWhBQ01FUWVBZ2FpUUVJQUJCZ0NCcUlnTWdBallDQUNBQVFZQUlJQUVnQXhDQUFob2dBRUdRSUdvaUFVRUFOZ0pFSUFGQkFUWUNTQ0FCUVVCclFRRTJBZ0FnQVNBQU5nSUFJQUFrQkF0NkFnVi9BWDRnQUVFWWFpSURLQUlBSWdFZ0FDZ0NGQ0lFVHdSQVFnQVBDeUFBS0FJQUlRVWdBU0VBQWtBRFFDQURJQUJCQVdvaUFUWUNBQ0FGSUFCcUxRQUFJZ0JCL3dCeHJTQUNyWVlnQm53aEJpQUFRWUFCY1VVTkFTQUNRUWRxSVFJZ0FTQUVTUVJBSUFFaEFBd0JCVUlBSVFZTEN3c2dCZ3NHQUVFTkVBQUxHQUFnQUNnQ0FFRWdjVVVFUUNBQklBSWdBQkNOQWhvTEMrNENBUUYvQWtBQ1FBSkFBa0FDUUNBQlFRRnJEdjhCQUFJQkF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUF3c2dBQ2dDQUVVRVFDQUFJQUUyQWdBTERBTUxJQUFvQWdCQkMwY0VRQ0FBUVFNMkFnQUxEQUlMSUFBb0FnQkJBa2tFUUNBQVFRSTJBZ0FMREFFTElBQWdBVFlDQUFzZ0FFRUVhaUlDSUFJb0FnQkJBV28yQWdBTHJnSUJBbjhnQUNnQ0xFR3M4d0JxS0FJQUlnTkJwTXNFYWlnQ0FBUkFJQU5Cc01zRWFpZ0NBQ0lFQkVCQkFTQURRYXpMQkdvb0FnQWdBU0FDSUFSQkQzRkI2Z0JxRVFNQVFYOUdCRUJCclBVQ1FmOEJFS1FCQ3dzZ0EwRzR5d1JxS0FJQUlnTUVRQ0FCSUFJZ0EwRWZjVUVxYWhFRUFFVUVRRUdzOVFKQi93RVFwQUVMQ3dzZ0FDQUJOZ0ljSUFBZ0FqWUNHQ0FBTEFBTUJFQWdBRUVRYWlJREtBSUFJQUpQQkVBZ0FFRVVhaUlFS0FJQUlBRWdBaEJUR2lBRUlBUW9BZ0FnQW1vMkFnQWdBeUFES0FJQUlBSnJOZ0lBQ3dVZ0FDd0FLVVVFUUFKL0lBQW9BakFoQTBFQklBSkZEUUFhSUFNb0FnUWdBU0FDRUVNTEdnc0xJQUJCK0FCcUlnTWdBeWtEQUNBQ3JYdzNBd0FnQUN3QUtnUkFFSVVCRHdzZ0FFR29BV29nQVNBQ0VLc0NFSVVCQzRBQkFRRi9Jd1FoQlNNRVFZQUNhaVFFSUFJZ0Ewb2dCRUdBd0FSeFJYRUVRQ0FGSUFGQkdIUkJHSFVnQWlBRGF5SUJRWUFDU1FSL0lBRUZRWUFDQ3hCVUdpQUJRZjhCU3dSQUlBSWdBMnNoQWdOQUlBQWdCVUdBQWhCaklBRkJnSDVxSWdGQi93RkxEUUFMSUFKQi93RnhJUUVMSUFBZ0JTQUJFR01MSUFVa0JBc3JBQ0FBUWY4QmNVRVlkQ0FBUVFoMVFmOEJjVUVRZEhJZ0FFRVFkVUgvQVhGQkNIUnlJQUJCR0haeUM0MEpBUkIvSXdRaEJ5TUVRWUFCYWlRRUlBSWdBellDQUNBSFFVQnJJZ1JDQURjQ0FDQUVRZ0EzQWdnZ0JFSUFOd0lRSUFSQ0FEY0NHQ0FFUWdBM0FpQWdCRUlBTndJb0lBUkNBRGNDTUNBRVFnQTNBamdnQTBVaUV3Ui9JQVJCSkdvaEVDQUVRU2hxSVJGQkFBVkJBQ0VBQTBBZ0JDQUJJQUJxTEFBQVFROXhRUUowYWlJRklBVW9BZ0JCQVdvMkFnQWdBRUVCYWlJQUlBTkhEUUFMSUFSQkpHb2lBQ0VRSUFSQktHb2lDaUVSSUFRb0FnZ2hCaUFFS0FJTUlRZ2dCQ2dDRUNFSklBUW9BaFFoQ3lBRUtBSVlJUXdnQkNnQ0hDRU5JQVFvQWlBaERpQUFLQUlBSVJJZ0NpZ0NBQ0VLSUFRb0FnUUxJUVVnQkVFQU5nSUFJQUpCaUJscVFRQWdBMEVCZEJCVUdpQUNRY1FBYWlJQVFRQTJBZ0FnQWtFQU5nSUVJQUlnQlVFUGREWUNDQ0FDUVFBMkFrZ2dBaUFHSUFWQkFYUnFJZzlCRG5RMkFnd2dBaUFGTmdKTUlBSWdDQ0FQUVFGMGFpSVBRUTEwTmdJUUlBSWdCaUFGYWlJRk5nSlFJQUlnQ1NBUFFRRjBhaUlHUVF4ME5nSVVJQUlnQ0NBRmFpSUZOZ0pVSUFJZ0N5QUdRUUYwYWlJR1FRdDBOZ0lZSUFJZ0NTQUZhaUlGTmdKWUlBSWdEQ0FHUVFGMGFpSUdRUXAwTmdJY0lBSWdDeUFGYWlJRk5nSmNJQUlnRFNBR1FRRjBhaUlHUVFsME5nSWdJQUlnRENBRmFpSUZOZ0pnSUFJZ0RpQUdRUUYwYWlJR1FRaDBOZ0lrSUFJZ0RTQUZhaUlGTmdKa0lBSWdFaUFHUVFGMGFpSUdRUWQwTmdJb0lBSWdEaUFGYWlJRk5nSm9JQUlnQ2lBR1FRRjBhaUlHUVFaME5nSXNJQUlnRUNnQ0FDQUZhaUlGTmdKc0lBSWdCQ2dDTENJSUlBWkJBWFJxSWdaQkJYUTJBakFnQWlBUktBSUFJQVZxSWdVMkFuQWdBaUFFS0FJd0lna2dCa0VCZEdvaUJrRUVkRFlDTkNBQ0lBZ2dCV29pQlRZQ2RDQUNJQVFvQWpRaUNDQUdRUUYwYWlJR1FRTjBOZ0k0SUFJZ0NTQUZhaUlGTmdKNElBSWdCQ2dDT0NJSklBWkJBWFJxSWdaQkFuUTJBandnQWlBSUlBVnFJZ1UyQW53Z0FrRkFheUFFS0FJOElBWkJBWFJxUVFGME5nSUFJQUlnQ1NBRmFqWUNnQUVnQnlBQUtRSUFOd0lBSUFjZ0FDa0NDRGNDQ0NBSElBQXBBaEEzQWhBZ0J5QUFLUUlZTndJWUlBY2dBQ2tDSURjQ0lDQUhJQUFwQWlnM0FpZ2dCeUFBS1FJd053SXdJQWNnQUNrQ09EY0NPQUpBQWtBZ0V3MEFRUUFoQUFOQUlBRWdBR29zQUFCQkQzRWlCQVJBSUFKQmlCbHFJQWNnQkVFQ2RHb2lCQ2dDQUNJRlFRRjBhaUFBT3dFQUlBUWdCVUVCYWpZQ0FBc2dBRUVCYWlJQUlBTkhEUUFMQWtBQ1FBSkFJQU5CcWdKckRna0FBQUVCQVFFQkFRQUJDMEVLSVFRTUFRc01BUXNNQVF0QkJ5RUVDeUFDUVlRQmFpSUZJQVEyQWdCQkFTQUVkQ0VHUVFBaEFVRUJJUUFEUUNBQlFSQWdCR3QwSVFRQ1FDQUFRUkJKQkVBRFFDQUVJQUpCQkdvZ0FFRUNkR29vQWdCSkRRSWdBRUVCYWlJQVFSQkpEUUJCRUNFQUN3c0xJQUpCaUFGcUlBRnFJQUE2QUFBZ0FrR0lDV29nQVVFQmRHb2dCQ0FDSUFCQkFuUnFLQUlBYTBFUUlBQnJkaUFDUWNRQWFpQUFRUUowYWlnQ0FHb2lCQ0FEU1FSL0lBSkJpQmxxSUFSQkFYUnFMZ0VBQlVFQUN5SUVPd0VBSUFGQkFXb2lBU0FHU1FSQUlBVW9BZ0FoQkF3QkN3c2dCeVFFQzZjREFRWi9Jd1FoQXlNRVFSQnFKQVFnQTBFSWFpRUVJQUZCQURvQUFBSkFJQUJCL3Y4REVIUUVRRUdzSXlnQ0FDZ0NBQVIvUVFRRlFRRUxJQUpHQkVCQkFTRUVCVUVCSVFRRFFBSkFBa0FDUUFOQUFrQWdBQ0FIUVFKMGFpZ0NBQ0lGUWY3L0EwZ05BaUFGUWY3L0Eyc05BQ0FIUVFGcUlRY2dCaUFDUWF3aktBSUFLQUlBQkg5QkJBVkJBUXRyU1EwQkRBZ0xDd3dCQ3lBRlJRMEJDeUFIUVFGcUlRY2dCVUdBZjNGQmdNRURSZ1IvSUFFZ0Jtb2dCVG9BQUNBR1FRRnFCU0FEUWdBM0F3QWdBU0FHYWlJSUlBVWdBeENSQVVGL1JnUkFRUUFoQkFzZ0EwSUFOd01BSUFoQnJDTW9BZ0FvQWdBRWYwRUVCVUVCQ3lBREVJZ0NJZ1ZCQVVvRWZ5QUZCVUVCQ3lBR2Fnc2lCaUFDUWF3aktBSUFLQUlBQkg5QkJBVkJBUXRyU1EwQkRBUUxDeUFCSUFacVFRQTZBQUFMQlNBRFFnQTNBd0FnQkNBQU5nSUFBbjhDUUFKQUFrQWdBU0FFSUFJZ0F4QzRBMEYvYXc0Q0FBRUNDMEVBREFJTElBQW9BZ0JGREFFTFFRRUxJUVFMQ3lBQ1JRUkFJQU1rQkNBRVFmOEJjVUVBUnc4TElBRWdBa0YvYW1wQkFEb0FBQ0FESkFRZ0JFSC9BWEZCQUVjTE5nRURmeUFBSVFJRFFDQUJRUVJxSVFNZ0FrRUVhaUVFSUFJZ0FTZ0NBQ0lCTmdJQUlBRUVRQ0FFSVFJZ0F5RUJEQUVMQ3lBQUMxQUJBbjhDZnlBQ0JIOERRQ0FBTEFBQUlnTWdBU3dBQUNJRVJnUkFJQUJCQVdvaEFDQUJRUUZxSVFGQkFDQUNRWDlxSWdKRkRRTWFEQUVMQ3lBRFFmOEJjU0FFUWY4QmNXc0ZRUUFMQ3lJQUM0NDNBUXgvQWtBQ1FBSkFJd1FoQVNNRVFSQnFKQVFnQVNFS0FrQWdBRUgxQVVrRVFDQUFRUXRxUVhoeElRSkJ3TGNES0FJQUlnWWdBRUVMU1FSL1FSQWlBZ1VnQWd0QkEzWWlBSFlpQVVFRGNRUkFJQUZCQVhGQkFYTWdBR29pQUVFRGRFSG90d05xSWdGQkNHb2lCU2dDQUNJQ1FRaHFJZ1FvQWdBaUF5QUJSZ1JBUWNDM0F5QUdRUUVnQUhSQmYzTnhOZ0lBQlNBRElBRTJBZ3dnQlNBRE5nSUFDeUFDSUFCQkEzUWlBRUVEY2pZQ0JDQUNJQUJxUVFScUlnQWdBQ2dDQUVFQmNqWUNBQ0FLSkFRZ0JBOExJQUpCeUxjREtBSUFJZ2hMQkVBZ0FRUkFJQUVnQUhSQkFpQUFkQ0lBUVFBZ0FHdHljU0lBUVFBZ0FHdHhRWDlxSWdGQkRIWkJFSEVoQUNBQklBQjJJZ0ZCQlhaQkNIRWlBeUFBY2lBQklBTjJJZ0JCQW5aQkJIRWlBWElnQUNBQmRpSUFRUUYyUVFKeElnRnlJQUFnQVhZaUFFRUJka0VCY1NJQmNpQUFJQUYyYWlJRFFRTjBRZWkzQTJvaUFFRUlhaUlFS0FJQUlnRkJDR29pQnlnQ0FDSUZJQUJHQkVCQndMY0RJQVpCQVNBRGRFRi9jM0VpQURZQ0FBVWdCU0FBTmdJTUlBUWdCVFlDQUNBR0lRQUxJQUVnQWtFRGNqWUNCQ0FCSUFKcUlnUWdBMEVEZENJRElBSnJJZ1ZCQVhJMkFnUWdBU0FEYWlBRk5nSUFJQWdFUUVIVXR3TW9BZ0FoQXlBSVFRTjJJZ0pCQTNSQjZMY0RhaUVCSUFCQkFTQUNkQ0lDY1FSL0lBRkJDR29pQWlnQ0FBVkJ3TGNESUFBZ0FuSTJBZ0FnQVVFSWFpRUNJQUVMSVFBZ0FpQUROZ0lBSUFBZ0F6WUNEQ0FESUFBMkFnZ2dBeUFCTmdJTUMwSEl0d01nQlRZQ0FFSFV0d01nQkRZQ0FDQUtKQVFnQnc4TFFjUzNBeWdDQUNJTUJFQWdERUVBSUF4cmNVRi9haUlCUVF4MlFSQnhJUUFnQVNBQWRpSUJRUVYyUVFoeElnTWdBSElnQVNBRGRpSUFRUUoyUVFSeElnRnlJQUFnQVhZaUFFRUJka0VDY1NJQmNpQUFJQUYySWdCQkFYWkJBWEVpQVhJZ0FDQUJkbXBCQW5SQjhMa0RhaWdDQUNJREtBSUVRWGh4SUFKcklRRWdBMEVRYWlBREtBSVFSVUVDZEdvb0FnQWlBQVJBQTBBZ0FDZ0NCRUY0Y1NBQ2F5SUZJQUZKSWdRRVFDQUZJUUVMSUFRRVFDQUFJUU1MSUFCQkVHb2dBQ2dDRUVWQkFuUnFLQUlBSWdBTkFDQUJJUVVMQlNBQklRVUxJQU1nQW1vaUN5QURTd1JBSUFNb0FoZ2hDUUpBSUFNb0Fnd2lBQ0FEUmdSQUlBTkJGR29pQVNnQ0FDSUFSUVJBSUFOQkVHb2lBU2dDQUNJQVJRUkFRUUFoQUF3REN3c0RRQ0FBUVJScUlnUW9BZ0FpQndSQUlBY2hBQ0FFSVFFTUFRc2dBRUVRYWlJRUtBSUFJZ2NFUUNBSElRQWdCQ0VCREFFTEN5QUJRUUEyQWdBRklBTW9BZ2dpQVNBQU5nSU1JQUFnQVRZQ0NBc0xBa0FnQ1FSQUlBTWdBeWdDSENJQlFRSjBRZkM1QTJvaUJDZ0NBRVlFUUNBRUlBQTJBZ0FnQUVVRVFFSEV0d01nREVFQklBRjBRWDl6Y1RZQ0FBd0RDd1VnQ1VFUWFpQUpLQUlRSUFOSFFRSjBhaUFBTmdJQUlBQkZEUUlMSUFBZ0NUWUNHQ0FES0FJUUlnRUVRQ0FBSUFFMkFoQWdBU0FBTmdJWUN5QURLQUlVSWdFRVFDQUFJQUUyQWhRZ0FTQUFOZ0lZQ3dzTElBVkJFRWtFUUNBRElBVWdBbW9pQUVFRGNqWUNCQ0FESUFCcVFRUnFJZ0FnQUNnQ0FFRUJjallDQUFVZ0F5QUNRUU55TmdJRUlBc2dCVUVCY2pZQ0JDQUxJQVZxSUFVMkFnQWdDQVJBUWRTM0F5Z0NBQ0VFSUFoQkEzWWlBVUVEZEVIb3R3TnFJUUFnQmtFQklBRjBJZ0Z4Qkg4Z0FFRUlhaUlDS0FJQUJVSEF0d01nQmlBQmNqWUNBQ0FBUVFocUlRSWdBQXNoQVNBQ0lBUTJBZ0FnQVNBRU5nSU1JQVFnQVRZQ0NDQUVJQUEyQWd3TFFjaTNBeUFGTmdJQVFkUzNBeUFMTmdJQUN5QUtKQVFnQTBFSWFnOEZJQUloQUFzRklBSWhBQXNGSUFJaEFBc0ZJQUJCdjM5TEJFQkJmeUVBQlNBQVFRdHFJZ0JCZUhFaEEwSEV0d01vQWdBaUJRUkFJQUJCQ0hZaUFBUi9JQU5CLy8vL0Iwc0VmMEVmQlNBRFFRNGdBQ0FBUVlEK1AycEJFSFpCQ0hFaUFIUWlBVUdBNEI5cVFSQjJRUVJ4SWdJZ0FISWdBU0FDZENJQVFZQ0FEMnBCRUhaQkFuRWlBWEpySUFBZ0FYUkJEM1pxSWdCQkIycDJRUUZ4SUFCQkFYUnlDd1ZCQUFzaENFRUFJQU5ySVFJQ1FBSkFJQWhCQW5SQjhMa0RhaWdDQUNJQUJFQkJHU0FJUVFGMmF5RUVRUUFoQVNBRElBaEJIMFlFZjBFQUJTQUVDM1FoQjBFQUlRUURRQ0FBS0FJRVFYaHhJQU5ySWdZZ0Fra0VRQ0FHQkVBZ0FDRUJJQVloQWdWQkFDRUNJQUFoQVF3RUN3c2dBQ2dDRkNJR1JTQUdJQUJCRUdvZ0IwRWZka0VDZEdvb0FnQWlBRVp5UlFSQUlBWWhCQXNnQnlBQVJTSUdRUUZ6ZENFSElBWkZEUUFMQlVFQUlRRUxJQVFnQVhJRWZ5QUVCU0FGUVFJZ0NIUWlBRUVBSUFCcmNuRWlBRVVFUUNBRElRQU1Cd3NnQUVFQUlBQnJjVUYvYWlJRVFReDJRUkJ4SVFCQkFDRUJJQVFnQUhZaUJFRUZka0VJY1NJSElBQnlJQVFnQjNZaUFFRUNka0VFY1NJRWNpQUFJQVIySWdCQkFYWkJBbkVpQkhJZ0FDQUVkaUlBUVFGMlFRRnhJZ1J5SUFBZ0JIWnFRUUowUWZDNUEyb29BZ0FMSWdBTkFDQUJJUVFNQVFzRFFDQUFLQUlFUVhoeElBTnJJZ1FnQWtraUJ3UkFJQVFoQWdzZ0J3UkFJQUFoQVFzZ0FFRVFhaUFBS0FJUVJVRUNkR29vQWdBaUFBMEFJQUVoQkFzTElBUUVRQ0FDUWNpM0F5Z0NBQ0FEYTBrRVFDQUVJQU5xSWdnZ0JFME5CaUFFS0FJWUlRa0NRQ0FFS0FJTUlnQWdCRVlFUUNBRVFSUnFJZ0VvQWdBaUFFVUVRQ0FFUVJCcUlnRW9BZ0FpQUVVRVFFRUFJUUFNQXdzTEEwQWdBRUVVYWlJSEtBSUFJZ1lFUUNBR0lRQWdCeUVCREFFTElBQkJFR29pQnlnQ0FDSUdCRUFnQmlFQUlBY2hBUXdCQ3dzZ0FVRUFOZ0lBQlNBRUtBSUlJZ0VnQURZQ0RDQUFJQUUyQWdnTEN3SkFJQWtFUUNBRUlBUW9BaHdpQVVFQ2RFSHd1UU5xSWdjb0FnQkdCRUFnQnlBQU5nSUFJQUJGQkVCQnhMY0RJQVZCQVNBQmRFRi9jM0VpQURZQ0FBd0RDd1VnQ1VFUWFpQUpLQUlRSUFSSFFRSjBhaUFBTmdJQUlBQkZCRUFnQlNFQURBTUxDeUFBSUFrMkFoZ2dCQ2dDRUNJQkJFQWdBQ0FCTmdJUUlBRWdBRFlDR0FzZ0JDZ0NGQ0lCQkVBZ0FDQUJOZ0lVSUFFZ0FEWUNHQXNMSUFVaEFBc0NRQ0FDUVJCSkJFQWdCQ0FDSUFOcUlnQkJBM0kyQWdRZ0JDQUFha0VFYWlJQUlBQW9BZ0JCQVhJMkFnQUZJQVFnQTBFRGNqWUNCQ0FJSUFKQkFYSTJBZ1FnQ0NBQ2FpQUNOZ0lBSUFKQkEzWWhBU0FDUVlBQ1NRUkFJQUZCQTNSQjZMY0RhaUVBUWNDM0F5Z0NBQ0lDUVFFZ0FYUWlBWEVFZnlBQVFRaHFJZ0lvQWdBRlFjQzNBeUFDSUFGeU5nSUFJQUJCQ0dvaEFpQUFDeUVCSUFJZ0NEWUNBQ0FCSUFnMkFnd2dDQ0FCTmdJSUlBZ2dBRFlDREF3Q0N5QUNRUWgySWdFRWZ5QUNRZi8vL3dkTEJIOUJId1VnQWtFT0lBRWdBVUdBL2o5cVFSQjJRUWh4SWdGMElnTkJnT0FmYWtFUWRrRUVjU0lGSUFGeUlBTWdCWFFpQVVHQWdBOXFRUkIyUVFKeElnTnlheUFCSUFOMFFROTJhaUlCUVFkcWRrRUJjU0FCUVFGMGNnc0ZRUUFMSWdGQkFuUkI4TGtEYWlFRElBZ2dBVFlDSENBSVFSQnFJZ1ZCQURZQ0JDQUZRUUEyQWdBZ0FFRUJJQUYwSWdWeFJRUkFRY1MzQXlBQUlBVnlOZ0lBSUFNZ0NEWUNBQ0FJSUFNMkFoZ2dDQ0FJTmdJTUlBZ2dDRFlDQ0F3Q0N5QURLQUlBSVFCQkdTQUJRUUYyYXlFRElBSWdBVUVmUmdSL1FRQUZJQU1MZENFQkFrQURRQ0FBS0FJRVFYaHhJQUpHRFFFZ0FVRUJkQ0VESUFCQkVHb2dBVUVmZGtFQ2RHb2lBU2dDQUNJRkJFQWdBeUVCSUFVaEFBd0JDd3NnQVNBSU5nSUFJQWdnQURZQ0dDQUlJQWcyQWd3Z0NDQUlOZ0lJREFJTElBQkJDR29pQVNnQ0FDSUNJQWcyQWd3Z0FTQUlOZ0lBSUFnZ0FqWUNDQ0FJSUFBMkFnd2dDRUVBTmdJWUN3c2dDaVFFSUFSQkNHb1BCU0FESVFBTEJTQURJUUFMQlNBRElRQUxDd3NMUWNpM0F5Z0NBQ0lDSUFCUEJFQkIxTGNES0FJQUlRRWdBaUFBYXlJRFFROUxCRUJCMUxjRElBRWdBR29pQlRZQ0FFSEl0d01nQXpZQ0FDQUZJQU5CQVhJMkFnUWdBU0FDYWlBRE5nSUFJQUVnQUVFRGNqWUNCQVZCeUxjRFFRQTJBZ0JCMUxjRFFRQTJBZ0FnQVNBQ1FRTnlOZ0lFSUFFZ0FtcEJCR29pQUNBQUtBSUFRUUZ5TmdJQUN3d0RDMEhNdHdNb0FnQWlBaUFBU3dSQVFjeTNBeUFDSUFCcklnSTJBZ0FNQWd0Qm1Mc0RLQUlBQkg5Qm9Mc0RLQUlBQlVHZ3V3TkJnQ0EyQWdCQm5Mc0RRWUFnTmdJQVFhUzdBMEYvTmdJQVFhaTdBMEYvTmdJQVFheTdBMEVBTmdJQVFmeTZBMEVBTmdJQVFaaTdBeUFLUVhCeFFkaXExYW9GY3pZQ0FFR0FJQXNpQVNBQVFTOXFJZ1JxSWdkQkFDQUJheUlHY1NJRklBQk5EUUJCK0xvREtBSUFJZ0VFUUVId3VnTW9BZ0FpQXlBRmFpSUlJQU5OSUFnZ0FVdHlEUUVMSUFCQk1Hb2hDQUpBQWtCQi9Mb0RLQUlBUVFSeEJFQkJBQ0VDQlFKQUFrQUNRRUhZdHdNb0FnQWlBVVVOQUVHQXV3TWhBd05BQWtBZ0F5Z0NBQ0lKSUFGTkJFQWdDU0FEUVFScUlna29BZ0JxSUFGTERRRUxJQU1vQWdnaUF3MEJEQUlMQ3lBSElBSnJJQVp4SWdKQi8vLy8vd2RKQkVBZ0FoQ0hBU0lCSUFNb0FnQWdDU2dDQUdwR0JFQWdBVUYvUncwR0JRd0RDd1ZCQUNFQ0N3d0NDMEVBRUljQklnRkJmMFlFUUVFQUlRSUZRWnk3QXlnQ0FDSUNRWDlxSWdNZ0FXcEJBQ0FDYTNFZ0FXc2hBaUFESUFGeEJIOGdBZ1ZCQUFzZ0JXb2lBa0h3dWdNb0FnQWlCMm9oQXlBQ0lBQkxJQUpCLy8vLy93ZEpjUVJBUWZpNkF5Z0NBQ0lHQkVBZ0F5QUhUU0FESUFaTGNnUkFRUUFoQWd3RkN3c2dBaENIQVNJRElBRkdEUVVnQXlFQkRBSUZRUUFoQWdzTERBRUxJQWdnQWtzZ0FrSC8vLy8vQjBrZ0FVRi9SM0Z4UlFSQUlBRkJmMFlFUUVFQUlRSU1BZ1VNQkFzQUN5QUVJQUpyUWFDN0F5Z0NBQ0lEYWtFQUlBTnJjU0lEUWYvLy8vOEhUdzBDUVFBZ0Ftc2hCQ0FERUljQlFYOUdCRUFnQkJDSEFScEJBQ0VDQlNBRElBSnFJUUlNQXdzTFFmeTZBMEg4dWdNb0FnQkJCSEkyQWdBTElBVkIvLy8vL3dkSkJFQWdCUkNIQVNJQlFRQVFod0VpQTBrZ0FVRi9SeUFEUVg5SGNYRWhCU0FESUFGcklnTWdBRUVvYWtzaUJBUkFJQU1oQWdzZ0FVRi9SaUFFUVFGemNpQUZRUUZ6Y2tVTkFRc01BUXRCOExvRFFmQzZBeWdDQUNBQ2FpSUROZ0lBSUFOQjlMb0RLQUlBU3dSQVFmUzZBeUFETmdJQUN3SkFRZGkzQXlnQ0FDSUVCRUJCZ0xzRElRTUNRQUpBQTBBZ0FTQURLQUlBSWdVZ0EwRUVhaUlIS0FJQUlnWnFSZzBCSUFNb0FnZ2lBdzBBQ3d3QkN5QURLQUlNUVFoeFJRUkFJQUVnQkVzZ0JTQUVUWEVFUUNBSElBWWdBbW8yQWdCQnpMY0RLQUlBSUFKcUlRSkJBQ0FFUVFocUlnTnJRUWR4SVFGQjJMY0RJQVFnQTBFSGNRUi9JQUVGUVFBaUFRdHFJZ00yQWdCQnpMY0RJQUlnQVdzaUFUWUNBQ0FESUFGQkFYSTJBZ1FnQkNBQ2FrRW9OZ0lFUWR5M0EwR291d01vQWdBMkFnQU1CQXNMQ3lBQlFkQzNBeWdDQUVrRVFFSFF0d01nQVRZQ0FBc2dBU0FDYWlFRlFZQzdBeUVEQWtBQ1FBTkFJQU1vQWdBZ0JVWU5BU0FES0FJSUlnTU5BRUdBdXdNaEF3c01BUXNnQXlnQ0RFRUljUVJBUVlDN0F5RURCU0FESUFFMkFnQWdBMEVFYWlJRElBTW9BZ0FnQW1vMkFnQkJBQ0FCUVFocUlnSnJRUWR4SVFOQkFDQUZRUWhxSWdkclFRZHhJUWtnQVNBQ1FRZHhCSDhnQXdWQkFBdHFJZ2dnQUdvaEJpQUZJQWRCQjNFRWZ5QUpCVUVBQzJvaUJTQUlheUFBYXlFSElBZ2dBRUVEY2pZQ0JBSkFJQVFnQlVZRVFFSE10d05CekxjREtBSUFJQWRxSWdBMkFnQkIyTGNESUFZMkFnQWdCaUFBUVFGeU5nSUVCVUhVdHdNb0FnQWdCVVlFUUVISXR3TkJ5TGNES0FJQUlBZHFJZ0EyQWdCQjFMY0RJQVkyQWdBZ0JpQUFRUUZ5TmdJRUlBWWdBR29nQURZQ0FBd0NDeUFGS0FJRUlnQkJBM0ZCQVVZRWZ5QUFRWGh4SVFrZ0FFRURkaUVDQWtBZ0FFR0FBa2tFUUNBRktBSU1JZ0FnQlNnQ0NDSUJSZ1JBUWNDM0EwSEF0d01vQWdCQkFTQUNkRUYvYzNFMkFnQUZJQUVnQURZQ0RDQUFJQUUyQWdnTEJTQUZLQUlZSVFRQ1FDQUZLQUlNSWdBZ0JVWUVRQ0FGUVJCcUlnRkJCR29pQWlnQ0FDSUFCRUFnQWlFQkJTQUJLQUlBSWdCRkJFQkJBQ0VBREFNTEN3TkFJQUJCRkdvaUFpZ0NBQ0lEQkVBZ0F5RUFJQUloQVF3QkN5QUFRUkJxSWdJb0FnQWlBd1JBSUFNaEFDQUNJUUVNQVFzTElBRkJBRFlDQUFVZ0JTZ0NDQ0lCSUFBMkFnd2dBQ0FCTmdJSUN3c2dCRVVOQVFKQUlBVW9BaHdpQVVFQ2RFSHd1UU5xSWdJb0FnQWdCVVlFUUNBQ0lBQTJBZ0FnQUEwQlFjUzNBMEhFdHdNb0FnQkJBU0FCZEVGL2MzRTJBZ0FNQXdVZ0JFRVFhaUFFS0FJUUlBVkhRUUowYWlBQU5nSUFJQUJGRFFNTEN5QUFJQVEyQWhnZ0JVRVFhaUlDS0FJQUlnRUVRQ0FBSUFFMkFoQWdBU0FBTmdJWUN5QUNLQUlFSWdGRkRRRWdBQ0FCTmdJVUlBRWdBRFlDR0FzTElBVWdDV29oQUNBSklBZHFCU0FGSVFBZ0J3c2hCU0FBUVFScUlnQWdBQ2dDQUVGK2NUWUNBQ0FHSUFWQkFYSTJBZ1FnQmlBRmFpQUZOZ0lBSUFWQkEzWWhBU0FGUVlBQ1NRUkFJQUZCQTNSQjZMY0RhaUVBUWNDM0F5Z0NBQ0lDUVFFZ0FYUWlBWEVFZnlBQVFRaHFJZ0lvQWdBRlFjQzNBeUFDSUFGeU5nSUFJQUJCQ0dvaEFpQUFDeUVCSUFJZ0JqWUNBQ0FCSUFZMkFnd2dCaUFCTmdJSUlBWWdBRFlDREF3Q0N3Si9JQVZCQ0hZaUFBUi9RUjhnQlVILy8vOEhTdzBCR2lBRlFRNGdBQ0FBUVlEK1AycEJFSFpCQ0hFaUFIUWlBVUdBNEI5cVFSQjJRUVJ4SWdJZ0FISWdBU0FDZENJQVFZQ0FEMnBCRUhaQkFuRWlBWEpySUFBZ0FYUkJEM1pxSWdCQkIycDJRUUZ4SUFCQkFYUnlCVUVBQ3dzaUFVRUNkRUh3dVFOcUlRQWdCaUFCTmdJY0lBWkJFR29pQWtFQU5nSUVJQUpCQURZQ0FFSEV0d01vQWdBaUFrRUJJQUYwSWdOeFJRUkFRY1MzQXlBQ0lBTnlOZ0lBSUFBZ0JqWUNBQ0FHSUFBMkFoZ2dCaUFHTmdJTUlBWWdCallDQ0F3Q0N5QUFLQUlBSVFCQkdTQUJRUUYyYXlFQ0lBVWdBVUVmUmdSL1FRQUZJQUlMZENFQkFrQURRQ0FBS0FJRVFYaHhJQVZHRFFFZ0FVRUJkQ0VDSUFCQkVHb2dBVUVmZGtFQ2RHb2lBU2dDQUNJREJFQWdBaUVCSUFNaEFBd0JDd3NnQVNBR05nSUFJQVlnQURZQ0dDQUdJQVkyQWd3Z0JpQUdOZ0lJREFJTElBQkJDR29pQVNnQ0FDSUNJQVkyQWd3Z0FTQUdOZ0lBSUFZZ0FqWUNDQ0FHSUFBMkFnd2dCa0VBTmdJWUN3c2dDaVFFSUFoQkNHb1BDd3NEUUFKQUlBTW9BZ0FpQlNBRVRRUkFJQVVnQXlnQ0JHb2lDQ0FFU3cwQkN5QURLQUlJSVFNTUFRc0xRUUFnQ0VGUmFpSURRUWhxSWdWclFRZHhJUWNnQXlBRlFRZHhCSDhnQndWQkFBdHFJZ01nQkVFUWFpSU1TUVIvSUFRaUF3VWdBd3RCQ0dvaEJpQURRUmhxSVFVZ0FrRllhaUVKUVFBZ0FVRUlhaUlMYTBFSGNTRUhRZGkzQXlBQklBdEJCM0VFZnlBSEJVRUFJZ2NMYWlJTE5nSUFRY3kzQXlBSklBZHJJZ2MyQWdBZ0N5QUhRUUZ5TmdJRUlBRWdDV3BCS0RZQ0JFSGN0d05CcUxzREtBSUFOZ0lBSUFOQkJHb2lCMEViTmdJQUlBWkJnTHNES1FJQU53SUFJQVpCaUxzREtRSUFOd0lJUVlDN0F5QUJOZ0lBUVlTN0F5QUNOZ0lBUVl5N0EwRUFOZ0lBUVlpN0F5QUdOZ0lBSUFVaEFRTkFJQUZCQkdvaUFrRUhOZ0lBSUFGQkNHb2dDRWtFUUNBQ0lRRU1BUXNMSUFNZ0JFY0VRQ0FISUFjb0FnQkJmbkUyQWdBZ0JDQURJQVJySWdkQkFYSTJBZ1FnQXlBSE5nSUFJQWRCQTNZaEFpQUhRWUFDU1FSQUlBSkJBM1JCNkxjRGFpRUJRY0MzQXlnQ0FDSURRUUVnQW5RaUFuRUVmeUFCUVFocUlnTW9BZ0FGUWNDM0F5QURJQUp5TmdJQUlBRkJDR29oQXlBQkN5RUNJQU1nQkRZQ0FDQUNJQVEyQWd3Z0JDQUNOZ0lJSUFRZ0FUWUNEQXdEQ3lBSFFRaDJJZ0VFZnlBSFFmLy8vd2RMQkg5Qkh3VWdCMEVPSUFFZ0FVR0EvajlxUVJCMlFRaHhJZ0YwSWdKQmdPQWZha0VRZGtFRWNTSURJQUZ5SUFJZ0EzUWlBVUdBZ0E5cVFSQjJRUUp4SWdKeWF5QUJJQUowUVE5MmFpSUJRUWRxZGtFQmNTQUJRUUYwY2dzRlFRQUxJZ0pCQW5SQjhMa0RhaUVCSUFRZ0FqWUNIQ0FFUVFBMkFoUWdERUVBTmdJQVFjUzNBeWdDQUNJRFFRRWdBblFpQlhGRkJFQkJ4TGNESUFNZ0JYSTJBZ0FnQVNBRU5nSUFJQVFnQVRZQ0dDQUVJQVEyQWd3Z0JDQUVOZ0lJREFNTElBRW9BZ0FoQVVFWklBSkJBWFpySVFNZ0J5QUNRUjlHQkg5QkFBVWdBd3QwSVFJQ1FBTkFJQUVvQWdSQmVIRWdCMFlOQVNBQ1FRRjBJUU1nQVVFUWFpQUNRUjkyUVFKMGFpSUNLQUlBSWdVRVFDQURJUUlnQlNFQkRBRUxDeUFDSUFRMkFnQWdCQ0FCTmdJWUlBUWdCRFlDRENBRUlBUTJBZ2dNQXdzZ0FVRUlhaUlDS0FJQUlnTWdCRFlDRENBQ0lBUTJBZ0FnQkNBRE5nSUlJQVFnQVRZQ0RDQUVRUUEyQWhnTEJVSFF0d01vQWdBaUEwVWdBU0FEU1hJRVFFSFF0d01nQVRZQ0FBdEJnTHNESUFFMkFnQkJoTHNESUFJMkFnQkJqTHNEUVFBMkFnQkI1TGNEUVppN0F5Z0NBRFlDQUVIZ3R3TkJmellDQUVIMHR3TkI2TGNETmdJQVFmQzNBMEhvdHdNMkFnQkIvTGNEUWZDM0F6WUNBRUg0dHdOQjhMY0ROZ0lBUVlTNEEwSDR0d00yQWdCQmdMZ0RRZmkzQXpZQ0FFR011QU5CZ0xnRE5nSUFRWWk0QTBHQXVBTTJBZ0JCbExnRFFZaTRBellDQUVHUXVBTkJpTGdETmdJQVFaeTRBMEdRdUFNMkFnQkJtTGdEUVpDNEF6WUNBRUdrdUFOQm1MZ0ROZ0lBUWFDNEEwR1l1QU0yQWdCQnJMZ0RRYUM0QXpZQ0FFR291QU5Cb0xnRE5nSUFRYlM0QTBHb3VBTTJBZ0JCc0xnRFFhaTRBellDQUVHOHVBTkJzTGdETmdJQVFiaTRBMEd3dUFNMkFnQkJ4TGdEUWJpNEF6WUNBRUhBdUFOQnVMZ0ROZ0lBUWN5NEEwSEF1QU0yQWdCQnlMZ0RRY0M0QXpZQ0FFSFV1QU5CeUxnRE5nSUFRZEM0QTBISXVBTTJBZ0JCM0xnRFFkQzRBellDQUVIWXVBTkIwTGdETmdJQVFlUzRBMEhZdUFNMkFnQkI0TGdEUWRpNEF6WUNBRUhzdUFOQjRMZ0ROZ0lBUWVpNEEwSGd1QU0yQWdCQjlMZ0RRZWk0QXpZQ0FFSHd1QU5CNkxnRE5nSUFRZnk0QTBId3VBTTJBZ0JCK0xnRFFmQzRBellDQUVHRXVRTkIrTGdETmdJQVFZQzVBMEg0dUFNMkFnQkJqTGtEUVlDNUF6WUNBRUdJdVFOQmdMa0ROZ0lBUVpTNUEwR0l1UU0yQWdCQmtMa0RRWWk1QXpZQ0FFR2N1UU5Ca0xrRE5nSUFRWmk1QTBHUXVRTTJBZ0JCcExrRFFaaTVBellDQUVHZ3VRTkJtTGtETmdJQVFheTVBMEdndVFNMkFnQkJxTGtEUWFDNUF6WUNBRUcwdVFOQnFMa0ROZ0lBUWJDNUEwR291UU0yQWdCQnZMa0RRYkM1QXpZQ0FFRzR1UU5Cc0xrRE5nSUFRY1M1QTBHNHVRTTJBZ0JCd0xrRFFiaTVBellDQUVITXVRTkJ3TGtETmdJQVFjaTVBMEhBdVFNMkFnQkIxTGtEUWNpNUF6WUNBRUhRdVFOQnlMa0ROZ0lBUWR5NUEwSFF1UU0yQWdCQjJMa0RRZEM1QXpZQ0FFSGt1UU5CMkxrRE5nSUFRZUM1QTBIWXVRTTJBZ0JCN0xrRFFlQzVBellDQUVIb3VRTkI0TGtETmdJQUlBSkJXR29oQTBFQUlBRkJDR29pQld0QkIzRWhBa0hZdHdNZ0FTQUZRUWR4Qkg4Z0FnVkJBQ0lDQzJvaUJUWUNBRUhNdHdNZ0F5QUNheUlDTmdJQUlBVWdBa0VCY2pZQ0JDQUJJQU5xUVNnMkFnUkIzTGNEUWFpN0F5Z0NBRFlDQUFzTFFjeTNBeWdDQUNJQklBQkxCRUJCekxjRElBRWdBR3NpQWpZQ0FBd0RDd3RCaUx3RFFRdzJBZ0FnQ2lRRVFRQVBDeUFLSkFSQkFBOExRZGkzQTBIWXR3TW9BZ0FpQVNBQWFpSUROZ0lBSUFNZ0FrRUJjallDQkNBQklBQkJBM0kyQWdRTElBb2tCQ0FCUVFocUM4RVNBU2QvSXdRaEFpTUVRWUFCYWlRRUlBSkJRR3NpQXlBQkxRQUJRUWgwSUFFdEFBQnlJQUV0QUFKQkVIUnlJQUV0QUFOQkdIUnlOZ0lBSUFNZ0FTMEFCVUVJZENBQkxRQUVjaUFCTFFBR1FSQjBjaUFCTFFBSFFSaDBjallDQkNBRElBRXRBQWxCQ0hRZ0FTMEFDSElnQVMwQUNrRVFkSElnQVMwQUMwRVlkSEkyQWdnZ0F5QUJMUUFOUVFoMElBRXRBQXh5SUFFdEFBNUJFSFJ5SUFFdEFBOUJHSFJ5TmdJTUlBTWdBUzBBRVVFSWRDQUJMUUFRY2lBQkxRQVNRUkIwY2lBQkxRQVRRUmgwY2pZQ0VDQURJQUV0QUJWQkNIUWdBUzBBRkhJZ0FTMEFGa0VRZEhJZ0FTMEFGMEVZZEhJMkFoUWdBeUFCTFFBWlFRaDBJQUV0QUJoeUlBRXRBQnBCRUhSeUlBRXRBQnRCR0hSeU5nSVlJQU1nQVMwQUhVRUlkQ0FCTFFBY2NpQUJMUUFlUVJCMGNpQUJMUUFmUVJoMGNqWUNIQ0FESUFFdEFDRkJDSFFnQVMwQUlISWdBUzBBSWtFUWRISWdBUzBBSTBFWWRISTJBaUFnQXlBQkxRQWxRUWgwSUFFdEFDUnlJQUV0QUNaQkVIUnlJQUV0QUNkQkdIUnlOZ0lrSUFNZ0FTMEFLVUVJZENBQkxRQW9jaUFCTFFBcVFSQjBjaUFCTFFBclFSaDBjallDS0NBRElBRXRBQzFCQ0hRZ0FTMEFMSElnQVMwQUxrRVFkSElnQVMwQUwwRVlkSEkyQWl3Z0F5QUJMUUF4UVFoMElBRXRBREJ5SUFFdEFESkJFSFJ5SUFFdEFETkJHSFJ5TmdJd0lBTWdBUzBBTlVFSWRDQUJMUUEwY2lBQkxRQTJRUkIwY2lBQkxRQTNRUmgwY2pZQ05DQURJQUV0QURsQkNIUWdBUzBBT0hJZ0FTMEFPa0VRZEhJZ0FTMEFPMEVZZEhJMkFqZ2dBeUFCTFFBOVFRaDBJQUV0QUR4eUlBRXRBRDVCRUhSeUlBRXRBRDlCR0hSeU5nSThJQUlpQlNBQVFmUUJhaUlqS0FJQUlnSW9BZ0FpRERZQ0FDQUZRUVJxSWhVZ0FpZ0NCQ0lLTmdJQUlBVkJDR29pRmlBQ0tBSUlJZ1kyQWdBZ0JVRU1haUlYSUFJb0Fnd2lBVFlDQUNBRlFSQnFJaGdnQWlnQ0VDSUxOZ0lBSUFWQkZHb2lHU0FDS0FJVUlnODJBZ0FnQlVFWWFpSWtJQUlvQWhnaURUWUNBQ0FGUVJ4cUlpVWdBaWdDSENJSU5nSUFJQVZCSUdvaUprSG56S2ZRQmpZQ0FDQUZRU1JxSWhwQmhkMmUyM3MyQWdBZ0JVRW9haUliUWZMbXUrTUROZ0lBSUFWQkxHb2lIRUc2NnIrcWVqWUNBQ0FGUVRCcUloMGdBQ2dDK0FFaUFpZ0NBRUgvcExtSUJYTWlCellDQUNBRlFUUnFJaDRnQWlnQ0JFR00wWlhZZVhNaUNUWUNBQ0FGUVRocUlpY2dBQ2dDL0FFaUFDZ0NBRUdyczQvOEFYTWlBallDQUNBRlFUeHFJaWdnQUNnQ0JFR1ptb1BmQlhNaUFEWUNBRUhuektmUUJpRVFRWVhkbnR0N0lSSkI4dWE3NHdNaEUwRzY2citxZWlFVUEwQWdDeUFISUFzZ0RHb2dBeUFFUVFSMFFmY3VhaTBBQUVFQ2RHb29BZ0JxSWc1eklnZEJFSFFnQjBFUWRuSWlDeUFRYWlJTWN5SUhRUlIwSUFkQkRIWnlJZ2NnRG1vZ0F5QUVRUVIwUWZndWFpMEFBRUVDZEdvb0FnQnFJUkVnQnlBTElCRnpJZ2RCR0hRZ0IwRUlkbklpRGlBTWFpSVFjeUlIUVJsMElBZEJCM1p5SVI4Z0R5QUpJQThnQ21vZ0F5QUVRUVIwUWZrdWFpMEFBRUVDZEdvb0FnQnFJZ3B6SWdsQkVIUWdDVUVRZG5JaUN5QVNhaUlQY3lJSlFSUjBJQWxCREhaeUlnd2dDbW9nQXlBRVFRUjBRZm91YWkwQUFFRUNkR29vQWdCcUlTQWdEU0FDSUEwZ0Jtb2dBeUFFUVFSMFFmc3VhaTBBQUVFQ2RHb29BZ0JxSWdweklnSkJFSFFnQWtFUWRuSWlDU0FUYWlJR2N5SUNRUlIwSUFKQkRIWnlJZ0lnQ21vZ0F5QUVRUVIwUWZ3dWFpMEFBRUVDZEdvb0FnQnFJU0VnQWlBSklDRnpJZ0pCR0hRZ0FrRUlkbklpRWlBR2FpSUhjeUlDUVJsMElBSkJCM1p5SVEwZ0NDQUFJQWdnQVdvZ0F5QUVRUVIwUWYwdWFpMEFBRUVDZEdvb0FnQnFJZ1p6SWdCQkVIUWdBRUVRZG5JaUFTQVVhaUlDY3lJQVFSUjBJQUJCREhaeUlnQWdCbW9nQXlBRVFRUjBRZjR1YWkwQUFFRUNkR29vQWdCcUlTSWdBQ0FCSUNKeklnQkJHSFFnQUVFSWRuSWlBU0FDYWlJS2N5SUFRUmwwSUFCQkIzWnlJUWdnQVNBTUlBc2dJSE1pQUVFWWRDQUFRUWgyY2lJSklBOXFJZ3R6SWdCQkdYUWdBRUVIZG5JaUFTQVJhaUFESUFSQkJIUkIveTVxTFFBQVFRSjBhaWdDQUdvaUFuTWlBRUVRZENBQVFSQjJjaUlBSUFkcUlRWWdBQ0FCSUFaeklnQkJGSFFnQUVFTWRuSWlBU0FDYWlBRElBUkJCSFJCZ0M5cUxRQUFRUUowYWlnQ0FHb2lESE1pQUVFWWRDQUFRUWgyY2lJUklBWnFJUk1nQVNBVGN5SUFRUmwwSUFCQkIzWnlJUThnRFNBT0lBMGdJR29nQXlBRVFRUjBRWUV2YWkwQUFFRUNkR29vQWdCcUlnWnpJZ0JCRUhRZ0FFRVFkbklpQWlBS2FpSUJjeUlBUVJSMElBQkJESFp5SWdBZ0Jtb2dBeUFFUVFSMFFZSXZhaTBBQUVFQ2RHb29BZ0JxSVFvZ0FDQUNJQXB6SWdCQkdIUWdBRUVJZG5JaUJ5QUJhaUlVY3lJQVFSbDBJQUJCQjNaeUlRMGdDQ0FKSUFnZ0lXb2dBeUFFUVFSMFFZTXZhaTBBQUVFQ2RHb29BZ0JxSWdaeklnQkJFSFFnQUVFUWRuSWlBaUFRYWlJQmN5SUFRUlIwSUFCQkRIWnlJZ0FnQm1vZ0F5QUVRUVIwUVlRdmFpMEFBRUVDZEdvb0FnQnFJUVlnQUNBQ0lBWnpJZ0JCR0hRZ0FFRUlkbklpQ1NBQmFpSVFjeUlBUVJsMElBQkJCM1p5SVE0Z0h5QVNJQjhnSW1vZ0F5QUVRUVIwUVlVdmFpMEFBRUVDZEdvb0FnQnFJZ2h6SWdCQkVIUWdBRUVRZG5JaUFpQUxhaUlCY3lJQVFSUjBJQUJCREhaeUlnQWdDR29nQXlBRVFRUjBRWVl2YWkwQUFFRUNkR29vQWdCcUlRZ2dBQ0FDSUFoeklnQkJHSFFnQUVFSWRuSWlBaUFCYWlJQmN5SUFRUmwwSUFCQkIzWnlJUXNnQkVFQmFpSUFRUXBIQkVBZ0FDRUVJQUVoRWlBSUlRRWdEaUVJSUJFaEFBd0JDd3NnQlNBTU5nSUFJQmdnQ3pZQ0FDQWRJQWMyQWdBZ0ppQVFOZ0lBSUJVZ0NqWUNBQ0FaSUE4MkFnQWdIaUFKTmdJQUlCb2dBVFlDQUNBV0lBWTJBZ0FnSkNBTk5nSUFJQ2NnQWpZQ0FDQWJJQk0yQWdBZ0Z5QUlOZ0lBSUNVZ0RqWUNBQ0FvSUJFMkFnQWdIQ0FVTmdJQUlDTW9BZ0FpQVNBTUlBRW9BZ0J6SUJCek5nSUFJQUZCQkdvaUFDQVZLQUlBSUFBb0FnQnpJQm9vQWdCek5nSUFJQUZCQ0dvaUFDQVdLQUlBSUFBb0FnQnpJQnNvQWdCek5nSUFJQUZCREdvaUFDQVhLQUlBSUFBb0FnQnpJQndvQWdCek5nSUFJQUZCRUdvaUFDQVlLQUlBSUFBb0FnQnpJQjBvQWdCek5nSUFJQUZCRkdvaUFDQVpLQUlBSUFBb0FnQnpJQjRvQWdCek5nSUFJQUZCR0dvaUFDQU5JQUFvQWdCeklBSnpOZ0lBSUFGQkhHb2lBQ0FPSUFBb0FnQnpJQkZ6TmdJQUlBVWtCQXVCQVFFRGZ3SkFJQUFpQWtFRGNRUkFJQUloQVFOQUlBRXNBQUJGRFFJZ0FVRUJhaUlCSWdCQkEzRU5BQ0FCSVFBTEN3TkFJQUJCQkdvaEFTQUFLQUlBSWdOQmdJR0NoSGh4UVlDQmdvUjRjeUFEUWYvOSszZHFjVVVFUUNBQklRQU1BUXNMSUFOQi93RnhCRUFEUUNBQVFRRnFJZ0FzQUFBTkFBc0xDeUFBSUFKckN5c0JBWDhnQWtVRVFDQUFEd3NnQUNBQklBSkJmMm9pQXhDdUFSb2dBQ0FEUVFKMGFrRUFOZ0lBSUFBTGR3RUNmeUFBUWNRZE5nSUFJQUJCQkdvaUFpZ0NBQ0lCUlFSQUR3c2dBQ3dBRUFSQUR3c2dBQ3dBRWdSQVFRQWtCU01GSVFCQkFDUUZJQUJCQVhGRkJFQVBDd1ZCQUNRRlFTd2dBUkFNSXdVaEFVRUFKQVVnQVVFQmNVVUVRQ0FDUVFBMkFnQWdBRUVBTmdJTUR3c0xRUUFRR0NJQUVGb0xoUXNCRm44Z0FFSGdsd0ZxSWhRb0FnQWlBeUFBUWNnTWFpSVBLQUlBSWdSUEJFQkJmdzhMSUFCQjZKY0JhaUlGS0FJQUlnSWdCRWtFUUVGL0R3c2dCQzRCQUVFQlJnUkFJQVFnQUJDSkJBVWdCQ2dDQ0NJQklBTk5JQUVnQWt0eUJFQkJmdzhMSUFRZ0FCQ0tCRVVFUUVGL0R3c0xJQUJCOUpRQmFpSUlLQUlBSUFCQmdKVUJhaUlKS0FJQUlnSWdBRUg4bEFGcUlnWW9BZ0FpQVd4cUlRTWdDQ0FETmdJQUlBWWdBRUdFbFFGcUlnd29BZ0FnQW1zZ0FXd2lBallDQUFKQUlBQkIxQXhxSWhBb0FnQWlBUVJBSUFCQjRBeHFJUU1GSUFCQitKUUJhaUVWSUFCQmpKVUJhaUVSSUFCQjRBeHFJUVFnQUVIWURHb2hCeUFESVFFQ1FBSkFBMEFDUUFOQUFrQWdBaUFCYWlBQmMwR0FnSUFJVHdSQUlBSkJnSUFDVHcwQklBWkJBQ0FCYTBILy93RnhOZ0lBQ3lBVktBSUFJUk1nRVNnQ0FDSUtRUVJxSWhJb0FnQWlBVUhpL3dGS0JFQWdDa0hvQUdvaUN5Z0NBQ0FCYXlJTlFRQk9CRUFnQ2tId0FHb2lGaUFLUWZnQWFpSU9LQUlBSUFGcklCWW9BZ0JxTmdJQUFrQUNRQ0FOQkVBZ0NrRVFhaUlDS0FJQUlnTWdBeUFCYWlBTkVGMGFJQkpCQURZQ0FDQUxJQTAyQWdBZ0RVR0FnQUpIRFFGQmdJQUNJUUVGSUJKQkFEWUNBQ0FMUVFBMkFnQWdDa0VRYWlFQ0RBRUxEQUVMSUFvb0FnQWdBaWdDQUNBTmFrR0FnQUlnRFdzUVhpRURJQXNvQWdBaUFTQURhaUVDSUFOQkFFb0VRQ0FMSUFJMkFnQWdBaUVCQ3dzZ0NrSHNBR29pQXlBQlFXSnFJZ3MyQWdBZ0RpQVNLQUlBSWdFMkFnQWdBVUYvYWlBV0tBSUFJZ0pxSVE0Z0FrRi9Sd1JBSUFNZ0N5QU9TQVIvSUFzRklBNExOZ0lBQ3dzTElBb29BaEFoQWlBU0lBRkJBV28yQWdBZ0ZTQVRRUWgwSUFJZ0FXb3RBQUJ5TmdJQUlBWWdCaWdDQUVFSWRDSUNOZ0lBSUFnZ0NDZ0NBRUVJZENJQk5nSUFEQUVMQ3lBVUtBSUFJUU1nQkNnQ0FDRUNJQThvQWdBaEFRTkFJQUpCQVdvaEFpQURJQUVvQWd3aUFVOE5BU0FGS0FJQUlBRkpEUUVnQnlnQ0FDQUJMd0VBUmcwQUN5QUVJQUkyQWdBZ0R5QUJOZ0lBSUFFZ0FCQ0lCRVVFUUVGL0lRSU1Bd3NnQ0NBSUtBSUFJQWtvQWdBaUF5QUdLQUlBSWdKc2FpSUJOZ0lBSUFZZ0RDZ0NBQ0FEYXlBQ2JDSUNOZ0lBSUJBb0FnQWlBMFVOQVNBRElRRWdCQ0VEREFVTEN3d0JDMEYvRHdzZ0JDQUNOZ0lBSUE4Z0FUWUNBRUYvRHdzTElBRXRBQUFoQWdKQUFrQWdBeWdDQUEwQUlCUW9BZ0FnQVNnQ0JDSUJUdzBBSUFCQjBBeHFJQUUyQWdBZ0R5QUJOZ0lBREFFTElBQVFod1FnQUVId0ZHb2lBU3dBQUVVRVFDQUJRUUU2QUFBZ0FFSHdER3BCQUVHQUFoQlVHZ3NMSUFCQitKUUJhaUVRSUFCQmpKVUJhaUVUSUFnb0FnQWhBQ0FHS0FJQUlRRURRQUpBSUFFZ0FHb2dBSE5CZ0lDQUNFOEVRQ0FCUVlDQUFrOE5BU0FHUVFBZ0FHdEIvLzhCY1RZQ0FBc2dFQ2dDQUNFT0lCTW9BZ0FpQlVFRWFpSU1LQUlBSWdCQjR2OEJTZ1JBSUFWQjZBQnFJZ2NvQWdBZ0FHc2lDVUVBVGdSQUlBVkI4QUJxSWhFZ0JVSDRBR29pQkNnQ0FDQUFheUFSS0FJQWFqWUNBQUpBQWtBZ0NRUkFJQVZCRUdvaUFTZ0NBQ0lESUFNZ0FHb2dDUkJkR2lBTVFRQTJBZ0FnQnlBSk5nSUFJQWxCZ0lBQ1J3MEJRWUNBQWlFQUJTQU1RUUEyQWdBZ0IwRUFOZ0lBSUFWQkVHb2hBUXdCQ3d3QkN5QUZLQUlBSUFFb0FnQWdDV3BCZ0lBQ0lBbHJFRjRoQXlBSEtBSUFJZ0FnQTJvaEFTQURRUUJLQkVBZ0J5QUJOZ0lBSUFFaEFBc0xJQVZCN0FCcUlnTWdBRUZpYWlJSE5nSUFJQVFnRENnQ0FDSUFOZ0lBSUFCQmYyb2dFU2dDQUNJQmFpRUVJQUZCZjBjRVFDQURJQWNnQkVnRWZ5QUhCU0FFQ3pZQ0FBc0xDeUFGS0FJUUlRRWdEQ0FBUVFGcU5nSUFJQkFnRGtFSWRDQUJJQUJxTFFBQWNqWUNBQ0FHSUFZb0FnQkJDSFFpQVRZQ0FDQUlJQWdvQWdCQkNIUWlBRFlDQUF3QkN3c2dBZ3ZLQVFFQ2Z3SkFJQUFRV0NJQlFZQ0FBM0VpQWtFUWRFRVFkVUVBU0FSQUlBSkJFSFJCRUhWQmdJQithdzBCSUFCQkFoQlZJQUFRV0NFQklBQkJFQkJWSUFFUEJTQUNRUkIwUVJCMVFZQ0FBVWdFUUNBQ0RRSWdBRUVHRUZVZ0FVRUtka0VQY1E4TElBSkJFSFJCRUhWQmdJQUJhdzBCSUFGQmdQZ0FjUVJBSUFCQkNoQlZJQUZCQm5aQi93RnhEd1VnQUVFT0VGVWdBVUVDZGtHQWZuSVBDd0FMQUFzZ0FFRUNFRlVnQUJCWVFSQjBJUUVnQUVFUUVGVWdBQkJZSUFGeUlRRWdBRUVRRUZVZ0FRdGVBUUovSUFFb0FnQWlBa1VnQUNnQ0FDSURSU0FESUFKSGNuSUVRQ0FDSVFBZ0F5RUJCUU5BSUFGQkJHb2lBU2dDQUNJQ1JTQUFRUVJxSWdBb0FnQWlBMFVnQXlBQ1IzSnlCRUFnQWlFQUlBTWhBUVVNQVFzTEN5QUJJQUJyQzBRQkFuOGdBUVJBQTBBZ0FFRUVhaUVESUFBb0FnQWlBa1VnQWlBQlJuSkZCRUFnQXlFQURBRUxDeUFDUlFSQVFRQWhBQXNGSUFBZ0FCQlpRUUowYWlFQUN5QUFDOWdFQVFGL0lBQW9Bb0FCSUFGTEJFQWdBQ2dDQUNBQmFnOExBa0FnQUNnQ2hBRWdBVXNFUUVFQklRSUZJQUFvQW9nQklBRkxCRUJCQWlFQ0JTQUFLQUtNQVNBQlN3UkFRUU1oQWdVZ0FDZ0NrQUVnQVVzRVFFRUVJUUlGSUFBb0FwUUJJQUZMQkVCQkJTRUNCU0FBS0FLWUFTQUJTd1JBUVFZaEFnVWdBQ2dDbkFFZ0FVc0VRRUVISVFJRklBQW9BcUFCSUFGTEJFQkJDQ0VDQlNBQUtBS2tBU0FCU3dSQVFRa2hBZ1VnQUNnQ3FBRWdBVXNFUUVFS0lRSUZJQUFvQXF3QklBRkxCRUJCQ3lFQ0JTQUFLQUt3QVNBQlN3UkFRUXdoQWdVZ0FDZ0N0QUVnQVVzRVFFRU5JUUlGSUFBb0FyZ0JJQUZMQkVCQkRpRUNCU0FBS0FLOEFTQUJTd1JBUVE4aEFnVWdBQ2dDd0FFZ0FVc0VRRUVRSVFJRklBQW9Bc1FCSUFGTEJFQkJFU0VDQlNBQUtBTElBU0FCU3dSQVFSSWhBZ1VnQUNnQ3pBRWdBVXNFUUVFVElRSU1Fd3NnQUNnQzBBRWdBVXNFUUVFVUlRSU1Fd3NnQUNnQzFBRWdBVXNFUUVFVklRSU1Fd3NnQUNnQzJBRWdBVXNFUUVFV0lRSU1Fd3NnQUNnQzNBRWdBVXNFUUVFWElRSU1Fd3NnQUNnQzRBRWdBVXNFUUVFWUlRSU1Fd3NnQUNnQzVBRWdBVXNFUUVFWklRSU1Fd3NnQUNnQzZBRWdBVXNFUUVFYUlRSU1Fd3NnQUNnQzdBRWdBVXNFUUVFYklRSU1Fd3NnQUNnQzhBRWdBVXNFUUVFY0lRSU1Fd3NnQUNnQzlBRWdBVXNFUUVFZElRSU1Fd3NnQUNnQytBRWdBVXNFUUVFZUlRSU1Fd3NnQUNnQy9BRWdBVXNFUUVFZklRSU1Fd3NnQUNnQ0FBOExDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3c0xJQUFnQWtFQ2RHb29BZ0FnQVNBQUlBSkJBblJxS0FKOGEyb0w3UU1CQjM4Z0FFSGdBR29pQmlnQ0FDSUVJQUpySWdNZ0FFSE16UU5xS0FJQVFmOWZhaUlGU1NBRUlBVkpjVVVFUUNBQlJRUkFEd3NnQUVHa2xnRnFJUWNnQXlFQ0lBQkIwTTBEYWlJSUtBSUFJUU1nQkNFQUEwQWdBa0VCYWlFRUlBY29BZ0FpQlNBQWFpQUZJQU1nQW5GcUxBQUFPZ0FBSUFZZ0JpZ0NBRUVCYWlBSUtBSUFJZ054SWdBMkFnQWdBVUYvYWlJQkJFQWdCQ0VDREFFTEN3OExJQUJCcEpZQmFpZ0NBQ0lKSUFOcUlRTWdDU0FFYWlFQUlBWWdCQ0FCYWpZQ0FDQUJRUWRMQkVBZ0NTQUVJQUZCZUdvaUIwRjRjU0lJYWtFSWFpSUZJQUpyYWlFRUlBTWhBZ05BSUFBZ0Fpd0FBRG9BQUNBQUlBSXNBQUU2QUFFZ0FDQUNMQUFDT2dBQ0lBQWdBaXdBQXpvQUF5QUFJQUlzQUFRNkFBUWdBQ0FDTEFBRk9nQUZJQUFnQWl3QUJqb0FCaUFBSUFJc0FBYzZBQWNnQWtFSWFpRUNJQUJCQ0dvaEFDQUJRWGhxSWdGQkIwc05BQXNnQ1NBRmFpRUFJQVFoQXlBSElBaHJJUUVMSUFGRkJFQVBDeUFBSUFNc0FBQTZBQUFnQVVFQlJnUkFEd3NnQUNBRExBQUJPZ0FCSUFGQkFrMEVRQThMSUFBZ0F5d0FBam9BQWlBQlFRTkdCRUFQQ3lBQUlBTXNBQU02QUFNZ0FVRUVUUVJBRHdzZ0FDQURMQUFFT2dBRUlBRkJCVVlFUUE4TElBQWdBeXdBQlRvQUJTQUJRUVpOQkVBUEN5QUFJQU1zQUFZNkFBWUxoeEFCQkg4akJDRUZJd1JCZ0FocUpBUWdCVUdBQkdvaEFpQUFMQUNBQkFSL0lBSWdBRUdBQkJCVEdpTUVJUUFqQkVFUWFpUUVRUlFnQUJBbElRTWdBQ1FFSUFOQnl3QnFJUVJCQUNFQUEwQWdBaUFBYWlJRElBUWdBR29nQXkwQUFITTZBQUFnQUVFQmFpSUFRWUFFUncwQUN5QUNRZndEYWdVZ0Fnc2hBeUFGSVFBZ0EwRUFOZ0lBSUFFc0FJQUVCSDhnQUNBQlFZQUVFRk1hSXdRaEFTTUVRUkJxSkFSQkZDQUJFQ1VoQXlBQkpBUWdBMEhMQUdvaEJFRUFJUUVEUUNBQUlBRnFJZ01nQkNBQmFpQURMUUFBY3pvQUFDQUJRUUZxSWdGQmdBUkhEUUFMSUFCQi9BTnFCU0FBQzBFQU5nSUFJQUlnQUJCeklRRWdBa0VBT2dBQUlBSkJBRG9BQVNBQ1FRQTZBQUlnQWtFQU9nQURJQUpCQURvQUJDQUNRUUE2QUFVZ0FrRUFPZ0FHSUFKQkFEb0FCeUFDUVFBNkFBZ2dBa0VBT2dBSklBSkJBRG9BQ2lBQ1FRQTZBQXNnQWtFQU9nQU1JQUpCQURvQURTQUNRUUE2QUE0Z0FrRUFPZ0FQSUFKQkFEb0FFQ0FDUVFBNkFCRWdBa0VBT2dBU0lBSkJBRG9BRXlBQ1FRQTZBQlFnQWtFQU9nQVZJQUpCQURvQUZpQUNRUUE2QUJjZ0FrRUFPZ0FZSUFKQkFEb0FHU0FDUVFBNkFCb2dBa0VBT2dBYklBSkJBRG9BSENBQ1FRQTZBQjBnQWtFQU9nQWVJQUpCQURvQUh5QUNRUUE2QUNBZ0FrRUFPZ0FoSUFKQkFEb0FJaUFDUVFBNkFDTWdBa0VBT2dBa0lBSkJBRG9BSlNBQ1FRQTZBQ1lnQWtFQU9nQW5JQUpCQURvQUtDQUNRUUE2QUNrZ0FrRUFPZ0FxSUFKQkFEb0FLeUFDUVFBNkFDd2dBa0VBT2dBdElBSkJBRG9BTGlBQ1FRQTZBQzhnQWtFQU9nQXdJQUpCQURvQU1TQUNRUUE2QURJZ0FrRUFPZ0F6SUFKQkFEb0FOQ0FDUVFBNkFEVWdBa0VBT2dBMklBSkJBRG9BTnlBQ1FRQTZBRGdnQWtFQU9nQTVJQUpCQURvQU9pQUNRUUE2QURzZ0FrRUFPZ0E4SUFKQkFEb0FQU0FDUVFBNkFENGdBa0VBT2dBL0lBSkJRR3RCQURvQUFDQUNRUUE2QUVFZ0FrRUFPZ0JDSUFKQkFEb0FReUFDUVFBNkFFUWdBa0VBT2dCRklBSkJBRG9BUmlBQ1FRQTZBRWNnQWtFQU9nQklJQUpCQURvQVNTQUNRUUE2QUVvZ0FrRUFPZ0JMSUFKQkFEb0FUQ0FDUVFBNkFFMGdBa0VBT2dCT0lBSkJBRG9BVHlBQ1FRQTZBRkFnQWtFQU9nQlJJQUpCQURvQVVpQUNRUUE2QUZNZ0FrRUFPZ0JVSUFKQkFEb0FWU0FDUVFBNkFGWWdBa0VBT2dCWElBSkJBRG9BV0NBQ1FRQTZBRmtnQWtFQU9nQmFJQUpCQURvQVd5QUNRUUE2QUZ3Z0FrRUFPZ0JkSUFKQkFEb0FYaUFDUVFBNkFGOGdBa0VBT2dCZ0lBSkJBRG9BWVNBQ1FRQTZBR0lnQWtFQU9nQmpJQUpCQURvQVpDQUNRUUE2QUdVZ0FrRUFPZ0JtSUFKQkFEb0FaeUFDUVFBNkFHZ2dBa0VBT2dCcElBSkJBRG9BYWlBQ1FRQTZBR3NnQWtFQU9nQnNJQUpCQURvQWJTQUNRUUE2QUc0Z0FrRUFPZ0J2SUFKQkFEb0FjQ0FDUVFBNkFIRWdBa0VBT2dCeUlBSkJBRG9BY3lBQ1FRQTZBSFFnQWtFQU9nQjFJQUpCQURvQWRpQUNRUUE2QUhjZ0FrRUFPZ0I0SUFKQkFEb0FlU0FDUVFBNkFIb2dBa0VBT2dCN0lBSkJBRG9BZkNBQ1FRQTZBSDBnQWtFQU9nQitJQUpCQURvQWZ5QUFRUUE2QUFBZ0FFRUFPZ0FCSUFCQkFEb0FBaUFBUVFBNkFBTWdBRUVBT2dBRUlBQkJBRG9BQlNBQVFRQTZBQVlnQUVFQU9nQUhJQUJCQURvQUNDQUFRUUE2QUFrZ0FFRUFPZ0FLSUFCQkFEb0FDeUFBUVFBNkFBd2dBRUVBT2dBTklBQkJBRG9BRGlBQVFRQTZBQThnQUVFQU9nQVFJQUJCQURvQUVTQUFRUUE2QUJJZ0FFRUFPZ0FUSUFCQkFEb0FGQ0FBUVFBNkFCVWdBRUVBT2dBV0lBQkJBRG9BRnlBQVFRQTZBQmdnQUVFQU9nQVpJQUJCQURvQUdpQUFRUUE2QUJzZ0FFRUFPZ0FjSUFCQkFEb0FIU0FBUVFBNkFCNGdBRUVBT2dBZklBQkJBRG9BSUNBQVFRQTZBQ0VnQUVFQU9nQWlJQUJCQURvQUl5QUFRUUE2QUNRZ0FFRUFPZ0FsSUFCQkFEb0FKaUFBUVFBNkFDY2dBRUVBT2dBb0lBQkJBRG9BS1NBQVFRQTZBQ29nQUVFQU9nQXJJQUJCQURvQUxDQUFRUUE2QUMwZ0FFRUFPZ0F1SUFCQkFEb0FMeUFBUVFBNkFEQWdBRUVBT2dBeElBQkJBRG9BTWlBQVFRQTZBRE1nQUVFQU9nQTBJQUJCQURvQU5TQUFRUUE2QURZZ0FFRUFPZ0EzSUFCQkFEb0FPQ0FBUVFBNkFEa2dBRUVBT2dBNklBQkJBRG9BT3lBQVFRQTZBRHdnQUVFQU9nQTlJQUJCQURvQVBpQUFRUUE2QUQ4Z0FFRkFhMEVBT2dBQUlBQkJBRG9BUVNBQVFRQTZBRUlnQUVFQU9nQkRJQUJCQURvQVJDQUFRUUE2QUVVZ0FFRUFPZ0JHSUFCQkFEb0FSeUFBUVFBNkFFZ2dBRUVBT2dCSklBQkJBRG9BU2lBQVFRQTZBRXNnQUVFQU9nQk1JQUJCQURvQVRTQUFRUUE2QUU0Z0FFRUFPZ0JQSUFCQkFEb0FVQ0FBUVFBNkFGRWdBRUVBT2dCU0lBQkJBRG9BVXlBQVFRQTZBRlFnQUVFQU9nQlZJQUJCQURvQVZpQUFRUUE2QUZjZ0FFRUFPZ0JZSUFCQkFEb0FXU0FBUVFBNkFGb2dBRUVBT2dCYklBQkJBRG9BWENBQVFRQTZBRjBnQUVFQU9nQmVJQUJCQURvQVh5QUFRUUE2QUdBZ0FFRUFPZ0JoSUFCQkFEb0FZaUFBUVFBNkFHTWdBRUVBT2dCa0lBQkJBRG9BWlNBQVFRQTZBR1lnQUVFQU9nQm5JQUJCQURvQWFDQUFRUUE2QUdrZ0FFRUFPZ0JxSUFCQkFEb0FheUFBUVFBNkFHd2dBRUVBT2dCdElBQkJBRG9BYmlBQVFRQTZBRzhnQUVFQU9nQndJQUJCQURvQWNTQUFRUUE2QUhJZ0FFRUFPZ0J6SUFCQkFEb0FkQ0FBUVFBNkFIVWdBRUVBT2dCMklBQkJBRG9BZHlBQVFRQTZBSGdnQUVFQU9nQjVJQUJCQURvQWVpQUFRUUE2QUhzZ0FFRUFPZ0I4SUFCQkFEb0FmU0FBUVFBNkFINGdBRUVBT2dCL0lBQWtCQ0FCUlFzbEFRRi9JQUlnQUJCWmEwRi9haUlEUVFCTUJFQWdBQThMSUFBZ0FTQURFTElER2lBQUN4WUFJQUJCQUVIQXl3UVFWQm9nQUVHb3dBSnFFRndMYlFFRWZ5QUFLQUlVSUFCQkdHb2lCQ2dDQUNJRmF5SURJQUpKSWdZRWZ5QURCU0FDSWdNTEJFQWdBU0FBS0FJQUlBVnFJQU1RVXhvTElBWkZCRUFnQkNBRUtBSUFJQU5xTmdJQUlBTVBDeUFCSUFOcVFRQWdBaUFEYXhCVUdpQUVJQVFvQWdBZ0EybzJBZ0FnQXd1ZUF3RUlmeU1FSVFRakJFRWdhaVFFSUFSQkNHb2hCU0FCUVFBMkFnQWdCRUlBTndNQUlBUkJFR29pQXlBQU5nSUFBa0FDUUFKQUFrQUNRQUpBSUFFZ0F5QUNJQVFRdVFOQmYyc09BZ0FCQWdzTUFnc2dBQ3dBQUEwQlFRRWhBQXdDQzBFQklRQU1BUXNnQWtFQlN3UkFRUUFoQXdKQUFrQURRQ0FBSUFocUlnWXNBQUJGRFFFZ0JVSUFOd01BSUFFZ0EwRUNkR29pQ1NBR1Fhd2pLQUlBS0FJQUJIOUJCQVZCQVFzZ0JSQ0tBa0YvUmdSL0lBWXNBQUFpQjBFQVRnMERJQXBGQkVBZ0NVSCsvd00yQWdBZ0EwRUJhaUlESUFKUERRUWdCaXdBQUNFSEN5QUJJQU5CQW5ScUlBZEIvd0Z4UVlEQUEzSTJBZ0JCQVNFS0lBaEJBV29GSUFWQ0FEY0RBQ0FHUWF3aktBSUFLQUlBQkg5QkJBVkJBUXNnQlJDSUFpSUhRUUZLQkg4Z0J3VkJBUXNnQ0dvTElRZ2dBMEVCYWlJRElBSkpEUUJCQUNFQURBVUxBQXNnQVNBRFFRSjBha0VBTmdJQVFRRWhBQXdEQzBFQUlRQUZRUUFoQUF3QkN3d0JDeUFDUlFSQUlBUWtCQ0FBUWY4QmNVRUFSdzhMQ3lBQklBSkJmMnBCQW5ScVFRQTJBZ0FnQkNRRUlBQkIvd0Z4UVFCSEMvRUJBZ04vQVg0akJDRUJJd1JCMEFCcUpBUWdBRUd0dkFOcUxBQUFCRUFnQVNRRVFRQVBDeUFBUVlpOEEyb2lBeUFBSUFBb0FnQW9BaFJCQjNGQmhnRnFFUUFBSWdRM0F3QUNRQUpBQWtBQ1FBSkFBa0FnQUVHWXZBTnFLQUlBUVFGckRnTUFBUUlEQ3lBQUVOY0NJUUlNQXdzZ0FCRFdBaUVDREFJTElBQVExUUloQWd3QkN3d0JDeUFDQkVBZ0F5a0RBQ0VFQlNBQkpBUkJBQThMQ3lBQVFaQzhBMm9wQXdBZ0JGVUVRQ0FCSkFRZ0FnOExJQUZCQURZQ1JDQUJRUmcyQWtnZ0FVRkFhMEVCTmdJQUlBRWdBRUVZYWpZQ0FDQUFRYXk4QTJwQkFUb0FBRUdzOVFKQkF4QmtJQUVrQkVFQUM5Y0JBZ1ovQVg0akJDRURJd1JCb0FKcUpBUWdBMEVnYWlFR0lBTWhCU0FBUVNCcUlnTXBBd0FoQ1NBRElBa2dBcTE4TndNQUlBSkZCRUFnQlVFZ0VGc2dCa0dBQWhCYklBVWtCQThMSUFCQktHb2hCeUFBUVN4cUlRZ2dDYWRCUDNFaEF3TkFJQUpCd0FBZ0Eyc2lCRXNFZnlBRUJTQUNJZ1FMUWNBQVJnUkFJQWNnQVRZQ0FBVWdCeUFJTmdJQUlBQkJMR29nQTJvZ0FTQUVFRk1hQ3lBRUlBTnFJZ05Cd0FCR0JFQWdBQkRoQVVFQUlRTUxJQUVnQkdvaEFTQUNJQVJySWdJTkFBc2dCVUVnRUZzZ0JrR0FBaEJiSUFVa0JBdDRBUUYvSUFCQjlBMDJBZ0FnQUVHbzh3QnFMQUFBQkVBZ0FFR3M4d0JxS0FJQUlnRUVRQ0FCRUhrZ0FSQlNDd3NnQUVHUTdnSnFLQUlBSWdFRVFDQUJFRklMSUFCQjBPY0JhaWdDQUNJQkJFQWdBUkJTQ3lBQVFkanpBR29RdFFJZ0FFSHc4UUJxRUlRQklBQkJuTUFBYWhDT0FTQUFFSEFMQmdCQkVCQUFDd2dBUVFVUUFFRUFDd2dBUVFJUUFFRUFDekFCQVg4akJDRUNJd1JCRUdva0JDQUNJQUUyQWdCQjhDQW9BZ0FpQVNBQUlBSVF6Z0VhUVFvZ0FSQ3JBeG9RT1F1akFnRUVmeUFCUlFSQUlBQkJ2TTBEYWtFQU5nSUFJQUJCeU0wRGFrRUFOZ0lBSUFCQm5NMERhaUlFS0FJQUlnRUVRQ0FBUVpqTkEyb2hCUU5BSUFVb0FnQWdBa0VDZEdvb0FnQWlBd1JBSUFNb0Fqd2lBUVJBSUFFUVVnc2dBeWdDTENJQkJFQWdBUkJTQ3lBREtBSVVJZ0VFUUNBQkVGSUxJQU1RVWlBRUtBSUFJUUVMSUFKQkFXb2lBaUFCU1EwQUN3c2dCRUVBTmdJQUN5QUFRYXpOQTJvaUF5Z0NBQ0lDUlFSQUlBTkJBRFlDQUE4TElBQkJxTTBEYWlFRVFRQWhBU0FDSVFBRFFDQUVLQUlBSUFGQkFuUnFLQUlBSWdJRVFDQUNLQUk4SWdBRVFDQUFFRklMSUFJb0Fpd2lBQVJBSUFBUVVnc2dBaWdDRkNJQUJFQWdBQkJTQ3lBQ0VGSWdBeWdDQUNFQUN5QUJRUUZxSWdFZ0FFa05BQXNnQTBFQU5nSUFDMGdCQVg4Z0FFRkFheWdDQUNJQkJFQWdBUkNPQVNBQkVGSUxJQUFvQWtRaUFRUkFJQUVRamdFZ0FSQlNDeUFBUWFnQmFoQ05BU0FBUVp3QmFoQ05BU0FBUVpBQmFoQ05BUXNZQUVHMzlRSXNBQUJGQkVBUEMwR3M5UUpCL3dFUXBBRUxCZ0JCRGhBQUMxRUJBWDhnQUVFQVNpTURLQUlBSWdFZ0FHb2lBQ0FCU0hFZ0FFRUFTSElFUUJBREdrRU1FQjlCZnc4TEl3TWdBRFlDQUNBQUVBSktCRUFRQVVVRVFDTURJQUUyQWdCQkRCQWZRWDhQQ3dzZ0FRc0dBQ0FBRUZJTEVnQWdBZ1JBSUFBZ0FTQUNFRk1hQ3lBQUMwWUJBWDlCQ0JBVUlRQkJBQ1FGUVJjZ0FFRy83Z0FRRFNNRklRRkJBQ1FGSUFGQkFYRUVRQkFYSVFFZ0FCQWFJQUVRSGdVZ0FFSHNKVFlDQUNBQVFmZ0tRUXdRR3dzTFhnRUNmeUFBTEFBQUlnSkZJQUlnQVN3QUFDSURSM0lFUUNBRElRQWdBaUVCQlFOQUlBQkJBV29pQUN3QUFDSUNSU0FDSUFGQkFXb2lBU3dBQUNJRFIzSUVRQ0FESVFBZ0FpRUJCUXdCQ3dzTElBRkIvd0Z4SUFCQi93Rnhhd3NVQVFGL0lBQVFaeUVDSUFFRWZ5QUNCU0FBQ3d0cUFRRi9RUUFrQlVFT0lBQkJCR3BCQkJBTkl3VWhBVUVBSkFVZ0FVRUJjVVVFUUNBQVFRaHFJZ0FvQWdBaUFVVUVRQThMUVFBa0JVRU9JQUZCekJZUURTTUZJUUZCQUNRRklBRkJBWEZGQkVBZ0FDZ0NBQ0lBUlFSQUR3c2dBQkJTRHdzTFFRQVFHQkJhQzhjQkFRRi9RUUFrQlVFT0lBQkJ3QkVRRFNNRklRRkJBQ1FGSUFGQkFYRkZCRUJCQUNRRlFRNGdBRUhFRVdwQjRCTVFEU01GSVFGQkFDUUZJQUZCQVhGRkJFQWdBRUdzSUdvUVhDQUFRYlFiYWhCY0lBQkJ2QlpxRUZ3Z0FFSEVFV29RWENBQVFaQU5haEJjSUFCQjRBaHFFRndnQUVHd0JHb1FYQ0FBRUZ3UEN3dEJBQkFZSVFFZ0FFR3NJR29RWENBQVFiUWJhaEJjSUFCQnZCWnFFRndnQUVIRUVXb1FYQ0FBUVpBTmFoQmNJQUJCNEFocUVGd2dBRUd3QkdvUVhDQUFFRndnQVJCYUN6d0JBWDhnQWdSQVFRQWtCVUVkSUFBZ0FTQUNFQWNhSXdVaEFVRUFKQVVnQVVFQmNRUkFRUUFRR0NJQUVGb0ZJQUFoQXdzRklBQWhBd3NnQXdzbkFRRi9Jd1FoQXlNRVFSQnFKQVFnQXlBQ05nSUFJQUFnQVNBREVNNEJJUUFnQXlRRUlBQUxwQUlBQW44Z0FBUi9JQUZCZ0FGSkJFQWdBQ0FCT2dBQVFRRU1BZ3RCckNNb0FnQW9BZ0JGQkVBZ0FVR0FmM0ZCZ0w4RFJnUkFJQUFnQVRvQUFFRUJEQU1GUVlpOEEwSFVBRFlDQUVGL0RBTUxBQXNnQVVHQUVFa0VRQ0FBSUFGQkJuWkJ3QUZ5T2dBQUlBQWdBVUUvY1VHQUFYSTZBQUZCQWd3Q0N5QUJRWUN3QTBrZ0FVR0FRSEZCZ01BRFJuSUVRQ0FBSUFGQkRIWkI0QUZ5T2dBQUlBQWdBVUVHZGtFL2NVR0FBWEk2QUFFZ0FDQUJRVDl4UVlBQmNqb0FBa0VEREFJTElBRkJnSUI4YWtHQWdNQUFTUVIvSUFBZ0FVRVNka0h3QVhJNkFBQWdBQ0FCUVF4MlFUOXhRWUFCY2pvQUFTQUFJQUZCQm5aQlAzRkJnQUZ5T2dBQ0lBQWdBVUUvY1VHQUFYSTZBQU5CQkFWQmlMd0RRZFFBTmdJQVFYOExCVUVCQ3dzTGdRRUNBbjhCZmlBQXB5RUNJQUJDLy8vLy93OVdCRUFEUUNBQlFYOXFJZ0VnQUVJS2dxZEIvd0Z4UVRCeU9nQUFJQUJDQ29BaEJDQUFRdi8vLy8rZkFWWUVRQ0FFSVFBTUFRc0xJQVNuSVFJTElBSUVRQU5BSUFGQmYyb2lBU0FDUVFwd1FUQnlPZ0FBSUFKQkNtNGhBeUFDUVFwUEJFQWdBeUVDREFFTEN3c2dBUXNKQUNBQVFRQVFrd0lMU1FFQmYwR285UUJCcVBVQUtBSUFRUUZxSWdGQkEwc0VmMEVBSWdFRklBRUxOZ0lBSUFBZ0FVRU5kRUdzOVFCcUlnQkJnQkFRZXhvZ0FVRU5kRUdvdFFGcVFRQTJBZ0FnQUF2VEFRRUJmeUFBUVFBUWd3RWdBRUdrbGdGcUtBSUFJZ0VFUUNBQkVGSUxJQUJCdU0wRGFpZ0NBQ0lCQkVBZ0FSQlNDeUFBUWFqTkEyb29BZ0FpQVFSQUlBRVFVZ3NnQUVHWXpRTnFLQUlBSWdFRVFDQUJFRklMSUFCQmlNMERhaENZQVNBQVFkRE1BMm9Rc2dJZ0FFSFF4Z05xSWdFb0FnQUVRQ0FCUVFBMkFnQWdBRUg4eHdOcUtBSUFFRklMSUFCQnFKWUJhaERZQVNBQUtBSTBJZ0VFUUNBQkVGSUxJQUFvQWlRaUFRUkFJQUVRVWdzZ0FDZ0NGQ0lCUlFSQUlBQkJCR29RbUFFUEN5QUJFRklnQUVFRWFoQ1lBUXZOQXdFR2Z3SkFBa0FnQUVHUWxRRnFJZ0lvQWdBRVFDQUNRUUEyQWdBZ0FFRzhsZ0ZxSWdFb0FnQVFVaUFDS0FJQUlnTkJnSURBQUVnRVFDQURSUTBDQlNBRFFZQ0FRR3BGRFFNTElBSkJBRFlDQUNBQktBSUFFRklGSUFCQnZKWUJhaUVCQ3dzZ0FVSHdxdFVBRUd3aUFUWUNBQ0FCQkVBZ0FFSG9sd0ZxSUFGQjRLclZBR28yQWdBZ0FrR0FnTUFBTmdJQUJVR3M5UUlRVmdzTElBQkI4QlJxUVFFNkFBQWdBRUhrREdwQkFqWUNBQ0FBRU44QklBQkI4QkJxUVFBNkFBQWdBRUh4RUdwQkFqb0FBQ0FBUWZJUWFpSUJRb1NJa0tEQWdJR0NCRGNBQUNBQlFRUTZBQWdnQUVIN0VHcEJCa0gxQVJCVUdpQUFRZkFPYWtFQU9nQUFJQUJCOFE1cVFRRTZBQUFnQUVIeURtcEJBam9BQUVFRElRTkJBU0VCUVFFaEJFRURJUVVEUUNBQVFmQU9haUFGYWlBRE9nQUFJQVJCQVdvaEFpQUJRWDlxSWdGRklnWUVRQ0FDSVFFTElBTWdCbW9oQXlBR1JRUkFJQVFoQWdzZ0JVRUJhaUlGUVlBQ1J3UkFJQUloQkF3QkN3c2dBRUh3RW1vaUFVSUFOd0lBSUFGQ0FEY0NDQ0FCUWdBM0FoQWdBVUlBTndJWUlBRkNBRGNDSUNBQlFnQTNBaWdnQVVJQU53SXdJQUZDQURjQ09DQUFRYkFUYWtFSVFjQUJFRlFhSUFCQnhBeHFRUWM2QUFBTG1BTUNCWDhCZmlNRUlRUWpCRUdnQW1va0JDQUFJQUJCTEdvaUJUWUNLQ0FBUVNCcUlnWXBBd0FpQjZkQlAzRWlBMEVCYWlFQ0lBQkJMR29nQTJwQmdIODZBQUFnQWtFNFJ3UkFJQUJCTEdvaEF3TkFJQUpCUDNFaUFnUkFJQUJCTEdvZ0FtcEJBRG9BQUNBQ1FRRnFJZ0pCT0VjTkFRVWdBQkRoQVNBRFFRQTZBQUJCQVNFQ0RBRUxDd3NnQkVFZ2FpRURJQUFnQjBJMWlEd0FaQ0FBSUFkQ0xZZzhBR1VnQUNBSFFpV0lQQUJtSUFBZ0IwSWRpRHdBWnlBQUlBZENGWWc4QUdnZ0FDQUhRZzJJUEFCcElBQWdCMElGaUR3QWFpQUFJQWVuUWY4QmNVRURkRG9BYXlBQUVPRUJRUUFoQWdOQUlBRWdBbW9nQUNBQ1FRSjJRUUowYWlnQ0FDQUNRUU4wUVJoeFFSaHpkam9BQUNBQ1FRRnFJZ0pCSUVjTkFBc2dBRUhuektmUUJqWUNBQ0FBUVlYZG50dDdOZ0lFSUFCQjh1YTc0d00yQWdnZ0FFRzY2citxZWpZQ0RDQUFRZitrdVlnRk5nSVFJQUJCak5HVjJIazJBaFFnQUVHcnM0LzhBVFlDR0NBQVFabWFnOThGTmdJY0lBWkNBRGNEQUNBRVFTQVFXeUFEUVlBQ0VGc2dCVUhBQUJCYklBUWtCQXNkQVFGL0lBQXNBQWdFUUE4TElBQW9BZ3dpQVVVRVFBOExJQUVRVWd2NUFnRUVmeUFDUlFSQUlBQVBDd0pBQWtBRFFDQUJRUWR4QkVBZ0FFSC9BWEVnQVMwQUFITkJBblJCdlBVQ2FpZ0NBQ0FBUVFoMmN5RUFJQUZCQVdvaEFTQUNRWDlxSWdKRkRRSU1BUXNMREFFTElBQVBDeUFDUVFkTEJFQWdBa0Y0YWlJRVFYaHhJZ1ZCQ0dvaEJpQUJJUU1EUUNBREtBSUFJQUJ6SWdCQkNIWkIvd0Z4UVFKMFFieWxBMm9vQWdBZ0FFSC9BWEZCQW5SQnZLMERhaWdDQUhNZ0FFRVFka0gvQVhGQkFuUkJ2SjBEYWlnQ0FITWdBRUVZZGtFQ2RFRzhsUU5xS0FJQWN5QURLQUlFSWdCQi93RnhRUUowUWJ5TkEyb29BZ0J6SUFCQkNIWkIvd0Z4UVFKMFFieUZBMm9vQWdCeklBQkJFSFpCL3dGeFFRSjBRYno5QW1vb0FnQnpJQUJCR0haQkFuUkJ2UFVDYWlnQ0FITWhBQ0FEUVFocUlRTWdBa0Y0YWlJQ1FRZExEUUFMSUFFZ0Jtb2hBU0FFSUFWcklnSkZCRUFnQUE4TEN3TkFJQUJCL3dGeElBRXRBQUJ6UVFKMFFiejFBbW9vQWdBZ0FFRUlkbk1oQUNBQlFRRnFJUUVnQWtGL2FpSUNEUUFMSUFBTGdBTUJCbjhqQkNFRUl3UkJRR3NrQkNBQUlBQW9BZ0FpQjBGNGFpZ0NBR29oQ0NBSFFYeHFLQUlBSVFZZ0JDQUNOZ0lBSUFRZ0FEWUNCQ0FFSUFFMkFnZ2dCQ0FETmdJTUlBUkJGR29oQUNBRVFSaHFJUWtnQkVFY2FpRUhJQVJCSUdvaEF5QUVRU2hxSVFFZ0JFRVFhaUlGUWdBM0FnQWdCVUlBTndJSUlBVkNBRGNDRUNBRlFnQTNBaGdnQlVFQU5nSWdJQVZCQURzQkpDQUZRUUE2QUNZQ1FDQUdJQUpHQkg4Z0JFRUJOZ0l3SUFZZ0JDQUlJQWhCQVVFQUlBWW9BZ0FvQWhSQkIzRkJxQUpxRVFzQUlBa29BZ0JCQVVZRWZ5QUlCVUVBQ3dVZ0JpQUVJQWhCQVVFQUlBWW9BZ0FvQWhoQkIzRkJvQUpxRVF3QUFrQUNRQUpBQWtBZ0JDZ0NKQTRDQUFFQ0N5QUFLQUlBSVFBZ0FTZ0NBRUVCUmlBSEtBSUFRUUZHY1NBREtBSUFRUUZHY1VVRVFFRUFJUUFMREFRTERBRUxRUUFoQUF3Q0N5QUpLQUlBUVFGSEJFQWdBU2dDQUVVZ0J5Z0NBRUVCUm5FZ0F5Z0NBRUVCUm5GRkJFQkJBQ0VBREFNTEN5QUZLQUlBQ3lFQUN5QUVKQVFnQUF0REFRSi9JQUFRV1NFQkFrQUNRQU5BSUFGQkFFd05BU0FBSUFGQmYyb2lBa0VDZEdvb0FnQkJMMGNFUUNBQ0lRRU1BUXNMREFFTElBQVBDeUFBSUFGQkFuUnFDeVVBSUFBZ0FTQUNFTllEQkVBUEN5QUFMQUFVUlFSQUR3dEJyUFVDSUFCQkdHb1F0QUlMQ0FBZ0FDQUJFSE1MUEFFQmZ5QUFRUUEyQWhBZ0FDZ0NBQ0lCQkVBZ0FSQlNJQUJCQURZQ0FBc2dBRUVBTmdJRUlBQkJBRFlDQ0NBQVFRQTJBaFFnQUVFQU5nSllDOFFHQVFGL1FRY2hBQU5BSUFFZ0FDQUJMZ0VBUVlEK0EzRnlPd0VBSUFGQkFtb2lBeUFBSUFNdUFRQkJnUDREY1hJN0FRQWdBVUVFYWlJRElBQWdBeTRCQUVHQS9nTnhjanNCQUNBQlFRWnFJZ01nQUNBRExnRUFRWUQrQTNGeU93RUFJQUZCQ0dvaUF5QUFJQU11QVFCQmdQNERjWEk3QVFBZ0FVRUthaUlESUFBZ0F5NEJBRUdBL2dOeGNqc0JBQ0FCUVF4cUlnTWdBQ0FETGdFQVFZRCtBM0Z5T3dFQUlBRkJEbW9pQXlBQUlBTXVBUUJCZ1A0RGNYSTdBUUFnQVVFUWFpSURJQUFnQXk0QkFFR0EvZ054Y2pzQkFDQUJRUkpxSWdNZ0FDQURMZ0VBUVlEK0EzRnlPd0VBSUFGQkZHb2lBeUFBSUFNdUFRQkJnUDREY1hJN0FRQWdBVUVXYWlJRElBQWdBeTRCQUVHQS9nTnhjanNCQUNBQlFSaHFJZ01nQUNBRExnRUFRWUQrQTNGeU93RUFJQUZCR21vaUF5QUFJQU11QVFCQmdQNERjWEk3QVFBZ0FVRWNhaUlESUFBZ0F5NEJBRUdBL2dOeGNqc0JBQ0FCUVI1cUlnTWdBQ0FETGdFQVFZRCtBM0Z5T3dFQUlBRkJJR29pQXlBQUlBTXVBUUJCZ1A0RGNYSTdBUUFnQVVFaWFpSURJQUFnQXk0QkFFR0EvZ054Y2pzQkFDQUJRU1JxSWdNZ0FDQURMZ0VBUVlEK0EzRnlPd0VBSUFGQkptb2lBeUFBSUFNdUFRQkJnUDREY1hJN0FRQWdBVUVvYWlJRElBQWdBeTRCQUVHQS9nTnhjanNCQUNBQlFTcHFJZ01nQUNBRExnRUFRWUQrQTNGeU93RUFJQUZCTEdvaUF5QUFJQU11QVFCQmdQNERjWEk3QVFBZ0FVRXVhaUlESUFBZ0F5NEJBRUdBL2dOeGNqc0JBQ0FCUVRCcUlnTWdBQ0FETGdFQVFZRCtBM0Z5T3dFQUlBRkJNbW9pQXlBQUlBTXVBUUJCZ1A0RGNYSTdBUUFnQVVFMGFpSURJQUFnQXk0QkFFR0EvZ054Y2pzQkFDQUJRVFpxSWdNZ0FDQURMZ0VBUVlEK0EzRnlPd0VBSUFGQk9Hb2lBeUFBSUFNdUFRQkJnUDREY1hJN0FRQWdBVUU2YWlJRElBQWdBeTRCQUVHQS9nTnhjanNCQUNBQlFUeHFJZ01nQUNBRExnRUFRWUQrQTNGeU93RUFJQUZCUG1vaUF5QUFJQU11QVFCQmdQNERjWEk3QVFBZ0FVRkFheUVCSUFCQmYyb2hBeUFBUVFCS0JFQWdBeUVBREFFTEN5QUNRUWRxUVFCQitRRVFWQm9nQWtFZ09nQUdJQUpCd0FBNkFBVWdBa0hnQURvQUJDQUNRWUIvT2dBRElBSkJvSDg2QUFJZ0FrRkFPZ0FCSUFKQllEb0FBQXVGQXdFRWZ5QUFRYW9CYWlJRExBQUFCRUFnQVNFQ0JTQURRWDg2QUFBZ0FCQ05CQ0FBUWJnQmFpQUJRUUowYWlJRUtBSUFJZ0lFUUNBRUlBSW9BZ0EyQWdBZ0FnOEZJQUVoQWdzTEFrQUNRQU5BSUFKQkFXb2lBa0VtUmcwQklBQkJ1QUZxSUFKQkFuUnFJZ1VvQWdBaUJFVU5BQXdDQ3dBTElBTWdBeXdBQUVGL2Fqb0FBQ0FBUWR3Q2FpSUNLQUlBSWdNZ0FDZ0MwQUpySUFCQkJHb2dBV290QUFBaUFVRU1iQ0lFVEFSQVFRQVBDeUFDSUFNZ0JHczJBZ0FnQUVIVUFtb2lBaWdDQUNBQlFRUjBheUVBSUFJZ0FEWUNBQ0FBRHdzZ0JTQUVLQUlBTmdJQUlBQkJCR29nQW1vdEFBQWdBRUVFYWlBQmFpMEFBQ0lDYXlFQklBUWdBa0VFZEdvaEFpQUJJQUJCQkdvZ0FDQUJhaTBBS1NJRGFpMEFBRWNFUUNBQ0lBQkJ1QUZxSUFOQmYyb2lBMEVDZEdvaUJTZ0NBRFlDQUNBRklBSTJBZ0FnQWlBQVFRUnFJQU5xTFFBQUlnTkJCSFJxSVFJZ0FTQURheUVCQ3lBQ0lBQkJ1QUZxSUFBZ0FXb3RBQ2xCQW5ScUlnQW9BZ0EyQWdBZ0FDQUNOZ0lBSUFRTElBRUJmeUFBS0FMSUFTSUJCRUFnQVJDVkFTQUJFRklMSUFCQkVHb1FoQUVMWVFBZ0FFSG56S2ZRQmpZQ0FDQUFRWVhkbnR0N05nSUVJQUJCOHVhNzR3TTJBZ2dnQUVHNjZyK3FlallDRENBQVFmK2t1WWdGTmdJUUlBQkJqTkdWMkhrMkFoUWdBRUdyczQvOEFUWUNHQ0FBUVptYWc5OEZOZ0ljSUFCQ0FEY0RJQXVzQkFFR2Z5TUVJUVFqQkVGQWF5UUVJQUJCRkdvaUJTZ0NBQ0lJSUFKQkEzUWlDV29oQmlBRklBWTJBZ0FnQUVFWWFpSUhLQUlBSVFVZ0JpQUpTUVJBSUFjZ0JVRUJhaUlGTmdJQUN5QUhJQVVnQWtFZGRtbzJBZ0FnQ0VFRGRrRS9jU0lHSUFKcVFUOUxCRUFnQUVFY2FpQUdhaUFCUWNBQUlBWnJJZ1VRVXhvZ0FDQUFRZHdBYWlJR0lBQkJIR29nQXhEakFTQUZRVDlxSUFKSkJFQWdBd1JBQTBBZ0JDQUJJQVZxSWdNcEFBQTNBQUFnQkNBREtRQUlOd0FJSUFRZ0F5a0FFRGNBRUNBRUlBTXBBQmczQUJnZ0JDQURLUUFnTndBZ0lBUWdBeWtBS0RjQUtDQUVJQU1wQURBM0FEQWdCQ0FES1FBNE53QTRJQUFnQmlBRVFRRVE0d0VnQlVGQWF5RURJQVZCL3dCcUlBSkpCRUFnQXlFRkRBRUZRUUFoQmdzTEJRTkFJQVFnQVNBRmFpSURLUUFBTndBQUlBUWdBeWtBQ0RjQUNDQUVJQU1wQUJBM0FCQWdCQ0FES1FBWU53QVlJQVFnQXlrQUlEY0FJQ0FFSUFNcEFDZzNBQ2dnQkNBREtRQXdOd0F3SUFRZ0F5a0FPRGNBT0NBQUlBWWdCRUVBRU9NQklBTWdCQ2tBQURjQUFDQURJQVFwQUFnM0FBZ2dBeUFFS1FBUU53QVFJQU1nQkNrQUdEY0FHQ0FESUFRcEFDQTNBQ0FnQXlBRUtRQW9Od0FvSUFNZ0JDa0FNRGNBTUNBRElBUXBBRGczQURnZ0JVRkFheUVESUFWQi93QnFJQUpKQkVBZ0F5RUZEQUVGUVFBaEJnc0xDd1ZCQUNFR0lBVWhBd3NGUVFBaEF3c2dBeUFDVHdSQUlBUWtCQThMSUFCQkhHb2dCbW9nQVNBRGFpQUNJQU5yRUZNYUlBUWtCQXN4QVFGL0lBRkIvd0ZHQkVBZ0FDd0FDRVVFUUE4TEN5QUFJQUVRWkVFRUVCUWlBaUFCTmdJQUlBSkJnQWhCQUJBYkM5UURBUVovQWtBakJDRURJd1JCZ0lBQmFpUUVJQU5CZ0VCcklRUWdBa0VBU0NFRkFrQWdBa0gvL3dOeElnSUVRQ0FBRUZraEJnSkFJQUpCQVhJaUIwRURSaUlJUlFSQUlBQWdBU0FHRU1rQlJRUkFBa0FDUUNBQklBWkJBblJxS0FJQURsMEFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQzBFQklRQU1CZ3NMQ3dzZ0FrRUJSZ1JBSUFNa0JFRUFEd3NnQUNBRVFZQVFFSUlDSUFFZ0EwR0FFQkNDQWdKL0lBZ0VRQ0FGQkg4Z0JDQURFSE1GSUFRZ0F4Q2RBUXNpQkVVTkF3VWdCMEVGUncwRElBSkJCRVloQmlBRUVNb0JCRUFnQUNBQklBVVE1d0VNQWdzZ0JrVUVRQ0FBRU1vQlJRUkFJQVVFZnlBRUlBTVFjd1VnQkNBREVKMEJDeUlFUlEwRlFRQU1Bd3NMSUFRb0FnQkZEUU1nQkNBRElBUVFXUkRKQVVVTkF3dEJBQXNoQUF3Q0N3c2dBQkNiQVNFQVFid09JQUVRbXdFaUFVRUdFTWtCUlFSQUlBTWtCRUVBRHdzZ0FrRUNSd1JBSUFBZ0FTQUZFT2NCSVFBTUFRc2dCUVIvSUFBZ0FSQnpCU0FBSUFFUW5RRUxJUUFnQXlRRUlBQkZEd3NnQXlRRUlBQUxaZ0VEZnlBQVFSaHFJZ0lvQWdBaUFVRURhaUlESUFBb0FoUlBCRUJCQUE4TElBQW9BZ0FpQUNBQlFRRnFhaTBBQUVFSWRDQUFJQUZxTFFBQWNpQUFJQUZCQW1wcUxRQUFRUkIwY2lBQUlBTnFMUUFBUVJoMGNpRUFJQUlnQVVFRWFqWUNBQ0FBQytjQ0FRZC9Jd1FoQlNNRVFaQURhaVFFSUFWQjhBSnFJUWdnQlVIZ0FXb2hCaUFGUWZBQWFpRUpJQVZCMEFKcUlRb0NRQUpBSUFGQndBQkxCRUFnQmhDaUFTQUdJQUFnQVJCOUlBWWdDQkNYQVVFZ0lRRWdCaUVBQlNBQkJFQWdBQ0VJSUFZaEFBVWdBQ0VJUVFBaEFTQUdJUUJCQVNFSERBSUxDd05BSUFZZ0Iyb2dDQ0FIYWl3QUFFRTJjem9BQUNBSFFRRnFJZ2NnQVVjTkFBc2dBVUhBQUVrRVFFRUFJUWNNQVFWQkFDRUhDd3dCQ3lBR0lBRnFRVFpCd0FBZ0FXc1FWQnBCQVNFTEN5QUpFS0lCSUFrZ0FFSEFBQkI5SUFrZ0FpQURFSDBnQ1NBS0VKY0JJQVVRb2dFZ0IwVUVRRUVBSVFJRFFDQUdJQUpxSUFnZ0Ftb3NBQUJCM0FCek9nQUFJQUpCQVdvaUFpQUJSdzBBQ3dzZ0MwVUVRQ0FGSUFCQndBQVFmU0FGSUFwQklCQjlJQVVnQkJDWEFTQUZKQVFQQ3lBR0lBRnFRZHdBUWNBQUlBRnJFRlFhSUFVZ0FFSEFBQkI5SUFVZ0NrRWdFSDBnQlNBRUVKY0JJQVVrQkFzR0FFRVRFQUFMQmdCQkRCQUFDd2dBUVFNUUFFRUFDMWdCQTM4Z0FDZ0NCQ0lHUVFoMUlRVWdCa0VCY1FSQUlBSW9BZ0FnQldvb0FnQWhCUXNnQUNnQ0FDSUFLQUlBS0FJWUlRY2dBQ0FCSUFJZ0JXb2dCa0VDY1FSL0lBTUZRUUlMSUFRZ0IwRUhjVUdnQW1vUkRBQUxFUUFnQVNnQ1RCb2dBQ0FCRUt3RElnQUxRUUVCZndKQUlBQVFXU0lDUVg5S0JFQWdBQ0FDUVFKMGFpRUNBMEFnQWlnQ0FDQUJSZzBDSUFKQmZHb2lBaUFBVHcwQVFRQWhBZ3NGUVFBaEFnc0xJQUlMWkFFRGZ3SkFJQUlFUUNBQklRTWdBQ0VCQTBBZ0F5Z0NBQ0lGUlEwQ0lBTkJCR29oQXlBQlFRUnFJUVFnQVNBRk5nSUFJQUpCZjJvaUFnUkFJQVFoQVF3QkJTQUVJUUZCQUNFQ0N3c0ZJQUFoQVVFQUlRSUxDeUFCUVFBZ0FoQ3dBeG9nQUF2Q0JBRUtmeU1FSVFZakJFR0FRR3NrQkNBQUlRY0RRQUpBQTBBZ0FDSUVLQUlBSVFnQ1FBSkFBMEFDUUFKQUFrQUNRQ0FJRGpBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnRUNDeUFISVFBTUJ3c01BUXNNQWdzZ0JFRUVhaUlBS0FJQUlnaEJMa1lOQWlBQUlRUU1BQXNBQ3lBRVFRUnFJUUFNQVFzZ0JDZ0NDRUV1UncwQUN5QUVRUkJxSVFnZ0JDZ0NERUV2UmdSQUlBZ2hCd3NNQVFzTEFrQUNRQU5BQWtBQ1FBSkFBa0FDUUNBQUtBSUFJZ2NPWFFBQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FRSUxEQU1MSUFBb0FnUkIzQUJHQkVBZ0FFRUlha0hjQUJCMElnSUVRQ0FDUVFScVFkd0FFSFFpQTBFRWFpRUNJQU1FZnlBQ0JTQUFJZ0lMSVFNRklBQWlBeUVDQ3dVZ0FDSURJUUlMUVEwaEJRd0JDeUFBSWdvaENTQUhJUXNMQTBBZ0JVRU5SZ1JBUVFBaEJTQURJUW9nQWlFSklBTW9BZ0FoQ3dzQ1FBSkFBa0FnQzBFdWF3NENBQUVDQ3lBS1FRUnFJUU1nQ1NFQ1FRMGhCUXdDQ3lBS1FRUnFJZ0loQTBFTklRVU1BUXNMSUFrZ0FFWU5BaUFKSVFBTUFRc0xEQUVMSUFBb0FnQkJMa1lFUUNBQUtBSUVRUzVHQkVBZ0FFRUlhaUlDS0FJQVJRUkFJQUloQUFzTEN3c2dBVVVFUUNBR0pBUWdBQThMSUFZZ0FFR0FFQkJ2R2lBQklBWVFhaG9nQmlRRUlBQUxFd0FnQUFSL0lBQWdBVUVBRUpFQkJVRUFDd3ZhQXdNQmZ3RitBWHdDUUNBQlFSUk5CRUFDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRkJDV3NPQ2dBQkFnTUVCUVlIQ0FrS0N5QUNLQUlBUVFOcVFYeHhJZ0VvQWdBaEF5QUNJQUZCQkdvMkFnQWdBQ0FETmdJQURBc0xJQUlvQWdCQkEycEJmSEVpQVNnQ0FDRURJQUlnQVVFRWFqWUNBQ0FBSUFPc053TUFEQW9MSUFJb0FnQkJBMnBCZkhFaUFTZ0NBQ0VESUFJZ0FVRUVhallDQUNBQUlBT3ROd01BREFrTElBSW9BZ0JCQjJwQmVIRWlBU2tEQUNFRUlBSWdBVUVJYWpZQ0FDQUFJQVEzQXdBTUNBc2dBaWdDQUVFRGFrRjhjU0lCS0FJQUlRTWdBaUFCUVFScU5nSUFJQUFnQTBILy93TnhRUkIwUVJCMXJEY0RBQXdIQ3lBQ0tBSUFRUU5xUVh4eElnRW9BZ0FoQXlBQ0lBRkJCR28yQWdBZ0FDQURRZi8vQTNHdE53TUFEQVlMSUFJb0FnQkJBMnBCZkhFaUFTZ0NBQ0VESUFJZ0FVRUVhallDQUNBQUlBTkIvd0Z4UVJoMFFSaDFyRGNEQUF3RkN5QUNLQUlBUVFOcVFYeHhJZ0VvQWdBaEF5QUNJQUZCQkdvMkFnQWdBQ0FEUWY4QmNhMDNBd0FNQkFzZ0FpZ0NBRUVIYWtGNGNTSUJLd01BSVFVZ0FpQUJRUWhxTmdJQUlBQWdCVGtEQUF3REN5QUNLQUlBUVFkcVFYaHhJZ0VyQXdBaEJTQUNJQUZCQ0dvMkFnQWdBQ0FGT1FNQUN3c0xDekFCQW44Z0FFRUVhaUlCS0FJQUlnSUVRQ0FBTEFBUVJRUkFJQUlRUGdzZ0FVRUFOZ0lBQ3lBQVFRQTJBZ3hCQVF1QUJBSUhmd0orSUFJZ0FVY0VRQ0FBUWJxWUFXcEJBVG9BQUFzZ0FpQUJTU0lEQkVBZ0FFRzVtQUZxUVFFNkFBQUxJQUJCcUpnQmFpd0FBQVJBSUFCQjBNMERhaUlIS0FJQUlnTWdBaUFCYTNFaUJFVUVRQThMSUFCQnFKWUJhaUVGSUFCQnNKZ0JhaUVJSUFFaEFpQUFRY0NZQVdvaUJpa0RBQ0VLSUFNaEFRTkFJQVVnQWlBRUVQd0RJUU1nQ0NrREFDSUxJQXBWQkVBZ0JTQUNFSFVoQVNBTElBcDlJZ3FuSVFrZ0FDZ0NBQ0FCSUFvZ0E2MGlDbE1FZnlBSkJTQURDeEJsSUFZZ0Jpa0RBQ0FLZkNJS053TUFJQWNvQWdBaEFRc2dBU0FESUFKcWNTRUNJQVFnQTJzaUJBMEFDdzhMSUFCQnBKWUJhaUlGS0FJQUlBRnFJUVFnQTBVRVFDQUFRYkNZQVdvcEF3QWlDaUFBUWNDWUFXb2lBeWtEQUNJTFZ3UkFEd3NnQ2lBTGZTSUtweUVGSUFBb0FnQWdCQ0FLSUFJZ0FXc2lBSzBpQ2xNRWZ5QUZCU0FBQ3hCbElBTWdBeWtEQUNBS2ZEY0RBQThMSUFCQnpNMERhaWdDQUNBQmF5RURJQUJCc0pnQmFpSUdLUU1BSWdzZ0FFSEFtQUZxSWdFcEF3QWlDbFVFUUNBTElBcDlJZ3FuSVFjZ0FDZ0NBQ0FFSUFvZ0E2MGlDbE1FZnlBSEJTQURDeEJsSUFFZ0FTa0RBQ0FLZkNJS053TUFJQVlwQXdBaEN3c2dDeUFLVndSQUR3c2dDeUFLZlNJS3B5RUVJQUFvQWdBZ0JTZ0NBQ0FLSUFLdElncFRCSDhnQkFVZ0Fnc1FaU0FCSUFFcEF3QWdDbnczQXdBTHVnOEJHWDhqQkNFR0l3UkJvQWhxSkFRZ0FFRUVhaUlKS0FJQUlnVWdBRUhvQUdvaURTZ0NBQ0lDUVdkcVNnUkFJQUlnQldzaUFVRUFTQVJBSUFZa0JFRUFEd3NnQUVId0FHb2lCeUFBUWZnQWFpSURLQUlBSUFWcklBY29BZ0JxTmdJQUlBVkJnSUFCU2dSQUlBRkJBRW9FUUNBQUtBSVFJZ0lnQWlBRmFpQUJFRjBhQ3lBSlFRQTJBZ0FnRFNBQk5nSUFJQUVoQWdzZ0FrR0FnQUpHQkVCQkFDRUJRWUNBQWlFQ0JTQUFLQUlBSUFBb0FoQWdBbXBCZ0lBQ0lBSnJFRjRoQVNBTktBSUFJZ0lnQVdvaEJTQUJRUUJLQkVBZ0RTQUZOZ0lBSUFVaEFnc0xJQUJCN0FCcUlnUWdBa0ZpYWlJSU5nSUFJQU1nQ1NnQ0FDSUNOZ0lBSUFKQmYyb2dCeWdDQUNJRmFpRURJQVZCZjBjRVFDQUVJQWdnQTBnRWZ5QUlCU0FEQ3pZQ0FBc2dBVUYvUmdSQUlBWWtCRUVBRHdzRklBVWhBZ3NnQUVHNHJnSnFJaE1nQUVFUWFpSVBLQUlBSWdjZ0FrRUJhbW90QUFCQkNIUWdCeUFDYWkwQUFFRVFkSElnQnlBQ1FRSnFhaTBBQUhKQkNDQUFRUWhxSWdvb0FnQWlBV3QySWdSQmdJQUNjU0lGTmdJQUlBUkJnSUFCY1VVRVFDQUFRYlNtQW1wQkFFR0VDQkJVR2dzZ0NTQUJRUUpxSWdGQkEzWWdBbW9pQWpZQ0FDQUtJQUZCQjNFaUFUWUNBQ0FGQkg4Z0FFRzhyZ0pxSUFSQkRIWkJBM0VpQTBFQmFpSUVOZ0lBSUFCQndLNENhaUlGS0FJQUlBTktCRUFnQlVFQU5nSUFDeUFKSUFGQkFtb2lBVUVEZGlBQ2FpSUNOZ0lBSUFvZ0FVRUhjU0lCTmdJQUlBUkJnUUpzQlVIMkFnc2hEaUFHUVlRSWFpRUVJQVloQ0VFQUlRWURRQ0FFSUFacUlBY2dBa0VCYW1vdEFBQkJDSFFnQnlBQ2FpMEFBRUVRZEhJZ0J5QUNRUUpxYWkwQUFISkJDQ0FCYTNaQkRIWkJEM0U2QUFBZ0NTQUJRUVJxSWdGQkEzWWdBbW9pQlRZQ0FDQUtJQUZCQjNFaUFUWUNBQ0FHUVFGcUlnSkJFMGNFUUNBQ0lRWWdCU0VDREFFTEMwRUFJQVFnQUVHMCtBQnFJaFJCRXhCb0lBQkIrQUJxSVJFZ0FFSHdBR29oRUNBQVFld0FhaUVTSUFCQnVQa0FhaUVWSUFoQmYyb2hGa0VBSVFVZ0NTZ0NBQ0VCSUEwb0FnQWhBZ0pBQWtBRFFDQUZJQTVJSVJjZ0JVRUFTaUVZSUFJaEJnSkFBa0FDUUFOQUlCZEZEUVVnQVNBR1FYdHFTZ1JBSUFZZ0FXc2lCRUVBU0EwSElCQWdFU2dDQUNBQmF5QVFLQUlBYWpZQ0FDQUJRWUNBQVVvRVFDQUVRUUJLQkVBZ0R5Z0NBQ0lDSUFJZ0FXb2dCQkJkR2dzZ0NVRUFOZ0lBSUEwZ0JEWUNBQ0FFSWdZaEFnc2dFaUFHUVlDQUFrWUVmMEVBSVFGQmdJQUNCU0FBS0FJQUlBOG9BZ0FnQm1wQmdJQUNJQVpyRUY0aEFTQU5LQUlBSWdJZ0FXb2hCaUFCUVFCS0JIOGdEU0FHTmdJQUlBWWlBZ1VnQWdzTElnWkJZbW9pQ3pZQ0FDQVJJQWtvQWdBaUJEWUNBQ0FFUVg5cUlCQW9BZ0FpQTJvaEJ5QURRWDlIQkVBZ0VpQUxJQWRJQkg4Z0N3VWdCd3MyQWdBTElBRkJmMFlOQndVZ0FTRUVDeUFQS0FJQUlnd2dCRUVCYW1vdEFBQkJDSFFnRENBRWFpMEFBRUVRZEhJZ0RDQUVRUUpxYWkwQUFISkJDQ0FLS0FJQUlnZHJka0grL3dOeElnc2dBRUc0K0FCcUlCVW9BZ0FpQVVFQ2RHb29BZ0JKQkg4Z0NTQUhJQUJCdlBrQWFpQUxRUkFnQVd0MklnZHFMUUFBYWlJRFFRTjJJQVJxSWdFMkFnQWdDaUFEUVFkeElnUTJBZ0FnQUVHOGdRRnFJQWRCQVhScUJRTkFBa0FnQVVFQmFpSUJRUTlQQkVCQkR5RUREQUVMSUFzZ0FFRzQrQUJxSUFGQkFuUnFLQUlBVHcwQklBRWhBd3NMSUFrZ0F5QUhhaUlIUVFOMklBUnFJZ0UyQWdBZ0NpQUhRUWR4SWdRMkFnQWdBRUc4a1FGcUlBc2dBQ0FEUVFKMGFrRzArQUJxS0FJQWEwRVFJQU5yZGlBQVFmajRBR29nQTBFQ2RHb29BZ0JxSWdNZ0ZDZ0NBRThFZjBFQUJTQURDMEVCZEdvTElnTXVBUUFpQTBILy93TnhRUkJJRFFFZ0EwRVFSdzBESUF3Z0FXb3RBQUFoR1NBTUlBRkJBV3BxTFFBQUlRc2dEQ0FCUVFKcWFpMEFBQ0VISUFrZ0JFRUNhaUlEUVFOMklBRnFJZ0UyQWdBZ0NpQURRUWR4TmdJQUlCaEZEUUFNQWdzQUN5QUlJQVZxSUFCQnRLWUNhaUFGYWkwQUFDQURRZi8vQTNGcVFROXhPZ0FBSUFWQkFXb2hCUXdDQ3lBV0lBVnFMQUFBSVFNZ0MwSC9BWEZCQ0hRZ0dVRVFkSElnQjBIL0FYRnlRUWdnQkd0MlFRNTJRUU54UVFOcUlRUURRQ0FFUVg5cUlRWWdDQ0FGYWlBRE9nQUFJQVJCQVVvZ0JVRUJhaUlGSUE1SWNVVU5BaUFHSVFRTUFBc0FDeUFNSUFGQkFXcHFMUUFBUVFoMElBd2dBV290QUFCQkVIUnlJQXdnQVVFQ2Ftb3RBQUJ5UVFnZ0JHdDJRZi8vQTNFZ0EwRVJSaUlEQkg5QkRRVkJDUXQySUFNRWYwRURCVUVMQzJvaEJpQUpJQVFnQXdSL1FRTUZRUWNMYWlJRFFRTjJJQUZxSWdRMkFnQWdDaUFEUVFkeE5nSUFJQWdnQldwQkFFRUFRUUFnQm1zaUF5QUZJQTVySWdGTEJIOGdBd1VnQVF0ckVGUWFJQVloQVFOQUlBRkJmMm9oQmlBQlFRRktJQVZCQVdvaUJTQU9TSEVFUUNBR0lRRU1BUVVnQkNFQkRBSUxBQXNBQ3dBTElBWWdBVWdFUUNBSUpBUkJBUThMSUJNb0FnQUVRQ0FBUWJ5dUFtb2lBU2dDQUVFQVNnUkFRUUFoQWdOQVFRQWdDQ0FDUVlFQ2JHb2dBRUdFcndGcUlBSkI3QjFzYWtHQkFoQm9JQUpCQVdvaUFpQUJLQUlBU0EwQUN3c0ZRUUFnQ0NBQVFZUUJha0dxQWhCb1FRQWdDRUdxQW1vZ0FFSHdIbXBCTUJCb1FRQWdDRUhhQW1vZ0FFSEkyZ0JxUVJ3UWFBc2dBRUcwcGdKcUlBaEJoQWdRVXhvZ0NDUUVRUUVQQzBFQUlRQWdDQ1FFUVFBTDl3d0NFMzhDZmlNRUlRVWpCRUdnb0FGcUpBUWdCVUdZd0FCcUlRUWdBRUdzOHdCcUtBSUFJUWtnQUVId3JRSnFJUWdnQUVHd3B3RnFJUVlnQUVITTh3QnFJaFVvQWdBaUUwRURSd1JBSUFZaENBc0NRQ0FUUVFGeVFRTkdCRUFnQVVFQVJ5SUxJQWhCaWNFQWFpd0FBRUVBUnlJUGNRUkFJQUJCbUx3RGFpZ0NBRUVEUndSQUlBZ3RBQmxCRTB3RVFFRUJJUXRCQVNFUERBUUxJQWhCNU1BQWFpZ0NBRUYvUmdSQVFRRWhDMEVCSVE4TUJBc0xJQWhCdThFQWFpRUdJQUZCa0FGcUlBaEI0TUFBYWlBSVFickJBR29zQUFBRWZ5QUdCVUVBQ3hDcUFrVUVRQ0FFUVFBMkFrUWdCRUVGTmdKSUlBUWdBRUVZYWpZQ0FDQUVRVUJyUVFJMkFnQWdCQ0FJUVNCcU5nSUVDMEVCSVE5QkFTRUxDd1VnQVVFQVJ5RUxDd3NnQUNBQUtBSUFLQUlVUVFkeFFZWUJhaEVBQUNFWElBc0VRQ0FBRU5FQklSZ2dBVUdBQVdvaUJpQUdLUU1BSUJoOE53TUFDeUFGUVFocUlSWWdCU0lNUVppUUFXb2hCaUFNUVppQUFXb2hFQ0FBRUxJQkdpQU1RUmhxSWdVZ0FFRVlhaUlSRUdvYUlBVkJnQkFnQUVHaXZBTnFMQUFBUlJEQ0FRSkFJQUFnQlNBSlFaMkZBMm9zQUFBRWYwRUVCVUVBQ3lJT0lBQW9BZ0FvQWdoQkgzRkJ5Z0JxRVFFQVJRUkFJQUZCaUFGcUlSUWdDVUd3eXdScUlRb2dDVUcweXdScUlRMGdDVUdzeXdScUlSSUNRQUpBSUFzRVFDQVVRZ0EzQXdBZ0JDQVJFR29hSUFSQmdCQkJBUkRDQVNBQUlBUWdEaUFBS0FJQUtBSUlRUjl4UWNvQWFoRUJBQTBCQTBBQ1FBSkFJQW9vQWdBRVFDQUVJQVVRYWhwQkF5QVNLQUlBSUFWQkFDQUtLQUlBUVE5eFFlb0FhaEVEQUVGL1JnUkFRUUVoQnd3Q0N5QUVJQVVRY3cwQ0lBVWdCa0dBRUJCcEdpQVFJQVlRMEFFYVFRQWdFaWdDQUNBR1FRQWdDaWdDQUVFUGNVSHFBR29SQXdCQmYwWUVRRUVCSVFjRklCQWdCaENMQVFSQUlBWWdCVUdBRUJCN0dnd0VCVUVBSVFjTEN3VkJBQ0VIQ3dzZ0RTZ0NBRVVFUUNBSEJFQU1CZ1VNQWdzQUN5QUZJQVJCZ0JBUWFSb2dCRUVBSUEwb0FnQkJIM0ZCS21vUkJBQkZEUVFnQkNBRlFZQVFFSHNhSUFjTkJBc2dDaWdDQUVVRVFDQU5LQUlBUlEwRUN5QUFJQVVnRGlBQUtBSUFLQUlJUVI5eFFjb0FhaEVCQUEwRklCUkNBRGNEQUF3QUN3QUZJQVFnRVJCcUdpQUVRWUFRUVFFUXdnRWdBQ0FFSUE0Z0FDZ0NBQ2dDQ0VFZmNVSEtBR29SQVFBTkFRTkFBa0FDUUNBS0tBSUFCRUFnQkNBRkVHb2FRUU1nRWlnQ0FDQUZRUUFnQ2lnQ0FFRVBjVUhxQUdvUkF3QkJmMFlFUUVFQklRY01BZ3NnQkNBRkVITU5BaUFGSUFaQmdCQVFhUm9nRUNBR0VOQUJHa0VBSUJJb0FnQWdCa0VBSUFvb0FnQkJEM0ZCNmdCcUVRTUFRWDlHQkVCQkFTRUhCU0FRSUFZUWl3RUVRQ0FHSUFWQmdCQVFleG9NQkFWQkFDRUhDd3NGUVFBaEJ3c0xJQTBvQWdCRkJFQWdCd1JBREFZRkRBSUxBQXNnQlNBRVFZQVFFR2thSUFSQkFDQU5LQUlBUVI5eFFTcHFFUVFBUlEwRUlBUWdCVUdBRUJCN0dpQUhEUVFMSUFvb0FnQkZCRUFnRFNnQ0FFVU5CQXNnQUNBRklBNGdBQ2dDQUNnQ0NFRWZjVUhLQUdvUkFRQkZEUUFNQlFzQUN3QUxJQVVnQkJCcUdnd0NDeUFKUWFqTEJHcEJEellDQUNBRVFRQTJBa1FnQkVIRUFEWUNTQ0FFUVVCclFRRTJBZ0FnQkNBRk5nSUFJQUFnRVNBT0lBQW9BZ0FvQWdoQkgzRkJ5Z0JxRVFFQUdpQUFJQmRCQUNBQUtBSUFLQUlRUVFOeFFiZ0NhaEVDQUNBTUpBUkJBQThMQ3dKQUFrQWdBMEhGQUdzT0ZBQUJBUUVCQVFFQkFRRUJBUUVCQVFBQkFRRUFBUXNnRENBUk5nSUFDeUFBUVFFUTJRSWdCU0FHUVlBUUVHa2FBa0FDUUNBSlFiRExCR29pQXlnQ0FDSUhSUTBBUVFNZ0NVR3N5d1JxSWdRb0FnQWdCVUVCSUFkQkQzRkI2Z0JxRVFNQVFYOUhCRUJCQUNBRUtBSUFJQVpCQVNBREtBSUFRUTl4UWVvQWFoRURBRUYvUncwQkN3d0JDeUFKUWJUTEJHb29BZ0FpQXdSQUlBWkJBU0FEUVI5eFFTcHFFUVFBUlEwQkN5QVBCSDhnQUNBVEVPOEJCU0FBRUh3TEdpQVZLQUlBUVFKR0JFQWdBQkR1QVNBQUlBQkJrTHdEYWlrREFDQUFRZmpuQVdvcEF3QjlRUUFnQUNnQ0FDZ0NFRUVEY1VHNEFtb1JBZ0FMSUFJRVFDQVdJQUJCMEtjQmFqWUNBQ0FKUWN5RUEyb3NBQUFhQ3lBTFJRUkFJQXdrQkVFQkR3c2dFMEVGUmdSQVFRQWhBQVVnQ0VHSndRQnFMQUFBSVFBZ0FTQUlRY2pBQUdvcEF3QTNBeUFMSUFFZ0FEb0FVU0FCUWdBM0EzQWdBVUdRQVdvZ0NFSGd3QUJxS0FJQUlBbEJvSXNFYWlnQ0FCQ3NBaUFNSkFSQkFROExJQXdrQkVFQUN6a0FJQUZCZ0lBUVR3UkFEd3NnQUNnQ0VDQUJhaUlBSUFKR0JFQVBDeUFBSUFKQmdJQVFJQUZySWdBZ0Ewc0VmeUFEQlNBQUN4QmRHZ3NEQUFFTE13QWdBRUlBTndJQUlBQkNBRGNDQ0NBQUlBRTJBaEFnQUVFQU5nSUVJQUJCQURZQ0dDQUFRUUEyQWhRZ0FFRUFOZ0ljQy84REFRSi9Jd1FoQ1NNRVFZQUZhaVFFSUFKRklBTXNBSUFFUlhJRVFDQUpKQVJCQUE4TElBQkJxQ1ZxSUFJMkFnQWdBeUFKUVlBQkVMTUVJQWtnQ1VHQUJHb2lDa0dBQVJCcEdnSkFBa0FDUUFKQUFrQUNRQ0FDUVFGckRnVUFBUUlEQkFVTElBQkJ4akZxSWdWQkFEb0FBQ0FBUWNVeGFpSUdRUUE2QUFBZ0FFSEVNV29pQjBFQU9nQUFJQW9zQUFBaUFBUkFRUUFoQVVFQUlRSkJBQ0VEUVFBaEJBTkFJQUpCL3dGeElBQkIvd0Z4SWdocUlRSWdBQ0FEY3lFRElBUkIvd0Z4SUFocUlnQkJCM1pCQVhFZ0FFRUJkSEloQkNBS0lBRkJBV29pQVdvc0FBQWlBQTBBQ3lBSElBSTZBQUFnQmlBRE9nQUFJQVVnQkRvQUFBc01CQXNnQUVHMEoyb1F2QUlnQUVISU1XcEJmeUFLSUFvUWJoQ1pBU0lCT3dFQUlBQkJ5akZxSUFGQkVIWTdBUUFnQUVIT01Xb2lCa0VBT3dFQUlBQkJ6REZxSWdkQkFEc0JBQ0FLTEFBQUlnRUVRRUVBSVFKQkFDRURRUUFoQkFOQUlBQkJ0Q2RxSUFGQi93RnhJZ0ZCQW5ScUlRVWdCeUFEUWYvL0EzRWdBWE1nQlNnQ0FITWlBenNCQUNBR0lBUkIvLzhEY1NBQmFpQUZLQUlBUVJCMmFpSUVPd0VBSUFvZ0FrRUJhaUlDYWl3QUFDSUJEUUFMQ3d3REN5QUFJQW9ReFFJTUFnc2dBQ0FCSUFNZ0NTQUVFTUlDREFFTElBQWdBU0FESUFrZ0JDQUZJQVlnQnlBSUVNQUNDeUFLUVlBQkVGc2dDVUdBQkJCYklBa2tCRUVCQy9VR0FRZC9JQUFoQkNBQ1FYOXFJUUJCQVNFQ0lBRWhCZ0pBQWtBRFFBSkFBa0FnQmtFQVJ5SUpCRUFEUUFKQUlBUXNBQUFpQlVVTkJpQUVRUUZxSVFNZ0JVSC9BWEVoQVFKL0lBVkJmMG9FZnlBREJTQUJRZUFCY1VIQUFVWUVRQ0FETEFBQUlnTkJ3QUZ4UVlBQlJ3UkFRUUFoQWd3S0N5QURRVDl4SUFGQkJuUkJ3QTl4Y2lFQklBUkJBbW9NQWdzZ0FVSHdBWEZCNEFGR0JFQWdBeXdBQUNJRlFjQUJjVUdBQVVjRVFFRUFJUUlNQ2dzZ0JDd0FBaUlEUWNBQmNVR0FBVWNFUUVFQUlRSU1DZ3NnQlVFR2RFSEFIM0VnQVVFTWRFR0E0QU54Y2lBRFFUOXhjaUVCSUFSQkEyb01BZ3NnQVVINEFYRkI4QUZIQkVCQkFDRUNEQWtMSUFNc0FBQWlCMEhBQVhGQmdBRkhCRUJCQUNFQ0RBa0xJQVFzQUFJaUJVSEFBWEZCZ0FGSEJFQkJBQ0VDREFrTElBUXNBQU1pQTBIQUFYRkJnQUZIQkVCQkFDRUNEQWtMSUFkQkRIUkJnT0FQY1NBQlFSSjBRWUNBOEFCeGNpQUZRUVowUWNBZmNYSWdBMEUvY1hJaEFTQUVRUVJxQ3dzaEJDQUFRUUZJRFFZZ0FVSC8vd05ORFFBZ0FFRUNTQTBHSUFCQmZtb2hBQ0FCUWYvL3d3Qk5EUU5CQUNFQ0RBRUxDeUFBUVg5cUlRQU1BZ1VEUUNBRUxBQUFJZ1ZGRFFZZ0JFRUJhaUVESUFWQi93RnhJUUVnQlVGL1NnUkFJQU1oQkF3RUN3Si9JQUZCNEFGeFFjQUJSZ1IvSUFNc0FBQWlBMEhBQVhGQmdBRkhCRUJCQUNFQ0RBa0xRUUloQ0NBRFFUOXhJUVVnQVVFR2RFSEFEM0VGSUFGQjhBRnhRZUFCUmdSQUlBTXNBQUFpQlVIQUFYRkJnQUZIQkVCQkFDRUNEQW9MSUFRc0FBSWlBMEhBQVhGQmdBRkhCRUJCQUNFQ0RBb0xRUU1oQ0NBRlFRWjBRY0FmY1NBQlFReDBRWURnQTNGeUlRVWdBMEUvY1F3Q0N5QUJRZmdCY1VId0FVY0VRRUVBSVFJTUNRc2dBeXdBQUNJSFFjQUJjVUdBQVVjRVFFRUFJUUlNQ1FzZ0JDd0FBaUlGUWNBQmNVR0FBVWNFUUVFQUlRSU1DUXNnQkN3QUF5SURRY0FCY1VHQUFVY0VRRUVBSVFJTUNRdEJCQ0VJSUFkQkRIUkJnT0FQY1NBQlFSSjBRWUNBOEFCeGNpQUZRUVowUWNBZmNYSWhCU0FEUVQ5eEN3c2hBU0FFSUFocUlRUWdCU0FCY2lJQlFmLy9BMDBOQXlBQlFmLy93d0JMQkVCQkFDRUNEQUVMQ3dzTElBbEZCRUJCQUNFR0RBSUxJQVlnQVRZQ0FDQUdRUVJxSVFZTUFRc2dDUVJBSUFZZ0FUWUNBQ0FHUVFScUlRWU1BUVZCQUNFR0RBRUxBQXNBQ3lBR1FRQTJBZ0FnQWc4TElBSUxPUUFnQkFSQUlBUkJBRG9BQUFzZ0FVVUVRRUVCRHdzZ0FTQUNJQWNFZjBFU0JVRVJDeUlBRUpjQ0JFQkJBUThMSUFFZ0FpQUFFSmNDQ3dZQVFSSVFBQXNJQUVFTEVBQkNBQXNJQUVFQkVBQkJBQXRhQVFOL0lBQW9BZ1FpQjBFSWRTRUdJQWRCQVhFRVFDQURLQUlBSUFacUtBSUFJUVlMSUFBb0FnQWlBQ2dDQUNnQ0ZDRUlJQUFnQVNBQ0lBTWdCbW9nQjBFQ2NRUi9JQVFGUVFJTElBVWdDRUVIY1VHb0Ftb1JDd0FMdGdFQUlBRkJBVG9BTlFKQUlBRW9BZ1FnQTBZRVFDQUJRUUU2QURRZ0FVRVFhaUlBS0FJQUlnTkZCRUFnQUNBQ05nSUFJQUVnQkRZQ0dDQUJRUUUyQWlRZ0FTZ0NNRUVCUmlBRVFRRkdjVVVOQWlBQlFRRTZBRFlNQWdzZ0F5QUNSd1JBSUFGQkpHb2lBQ0FBS0FJQVFRRnFOZ0lBSUFGQkFUb0FOZ3dDQ3lBQlFSaHFJZ0lvQWdBaUFFRUNSZ1JBSUFJZ0JEWUNBQVVnQUNFRUN5QUJLQUl3UVFGR0lBUkJBVVp4QkVBZ0FVRUJPZ0EyQ3dzTEMyMEJBWDhDUUNBQlFSQnFJZ0FvQWdBaUJBUkFJQVFnQWtjRVFDQUJRU1JxSWdBZ0FDZ0NBRUVCYWpZQ0FDQUJRUUkyQWhnZ0FVRUJPZ0EyREFJTElBRkJHR29pQUNnQ0FFRUNSZ1JBSUFBZ0F6WUNBQXNGSUFBZ0FqWUNBQ0FCSUFNMkFoZ2dBVUVCTmdJa0N3c0xzUVFCQkg4Q1FDQUFCRUFnQUJCWklRUUNRQUpBQTBBQ1FDQUVRUUJNQkVBZ0FDRUREQUVMSUFBZ0JFRi9haUlEUVFKMGFpZ0NBRUV2UmcwQ0lBTWhCQXdCQ3dzTUFRc2dBQ0FFUVFKMGFpRURDeUFEUVM0UXJRRWlBd1JBQWtBQ1FDQURRUVJxSWdRb0FnQU5BQ0FBRUZrZ0FVRjlhazhOQUF3QkN5QUVRWmdORU93QkJFQWdCRUhzREJEc0FRMEVDd3NnQkVHb0RSQnFHZ1VnQUVHRURTQUJFSGdhSUFBUVdTRURBa0FDUUFOQUFrQWdBMEVBVEFSQUlBQWhBUXdCQ3lBQUlBTkJmMm9pQVVFQ2RHb29BZ0JCTDBZTkFpQUJJUU1NQVFzTERBRUxJQUFnQTBFQ2RHb2hBUXNnQVVFdUVLMEJJUU1MQlVFQVFZUU5JQUVRZUJvTEN5QUNSUVJBSUFBUW9RTWhBZ05BQWtBZ0FpQUNLQUlBUVFGcUlnRTJBZ0FnQVVFNlJ3UkFRU0VoQlF3QkN5QUNRVEEyQWdBZ0FrRjhhaUlHSUFCSkRRQWdCaWdDQUVGUWFrRUtTUVJBSUFZaEFnd0NDd3NMSUFWQklVWUVRQThMSUFBZ0FCQlpRUUowYWlJQUlBWkhCRUFEUUNBQUlBQW9BZ0EyQWdRZ0FFRjhhaUVCSUFBZ0FrY0VRQ0FCSVFBTUFRc0xDeUFDUVRFMkFnQVBDeUFEUVFocUlnRW9BZ0JCVUdwQkNra0VRQ0FEUVF4cUlnQW9BZ0JCVUdwQkNra0VRQ0FBSUFBb0FnQkJBV29pQVRZQ0FDQUJRVHBIQkVBUEN3TkFJQUJCZkdvaUFTZ0NBQ0lDUVM1SEJFQWdBRUV3TmdJQUlBRWdBa0VCYWlJQ05nSUFJQUpCT2tZRVFDQUJJUUFNQWdWQklTRUZDd3NMSUFWQklVWUVRQThMSUFCQndRQTJBZ0FQQ3dzZ0FVRzREUkJxR2d0YUFBSkFBa0FnQVVVTkFDQUJLQUlBUlEwQUlBSWdBVWNFUUNBQ0lBRWdBeEN1QVJvTERBRUxJQUFFUUNBQUlBSWdBeEI3R2dVZ0FrRUFOZ0lBQ3dzZ0EwVUVRQ0FDRHdzZ0FpQURRWDlxUVFKMGFrRUFOZ0lBSUFJTHpRRUJCWDhnQUNnQ1ZDRUVBa0FDUUNBQUtBSWNJZ01nQVVZTkFDQUFJQU1nQUNnQ0ZDQURheERFQVVGL1J3MEFRWDhoQUF3QkN3SkFJQUpCQUVjZ0JFRUVhaUlGS0FJQVFRQkhjUVJBSUFJaEFDQUVLQUlBSVFZRFFDQUdJQUVnQUJETUFTSURRWDlNQkVBZ0F5RUFEQU1MSUFFZ0Eyb2hBU0FGSUFVb0FnQkJmMm9pQnpZQ0FDQUVJQVFvQWdCQkJHb2lCallDQUNBQUlBTnJJZ0JCQUVjZ0IwRUFSM0VOQUNBRElRQUxCVUVBSVFBTEN5QUVLQUlBUVFBMkFnQWdBRUVBVGdSQUlBSWhBQXNMSUFBTE93RUJmd0pBSUFJRVFBTkFJQUFvQWdCQklIRU5BaUFCUVFScUlRTWdBU2dDQUNBQUVLd0JHaUFDUVg5cUlnSUVRQ0FESVFFTUFRc0xDd3NMRGdBZ0FDQUJJQUlRc1FNYUlBQUxIZ0VCZnlBQUlBQWdBUkMwQTBFQ2RHb2lBaWdDQUFSL0lBSUZRUUFMQ3pjQkFYOGdBQkJaSWdKRkJFQVBDeUFDUVFGcUlBRkpJQUFnQWtGL2FrRUNkR29vQWdCQkwwZHhSUVJBRHdzZ0FFSDhEQkNHQWhvTFVRRUNmd0ovSUFJRWZ3TkFJQUVvQWdBaUEwVWdBQ2dDQUNJRVJTQUVJQU5IY25KRkJFQWdBRUVFYWlFQUlBRkJCR29oQVVFQUlBSkJmMm9pQWtVTkF4b01BUXNMSUFRZ0Eyc0ZRUUFMQ3lJQUN4WUFJQUJGQkVCQkFBOExJQUJCMkE0UXh3RkJBRWNMU2dFQmZ5TUVJUU1qQkVFUWFpUUVJQU1nQURZQ0FDQURJQUUyQWdRZ0F5QUNOZ0lJUWNZQklBTVFKQ0lBUVlCZ1N3UkFRWWk4QTBFQUlBQnJOZ0lBUVg4aEFBc2dBeVFFSUFBTHlnSUJBMzhqQkNFRUl3UkJFR29rQkFKL0lBRUVmd0pBSUFJRVFDQUFSUVJBSUFRaEFBc2dBU3dBQUNJRFFYOUtCRUFnQUNBRFFmOEJjVFlDQUNBRFFRQkhEQVFMSUFFc0FBQWhBMEdzSXlnQ0FDZ0NBRVVFUUNBQUlBTkIvNzhEY1RZQ0FFRUJEQVFMSUFOQi93RnhRYjUrYWlJRFFUSk5CRUFnQTBFQ2RFR2tIbW9vQWdBaEF5QUNRUVJKQkVBZ0EwR0FnSUNBZUNBQ1FRWnNRWHBxZG5FTkF3c2dBUzBBQVNJQ1FRTjJJZ1ZCY0dvZ0JTQURRUnAxYW5KQkIwMEVRQ0FDUVlCL2FpQURRUVowY2lJQ1FRQk9CRUFnQUNBQ05nSUFRUUlNQmdzZ0FTMEFBa0dBZjJvaUEwRS9UUVJBSUFNZ0FrRUdkSElpQWtFQVRnUkFJQUFnQWpZQ0FFRUREQWNMSUFFdEFBTkJnSDlxSWdGQlAwMEVRQ0FBSUFFZ0FrRUdkSEkyQWdCQkJBd0hDd3NMQ3dzTFFZaThBMEhVQURZQ0FFRi9CVUVBQ3dzaEFDQUVKQVFnQUF1eEZBSVVmd0YrSXdRaEN5TUVRVUJySkFRZ0MwRVVhaUVUSUF0QkVHb2lEU0FCTmdJQUlBQkJBRWNoRWlBTFFSaHFJZ0ZCS0dvaUVDRVZJQUZCSjJvaEZpQUxRUWhxSWhSQkJHb2hHRUVBSVFFQ1FBSkFBMEFDUUNBTVFYOUtCRUFnQlVILy8vLy9CeUFNYTBvRWYwR0l2QU5CeXdBMkFnQkJmd1VnQlNBTWFnc2hEQXNnRFNnQ0FDSUpMQUFBSWdaRkRRSWdDU0VGQWtBQ1FBTkFBa0FDUUFKQUFrQWdCa0VZZEVFWWRRNG1BUUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0FDQ3lBRklRWU1CQXNNQVFzZ0RTQUZRUUZxSWdVMkFnQWdCU3dBQUNFR0RBRUxDd3dCQ3dOQUlBWXNBQUZCSlVjTkFTQUZRUUZxSVFVZ0RTQUdRUUpxSWdZMkFnQWdCaXdBQUVFbFJnMEFDd3NnQlNBSmF5RUZJQklFUUNBQUlBa2dCUkJqQ3lBRkRRRWdEU0FOS0FJQUlnVWdEU2dDQUN3QUFVRlFha0VLVHdSL1FYOGhDa0VCQlNBRkxBQUNRU1JHQkg4Z0JTd0FBVUZRYWlFS1FRRWhBVUVEQlVGL0lRcEJBUXNMYWlJRk5nSUFJQVVzQUFBaUNFRmdhaUlHUVI5TFFRRWdCblJCaWRFRWNVVnlCRUJCQUNFR0JVRUFJUWNnQ0NFR0EwQkJBU0FHUVJoMFFSaDFRV0JxZENBSGNpRUdJQTBnQlVFQmFpSUZOZ0lBSUFVc0FBQWlDRUZnYWlJSFFSOUxRUUVnQjNSQmlkRUVjVVZ5UlFSQUlBWWhCeUFJSVFZTUFRc0xDd0pBSUFoQi93RnhRU3BHQkg4Q2Z3SkFJQVVzQUFGQlVHcEJDazhOQUNBTktBSUFJZ1VzQUFKQkpFY05BQ0FFSUFWQkFXb2lBU3dBQUVGUWFrRUNkR3BCQ2pZQ0FDQURJQUVzQUFCQlVHcEJBM1JxS1FNQXB5RUJRUUVoQnlBRlFRTnFEQUVMSUFFRVFFRi9JUXdNQkFzZ0VnUkFJQUlvQWdCQkEycEJmSEVpQlNnQ0FDRUJJQUlnQlVFRWFqWUNBQVZCQUNFQkMwRUFJUWNnRFNnQ0FFRUJhZ3NoQlNBTklBVTJBZ0FnQmtHQXdBQnlJUWhCQUNBQmF5RVBJQUZCQUVnaURrVUVRQ0FHSVFnTElBNUZCRUFnQVNFUEN5QUhJUUVnQlFVZ0RSQ1BBaUlQUVFCSUJFQkJmeUVNREFNTElBWWhDQ0FOS0FJQUN5SUdMQUFBUVM1R0JFQWdCaXdBQVVFcVJ3UkFJQTBnQmtFQmFqWUNBQ0FORUk4Q0lRVWdEU2dDQUNFR0RBSUxJQVlzQUFKQlVHcEJDa2tFUUNBTktBSUFJZ1lzQUFOQkpFWUVRQ0FFSUFaQkFtb2lCU3dBQUVGUWFrRUNkR3BCQ2pZQ0FDQURJQVVzQUFCQlVHcEJBM1JxS1FNQXB5RUZJQTBnQmtFRWFpSUdOZ0lBREFNTEN5QUJCRUJCZnlFTURBTUxJQklFUUNBQ0tBSUFRUU5xUVh4eElnWW9BZ0FoQlNBQ0lBWkJCR28yQWdBRlFRQWhCUXNnRFNBTktBSUFRUUpxSWdZMkFnQUZRWDhoQlFzTFFRQWhEZ05BSUFZc0FBQkJ2MzlxUVRsTEJFQkJmeUVNREFJTElBMGdCa0VCYWlJSE5nSUFJQTVCT213Z0Jpd0FBR3BCek9VQWFpd0FBQ0lSUWY4QmNTSUdRWDlxUVFoSkJFQWdCaUVPSUFjaEJnd0JDd3NnRVVVRVFFRi9JUXdNQVFzZ0NrRi9TaUVYQWtBQ1FDQVJRUk5HQkVBZ0Z3UkFRWDhoREF3RUJRd0NDd0FGSUJjRVFDQUVJQXBCQW5ScUlBWTJBZ0FnQ3lBRElBcEJBM1JxS1FNQU53TUFEQUlMSUJKRkJFQkJBQ0VNREFRTElBc2dCaUFDRUxFQklBMG9BZ0FoQndzTUFRc2dFa1VFUUVFQUlRVU1Bd3NMSUFkQmYyb3NBQUFpQmtGZmNTRUhJQTVCQUVjZ0JrRVBjVUVEUm5GRkJFQWdCaUVIQ3lBSVFmLy9lM0VoQ2lBSVFZREFBSEVFZnlBS0JTQUlDeUVHQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUhRY0VBYXc0NEN3d0pEQXNMQ3d3TURBd01EQXdNREF3TUNnd01EQXdDREF3TURBd01EQXdMREFZRUN3c0xEQVFNREF3SEFBTUJEQXdJREFVTURBSU1Dd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQWdEa0gvQVhGQkdIUkJHSFVPQ0FBQkFnTUVCd1VHQndzZ0N5Z0NBQ0FNTmdJQVFRQWhCUXdiQ3lBTEtBSUFJQXcyQWdCQkFDRUZEQm9MSUFzb0FnQWdES3czQXdCQkFDRUZEQmtMSUFzb0FnQWdERHNCQUVFQUlRVU1HQXNnQ3lnQ0FDQU1PZ0FBUVFBaEJRd1hDeUFMS0FJQUlBdzJBZ0JCQUNFRkRCWUxJQXNvQWdBZ0RLdzNBd0JCQUNFRkRCVUxRUUFoQlF3VUMwSDRBQ0VISUFWQkNFMEVRRUVJSVFVTElBWkJDSEloQmd3TEN3d0tDeUFWSUFzcEF3QWlHU0FRRUw0RElnaHJJZ3BCQVdvaERrRUFJUWxCM2VrQUlRY2dCa0VJY1VVZ0JTQUtTbkpGQkVBZ0RpRUZDd3dOQ3lBTEtRTUFJaGxDQUZNRVFDQUxRZ0FnR1gwaUdUY0RBRUVCSVFsQjNla0FJUWNGSUFaQmdCQnhSU0VJSUFaQkFYRUVmMEhmNlFBRlFkM3BBQXNoQnlBR1FZRVFjVUVBUnlFSklBaEZCRUJCM3VrQUlRY0xDd3dKQzBFQUlRbEIzZWtBSVFjZ0N5a0RBQ0VaREFnTElCWWdDeWtEQUR3QUFDQVdJUWhCQUNFSlFkM3BBQ0VPSUJBaEIwRUJJUVVnQ2lFR0RBd0xRWWk4QXlnQ0FCQ1NBaUVJREFjTElBc29BZ0FpQ0VVRVFFR0M3Z0FoQ0FzTUJnc2dGQ0FMS1FNQVBnSUFJQmhCQURZQ0FDQUxJQlEyQWdCQmZ5RUtJQlFoQ0F3R0N5QUxLQUlBSVFnZ0JRUkFJQVVoQ2d3R0JTQUFRU0FnRDBFQUlBWVFaa0VBSVFVTUNBc0FDeUFBSUFzckF3QWdEeUFGSUFZZ0J4QzlBeUVGREFrTElBa2hDRUVBSVFsQjNla0FJUTRnRUNFSERBWUxJQXNwQXdBaUdTQVFJQWRCSUhFUXZ3TWhDQ0FIUVFSMVFkM3BBR29oQnlBR1FRaHhSU0FaUWdCUmNpSUpCRUJCM2VrQUlRY0xJQWtFZjBFQUJVRUNDeUVKREFNTElCa2dFQkNTQVNFSURBSUxJQWhCQUNBRkVNTURJZ1pGSVJFZ0JpQUlheUVKSUFnZ0JXb2hCeUFSUlFSQUlBa2hCUXRCQUNFSlFkM3BBQ0VPSUJGRkJFQWdCaUVIQ3lBS0lRWU1Bd3NnQ0NFSlFRQWhCVUVBSVFjRFFBSkFJQWtvQWdBaURrVU5BQ0FUSUE0UXNBRWlCMEVBU0NBSElBb2dCV3RMY2cwQUlBbEJCR29oQ1NBS0lBY2dCV29pQlVzTkFRc0xJQWRCQUVnRVFFRi9JUXdNQkFzZ0FFRWdJQThnQlNBR0VHWWdCUVJBUVFBaEJ3TkFJQWdvQWdBaUNVVU5BeUFUSUFrUXNBRWlDU0FIYWlJSElBVktEUU1nQ0VFRWFpRUlJQUFnRXlBSkVHTWdCeUFGU1EwQURBTUxBQVZCQUNFRkRBSUxBQXNnQmtILy8zdHhJUW9nQlVGL1NnUkFJQW9oQmdzZ0JVRUFSeUFaUWdCU0lncHlJUTRnQlNBVklBaHJJQXBCQVhOQkFYRnFJZ3BLQkVBZ0JTRUtDeUFPQkVBZ0NpRUZDeUFPUlFSQUlCQWhDQXNnQnlFT0lCQWhCd3dCQ3lBQVFTQWdEeUFGSUFaQmdNQUFjeEJtSUE4Z0JVb0VRQ0FQSVFVTERBSUxJQUJCSUNBUElBVWdCeUFJYXlJS1NBUi9JQW9GSUFVTEloRWdDV29pQjBnRWZ5QUhCU0FQQ3lJRklBY2dCaEJtSUFBZ0RpQUpFR01nQUVFd0lBVWdCeUFHUVlDQUJITVFaaUFBUVRBZ0VTQUtRUUFRWmlBQUlBZ2dDaEJqSUFCQklDQUZJQWNnQmtHQXdBQnpFR1lNQVFzTERBRUxJQUJGQkVBZ0FRUkFRUUVoQUFOQUlBUWdBRUVDZEdvb0FnQWlBUVJBSUFNZ0FFRURkR29nQVNBQ0VMRUJJQUJCQVdvaEFTQUFRUWxJQkVBZ0FTRUFEQUlGSUFFaEFBc0xDeUFBUVFwSUJFQURRQ0FFSUFCQkFuUnFLQUlBQkVCQmZ5RU1EQVVMSUFCQkFXb2hBU0FBUVFsSUJFQWdBU0VBREFFRlFRRWhEQXNMQlVFQklRd0xCVUVBSVF3TEN3c2dDeVFFSUF3TDdRSUJDMzhqQkNFRUl3UkI0QUZxSkFRZ0JFR0lBV29oQlNBRVFkQUFhaUlEUWdBM0FnQWdBMElBTndJSUlBTkNBRGNDRUNBRFFnQTNBaGdnQTBJQU53SWdJQVJCK0FCcUlnWWdBaWdDQURZQ0FFRUFJQUVnQmlBRUlBTVF6UUZCQUVnRVFFRi9JUUVGSUFBb0Frd2FRUUFoQWlBQUtBSUFJUWNnQUN3QVNrRUJTQVJBSUFBZ0IwRmZjVFlDQUFzZ0FFRXdhaUlJS0FJQUJFQWdBQ0FCSUFZZ0JDQURFTTBCSVFFRklBQkJMR29pQ1NnQ0FDRUtJQWtnQlRZQ0FDQUFRUnhxSWd3Z0JUWUNBQ0FBUVJScUlnc2dCVFlDQUNBSVFkQUFOZ0lBSUFCQkVHb2lEU0FGUWRBQWFqWUNBQ0FBSUFFZ0JpQUVJQU1RelFFaEFTQUtCRUFnQUVFQVFRQWdBQ2dDSkVFZmNVSEtBR29SQVFBYUlBc29BZ0JGQkVCQmZ5RUJDeUFKSUFvMkFnQWdDRUVBTmdJQUlBMUJBRFlDQUNBTVFRQTJBZ0FnQzBFQU5nSUFDd3NnQUNBQUtBSUFJZ01nQjBFZ2NYSTJBZ0FnQTBFZ2NRUkFRWDhoQVFzTElBUWtCQ0FCQ3g4QkFuOGdBQ0FBRUZraUFVRUNkR3BCZkdvaEFpQUJCSDhnQWdVZ0FBc0xEQUFnQUNBQkVNSURHaUFBQys4QkFnSi9BbjRnQUNBQUtBSUFLQUlVUVFkeFFZWUJhaEVBQUNFRElBQW9BZ0FvQWhBaEFVRUFKQVVnQVNBQVFRQkJBRUVDRUZBakJTRUJRUUFrQlNBQlFRRnhSUVJBSUFBb0FnQW9BaFFoQVVFQUpBVWdBU0FBRUU2dEl3ZXRRaUNHaENFRUl3VWhBVUVBSkFVZ0FVRUJjVVVFUUNBQUtBSUFLQUlRSVFGQkFDUUZJQUVnQUNBRHB5QURRaUNJcDBFQUVGQWpCU0VCUVFBa0JTQUJRUUZ4QkVCQkFCQVlFRm9GSUFRUEN3c0xFQmNoQVNBQUtBSUFLQUlRSVFKQkFDUUZJQUlnQUNBRHB5QURRaUNJcDBFQUVGQWpCU0VBUVFBa0JTQUFRUUZ4QkVCQkFCQVlFRm9GSUFFUUhndENBQXRjQVFGL0lBQkJ4QjAyQWdBZ0FFRUFOZ0lFSUFCQkFEWUNHQ0FBUVFBNkFBZ2dBRUdZd0FCcVFRQTJBZ0FnQUVFQU9nQVZJQUJCREdvaUFVRUFOZ0lBSUFGQkFEc0JCQ0FCUVFBNkFBWWdBRUVCT2dBVElBQkJBVG9BRkFzL0FRSi9JQUJCQkdvaUFpZ0NBQ0lCUlFSQUlBQXNBQlFFUUVHczlRSWdBRUVZYWhDMEFpQUNLQUlBSVFFRlFuOFBDd3NnQVJCUnJTTUhyVUlnaG9RTDVRSUNDWDhCZmlBQVFSRnFJZ1VzQUFBRWZpQUFJQUFvQWdBb0FoUkJCM0ZCaGdGcUVRQUFCVUlBQ3lFTUlBQkJER29oQ0VId0h5Z0NBQ0VKSUFCQkJHb2hCaUFBUVFocUlRY2dBRUdZd0FCcUlRb2dBRUVVYWlFTElBQkJHR29oQXdKQUFrQUNRQU5BSUFnb0FnQkJBVVlFUUNBR0lBazJBZ0FMSUFjc0FBQUVRQ0FIUVFBNkFBQUxJQVlvQWdBZ0FTQUNFRUVpQkVGL1J3MERJQXBCQWpZQ0FDQUxMQUFBUlFSQVFYOGhCQXdFQ3lBRkxBQUFEUUVnQ0NnQ0FBMENEQUlMQUFzZ0FrVUVRRUVBRHd0QkFDRUVRUUFoQXdOQUlBQWdEQ0FEclh4QkFDQUFLQUlBS0FJUVFRTnhRYmdDYWhFQ0FDQUlLQUlBUVFGR0JFQWdCaUFKTmdJQUN5QUhMQUFBQkVBZ0IwRUFPZ0FBQ3lBR0tBSUFJQUVnQWlBRGF5SUZRWUFFU1FSL0lBVUZRWUFFQ3hCQklnVkJmMFlFZjBHQUJBVWdCUXNnQkdvaEJDQURRWUFFYWlJRElBSkpEUUFMSUFRUEMwR3M5UUlnQXhDNkJFRi9Ed3NnQkF1TUFnRURmeUFCS0FJQUlRSWdBRUlBTndJQUlBQkJBRFlDQ0NBQ1FlLy8vLzhEU3dSQUlBQVFpZ0VMSUFGQkJHb2hCQUpBSUFKQkFra0VRQ0FBSUFJNkFBc2dBZ1JBSUFBaEF3VWdBQ0FDUVFKMGFrRUFOZ0lBRHdzRklBSkJCR3BCZkhFaUFVSC8vLy8vQTAwRVFDQUFJQUZCQW5RUVh5SUROZ0lBSUFBZ0FVR0FnSUNBZUhJMkFnZ2dBQ0FDTmdJRURBSUxRUWdRRkNFQVFRQWtCVUVYSUFCQnpPNEFFQTBqQlNFQlFRQWtCU0FCUVFGeEJFQVFGeUVCSUFBUUdpQUJFQjRGSUFCQjdDVTJBZ0FnQUVINENrRU1FQnNMQ3d0QkFDUUZRUjBnQXlBRUlBSVFCeG9qQlNFQVFRQWtCU0FBUVFGeEJFQkJBQkFZSWdBUVdnVWdBeUFDUVFKMGFrRUFOZ0lBQ3dzUEFDQUJJQUFvQWdCcUlBSTJBZ0FMRFFBZ0FTQUFLQUlBYWlnQ0FBdlFCZ0VDZnlBQUtBSUFJZ0VFUUNBQkVGSWdBRUVBTmdJQUN5QUFRUVJxSWdFb0FnQWlBZ1JBSUFJUVVpQUJRUUEyQWdBTElBQkJDR29pQVNnQ0FDSUNCRUFnQWhCU0lBRkJBRFlDQUFzZ0FFRU1haUlCS0FJQUlnSUVRQ0FDRUZJZ0FVRUFOZ0lBQ3lBQVFSQnFJZ0VvQWdBaUFnUkFJQUlRVWlBQlFRQTJBZ0FMSUFCQkZHb2lBU2dDQUNJQ0JFQWdBaEJTSUFGQkFEWUNBQXNnQUVFWWFpSUJLQUlBSWdJRVFDQUNFRklnQVVFQU5nSUFDeUFBUVJ4cUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCSUdvaUFTZ0NBQ0lDQkVBZ0FoQlNJQUZCQURZQ0FBc2dBRUVrYWlJQktBSUFJZ0lFUUNBQ0VGSWdBVUVBTmdJQUN5QUFRU2hxSWdFb0FnQWlBZ1JBSUFJUVVpQUJRUUEyQWdBTElBQkJMR29pQVNnQ0FDSUNCRUFnQWhCU0lBRkJBRFlDQUFzZ0FFRXdhaUlCS0FJQUlnSUVRQ0FDRUZJZ0FVRUFOZ0lBQ3lBQVFUUnFJZ0VvQWdBaUFnUkFJQUlRVWlBQlFRQTJBZ0FMSUFCQk9Hb2lBU2dDQUNJQ0JFQWdBaEJTSUFGQkFEWUNBQXNnQUVFOGFpSUJLQUlBSWdJRVFDQUNFRklnQVVFQU5nSUFDeUFBUVVCcklnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCeEFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCeUFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCekFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCMEFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCMUFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCMkFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCM0FCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCNEFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCNUFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCNkFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCN0FCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCOEFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCOUFCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCK0FCcUlnRW9BZ0FpQWdSQUlBSVFVaUFCUVFBMkFnQUxJQUJCL0FCcUlnQW9BZ0FpQVVVRVFBOExJQUVRVWlBQVFRQTJBZ0FMNkFvQkduOGpCQ0VDSXdSQkVHb2tCQ0FDUVFocUlSSWdBaUVKSUFCQjRBQnFJZ29vQWdBZ0FFSGtBR29pRENnQ0FDSUNheUFBUWRETkEyb2lEU2dDQUNJRGNTRVRJQUJCTkdvaEJ3SkFBa0FnQUVFNGFpSUxLQUlBUlEwQUlBQkJIR29oRGlBQVFSaHFJUlFnQUVFZ2FpRVhJQUJCRkdvaER5QUFRY3pOQTJvaEdDQUFRYWlZQVdvaEZTQUFRYVNXQVdvaEVDQUFRYWlXQVdvaEVTQUFRYnFZQVdvaEdTQUFRY0NZQVdvaEZpQVRJUUVDUUFKQUFrQUNRQU5BQWtBZ0J5Z0NBQ0lHSUFWQkJIUnFJaG9zQUFCQkNFY0VRQ0FHSUFWQkJIUnFLQUlFSVFRZ0JpQUZRUVIwYWtFTmFpSUlMQUFBQkVBZ0JDQU1LQUlBYXlBRGNTQVRTdzBDSUFoQkFEb0FBQXdDQ3lBR0lBVkJCSFJxS0FJSUlRWWdBeUFFSUFKcmNTQUJTUVJBSUFRZ0FrY0VRQ0FBSUFJZ0JCQ3pBU0FFSVFJZ0NpZ0NBQ0FFYXlBTktBSUFJZ054SVFFTElBWWdBVXNOQkNBR0JFQWdEaWdDQUNFQklCUWdCallDQUNBQklBWkpCRUFnRnlnQ0FDSUNRUUJISUFZZ0FrdHhCSDhnQ1NBQ05nSUFRYXoxQWtIWUd5QUpFR0JCclBVQ0VGWWdEaWdDQUNFQklCUW9BZ0FGSUFZTElRSWdEeWdDQUNBQ0lBRkJJR29nQVVFQ2Rtb2lBVXNFZnlBQ0JTQUJJZ0lMRUZjaUFVVUVRRUdzOVFJUVZnc2dEeUFCTmdJQUlBNGdBallDQUFzZ0R5Z0NBQ0VCQWtBZ0F5QUdJQVJxY1NJRFFYOXFJQVJKQkVBZ0dDZ0NBQ0FFYXlFSUlCVXNBQUJGQkVBZ0FTQVFLQUlBSUFScUlBZ1FVeG9nQVNBSWFpQVFLQUlBSUFNUVV4b01BZ3NnQ0FSQVFRQWhBZ05BSUFFZ0Ftb2dFU0FDSUFScUVIVXNBQUE2QUFBZ0FrRUJhaUlDSUFoSERRQUxJQU5GRFFJTElBRWdDR29oQkVFQUlRSURRQ0FFSUFKcUlCRWdBaEIxTEFBQU9nQUFJQUpCQVdvaUFpQURSdzBBQ3dVZ0ZTd0FBQVJBUVFBaEFnTkFJQUVnQW1vZ0VTQUNJQVJxRUhVc0FBQTZBQUFnQWtFQmFpSUNJQVpIRFFBTEJTQUJJQkFvQWdBZ0JHb2dCaEJUR2dzTEN5QUFJQUVnQmlBYUVQZ0RJUUlnQnlnQ0FDQUZRUVIwYWtFSU9nQUFJQUlFUUNBQUtBSUFJQUlnQmhCbEN5QVpRUUU2QUFBZ0ZpQVdLUU1BSUFhdGZEY0RBQ0FLS0FJQUlBTWlBbXNnRFNnQ0FDSURjU0VCQ3dzTEN5QUZRUUZxSWdVZ0N5Z0NBQ0lFU1EwQVFRQWhBU0FFSVFNTUFnc0FDeUFNSUFJMkFnQWdCU0FMS0FJQUlnTkpCRUFnQnlnQ0FDRUJBMEFnQVNBRlFRUjBhaXdBQUVFSVJ3UkFJQUVnQlVFRWRHcEJBRG9BRFFzZ0JVRUJhaUlGSUFOSkRRQkJBU0VHREFNTEFBVkJBU0VCQ3dzZ0F3UkFJQUVoQmd3QkJTQUJSUTBEQ3d3QkMwRUFJUVZCQUNFQlFRRWhCQU5BSUFSRkJFQWdCeWdDQUNJRElBRWdCV3RCQkhScUlnUWdBeUFCUVFSMGFpSURLUUlBTndJQUlBUWdBeWtDQ0RjQ0NDQUxLQUlBSVFNTElBVWdCeWdDQUNBQlFRUjBhaXdBQUVFSVJtb2lCVVVoQkNBQlFRRnFJZ0VnQTBrTkFBc2dCRVVFUUNBQVFUeHFJZ1FvQWdBaEFTQUxJQU1nQldzaUF6WUNBQ0FCSUFOSkJFQWdBRUZBYXlnQ0FDSUZRUUJISUFNZ0JVdHhCRUFnRWlBRk5nSUFRYXoxQWtIWUd5QVNFR0JCclBVQ0VGWWdCQ2dDQUNFQklBc29BZ0FoQXdzZ0J5Z0NBQ0FESUFGQklHb2dBVUVDZG1vaUFVc0VmeUFEQlNBQklnTUxRUVIwRUZjaUFVVUVRRUdzOVFJUVZnc2dCeUFCTmdJQUlBUWdBellDQUNBR0RRSU1Bd3NMSUFaRkRRRUxJQW9vQWdBaEFnd0JDeUFBSUFJZ0NpZ0NBQkN6QVNBTUlBb29BZ0FpQWpZQ0FBc2dEU2dDQUNFRElBQkJvSllCYWlJRklBQkJ6TTBEYWlnQ0FDSUFRWUNBZ0FKSkJIOGdBQVZCZ0lDQUFnc2dBbW9nQTNFaUFUWUNBQ0FNS0FJQUlRQWdBU0FDUndSQUlBQWdBa1lFUUNBSkpBUVBDeUFESUFBZ0FtdHhJQU1nQVNBQ2EzRlBCRUFnQ1NRRUR3c0xJQVVnQURZQ0FDQUpKQVFMUVFFQ2Z5QUFRUkJxSWdRb0FnQWlBeUFBS0FJRVR3UkFRUUFQQ3lBRUlBTkJBV29nQUNnQ0FDQURRUUowYWlJQUVGbHFOZ0lBSUFFZ0FDQUNFRzhhUVFFTHZRd0JFSDhDUUNNRUlRWWpCRUd3QTJva0JDQUdRWlFEYWlFSkFrQWdBRUVFYWlJRktBSUFJZ1FnQUVIb0FHb2lDQ2dDQUNJQlFXZHFTZ1JBSUFFZ0JHc2lBa0VBU0EwQ0lBQkJCR29oQXlBRVFZQ0FBVW9FUUNBQ1FRQktCRUFnQUNnQ0VDSUJJQUVnQkdvZ0FoQmRHZ3NnQTBFQU5nSUFJQWdnQWpZQ0FBVWdBU0VDQ3lBQUtBSUFJQUFvQWhBZ0FtcEJnSUFDSUFKckVGNGhBaUFJS0FJQUlnUWdBbW9oQVNBQ1FRQktCRUFnQ0NBQk5nSUFJQUFnQVVGaWFqWUNiQXdDQ3lBQUlBUkJZbW8yQW13Z0FrRi9SZzBDQ3dzZ0JVRUFJQUJCQ0dvaUN5Z0NBR3RCQjNFUVZTQUFRY2pNQTJvaEFpQUZFRmdpQVVHQWdBSnhCRUFnQWtFQk5nSUFJQUJCd0xFQ2FpQUFJQUJCc01rRGFoQ01CQ0VBSUFZa0JDQUFEd3NnQWtFQU5nSUFJQUJCdUxFQ2FrRUFOZ0lBSUFCQnZMRUNha0VBTmdJQUlBRkJnSUFCY1VVRVFDQUFRYlRKQTJwQkFFR1VBeEJVR2dzZ0JVRUNFRlZCQUNFQ0EwQWdCUkJZUVF4MklRRWdCVUVFRUZVQ1FBSkFJQUZCL3dGeFFROUdCRUFnQlJCWVFReDJRZjhCY1NFRUlBVkJCQkJWSUFRRVFDQUVRUUpxSVFFZ0NTQUNha0VBUVFCQmZpQUVheUlFSUFKQmJHb2lBMHNFZnlBRUJTQURDMnNRVkJvRFFDQUJRWDlxSVFRZ0FrRUJhaUlEUVJSSklBRkJBVXB4QkVBZ0JDRUJJQU1oQWd3QkN3c0ZRUThoQVF3Q0N3VWdBVUgvQVhFaEFRd0JDd3dCQ3lBSklBSnFJQUU2QUFBTElBSkJBV29pQWtFVVNRMEFDMEVBSUFrZ0FFRzArQUJxSWcxQkZCQm9JQUJCQkdvaERpQUFRUkJxSVFrZ0FFSHNBR29oRENBQVFiajVBR29oRHlBR1FYOXFJUkJCQUNFQ1FRQWhCQUpBQWtBRFFBSkFBa0FDUUFKQUEwQWdCU2dDQUNJSElBZ29BZ0FpQTBGN2Frb0VRQ0FESUFkcklnRkJBRWdOQ0NBSFFZQ0FBVW9FUUNBQlFRQktCRUFnQ1NnQ0FDSURJQU1nQjJvZ0FSQmRHZ3NnRGtFQU5nSUFJQWdnQVRZQ0FBVWdBeUVCQ3lBQUtBSUFJQWtvQWdBZ0FXcEJnSUFDSUFGckVGNGhBU0FJS0FJQUlnY2dBV29oQXlBQlFRQktCRUFnQ0NBRE5nSUFJQXdnQTBGaWFqWUNBQVVnRENBSFFXSnFOZ0lBSUFGQmYwWU5DUXNMSUFrb0FnQWlBU0FGS0FJQUlnTkJBV3BxTFFBQVFRaDBJQUVnQTJvdEFBQkJFSFJ5SUFFZ0EwRUNhbW90QUFCeVFRZ2dDeWdDQUNJS2EzWkIvdjhEY1NJSElBQkJ1UGdBYWlBUEtBSUFJZ0ZCQW5ScUtBSUFTUVIvSUFVZ0NpQUFRYno1QUdvZ0IwRVFJQUZyZGlJQmFpMEFBR29pQjBFRGRpQURhallDQUNBTElBZEJCM0UyQWdBZ0FFRzhnUUZxSUFGQkFYUnFCUU5BQWtBZ0FVRUJhaUlCUVE5UEJFQkJEeUVCREFFTElBY2dBRUc0K0FCcUlBRkJBblJxS0FJQVR3MEJDd3NnQlNBQklBcHFJZ3BCQTNZZ0EybzJBZ0FnQ3lBS1FRZHhOZ0lBSUFCQnZKRUJhaUFISUFBZ0FVRUNkR3BCdFBnQWFpZ0NBR3RCRUNBQmEzWWdBRUg0K0FCcUlBRkJBblJxS0FJQWFpSUJJQTBvQWdCUEJIOUJBQVVnQVF0QkFYUnFDeUlCTGdFQUlnRkIvLzhEY1VFUVNBMEJJQUZCLy84RGNVRVNUZzBESUFVUVdDRURJQUZCRUVZRWZ5QUZRUU1RVlNBRFFRMTJRUU5xQlNBRlFRY1FWU0FEUVFsMlFRdHFDeUVCSUFSRkRRQU1BZ3NBQ3lBR0lBSnFJQUJCdE1rRGFpQUNhaTBBQUNBQlFmLy9BM0ZxUVE5eE9nQUFJQUpCQVdvaEFnd0NDeUFDUVpRRFRnMERJQkFnQW1vc0FBQWhCd05BSUFGQmYyb2hBeUFHSUFKcUlBYzZBQUFnQWtFQmFpRUVJQUpCa3dOSUlBRkJBVXB4QkVBZ0JDRUNJQU1oQVF3QkJTQUVJUUlMQ3d3QkN5QUZFRmdoQkNBQlFSSkdCSDhnQlVFREVGVWdCRUVOZGtFRGFnVWdCVUVIRUZVZ0JFRUpka0VMYWdzaEFTQUNRWlFEVGcwQ0lBWWdBbXBCQUVFQUlBSkI3SHhxSWdSQmZpQUJheUFCUVg5eklnTkJma29FZnlBREJVRitDMnNpQTBzRWZ5QUVCU0FEQzJzUVZCb0RRQ0FCUVg5cUlRTWdBa0VCYWlFRUlBSkJrd05JSUFGQkFVcHhCRUFnQXlFQklBUWhBZ3dCQlNBRUlRSUxDd3NnQWtFQVNpRUVJQUpCbEFOSURRQUxDeUFBUWN6TUEycEJBVG9BQUNBRktBSUFJQWdvQWdCS0RRRkJBQ0FHSUFCQmhBRnFRYXNDRUdoQkFDQUdRYXNDYWlBQVFmQWVha0U4RUdoQkFDQUdRZWNDYWlBQVFkdzhha0VSRUdoQkFDQUdRZmdDYWlBQVFjamFBR3BCSEJCb0lBQkJ0TWtEYWlBR1FaUURFRk1hSUFZa0JFRUJEd3RCQUNFQUlBWWtCRUVBRHdzZ0JpUUVRUUFMcEFzQkIzOGdBRUVFYWlJREVGZ2hCZ0ovSUFCQjBLNEJhaUlIS0FJQUlnRkIvK3NCU3dSL1FZRCtBeUFHUWZEL0EzRWlCRXNFZnlBRFFRZ1FWVUVJSVFGQkFBVkJDQ0VCQTBBZ0FVRUJhaUVCSUFKQkFXb2lCVUVDZEVHd0dHb29BZ0FnQkUwRVFDQUZJUUlNQVFzTElBTWdBUkJWSUFKQkFuUkJzQmhxS0FJQUN5RUNJQVFnQW10QkVDQUJhM1loQWlBQlFRSjBRY2dZYWdVZ0FVSC91d0ZMQkVCQmdCQWdCa0h3L3dOeElnUkxCSDhnQTBFR0VGVkJCaUVCUVFBRlFRWWhBUU5BSUFGQkFXb2hBU0FDUVFGcUlnVkJBblJCL0JocUtBSUFJQVJOQkVBZ0JTRUNEQUVMQ3lBRElBRVFWU0FDUVFKMFFmd1lhaWdDQUFzaEFpQUVJQUpyUVJBZ0FXdDJJUUlnQVVFQ2RFR1lHV29NQWdzZ0FVSC82d0JMQkVCQmdDQWdCa0h3L3dOeElnUkxCSDhnQTBFRkVGVkJCU0VCUVFBRlFRVWhBUU5BSUFGQkFXb2hBU0FDUVFGcUlnVkJBblJCc0JacUtBSUFJQVJOQkVBZ0JTRUNEQUVMQ3lBRElBRVFWU0FDUVFKMFFiQVdhaWdDQUFzaEFpQUVJQUpyUVJBZ0FXdDJJUUlnQVVFQ2RFSFFGbW9NQWdzZ0JrSHcvd054SVFRZ0FVSC9HMHNFZnlBRVFZREFBQ0FFU3dSL0lBTkJCUkJWUVFVaEFVRUFCVUVGSVFFRFFDQUJRUUZxSVFFZ0FrRUJhaUlGUVFKMFFZUVhhaWdDQUNBRVRRUkFJQVVoQWd3QkN3c2dBeUFCRUZVZ0FrRUNkRUdFRjJvb0FnQUxJZ0pyUVJBZ0FXdDJJUUlnQVVFQ2RFR2tGMm9GSUFSQmdJQUNJQVJMQkg4Z0EwRUVFRlZCQkNFQlFRQUZRUVFoQVFOQUlBRkJBV29oQVNBQ1FRRnFJZ1ZCQW5SQjJCZHFLQUlBSUFSTkJFQWdCU0VDREFFTEN5QURJQUVRVlNBQ1FRSjBRZGdYYWlnQ0FBc2lBbXRCRUNBQmEzWWhBaUFCUVFKMFFmd1hhZ3NMQ3lJQktBSUFJQUpxUWY4QmNTRUJJQUJCN0s0QmFpSUZLQUlBQkVBZ0JrSC9IMHNnQVVWeEJIOUJnQUlpQVFVZ0FRdEJmMm9oQWlBQkJFQWdBaUVCQlNBREVGZ2hCQ0FEUVFFUVZTQUVRWUNBQW5FRVFDQUZRUUEyQWdBZ0FFSG9yZ0ZxUVFBMkFnQVBDeUFEUVFFUVZVR0FJQ0FERUZoQjhQOERjU0lHU3dSL0lBTkJCUkJWUVFVaEFVRUFCVUVGSVFGQkFDRUNBMEFnQVVFQmFpRUJJQUpCQVdvaUJVRUNkRUd3Rm1vb0FnQWdCazBFUUNBRklRSU1BUXNMSUFNZ0FSQlZJQUpCQW5SQnNCWnFLQUlBQ3lFQ0lBWWdBbXRCRUNBQmEzWWdBVUVDZEVIUUZtb29BZ0JxUVFWMElBTVFXRUVMZG5JaEJpQURRUVVRVlNBQVFiQ1lBV29pQVNBQktRTUFJQVJCRG5aQkFYRkJBMm9pQWExOU53TUFJQUJCcEpZQmFpRURJQUJCNEFCcUlnVW9BZ0FoQWlBQVFkRE5BMm9pQkNnQ0FDRUFBMEFnQXlnQ0FDSUhJQUpxSUFjZ0FpQUdheUFBY1dvc0FBQTZBQUFnQlNBRktBSUFRUUZxSUFRb0FnQWlBSEVpQWpZQ0FDQUJRWDlxSWdFTkFBc1BDd1VnQUVIb3JnRnFJZ01vQWdBaEFpQURJQUpCQVdvMkFnQWdBa0VQU2dSQUlBQkI5SzRCYWlnQ0FFVUVRQ0FGUVFFMkFnQUxDd3NnQnlBSEtBSUFJQUZxSWdJZ0FrRUlkbXMyQWdBZ0FFSDRyZ0ZxSWdJb0FnQkJFR29oQlNBQ0lBVTJBZ0FnQlVIL0FVc0VRQ0FDUVpBQk5nSUFJQUJCL0s0QmFpSUNJQUlvQWdCQkFYWTJBZ0FMSUFCQnlwZ0JhaUFCUVFGMGFpSUZMd0VBUVFoMklRSWdBRUdrbGdGcUtBSUFJUU1nQUVIZ0FHb2lCQ2dDQUNFQklBUWdBVUVCYWpZQ0FDQURJQUZxSUFJNkFBQWdBRUd3bUFGcUlnRWdBU2tEQUVKL2ZEY0RBQ0FBUWNxb0FXb2dCUzRCQUNJRFFmLy9BM0VpQWtIL0FYRnFJZ1FzQUFBaEFTQUVJQUZCQVdvNkFBQWdBMEVCYWtFUWRFRVFkVUgrQVhGQm9RRktCRUFnQUVIS21BRnFJUU1nQUVIS3FBRnFJUVFEUUVFQUlBTWdCQkNmQVNBQVFjcW9BV29nQlM0QkFDSUdRZi8vQTNFaUFrSC9BWEZxSWdjc0FBQWhBU0FISUFGQkFXbzZBQUFnQmtFQmFrRVFkRUVRZFVIK0FYRkJvUUZLRFFBTEN5QUZJQUJCeXBnQmFpQUJRZjhCY1VFQmRHb2lBQzRCQURzQkFDQUFJQUpCQVdvN0FRQUw3d0lCQ0g5QmdDQWdBRUVFYWlJRUVGaEI4UDhEY1NJRFN3Ui9JQVJCQlJCVlFRVWhBVUVBQlVFRklRRURRQ0FCUVFGcUlRRWdBa0VCYWlJRlFRSjBRYkFXYWlnQ0FDQURUUVJBSUFVaEFnd0JDd3NnQkNBQkVGVWdBa0VDZEVHd0Ztb29BZ0FMSVFJZ0F5QUNhMEVRSUFGcmRpQUJRUUowUWRBV2FpZ0NBR29pQVVIL0FVc0VRQThMSUFCQnpLNEJhaUlFSUFCQnlxUUJhaUFCUVFGMGFpSUZMZ0VBSWdOQi8vOERjU0lDUVFoMk5nSUFJQUJCeXF3QmFpQUNRZjhCY1dvaUJpd0FBQ0VCSUFZZ0FVRUJham9BQUNBRFFRRnFRUkIwUVJCMVFmOEJjVVVFUUNBQVFjcWtBV29oQXlBQVFjcXNBV29oQmdOQVFRQWdBeUFHRUo4QklBUWdCUzRCQUNJSFFmLy9BM0VpQWtFSWRqWUNBQ0FBUWNxc0FXb2dBa0gvQVhGcUlnZ3NBQUFoQVNBSUlBRkJBV282QUFBZ0IwRUJha0VRZEVFUWRVSC9BWEZGRFFBTEN5QUZJQUJCeXFRQmFpQUJRZjhCY1VFQmRHb2lBQzRCQURzQkFDQUFJQUpCQVdvN0FRQUw2UWdDRUg4QmZpTUVJUVlqQkVFUWFpUUVJQUF2QVFBaEFpQUJRZFFNYWlJTktBSUFJZ01nQUVFSWFpSUtLQUlBUndSQUlBTXBBZ0FoRWdOQUlBTWdBMEY0YWlJREtRSUFOd0lBSUFNZ0VqY0NBQ0FESUFvb0FnQkhEUUFMQ3lBQ1FmLy9BM0VpREVGL2FpRU9JQU5CQVdvaUFpQUNMUUFBUVFScU9nQUFJQUJCQkdvaUJ5NEJBQ0VDSUFjZ0FrSC8vd054UVFScU93RUFJQUZCNEF4cUtBSUFRUUJISWc4Z0EwRUJhaUlGTFFBQUlnaHFRUUYySVFRZ0JTQUVPZ0FBSUFjZ0JFSC9BWEU3QVFBZ0F5QU1RUU4wYWlFUUlBNGhDU0FDUVFScVFSQjBRUkIxUWYvL0EzRWdDR3NoQlNBRElRSURRQ0FDUVFocUlRUWdCU0FDUVFscUlnZ3RBQUFpQzJzaEJTQUlJQXNnRDJwQkFYWWlDem9BQUNBSElBc2dCeThCQUdvN0FRQWdDQ3dBQUNJTFFmOEJjU0FDTFFBQlNnUkFJQVFzQUFBaEVTQUdJQVJCQW1vaUFpZ0JBRFlCQUNBR0lBSXVBUVE3QVFRZ0JDRUNBMEFDUUNBQ0lBSkJlR29pQ0NrQ0FEY0NBQ0FJSUFvb0FnQkdEUUFnQzBIL0FYRWdBa0Z4YWkwQUFFb0VRQ0FJSVFJTUFnc0xDeUFJSUJFNkFBQWdBa0Y1YWlBTE9nQUFJQWhCQW1vaUFpQUdLQUVBTmdFQUlBSWdCaTRCQkRzQkJBc2dDVUYvYWlJSkJFQWdCQ0VDREFFTEN5QVFRWGxxTEFBQUJFQWdBQzRCQUNFQUJVRUFJUUlnQXlBT1FRTjBhaUVEQTBBZ0FrRUJhaUVDSUFOQmVHb2hCQ0FEUVhscUxBQUFSUVJBSUFRaEF3d0JDd3NnQWlBRmFpRURJQUFnQUM4QkFDQUNheUlFUWYvL0EzRWlBanNCQUNBRVFmLy9BM0ZCQVVZRVFDQUtLQUlBSWdRc0FBQWhCU0FFTEFBQklRSWdCaUFFUVFKcUlna29BUUEyQVFBZ0JpQUpMZ0VFT3dFRUEwQWdBa0gvQVhFaUFpQUNRUUYyYTBIL0FYRWhBaUFEUVFGMUlnTkJBVW9OQUFzZ0JDQUJRY2lXQVdvZ0FTQU1RUUZxUVFGMmFrRzVsUUZxTFFBQVFRSjBhaUlCS0FJQU5nSUFJQUVnQkRZQ0FDQU5JQWMyQWdBZ0J5QUZPZ0FBSUFjZ0Fqb0FBU0FBUVFacUlnQWdCaWdCQURZQkFDQUFJQVl1QVFRN0FRUWdCaVFFRHdVZ0F5RUZJQUloQUFzTElBY2dCU0FGUVFGMmF5QUhMd0VBYWpzQkFDQU1RUUZxUVFGMklnSWdBRUgvL3dOeFFRRnFRUUYySWdOR0JFQWdDaWdDQUNFQUJTQUtLQUlBSVFBZ0FTQUNha0c1bFFGcUxBQUFJZ0pCL3dGeElRUWdBU0FEYWtHNWxRRnFMQUFBSWdsQi93RnhJUVVnQWlBSlJ3UkFJQUZCeUpZQmFpQUZRUUowYWlJSktBSUFJZ0lFUUNBSklBSW9BZ0EyQWdBZ0FpQUFJQU5CQkhRUVV4b2dBQ0VESUFJaEFBVWdBVUdVbFFGcUlBUnFMUUFBSUFGQmxKVUJhaUFGYWkwQUFDSURheUVDSUFBZ0EwRUVkR29oQXlBQ0lBRkJsSlVCYWlBQklBSnFRYm1WQVdvdEFBQWlCR290QUFCSEJFQWdBeUFCUWNpV0FXb2dCRUYvYWlJRVFRSjBhaUlGS0FJQU5nSUFJQVVnQXpZQ0FDQURJQUZCbEpVQmFpQUVhaTBBQUNJRVFRUjBhaUVESUFJZ0JHc2hBZ3NnQVNBQ2FrRzVsUUZxTFFBQUlRUUxJQU1nQVVISWxnRnFJQVJCQW5ScUlnRW9BZ0EyQWdBZ0FTQUROZ0lBQ3lBS0lBQTJBZ0FMSUEwZ0FEWUNBQ0FHSkFRTHV4SUJDWDhnQUVId0RHcEJBRUdBQWhCVUdpQUFRWkNWQVdvaUJoQ09CQ0FBUWV3TWFpSUlJQUJCNUF4cUlnVW9BZ0FpQTBGL2N5SUJRWE5LQkg4Z0FRVkJjd3MyQWdBZ0FFSEVsZ0ZxSWdjb0FnQWlBU0FBUWNDV0FXb2lBaWdDQUVZRVFDQUFRY2lXQVdvaUJDZ0NBQ0lCQkVBZ0JDQUJLQUlBTmdJQUJTQUdRUUFRb0FFaEFTQUZLQUlBSVFNTEJTQUhJQUZCY0dvaUFUWUNBQXNnQUVIUURHb2dBVFlDQUNBQVFjZ01haUlGSUFFMkFnQWdBVUVBTmdJTUlBQkI0QXhxSUFNMkFnQWdBVUdBQWpzQkFDQUJRWUVDT3dFRUlBQkJ5SllCYWlBQVFibVdBV290QUFBaUEwRUNkR29pQkNnQ0FDSUJCRUFnQkNBQktBSUFOZ0lBQlNBQ0lBSW9BZ0FpQVNBQVFaU1ZBV29nQTJvaUNTMEFBRUVFZEdvaUJEWUNBQ0FFSUFjb0FnQkxCRUFnQWlBRUlBa3RBQUJCQkhSck5nSUFJQVlnQXhDZ0FTRUJDd3NnQlNnQ0FDQUJOZ0lJSUFCQjFBeHFJQUUyQWdBZ0FFSG9ER29nQ0NnQ0FEWUNBQ0FBUWZFVWFrRUFPZ0FBSUFVb0FnQkJDR29oQTBFQUlRRURRQ0FES0FJQUlBRkJBM1JxSUFFNkFBQWdBeWdDQUNBQlFRTjBha0VCT2dBQklBTW9BZ0FnQVVFRGRHcEJBRFlDQkNBQlFRRnFJZ0ZCZ0FKSERRQkJBQ0VCQ3dOQUlBQkI5QlJxSUFGQkIzUnFRWUNBQVVIZCtRQWdBVUVDYWlJRGJtdEIvLzhEY1NJQ093RUFJQUFnQVVFSGRHcEJoQlZxSUFJN0FRQWdBQ0FCUVFkMGFrR1VGV29nQWpzQkFDQUFJQUZCQjNScVFhUVZhaUFDT3dFQUlBQWdBVUVIZEdwQnRCVnFJQUk3QVFBZ0FDQUJRUWQwYWtIRUZXb2dBanNCQUNBQUlBRkJCM1JxUWRRVmFpQUNPd0VBSUFBZ0FVRUhkR3BCNUJWcUlBSTdBUUFnQUNBQlFRZDBha0gyRkdwQmdJQUJRYjgrSUFOdWEwSC8vd054SWdJN0FRQWdBQ0FCUVFkMGFrR0dGV29nQWpzQkFDQUFJQUZCQjNScVFaWVZhaUFDT3dFQUlBQWdBVUVIZEdwQnBoVnFJQUk3QVFBZ0FDQUJRUWQwYWtHMkZXb2dBanNCQUNBQUlBRkJCM1JxUWNZVmFpQUNPd0VBSUFBZ0FVRUhkR3BCMWhWcUlBSTdBUUFnQUNBQlFRZDBha0htRldvZ0Fqc0JBQ0FBSUFGQkIzUnFRZmdVYWtHQWdBRkJ2N01CSUFOdWEwSC8vd054SWdJN0FRQWdBQ0FCUVFkMGFrR0lGV29nQWpzQkFDQUFJQUZCQjNScVFaZ1ZhaUFDT3dFQUlBQWdBVUVIZEdwQnFCVnFJQUk3QVFBZ0FDQUJRUWQwYWtHNEZXb2dBanNCQUNBQUlBRkJCM1JxUWNnVmFpQUNPd0VBSUFBZ0FVRUhkR3BCMkJWcUlBSTdBUUFnQUNBQlFRZDBha0hvRldvZ0Fqc0JBQ0FBSUFGQkIzUnFRZm9VYWtHQWdBRkI4NUVCSUFOdWEwSC8vd054SWdJN0FRQWdBQ0FCUVFkMGFrR0tGV29nQWpzQkFDQUFJQUZCQjNScVFab1ZhaUFDT3dFQUlBQWdBVUVIZEdwQnFoVnFJQUk3QVFBZ0FDQUJRUWQwYWtHNkZXb2dBanNCQUNBQUlBRkJCM1JxUWNvVmFpQUNPd0VBSUFBZ0FVRUhkR3BCMmhWcUlBSTdBUUFnQUNBQlFRZDBha0hxRldvZ0Fqc0JBQ0FBSUFGQkIzUnFRZndVYWtHQWdBRkJvY2tCSUFOdWEwSC8vd054SWdJN0FRQWdBQ0FCUVFkMGFrR01GV29nQWpzQkFDQUFJQUZCQjNScVFad1ZhaUFDT3dFQUlBQWdBVUVIZEdwQnJCVnFJQUk3QVFBZ0FDQUJRUWQwYWtHOEZXb2dBanNCQUNBQUlBRkJCM1JxUWN3VmFpQUNPd0VBSUFBZ0FVRUhkR3BCM0JWcUlBSTdBUUFnQUNBQlFRZDBha0hzRldvZ0Fqc0JBQ0FBSUFGQkIzUnFRZjRVYWtHQWdBRkJ2TFVCSUFOdWEwSC8vd054SWdJN0FRQWdBQ0FCUVFkMGFrR09GV29nQWpzQkFDQUFJQUZCQjNScVFaNFZhaUFDT3dFQUlBQWdBVUVIZEdwQnJoVnFJQUk3QVFBZ0FDQUJRUWQwYWtHK0ZXb2dBanNCQUNBQUlBRkJCM1JxUWM0VmFpQUNPd0VBSUFBZ0FVRUhkR3BCM2hWcUlBSTdBUUFnQUNBQlFRZDBha0h1RldvZ0Fqc0JBQ0FBSUFGQkIzUnFRWUFWYWtHQWdBRkJzc3dCSUFOdWEwSC8vd054SWdJN0FRQWdBQ0FCUVFkMGFrR1FGV29nQWpzQkFDQUFJQUZCQjNScVFhQVZhaUFDT3dFQUlBQWdBVUVIZEdwQnNCVnFJQUk3QVFBZ0FDQUJRUWQwYWtIQUZXb2dBanNCQUNBQUlBRkJCM1JxUWRBVmFpQUNPd0VBSUFBZ0FVRUhkR3BCNEJWcUlBSTdBUUFnQUNBQlFRZDBha0h3RldvZ0Fqc0JBQ0FBSUFGQkIzUnFRWUlWYWtHQWdBRkIwY0FCSUFOdWEwSC8vd054SWdNN0FRQWdBQ0FCUVFkMGFrR1NGV29nQXpzQkFDQUFJQUZCQjNScVFhSVZhaUFET3dFQUlBQWdBVUVIZEdwQnNoVnFJQU03QVFBZ0FDQUJRUWQwYWtIQ0ZXb2dBenNCQUNBQUlBRkJCM1JxUWRJVmFpQURPd0VBSUFBZ0FVRUhkR3BCNGhWcUlBTTdBUUFnQUNBQlFRZDBha0h5RldvZ0F6c0JBQ0FCUVFGcUlnRkJnQUZIRFFCQkFDRUJDd05BSUFBZ0FVRUdkR3BCQXpvQUJDQUFRUUpxSUFGQkJuUnFJQUZCS0d4QjBBQnFRZi8vQTNFaUF6c0JBQ0FBSUFGQkJuUnFRUVE2QUFVZ0FDQUJRUVowYWtFRE9nQUlJQUFnQVVFR2RHb2dBenNCQmlBQUlBRkJCblJxUVFRNkFBa2dBQ0FCUVFaMGFrRURPZ0FNSUFBZ0FVRUdkR29nQXpzQkNpQUFJQUZCQm5ScVFRUTZBQTBnQUNBQlFRWjBha0VET2dBUUlBQWdBVUVHZEdvZ0F6c0JEaUFBSUFGQkJuUnFRUVE2QUJFZ0FDQUJRUVowYWtFRE9nQVVJQUFnQVVFR2RHb2dBenNCRWlBQUlBRkJCblJxUVFRNkFCVWdBQ0FCUVFaMGFrRURPZ0FZSUFBZ0FVRUdkR29nQXpzQkZpQUFJQUZCQm5ScVFRUTZBQmtnQUNBQlFRWjBha0VET2dBY0lBQWdBVUVHZEdvZ0F6c0JHaUFBSUFGQkJuUnFRUVE2QUIwZ0FDQUJRUVowYWtFRE9nQWdJQUFnQVVFR2RHb2dBenNCSGlBQUlBRkJCblJxUVFRNkFDRWdBQ0FCUVFaMGFrRURPZ0FrSUFBZ0FVRUdkR29nQXpzQklpQUFJQUZCQm5ScVFRUTZBQ1VnQUNBQlFRWjBha0VET2dBb0lBQWdBVUVHZEdvZ0F6c0JKaUFBSUFGQkJuUnFRUVE2QUNrZ0FDQUJRUVowYWtFRE9nQXNJQUFnQVVFR2RHb2dBenNCS2lBQUlBRkJCblJxUVFRNkFDMGdBQ0FCUVFaMGFrRURPZ0F3SUFBZ0FVRUdkR29nQXpzQkxpQUFJQUZCQm5ScVFRUTZBREVnQUNBQlFRWjBha0VET2dBMElBQWdBVUVHZEdvZ0F6c0JNaUFBSUFGQkJuUnFRUVE2QURVZ0FDQUJRUVowYWtFRE9nQTRJQUFnQVVFR2RHb2dBenNCTmlBQUlBRkJCblJxUVFRNkFEa2dBQ0FCUVFaMGFrRURPZ0E4SUFBZ0FVRUdkR29nQXpzQk9pQUFJQUZCQm5ScVFRUTZBRDBnQUNBQlFRWjBha0ZBYTBFRE9nQUFJQUFnQVVFR2RHb2dBenNCUGlBQUlBRkJCblJxUVFRNkFFRWdBVUVCYWlJQlFSbEhEUUFMQytFRUFRUi9JQUJCK0FGcUlRTWdBRUdBQW1vaUJTZ0NBQ0lDUWNBQVN3UkFJQU1vQWdBaUFpZ0NBQ0VFSUFJZ0JFRkFhellDQUNBQ1FRUnFJZ0lnQWlnQ0FDQUVRYjkvUzJvMkFnQWdBQ0FBUWZBQmFpSUNLQUlBRUcwZ0JTQUZLQUlBUVVCcUlnUTJBZ0FnQWlnQ0FDSUNJQUpCUUdzZ0JCQlRHaUFGS0FJQUlRSUxJQU1vQWdBaUF5Z0NBQ0FDYWlFRUlBTWdCRFlDQUNBRFFRUnFJZ01nQXlnQ0FDQUVJQUpKYWpZQ0FDQUFLQUw4QVNFQ0lBQXNBSVFDQkVBZ0FrRi9OZ0lFQ3lBQ1FYODJBZ0FnQUVId0FXb2lBaWdDQUNBRktBSUFJZ1ZxUVFCQmdBRWdCV3NRVkJvZ0FDQUNLQUlBRUcwZ0FTQUFRZlFCYWlJQUtBSUFLQUlBSWdJNkFBQWdBU0FDUVFoMk9nQUJJQUVnQWtFUWRqb0FBaUFCSUFKQkdIWTZBQU1nQVNBQUtBSUFLQUlFSWdJNkFBUWdBU0FDUVFoMk9nQUZJQUVnQWtFUWRqb0FCaUFCSUFKQkdIWTZBQWNnQVNBQUtBSUFLQUlJSWdJNkFBZ2dBU0FDUVFoMk9nQUpJQUVnQWtFUWRqb0FDaUFCSUFKQkdIWTZBQXNnQVNBQUtBSUFLQUlNSWdJNkFBd2dBU0FDUVFoMk9nQU5JQUVnQWtFUWRqb0FEaUFCSUFKQkdIWTZBQThnQVNBQUtBSUFLQUlRSWdJNkFCQWdBU0FDUVFoMk9nQVJJQUVnQWtFUWRqb0FFaUFCSUFKQkdIWTZBQk1nQVNBQUtBSUFLQUlVSWdJNkFCUWdBU0FDUVFoMk9nQVZJQUVnQWtFUWRqb0FGaUFCSUFKQkdIWTZBQmNnQVNBQUtBSUFLQUlZSWdJNkFCZ2dBU0FDUVFoMk9nQVpJQUVnQWtFUWRqb0FHaUFCSUFKQkdIWTZBQnNnQVNBQUtBSUFLQUljSWdBNkFCd2dBU0FBUVFoMk9nQWRJQUVnQUVFUWRqb0FIaUFCSUFCQkdIWTZBQjhMeUFvQkpYOGpCQ0VFSXdSQm9BSnFKQVFnQkVFZ2FpRURJQUJGQkVBZ0JFRWdFRnNnQTBHQUFoQmJJQVFrQkE4TElBTWdBRUVvYWlJQ0tBSUFJZ0V0QUFGQkVIUWdBUzBBQUVFWWRISWdBUzBBQWtFSWRISWdBUzBBQTNJMkFnQWdBeUFCTFFBRlFSQjBJQUV0QUFSQkdIUnlJQUV0QUFaQkNIUnlJQUV0QUFkeU5nSUVJQU1nQVMwQUNVRVFkQ0FCTFFBSVFSaDBjaUFCTFFBS1FRaDBjaUFCTFFBTGNqWUNDQ0FESUFFdEFBMUJFSFFnQVMwQURFRVlkSElnQVMwQURrRUlkSElnQVMwQUQzSTJBZ3dnQXlBQkxRQVJRUkIwSUFFdEFCQkJHSFJ5SUFFdEFCSkJDSFJ5SUFFdEFCTnlOZ0lRSUFNZ0FpZ0NBQ0lCTFFBVlFSQjBJQUV0QUJSQkdIUnlJQUV0QUJaQkNIUnlJQUV0QUJkeU5nSVVJQU1nQVMwQUdVRVFkQ0FCTFFBWVFSaDBjaUFCTFFBYVFRaDBjaUFCTFFBYmNqWUNHQ0FESUFFdEFCMUJFSFFnQVMwQUhFRVlkSElnQVMwQUhrRUlkSElnQVMwQUgzSTJBaHdnQXlBQkxRQWhRUkIwSUFFdEFDQkJHSFJ5SUFFdEFDSkJDSFJ5SUFFdEFDTnlOZ0lnSUFNZ0FTMEFKVUVRZENBQkxRQWtRUmgwY2lBQkxRQW1RUWgwY2lBQkxRQW5jallDSkNBRElBSW9BZ0FpQVMwQUtVRVFkQ0FCTFFBb1FSaDBjaUFCTFFBcVFRaDBjaUFCTFFBcmNqWUNLQ0FESUFFdEFDMUJFSFFnQVMwQUxFRVlkSElnQVMwQUxrRUlkSElnQVMwQUwzSTJBaXdnQXlBQkxRQXhRUkIwSUFFdEFEQkJHSFJ5SUFFdEFESkJDSFJ5SUFFdEFETnlOZ0l3SUFNZ0FTMEFOVUVRZENBQkxRQTBRUmgwY2lBQkxRQTJRUWgwY2lBQkxRQTNjallDTkNBRElBRXRBRGxCRUhRZ0FTMEFPRUVZZEhJZ0FTMEFPa0VJZEhJZ0FTMEFPM0kyQWpnZ0F5QUNLQUlBSWdFdEFEMUJFSFFnQVMwQVBFRVlkSElnQVMwQVBrRUlkSElnQVMwQVAzSTJBanhCRUNFQklBTW9BZ0FoQWdOQUlBTWdBVUVDZEdvZ0FpQURJQUZCZVdwQkFuUnFLQUlBYWlBRElBRkJmbXBCQW5ScUtBSUFJZ0pCRTNZZ0FrRU5kSElnQWtFS2RuTWdBa0VSZGlBQ1FROTBjbk5xSUFNZ0FVRnhha0VDZEdvb0FnQWlBa0VTZGlBQ1FRNTBjaUFDUVFOMmN5QUNRUWQySUFKQkdYUnljMm8yQWdBZ0FVRUJhaUlCUWNBQVJ3MEFDeUFFSUFBb0FnQWlEVFlDQUNBRVFRUnFJaFVnQUVFRWFpSVdLQUlBSWc0MkFnQWdCRUVJYWlJWElBQkJDR29pR0NnQ0FDSVBOZ0lBSUFSQkRHb2lHU0FBUVF4cUlob29BZ0FpRURZQ0FDQUVRUkJxSWhzZ0FFRVFhaUljS0FJQUloRTJBZ0FnQkVFVWFpSWRJQUJCRkdvaUhpZ0NBQ0lTTmdJQUlBUkJHR29pSHlBQVFSaHFJaUFvQWdBaUV6WUNBQ0FFUVJ4cUlpRWdBRUVjYWlJaUtBSUFJaFEyQWdBZ0V5RUpJQkVoQVNBU0lRb2dEeUVGSUEwaEFpQU9JUVlnRkNFSElCQWhDQU5BSUFnZ0MwRUNkRUdzRDJvb0FnQWdCMm9nQVVFR2RpQUJRUnAwY2lBQlFRdDJJQUZCRlhSeWN5QUJRUmwySUFGQkIzUnljMm9nQ1NBQlFYOXpjU0FLSUFGeGMyb2dBeUFMUVFKMGFpZ0NBR29pREdvaEJ5QUNRUUoySUFKQkhuUnlJQUpCRFhZZ0FrRVRkSEp6SUFKQkZuWWdBa0VLZEhKeklBeHFJQVVnQm5NZ0FuRWdCU0FHY1hOcUlRZ2dDMEVCYWlJTFFjQUFSd1JBSUFJaERDQUdJU01nQVNFa0lBb2hKU0FISVFFZ0NDRUNJQVVoQ0NBSklRY2dEQ0VHSUNNaEJTQWtJUW9nSlNFSkRBRUxDeUFoSUFrMkFnQWdHeUFITmdJQUlCMGdBVFlDQUNBZklBbzJBZ0FnR1NBRk5nSUFJQVFnQ0RZQ0FDQVZJQUkyQWdBZ0Z5QUdOZ0lBSUFBZ0RTQUlhallDQUNBV0lBNGdBbW8yQWdBZ0dDQVBJQVpxTmdJQUlCb2dFQ0FGYWpZQ0FDQWNJQkVnQjJvMkFnQWdIaUFTSUFGcU5nSUFJQ0FnRXlBS2FqWUNBQ0FpSUJRZ0NXbzJBZ0FnQkNRRUM5TURBZ2QvQW40Z0FDZ0NBQ0lESUFNb0FnQW9BaFJCQjNGQmhnRnFFUUFBSVFnZ0FDZ0NBQ0VCSUFCQmlESnFJZ1VwQXdBZ0FFSDRNV29wQXdCOElRbEJBQ1FGUVFJZ0FTQUpweUFKUWlDSXAwRUFFRkFqQlNFQlFRQWtCUUpBSUFGQkFYRkZCRUFnQUVHQU1tb3BBd0FnQlNrREFIMGlDYWNoQVNBSlFZQ0FCQ0FBUVpBeWFpSUdLQUlBSWdKcklnU3RWQVIvSUFFRklBUWlBUXRCY0hFaEJDQUFLQUlBSWdkQisrNENhaXdBQUFSL0lBUWlBUVVnQVFzRVFDQUFRUkJxSWdRb0FnQWdBbW9oQWtFQUpBVkJCQ0FISUFJZ0FSQUhJUUVqQlNFQ1FRQWtCU0FDUVFGeERRSWdBVUVCU0FSQVFRQWhBUVVnQUNnQ0FFSDc3Z0pxTEFBQUJFQWdCQ2dDQUNBR0tBSUFhaUVDUVFBa0JVRUJJQUJCR0dvZ0FpQUJRWEJ4RUE0akJTRUFRUUFrQlNBQVFRRnhEUVFMSUFVZ0JTa0RBQ0FCckh3M0F3QWdCaUFHS0FJQUlBRnFOZ0lBQ3dWQkFDRUJDeUFES0FJQUtBSVFJUUJCQUNRRklBQWdBeUFJcHlBSVFpQ0lwMEVBRUZBakJTRUFRUUFrQlNBQVFRRnhCRUJCQUJBWUVGb0ZJQUVQQ3dzTEVCY2hBQ0FES0FJQUtBSVFJUUZCQUNRRklBRWdBeUFJcHlBSVFpQ0lwMEVBRUZBakJTRUJRUUFrQlNBQlFRRnhCRUJCQUJBWUVGb0ZJQUFRSGd0QkFBdnROQUVkZnlBREJFQWdBU0FDS1FBQU53QUFJQUVnQWlrQUNEY0FDQ0FCSUFJcEFCQTNBQkFnQVNBQ0tRQVlOd0FZSUFFZ0Fpa0FJRGNBSUNBQklBSXBBQ2czQUNnZ0FTQUNLUUF3TndBd0lBRWdBaWtBT0RjQU9BVWdBaUVCQ3lBQUtBSUFJUk1nQUVFRWFpSWRLQUlBSVFNZ0FFRUlhaUllS0FJQUlSRWdBRUVNYWlJZktBSUFJUllnQUVFUWFpSWdLQUlBSVJnZ0FTQUJLQUlBRUdjaURUWUNBQ0FCUVFScUlnSW9BZ0FRWnlFYklBSWdHellDQUNBV1FabnppZFFGYWlBRFFSNTBJQU5CQW5aeUlnNGdFWE1nRTNFZ0VYTnFJQnRxSUJOQkJYUWdFMEViZG5KQm1mT0oxQVZxSUJocUlBMXFJQllnRVhNZ0EzRWdGbk5xSWhoQkJYUWdHRUViZG5KcUlSWWdBVUVJYWlJREtBSUFFR2NoR3lBRElCczJBZ0FnRVVHWjg0blVCV29nRzJvZ0dDQU9JQk5CSG5RZ0UwRUNkbklpRFhOeElBNXphaUFXUVFWMElCWkJHM1p5YWlFYklBRkJER29pRXlnQ0FCQm5JUkVnRXlBUk5nSUFJQTVCbWZPSjFBVnFJQkZxSUJZZ0dFRWVkQ0FZUVFKMmNpSVNJQTF6Y1NBTmMyb2dHMEVGZENBYlFSdDJjbW9oR0NBQlFSQnFJaEVvQWdBUVp5RU9JQkVnRGpZQ0FDQU5RWm56aWRRRmFpQU9haUFiSUJaQkhuUWdGa0VDZG5JaUZDQVNjM0VnRW5OcUlCaEJCWFFnR0VFYmRuSnFJUTRnQVVFVWFpSVdLQUlBRUdjaERTQVdJQTAyQWdBZ0VrR1o4NG5VQldvZ0RXb2dHQ0FiUVI1MElCdEJBblp5SWhVZ0ZITnhJQlJ6YWlBT1FRVjBJQTVCRzNaeWFpRU5JQUZCR0dvaUd5Z0NBQkJuSVJJZ0d5QVNOZ0lBSUJSQm1mT0oxQVZxSUJKcUlBNGdHRUVlZENBWVFRSjJjaUlYSUJWemNTQVZjMm9nRFVFRmRDQU5RUnQyY21vaEVpQUJRUnhxSWhnb0FnQVFaeUVVSUJnZ0ZEWUNBQ0FVUVpuemlkUUZhaUFWYWlBTklBNUJIblFnRGtFQ2RuSWlHU0FYYzNFZ0YzTnFJQkpCQlhRZ0VrRWJkbkpxSVJRZ0FVRWdhaUlPS0FJQUVHY2hGU0FPSUJVMkFnQWdGVUdaODRuVUJXb2dGMm9nRWlBTlFSNTBJQTFCQW5aeUlob2dHWE54SUJsemFpQVVRUVYwSUJSQkczWnlhaUVWSUFGQkpHb2lEU2dDQUJCbklSY2dEU0FYTmdJQUlCZEJtZk9KMUFWcUlCbHFJQlFnRWtFZWRDQVNRUUoyY2lJRUlCcHpjU0FhYzJvZ0ZVRUZkQ0FWUVJ0MmNtb2hGeUFCUVNocUloSW9BZ0FRWnlFWklCSWdHVFlDQUNBWlFabnppZFFGYWlBYWFpQVZJQlJCSG5RZ0ZFRUNkbklpQlNBRWMzRWdCSE5xSUJkQkJYUWdGMEViZG5KcUlSa2dBVUVzYWlJVUtBSUFFR2NoR2lBVUlCbzJBZ0FnR2tHWjg0blVCV29nQkdvZ0Z5QVZRUjUwSUJWQkFuWnlJZ1lnQlhOeElBVnphaUFaUVFWMElCbEJHM1p5YWlFYUlBRkJNR29pRlNnQ0FCQm5JUVFnRlNBRU5nSUFJQVJCbWZPSjFBVnFJQVZxSUJrZ0YwRWVkQ0FYUVFKMmNpSUhJQVp6Y1NBR2Myb2dHa0VGZENBYVFSdDJjbW9oQkNBQlFUUnFJaGNvQWdBUVp5RUlJQmNnQ0RZQ0FDQUlRWm56aWRRRmFpQUdhaUFhSUJsQkhuUWdHVUVDZG5JaUNTQUhjM0VnQjNOcUlBUkJCWFFnQkVFYmRuSnFJUVVnQVVFNGFpSVpLQUlBRUdjaENpQVpJQW8yQWdBZ0NrR1o4NG5VQldvZ0Iyb2dCQ0FhUVI1MElCcEJBblp5SWdjZ0NYTnhJQWx6YWlBRlFRVjBJQVZCRzNaeWFpRUdJQUZCUEdvaUdpZ0NBQkJuSVFzZ0dpQUxOZ0lBSUF0Qm1mT0oxQVZxSUFscUlBVWdCRUVlZENBRVFRSjJjaUlKSUFkemNTQUhjMm9nQmtFRmRDQUdRUnQyY21vaEJDQUJJQTRvQWdBZ0NITWdBeWdDQUNJUGN5QUJLQUlBY3lJSVFRRjBJQWhCSDNaeUlndzJBZ0FnREVHWjg0blVCV29nQjJvZ0JpQUZRUjUwSUFWQkFuWnlJZ2NnQ1hOeElBbHphaUFFUVFWMElBUkJHM1p5YWlFRklBSWdEU2dDQUNBS2N5QVRLQUlBSWhCeklBSW9BZ0J6SWdoQkFYUWdDRUVmZG5JaUNqWUNBQ0FLUVpuemlkUUZhaUFKYWlBRUlBWkJIblFnQmtFQ2RuSWlDQ0FIYzNFZ0IzTnFJQVZCQlhRZ0JVRWJkbkpxSVFZZ0F5QVNLQUlBSUF0eklCRW9BZ0FpSEhNZ0QzTWlDVUVCZENBSlFSOTJjaUlKTmdJQUlBbEJtZk9KMUFWcUlBZHFJQVVnQkVFZWRDQUVRUUoyY2lJSElBaHpjU0FJYzJvZ0JrRUZkQ0FHUVJ0MmNtb2hCQ0FUSUJRb0FnQWdESE1nRmlnQ0FDSU1jeUFRY3lJTFFRRjBJQXRCSDNaeUlnczJBZ0FnQzBHWjg0blVCV29nQ0dvZ0JpQUZRUjUwSUFWQkFuWnlJZ2dnQjNOeElBZHphaUFFUVFWMElBUkJHM1p5YWlFRklCRWdGU2dDQUNBS2N5QWJLQUlBSWc5eklCeHpJZ3BCQVhRZ0NrRWZkbklpQ2pZQ0FDQUtRYUhYNS9ZR2FpQUhhaUFHUVI1MElBWkJBblp5SWdjZ0NITWdCSE5xSUFWQkJYUWdCVUViZG5KcUlRWWdGaUFYS0FJQUlBbHpJQmdvQWdBaUVITWdESE1pQ1VFQmRDQUpRUjkyY2lJSk5nSUFJQWxCb2RmbjlnWnFJQWhxSUFSQkhuUWdCRUVDZG5JaUNDQUhjeUFGYzJvZ0JrRUZkQ0FHUVJ0MmNtb2hCQ0FiSUJrb0FnQWdDM01nRGlnQ0FDSU1jeUFQY3lJTFFRRjBJQXRCSDNaeUlnczJBZ0FnQzBHaDErZjJCbW9nQjJvZ0JVRWVkQ0FGUVFKMmNpSUhJQWh6SUFaemFpQUVRUVYwSUFSQkczWnlhaUVGSUJnZ0dpZ0NBQ0FLY3lBTktBSUFJZzl6SUJCeklncEJBWFFnQ2tFZmRuSWlDallDQUNBS1FhSFg1L1lHYWlBSWFpQUdRUjUwSUFaQkFuWnlJZ2dnQjNNZ0JITnFJQVZCQlhRZ0JVRWJkbkpxSVFZZ0RpQUJLQUlBSUFseklCSW9BZ0FpRUhNZ0RITWlDVUVCZENBSlFSOTJjaUlKTmdJQUlBbEJvZGZuOWdacUlBZHFJQVJCSG5RZ0JFRUNkbklpQnlBSWN5QUZjMm9nQmtFRmRDQUdRUnQyY21vaEJDQU5JQUlvQWdBZ0MzTWdGQ2dDQUNJTWN5QVBjeUlMUVFGMElBdEJIM1p5SWdzMkFnQWdDMEdoMStmMkJtb2dDR29nQlVFZWRDQUZRUUoyY2lJSUlBZHpJQVp6YWlBRVFRVjBJQVJCRzNaeWFpRUZJQklnQXlnQ0FDQUtjeUFWS0FJQUlnOXpJQkJ6SWdwQkFYUWdDa0VmZG5JaUNqWUNBQ0FLUWFIWDUvWUdhaUFIYWlBR1FSNTBJQVpCQW5aeUlnY2dDSE1nQkhOcUlBVkJCWFFnQlVFYmRuSnFJUVlnRkNBVEtBSUFJQWx6SUJjb0FnQWlFSE1nREhNaUNVRUJkQ0FKUVI5MmNpSUpOZ0lBSUFsQm9kZm45Z1pxSUFocUlBUkJIblFnQkVFQ2RuSWlDQ0FIY3lBRmMyb2dCa0VGZENBR1FSdDJjbW9oQkNBVklCRW9BZ0FnQzNNZ0dTZ0NBQ0lNY3lBUGN5SUxRUUYwSUF0QkgzWnlJZ3MyQWdBZ0MwR2gxK2YyQm1vZ0Iyb2dCVUVlZENBRlFRSjJjaUlISUFoeklBWnphaUFFUVFWMElBUkJHM1p5YWlFRklCY2dGaWdDQUNBS2N5QWFLQUlBSWc5eklCQnpJZ3BCQVhRZ0NrRWZkbklpQ2pZQ0FDQUtRYUhYNS9ZR2FpQUlhaUFHUVI1MElBWkJBblp5SWdnZ0IzTWdCSE5xSUFWQkJYUWdCVUViZG5KcUlRWWdHU0FiS0FJQUlBbHpJQUVvQWdBaUVITWdESE1pQ1VFQmRDQUpRUjkyY2lJSk5nSUFJQWRCb2RmbjlnWnFJQWxxSUFSQkhuUWdCRUVDZG5JaUJ5QUljeUFGYzJvZ0JrRUZkQ0FHUVJ0MmNtb2hCQ0FhSUJnb0FnQWdDM01nQWlnQ0FDSU1jeUFQY3lJTFFRRjBJQXRCSDNaeUlnczJBZ0FnQ0VHaDErZjJCbW9nQzJvZ0JVRWVkQ0FGUVFKMmNpSUlJQWR6SUFaemFpQUVRUVYwSUFSQkczWnlhaUVGSUFFZ0RpZ0NBQ0FLY3lBREtBSUFJZzl6SUJCeklncEJBWFFnQ2tFZmRuSWlDallDQUNBSFFhSFg1L1lHYWlBS2FpQUdRUjUwSUFaQkFuWnlJZ2NnQ0hNZ0JITnFJQVZCQlhRZ0JVRWJkbkpxSVFZZ0FpQU5LQUlBSUFseklCTW9BZ0FpRUhNZ0RITWlDVUVCZENBSlFSOTJjaUlKTmdJQUlBaEJvZGZuOWdacUlBbHFJQVJCSG5RZ0JFRUNkbklpQ0NBSGN5QUZjMm9nQmtFRmRDQUdRUnQyY21vaEJDQURJQklvQWdBZ0MzTWdFU2dDQUNJTWN5QVBjeUlMUVFGMElBdEJIM1p5SWdzMkFnQWdCMEdoMStmMkJtb2dDMm9nQlVFZWRDQUZRUUoyY2lJSElBaHpJQVp6YWlBRVFRVjBJQVJCRzNaeWFpRUZJQk1nRkNnQ0FDQUtjeUFXS0FJQUlnOXpJQkJ6SWdwQkFYUWdDa0VmZG5JaUNqWUNBQ0FJUWFIWDUvWUdhaUFLYWlBR1FSNTBJQVpCQW5aeUlnZ2dCM01nQkhOcUlBVkJCWFFnQlVFYmRuSnFJUVlnRVNBVktBSUFJQWx6SUJzb0FnQWlFSE1nREhNaUNVRUJkQ0FKUVI5MmNpSUpOZ0lBSUFkQm9kZm45Z1pxSUFscUlBUkJIblFnQkVFQ2RuSWlCQ0FJY3lBRmMyb2dCa0VGZENBR1FSdDJjbW9oQnlBV0lCY29BZ0FnQzNNZ0dDZ0NBQ0lNY3lBUGN5SUxRUUYwSUF0QkgzWnlJZ3MyQWdBZ0NFR2gxK2YyQm1vZ0Myb2dCVUVlZENBRlFRSjJjaUlGSUFSeklBWnphaUFIUVFWMElBZEJHM1p5YWlFSUlCc2dHU2dDQUNBS2N5QU9LQUlBSWc5eklCQnpJZ3BCQVhRZ0NrRWZkbklpQ2pZQ0FDQUVRYUhYNS9ZR2FpQUthaUFHUVI1MElBWkJBblp5SWdZZ0JYTWdCM05xSUFoQkJYUWdDRUViZG5KcUlRUWdHQ0FhS0FJQUlBbHpJQTBvQWdBaUVITWdESE1pQ1VFQmRDQUpRUjkyY2lJSk5nSUFJQVZCb2RmbjlnWnFJQWxxSUFkQkhuUWdCMEVDZG5JaURDQUdjeUFJYzJvZ0JFRUZkQ0FFUVJ0MmNtb2hCU0FPSUFFb0FnQWdDM01nRWlnQ0FDSWNjeUFQY3lJSFFRRjBJQWRCSDNaeUlnczJBZ0FnQmtIYytlNzRlR29nQzJvZ0JDQUlRUjUwSUFoQkFuWnlJZ2R5SUF4eElBUWdCM0Z5YWlBRlFRVjBJQVZCRzNaeWFpRUdJQTBnQWlnQ0FDQUtjeUFVS0FJQUlnOXpJQkJ6SWdoQkFYUWdDRUVmZG5JaUNqWUNBQ0FNUWR6NTd2aDRhaUFLYWlBRklBUkJIblFnQkVFQ2RuSWlDSElnQjNFZ0JTQUljWEpxSUFaQkJYUWdCa0ViZG5KcUlRUWdFaUFES0FJQUlBbHpJQlVvQWdBaURITWdISE1pQ1VFQmRDQUpRUjkyY2lJSk5nSUFJQWRCM1BudStIaHFJQWxxSUFZZ0JVRWVkQ0FGUVFKMmNpSUhjaUFJY1NBR0lBZHhjbW9nQkVFRmRDQUVRUnQyY21vaEJTQVVJQk1vQWdBZ0MzTWdGeWdDQUNJUWN5QVBjeUlMUVFGMElBdEJIM1p5SWdzMkFnQWdDRUhjK2U3NGVHb2dCQ0FHUVI1MElBWkJBblp5SWdoeUlBZHhJQVFnQ0hGeWFpQUxhaUFGUVFWMElBVkJHM1p5YWlFR0lCVWdFU2dDQUNBS2N5QVpLQUlBSWc5eklBeHpJZ3BCQVhRZ0NrRWZkbklpQ2pZQ0FDQUhRZHo1N3ZoNGFpQUZJQVJCSG5RZ0JFRUNkbklpQjNJZ0NIRWdCU0FIY1hKcUlBcHFJQVpCQlhRZ0JrRWJkbkpxSVFRZ0Z5QVdLQUlBSUFseklCb29BZ0FpREhNZ0VITWlDVUVCZENBSlFSOTJjaUlKTmdJQUlBaEIzUG51K0hocUlBWWdCVUVlZENBRlFRSjJjaUlJY2lBSGNTQUdJQWh4Y21vZ0NXb2dCRUVGZENBRVFSdDJjbW9oQlNBWklCc29BZ0FnQzNNZ0FTZ0NBQ0lRY3lBUGN5SUxRUUYwSUF0QkgzWnlJZ3MyQWdBZ0IwSGMrZTc0ZUdvZ0JDQUdRUjUwSUFaQkFuWnlJZ2R5SUFoeElBUWdCM0Z5YWlBTGFpQUZRUVYwSUFWQkczWnlhaUVHSUJvZ0dDZ0NBQ0FLY3lBQ0tBSUFJZzl6SUF4eklncEJBWFFnQ2tFZmRuSWlDallDQUNBSVFkejU3dmg0YWlBRklBUkJIblFnQkVFQ2RuSWlDSElnQjNFZ0JTQUljWEpxSUFwcUlBWkJCWFFnQmtFYmRuSnFJUVFnQVNBT0tBSUFJQWx6SUFNb0FnQWlESE1nRUhNaUNVRUJkQ0FKUVI5MmNpSUpOZ0lBSUFkQjNQbnUrSGhxSUFZZ0JVRWVkQ0FGUVFKMmNpSUhjaUFJY1NBR0lBZHhjbW9nQ1dvZ0JFRUZkQ0FFUVJ0MmNtb2hCU0FDSUEwb0FnQWdDM01nRXlnQ0FDSVFjeUFQY3lJTFFRRjBJQXRCSDNaeUlnczJBZ0FnQ0VIYytlNzRlR29nQkNBR1FSNTBJQVpCQW5aeUlnaHlJQWR4SUFRZ0NIRnlhaUFMYWlBRlFRVjBJQVZCRzNaeWFpRUdJQU1nRWlnQ0FDQUtjeUFSS0FJQUlnOXpJQXh6SWdwQkFYUWdDa0VmZG5JaUNqWUNBQ0FIUWR6NTd2aDRhaUFGSUFSQkhuUWdCRUVDZG5JaUIzSWdDSEVnQlNBSGNYSnFJQXBxSUFaQkJYUWdCa0ViZG5KcUlRUWdFeUFVS0FJQUlBbHpJQllvQWdBaURITWdFSE1pQ1VFQmRDQUpRUjkyY2lJSk5nSUFJQWhCM1BudStIaHFJQVlnQlVFZWRDQUZRUUoyY2lJSWNpQUhjU0FHSUFoeGNtb2dDV29nQkVFRmRDQUVRUnQyY21vaEJTQVJJQlVvQWdBZ0MzTWdHeWdDQUNJUWN5QVBjeUlMUVFGMElBdEJIM1p5SWdzMkFnQWdCMEhjK2U3NGVHb2dCQ0FHUVI1MElBWkJBblp5SWdkeUlBaHhJQVFnQjNGeWFpQUxhaUFGUVFWMElBVkJHM1p5YWlFR0lCWWdGeWdDQUNBS2N5QVlLQUlBSWc5eklBeHpJZ3BCQVhRZ0NrRWZkbklpQ2pZQ0FDQUlRZHo1N3ZoNGFpQUZJQVJCSG5RZ0JFRUNkbklpQ0hJZ0IzRWdCU0FJY1hKcUlBcHFJQVpCQlhRZ0JrRWJkbkpxSVFRZ0d5QVpLQUlBSUFseklBNG9BZ0FpREhNZ0VITWlDVUVCZENBSlFSOTJjaUlKTmdJQUlBZEIzUG51K0hocUlBWWdCVUVlZENBRlFRSjJjaUlIY2lBSWNTQUdJQWR4Y21vZ0NXb2dCRUVGZENBRVFSdDJjbW9oQlNBWUlCb29BZ0FnQzNNZ0RTZ0NBQ0lRY3lBUGN5SUxRUUYwSUF0QkgzWnlJZ3MyQWdBZ0NFSGMrZTc0ZUdvZ0JDQUdRUjUwSUFaQkFuWnlJZ2h5SUFkeElBUWdDSEZ5YWlBTGFpQUZRUVYwSUFWQkczWnlhaUVHSUE0Z0FTZ0NBQ0FLY3lBU0tBSUFJZzl6SUF4eklncEJBWFFnQ2tFZmRuSWlDallDQUNBSFFkejU3dmg0YWlBRklBUkJIblFnQkVFQ2RuSWlCM0lnQ0hFZ0JTQUhjWEpxSUFwcUlBWkJCWFFnQmtFYmRuSnFJUVFnRFNBQ0tBSUFJQWx6SUJRb0FnQWlESE1nRUhNaUNVRUJkQ0FKUVI5MmNpSUpOZ0lBSUFoQjNQbnUrSGhxSUFZZ0JVRWVkQ0FGUVFKMmNpSUljaUFIY1NBR0lBaHhjbW9nQ1dvZ0JFRUZkQ0FFUVJ0MmNtb2hCU0FTSUFNb0FnQWdDM01nRlNnQ0FDSVFjeUFQY3lJTFFRRjBJQXRCSDNaeUlnczJBZ0FnQjBIYytlNzRlR29nQkNBR1FSNTBJQVpCQW5aeUlnZHlJQWh4SUFRZ0IzRnlhaUFMYWlBRlFRVjBJQVZCRzNaeWFpRUdJQlFnRXlnQ0FDQUtjeUFYS0FJQUlnOXpJQXh6SWdwQkFYUWdDa0VmZG5JaUNqWUNBQ0FJUWR6NTd2aDRhaUFGSUFSQkhuUWdCRUVDZG5JaUNISWdCM0VnQlNBSWNYSnFJQXBxSUFaQkJYUWdCa0ViZG5KcUlRUWdGU0FSS0FJQUlBbHpJQmtvQWdBaURITWdFSE1pQ1VFQmRDQUpRUjkyY2lJSk5nSUFJQWRCMW9PTDAzeHFJQVZCSG5RZ0JVRUNkbklpQnlBSWN5QUdjMm9nQ1dvZ0JFRUZkQ0FFUVJ0MmNtb2hCU0FYSUJZb0FnQWdDM01nR2lnQ0FDSVFjeUFQY3lJTFFRRjBJQXRCSDNaeUlnczJBZ0FnQ0VIV2c0dlRmR29nQmtFZWRDQUdRUUoyY2lJSUlBZHpJQVJ6YWlBTGFpQUZRUVYwSUFWQkczWnlhaUVHSUJrZ0d5Z0NBQ0FLY3lBQktBSUFJZzl6SUF4eklncEJBWFFnQ2tFZmRuSWlDallDQUNBSFFkYURpOU44YWlBRVFSNTBJQVJCQW5aeUlnY2dDSE1nQlhOcUlBcHFJQVpCQlhRZ0JrRWJkbkpxSVFRZ0dpQVlLQUlBSUFseklBSW9BZ0FpREhNZ0VITWlDVUVCZENBSlFSOTJjaUlKTmdJQUlBaEIxb09MMDN4cUlBVkJIblFnQlVFQ2RuSWlDQ0FIY3lBR2Myb2dDV29nQkVFRmRDQUVRUnQyY21vaEJTQUJJQTRvQWdBZ0MzTWdBeWdDQUNJUWN5QVBjeUlMUVFGMElBdEJIM1p5SWdzMkFnQWdCMEhXZzR2VGZHb2dCa0VlZENBR1FRSjJjaUlISUFoeklBUnphaUFMYWlBRlFRVjBJQVZCRzNaeWFpRUdJQUlnRFNnQ0FDQUtjeUFUS0FJQUlnOXpJQXh6SWdwQkFYUWdDa0VmZG5JaUNqWUNBQ0FJUWRhRGk5TjhhaUFFUVI1MElBUkJBblp5SWdnZ0IzTWdCWE5xSUFwcUlBWkJCWFFnQmtFYmRuSnFJUVFnQXlBU0tBSUFJQWx6SUJFb0FnQWlESE1nRUhNaUNVRUJkQ0FKUVI5MmNpSUpOZ0lBSUFkQjFvT0wwM3hxSUFWQkhuUWdCVUVDZG5JaUJ5QUljeUFHYzJvZ0NXb2dCRUVGZENBRVFSdDJjbW9oQlNBVElCUW9BZ0FnQzNNZ0ZpZ0NBQ0lRY3lBUGN5SUxRUUYwSUF0QkgzWnlJZ3MyQWdBZ0NFSFdnNHZUZkdvZ0JrRWVkQ0FHUVFKMmNpSUlJQWR6SUFSemFpQUxhaUFGUVFWMElBVkJHM1p5YWlFR0lCRWdGU2dDQUNBS2N5QWJLQUlBSWc5eklBeHpJZ3BCQVhRZ0NrRWZkbklpQ2pZQ0FDQUhRZGFEaTlOOGFpQUVRUjUwSUFSQkFuWnlJZ2NnQ0hNZ0JYTnFJQXBxSUFaQkJYUWdCa0ViZG5KcUlRUWdGaUFYS0FJQUlBbHpJQmdvQWdBaURITWdFSE1pQ1VFQmRDQUpRUjkyY2lJSk5nSUFJQWhCMW9PTDAzeHFJQVZCSG5RZ0JVRUNkbklpQ0NBSGN5QUdjMm9nQ1dvZ0JFRUZkQ0FFUVJ0MmNtb2hCU0FiSUJrb0FnQWdDM01nRGlnQ0FDSVFjeUFQY3lJTFFRRjBJQXRCSDNaeUlnczJBZ0FnQjBIV2c0dlRmR29nQmtFZWRDQUdRUUoyY2lJSElBaHpJQVJ6YWlBTGFpQUZRUVYwSUFWQkczWnlhaUVHSUJnZ0dpZ0NBQ0FLY3lBTktBSUFJZzl6SUF4eklncEJBWFFnQ2tFZmRuSWlDallDQUNBSVFkYURpOU44YWlBRVFSNTBJQVJCQW5aeUlnZ2dCM01nQlhOcUlBcHFJQVpCQlhRZ0JrRWJkbkpxSVFRZ0RpQUJLQUlBSUFseklCSW9BZ0FpREhNZ0VITWlEa0VCZENBT1FSOTJjaUlKTmdJQUlBZEIxb09MMDN4cUlBVkJIblFnQlVFQ2RuSWlCU0FJY3lBR2Myb2dDV29nQkVFRmRDQUVRUnQyY21vaERpQU5JQUlvQWdBZ0MzTWdGQ2dDQUNJTGN5QVBjeUlOUVFGMElBMUJIM1p5SWdjMkFnQWdDRUhXZzR2VGZHb2dCa0VlZENBR1FRSjJjaUlHSUFWeklBUnphaUFIYWlBT1FRVjBJQTVCRzNaeWFpRU5JQklnQXlnQ0FDQUtjeUFWS0FJQUlnaHpJQXh6SWdOQkFYUWdBMEVmZG5JaUVqWUNBQ0FGUWRhRGk5TjhhaUFFUVI1MElBUkJBblp5SWdRZ0JuTWdEbk5xSUJKcUlBMUJCWFFnRFVFYmRuSnFJUU1nRkNBVEtBSUFJQWx6SUJjb0FnQWlCWE1nQzNNaUUwRUJkQ0FUUVI5MmNpSVVOZ0lBSUFaQjFvT0wwM3hxSUE1QkhuUWdEa0VDZG5JaURpQUVjeUFOYzJvZ0ZHb2dBMEVGZENBRFFSdDJjbW9oRXlBVklCRW9BZ0FnQjNNZ0dTZ0NBQ0lHY3lBSWN5SVJRUUYwSUJGQkgzWnlJaFUyQWdBZ0JFSFdnNHZUZkdvZ0RVRWVkQ0FOUVFKMmNpSU5JQTV6SUFOemFpQVZhaUFUUVFWMElCTkJHM1p5YWlFUklCY2dGaWdDQUNBU2N5QWFLQUlBSWhKeklBVnpJaFpCQVhRZ0ZrRWZkbklpRnpZQ0FDQU9RZGFEaTlOOGFpQURRUjUwSUFOQkFuWnlJaFlnRFhNZ0UzTnFJQmRxSUJGQkJYUWdFVUViZG5KcUlRTWdHU0FiS0FJQUlCUnpJQUVvQWdCeklBWnpJZ0ZCQVhRZ0FVRWZkbklpQVRZQ0FDQU5RZGFEaTlOOGFpQVRRUjUwSUJOQkFuWnlJaE1nRm5NZ0VYTnFJQUZxSUFOQkJYUWdBMEViZG5KcUlRRWdHaUFZS0FJQUlCVnpJQUlvQWdCeklCSnpJZ0pCQVhRZ0FrRWZkbklpQWpZQ0FDQUFJQlpCMW9PTDAzeHFJQkZCSG5RZ0VVRUNkbklpRVNBVGN5QURjMm9nQUNnQ0FHb2dBbW9nQVVFRmRDQUJRUnQyY21vMkFnQWdIU0FkS0FJQUlBRnFOZ0lBSUI0Z0hpZ0NBQ0FEUVI1MElBTkJBblp5YWpZQ0FDQWZJQjhvQWdBZ0VXbzJBZ0FnSUNBZ0tBSUFJQk5xTmdJQUN5c0FJQUJCQURvQUNDQUJCRUJCZzRBQ0VGOGlBVUVBUVlPQUFoQlVHZ1ZCQUNFQkN5QUFJQUUyQWd3TDFRTUJBbjhqQkNFRkl3UkJJR29rQkFKQUFrQUNRQUpBQWtBQ1FDQURRWUFCYXc2QkFRQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUJBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBZ01MUVJBaEJrRUtJUU1NQXd0QkdDRUdRUXdoQXd3Q0MwRWdJUVpCRGlFRERBRUxEQUVMSUFBZ0F6WUNCRUVBSVFNRFFDQUZJQU5CQW5aQkFuUnFJQU5CQTNGcUlBSWdBMm9zQUFBNkFBQWdBMEVCYWlJRElBWkhEUUFMQ3lBRUJFQWdBQ0FFTEFBQU9nQUlJQUFnQkN3QUFUb0FDU0FBSUFRc0FBSTZBQW9nQUNBRUxBQURPZ0FMSUFBZ0JDd0FCRG9BRENBQUlBUXNBQVU2QUEwZ0FDQUVMQUFHT2dBT0lBQWdCQ3dBQnpvQUR5QUFJQVFzQUFnNkFCQWdBQ0FFTEFBSk9nQVJJQUFnQkN3QUNqb0FFaUFBSUFRc0FBczZBQk1nQUNBRUxBQU1PZ0FVSUFBZ0JDd0FEVG9BRlNBQUlBUXNBQTQ2QUJZZ0FDQUVMQUFQT2dBWEJTQUFRUWhxSWdKQ0FEY0NBQ0FDUWdBM0FnZ0xJQUFnQlJDd0JDQUJCRUFnQlNRRUR3c2dBQkN2QkNBRkpBUUxWZ0VCZnlNRUlRSWpCRUVRYWlRRVFSUWdBaEFsSVFNZ0FpUUVJQU1oQWlBQlJRUkFEd3NnQWtITEFHb2hBMEVBSVFJRFFDQUFJQUpxSWdRZ0F5QUNhaUFFTFFBQWN6b0FBQ0FDUVFGcUlnSWdBVWNOQUFzTDFnUUJCMzhnQUNFRUlBRWhBQUpBQWtBQ1FBTkFBa0FnQkNFQkEwQUNRQ0FBS0FJQUlRTWdBVUVFYWlFRUFrQUNRQUpBQWtBQ1FDQUJLQUlBSWdnT1FBQURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdFREF3TURBd01EQXdNREF3TURBd01EQXdNREF3SURDd3dJQ3d3SUN5QURSUTBFREFFTElBZ2dBMGNOQVFzZ0JDRUJJQUJCQkdvaEFBd0JDd3NnQ0VFdVJ3MEFBa0FDUUFKQUlBTU9YUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFTERBRUxEQUVMREFFTFFRQWhBQXNNQWdzZ0EwVWhBQXdCQ3dKQUFrQUNRQUpBSUFRb0FnQU9Md0FDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lCQWd0QkFTRUFEQU1MSUFGQkNHb2lBeWdDQUVFcVJnUkFJQUVvQWd4RkJFQkJBU0VBREFRTEN5QUFRUzRRZENJRlJTRUJJQU1vQWdCRkJFQWdBUVJBUVFFaEFBd0VDeUFGS0FJRVJTRUFEQU1MSUFFRVFDQUFJUVZCRXlFR0JTQUVRZGdPRU1jQkJFQkJFeUVHQlNBRlFRUnFJZ0JCTGhCMEJFQkJFeUVHQlNBQ0JIOGdBeUFBRUhNRklBTWdBQkNkQVFzaUFFVWhBQXdGQ3dzTERBRUxJQUFoQnlBRElRa0xBMEFnQmtFVFJnUkFJQVVpQnlnQ0FDRUpDeUFKUlFSQVFRQWhBQXdDQ3lBSFFRUnFJUVVnQkNBSElBSVE1d0VFUUVFQklRQUZRUk1oQmd3QkN3c0xJQUFMeXdFQ0JYOEJmaUFBUVJocUlnTW9BZ0FpQVVFRGFpSUVJQUFvQWhRaUJVa0VmaUFBS0FJQUlnSWdBVUVCYW1vdEFBQkJDSFFnQWlBQmFpMEFBSElnQWlBQlFRSnFhaTBBQUVFUWRISWdBaUFFYWkwQUFFRVlkSEloQWlBRElBRkJCR29pQVRZQ0FDQUNyUVZDQUFzaEJpQUJRUU5xSWdJZ0JVOEVRQ0FHRHdzZ0FDZ0NBQ0lBSUFGQkFXcHFMUUFBUVFoMElBQWdBV290QUFCeUlBQWdBVUVDYW1vdEFBQkJFSFJ5SUFBZ0Ftb3RBQUJCR0hSeUlRQWdBeUFCUVFScU5nSUFJQUN0UWlDR0lBYUVDK2NCQVFaL0l3UWhBeU1FUVJCcUpBUWdBa1VFUUNBREpBUVBDeUFESVFVZ0FFRUVhaUlHS0FJQUlBSnFJUU1nQmlBRE5nSUFJQU1nQUVFSWFpSUhLQUlBSWdSTEJFQWdBQ2dDRENJSVFRQkhJQU1nQ0V0eEJFQWdCU0FJTmdJQVFhejFBa0hZR3lBRkVHQkJyUFVDRUZZZ0J5Z0NBQ0VFSUFZb0FnQWhBd3NnQUNnQ0FDQURJQVJCSUdvZ0JFRUNkbW9pQkVzRWZ5QURJZ1FGSUFRTEVGY2lBMFVFUUVHczlRSVFWZ3NnQUNBRE5nSUFJQWNnQkRZQ0FBVWdBQ2dDQUNFREN5QURJQUJCRkdvaUFDZ0NBR29nQVNBQ0VGTWFJQUFnQUNnQ0FDQUNhallDQUNBRkpBUUx3Z0VCQTM4Q1FBSkFBa0FDUUFKQUlBQkJxQ1ZxS0FJQVFRRnJEZ1VBQVFJREF3UUxJQUpGQkVBUEN5QUFRY1l4YWlFRklBQkJ4VEZxSVFNZ0FFSEVNV29oQUFOQUlBTWdBeTBBQUNBRkxRQUFhaUlFT2dBQUlBQWdCQ0FBTFFBQWFpSUVPZ0FBSUFFZ0FTMEFBQ0FFYXpvQUFDQUJRUUZxSVFFZ0FrRi9haUlDRFFBTER3c2dBQ0FCSUFJUXhnSVBDeUFDUlFSQUR3c0RRQ0FBSUFFZ0Eyb1F3d0lnQTBFUWFpSURJQUpKRFFBTER3c2dBRUdzSldvZ0FTQUNJQUVRcmdRTEMrZ0RBUWgvSUFCQnRERnFJZ1lvQWdBZ0FFRzBKMm9nQVMwQUFFRUNkR29vQWdCeklRSWdCaUFDTmdJQUlBQkJ1REZxSWdjb0FnQWdBRUcwSjJvZ0FTMEFBVUVDZEdvb0FnQnpJUU1nQnlBRE5nSUFJQUJCdkRGcUlnZ29BZ0FnQUVHMEoyb2dBUzBBQWtFQ2RHb29BZ0J6SVFRZ0NDQUVOZ0lBSUFCQndERnFJZ2tvQWdBZ0FFRzBKMm9nQVMwQUEwRUNkR29vQWdCeklRVWdDU0FGTmdJQUlBWWdBaUFBUWJRbmFpQUJMUUFFUVFKMGFpZ0NBSE1pQWpZQ0FDQUhJQU1nQUVHMEoyb2dBUzBBQlVFQ2RHb29BZ0J6SWdNMkFnQWdDQ0FFSUFCQnRDZHFJQUV0QUFaQkFuUnFLQUlBY3lJRU5nSUFJQWtnQlNBQVFiUW5haUFCTFFBSFFRSjBhaWdDQUhNaUJUWUNBQ0FHSUFJZ0FFRzBKMm9nQVMwQUNFRUNkR29vQWdCeklnSTJBZ0FnQnlBRElBQkJ0Q2RxSUFFdEFBbEJBblJxS0FJQWN5SUROZ0lBSUFnZ0JDQUFRYlFuYWlBQkxRQUtRUUowYWlnQ0FITWlCRFlDQUNBSklBVWdBRUcwSjJvZ0FTMEFDMEVDZEdvb0FnQnpJZ1UyQWdBZ0JpQUNJQUJCdENkcUlBRXRBQXhCQW5ScUtBSUFjellDQUNBSElBTWdBRUcwSjJvZ0FTMEFEVUVDZEdvb0FnQnpOZ0lBSUFnZ0JDQUFRYlFuYWlBQkxRQU9RUUowYWlnQ0FITTJBZ0FnQ1NBRklBQkJ0Q2RxSUFFdEFBOUJBblJxS0FJQWN6WUNBQXQ0QVFKL0FrQWdBQ2dDQUJDVEFTSUNJQUVvQWdBUWt3RWlBMFlFUUFOQUFrQWdBQ2dDQUVVRVFFRUFJUUFNQVFzZ0FFRUVhaUlBS0FJQUVKTUJJZ0lnQVVFRWFpSUJLQUlBRUpNQklnTkdEUUVnQXlFQUlBSWhBUXdEQ3d0QkFBOEZJQU1oQUNBQ0lRRUxDeUFCSUFCSUJIOUJmd1ZCQVFzTGtRUUJCWDhnQUNnQ0FDSURSUVJBSUFGQkFEb0FBQThMSUFKQmYyb2hCQ0FBSVFJZ0F5RUFBa0FEUUNBRUlRTWdBaUVFQWtBQ2Z3SkFBa0FDUUFOQUFrQWdBMEVBVEEwSUlBTkJmMm9oQWlBRVFRUnFJUVVnQUVHQUFVa0VRQ0FDSVFRZ0JTRUNJQUVoQlNBQUlRTkJBU0VBREFFTElBQkJnQkJKQkVBZ0EwRithaUVDSUFOQkFVb05Bd3NnQUVHQWVIRkJnTEFEUmdSL0lBVW9BZ0FpQTBHQWVIRkJnTGdEUmlFR0lBQkJDblJCZ01pQVpXb2dBMm9oQXlBRVFRaHFJUVFnQmtVRVFDQUZJUVFMSUFaRkJFQWdBQ0VEQ3lBRUJTQUFJUU1nQlFzaEFBSkFBa0FnQTBHQWdBUkpCRUFnQWtGK2FpRUVJQUpCQVVvTkJnd0JCU0FEUVlDQWdBRkpCRUFnQWlFRURBSUxDd3dCQ3lBRVFYMXFJUUlnQkVFQ1NnMEZDeUFBS0FJQUlnVkZEUWdnQWlFRElBQWhCQ0FGSVFBTUFRc0xEQVFMSUFJaEJDQUZJUUlnQVNFRlFRRWhCeUFBSWdOQkJuWkJ3QUZ5SVFaQkFnd0NDeUFCSUFOQkRIWkI0QUZ5T2dBQUlBQWhBaUFCUVFGcUlRVkJBaUVISUFOQkJuWkJQM0ZCZ0FGeUlRWkJBd3dCQ3lBQklBTkJFblpCOEFGeU9nQUFJQUVnQTBFTWRrRS9jVUdBQVhJNkFBRWdBaUVFSUFBaEFpQUJRUUpxSVFWQkF5RUhJQU5CQm5aQlAzRkJnQUZ5SVFaQkJBc2hBQ0FGSUFZNkFBQWdBU0FIYWlFRklBTkJQM0ZCZ0FGeUlRTUxJQUVnQUdvaEFTQUZJQU02QUFBZ0FpZ0NBQ0lBRFFBTEN5QUJRUUE2QUFBTHVnRUJBbjlCdUE0b0FnQkJmMFlFUUVHNERrRVNFSlFDSWdFMkFnQWdBUkNVQWhvTEFuOENRQUpBQWtBZ0FFR2M2UUZxS0FJQURnSUFBUUlMSUFCQnpLY0JhaUlCS0FJQUlnQkJFSEVFUUVHNERpZ0NBRUgvQTNGQi93TnpEQU1GUWJnT0tBSUFRWDl6SVFJZ0FFRUJjUVIvUWFRQ0JVRzJBd3NnQW5FTUF3c0FDdzhMUWJnT0tBSUFRWDl6SVFJZ0FFSE1wd0ZxSVFFZ0FFR1I2UUZxTEFBQUJIOUIvNE1CQlVHMmd3SUxJQUp4Q3lFQUlBRWdBRFlDQUF2ZUFRRUVmeUFBRUh3aUFrVUVRRUVBRHdzZ0FFSE04d0JxSVFRZ0FVRUZSZ1JBQTBBQ1FDQURRUUZxSWdOQi93QnhSUVJBRUlVQkN5QUVLQUlBUVFWR0RRQWdBQ0FBUVpDOEEyb3BBd0JCQUNBQUtBSUFLQUlRUVFOeFFiZ0NhaEVDQUNBQUVId2lBZzBCUVFBaEFnc0xJQUlQQlNBQ0lRTUxBMEFDZjBFQUlBUW9BZ0FpQWtFRlJnMEFHaUFGUVFGcUlnVkIvd0J4UlFSQUVJVUJJQVFvQWdBaEFnc2dBeUFDSUFGR0RRQWFJQUFnQUVHUXZBTnFLUU1BUVFBZ0FDZ0NBQ2dDRUVFRGNVRzRBbW9SQWdBZ0FCQjhJZ01OQVVFQUN5RUNDeUFDQ3owQkFYOGdBRUdrdkFOcUxBQUFSUVJBSUFFUEMwRUFJQUZyUVE5eElBRnFJUUlnQUVHWXZBTnFLQUlBUVFOR0JIOGdBa0VRYWdVZ0FrRUlhZ3NMMWhBQ0ZYOEVmZ0pBSXdRaEJTTUVRZEFBYWlRRUlBQkJwTHdEYWlJUVFRQTZBQUFnQUVHc3ZBTnFJaEZCQURvQUFDQUFJQUJCcktZQmFpSU1RUWNnQUNnQ0FDZ0NERUVmY1VIS0FHb1JBUUJCQjBjTkFDQUFRYWk4QTJvaURVRUFOZ0lBQWtBQ1FBSkFJQXdzQUFCQjBnQkhEUUFDUUFKQUFrQUNRQ0FBUWEybUFXb3NBQUJCeFFCckRoMEFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBUUlMSUFCQnJxWUJhaXdBQUVIK0FFY05BeUFBUWErbUFXb3NBQUJCM2dCSERRTWdBRUdZdkFOcUlnSkJBVFlDQUNBQUtBSUFJZ01vQWhBaEJpQUFJQUFnQXlnQ0ZFRUhjVUdHQVdvUkFBQkNlWHhCQUNBR1FRTnhRYmdDYWhFQ0FBd0VDd3dCQ3d3QkN5QUFRYTZtQVdvc0FBQkI4Z0JIRFFBZ0FFR3ZwZ0ZxTEFBQVFTRkhEUUFnQUVHd3BnRnFMQUFBUVJwSERRQWdBRUd4cGdGcUxBQUFRUWRIRFFBQ1FBSkFBa0FDUUFKQUlBQkJzcVlCYWl3QUFBNERBQUVDQXd0QkFpRUNEQU1MUVFNaEFnd0NDMEVFSVFJTUFRc01BUXNnQUVHWXZBTnFJQUkyQWdBZ0FpRUdEQUlMUVFCQmdJQ0FBUkJYSWdSRklnNEVRRUdzOVFJUVZnc2dBQ2dDQUNnQ0ZDRUNRUUFrQlNBQ0lBQVFUcTBqQjYxQ0lJYUVJUmNqQlNFQ1FRQWtCUUpBSUFKQkFYRkZCRUFnRjZjaENTQUFLQUlBS0FJTUlRSkJBQ1FGSUFJZ0FDQUVRZkQvL3dBUUJ5RUhJd1VoQWtFQUpBVWdBa0VCY1VVRVFBSkFJQWRCQUVvRVFDQUFRWmk4QTJvaENpQUpRUnhJSVFzZ0JFRWNJQWxyYWlJSVFRRnFJUklnQ0VFQ2FpRVRJQWhCQTJvaEZBSkFJQWRCSDBvRVFFRUFJUUlDUUFKQUFrQURRQUpBQWtBZ0JDQUNhaUlETEFBQVFkSUFSZ1JBSUFjZ0Ftc2lGVUVFVHdSQUlBTXNBQUVpRmtIRkFFY0VRQ0FWUVFaTElCWkI0UUJHY1VVTkF5QURMQUFDUWZJQVJ3MERJQU1zQUFOQklVY05BeUFETEFBRVFScEhEUU1nQXl3QUJVRUhSdzBEQWtBQ1FBSkFBa0FnQXl3QUJnNERBQUVDQXd0QkFpRUREQWNMREFrTERBY0xEQU1MSUFNc0FBSkIvZ0JHQkVBZ0F5d0FBMEhlQUVZRVFDQUtRUUUyQWdBZ0N5QUNRUUJLY1VVTkN5QUlMQUFBUWRJQVJ3MEVJQklzQUFCQjB3QkhEUVFnRXl3QUFFSEdBRWNOQkNBVUxBQUFRZGdBUmcwTEN3c0xDd3NnQnlBQ1FRRnFJZ0pLRFFFTUNBc0xEQUlMUVFRaEF3d0JDMEVESVFNTEJVRUFJUUlDUUFKQUEwQUNRQUpBSUFRZ0Ftb2lBeXdBQUVIU0FFWUVRQ0FISUFKcklnaEJCRThFUUNBRExBQUJJZ3RCeFFCR0JFQWdBeXdBQWtIK0FFY05BeUFETEFBRFFkNEFSdzBEUVFFaEF3d0hDeUFJUVFaTElBdEI0UUJHY1FSQUlBTXNBQUpCOGdCR0JFQWdBeXdBQTBFaFJnUkFJQU1zQUFSQkdrY05CU0FETEFBRlFRZEhEUVVDUUFKQUFrQUNRQ0FETEFBR0RnTUFBUUlEQzBFQ0lRTU1EQXRCQXlFRERBZ0xEQWtMQ3dzTEN3c0xJQWNnQWtFQmFpSUNTZzBCREFjTEN3d0JDMEVFSVFNTEN5QUtJQU0yQWdBTElBMGdBaUFKYWlJQ05nSUFJQUFvQWdBb0FoQWhBMEVBSkFVZ0F5QUFJQUt0SWhlbklCZENJSWluUVFBUVVDTUZJUUpCQUNRRklBSkJBWEVOQkNBS0tBSUFRWDV4UVFKR0JFQWdBQ2dDQUNnQ0RDRUNRUUFrQlNBQ0lBQWdERUVIRUFjYUl3VWhBa0VBSkFVZ0FrRUJjUTBGQ3dzTElBMG9BZ0FoQWlBT1JRUkFJQVFRVWdzZ0FrVU5CU0FBUVppOEEyb2hBZ3dEQ3dzTEVCY2hBaUFPQkVBZ0FoQWVDeUFFRUZJZ0FoQWVEQUVMSUFJb0FnQWhCZ3NDZndKQUFrQUNRQ0FHUVFOckRnSUJBQUlMSUFWQkFEWUNSQ0FGUVRzMkFrZ2dCVUZBYTBFQk5nSUFJQVVnQUVFWWFqWUNBQXdEQ3lBQUlBQkJzNllCYWlJQ1FRRWdBQ2dDQUNnQ0RFRWZjVUhLQUdvUkFRQWFJQUlzQUFBTkFrRUlEQUVMUVFjTElRSWdBRUcwcGdGcUlBSTJBZ0FnQUVHczh3QnFLQUlBUWJETEJHb29BZ0JGQkVBZ0FFSFE4d0JxUVFFNkFBQUxJQUJCelBNQWFpRUNBa0FnQUJCOEJFQWdBRUhROHdCcUlRTWdBRUdRdkFOcUlRWURRQ0FDS0FJQUlnUkJBVVlOQWlBRVFRUkdJQU1zQUFCQkFFZHhEUUlnQUNBR0tRTUFRUUFnQUNnQ0FDZ0NFRUVEY1VHNEFtb1JBZ0FnQUJCOERRQUxDd3NnQUVHdHZBTnFMQUFBUlNBQmNrVU5BQ0FBSUFCQmtMd0RhaUlES1FNQVFRQWdBQ2dDQUNnQ0VFRURjVUc0QW1vUkFnQWdFU3dBQUFSQUlBVkJBRFlDUkNBRlFSazJBa2dnQlVGQWEwRUJOZ0lBSUFVZ0FFRVlhallDQUNBQlJRMEJDeUFBUVo2OEEyb2dBRUhVcGdGcUxBQUFPZ0FBQWtBQ1FDQUFRZER6QUdvc0FBQkZEUUFnRUN3QUFFVU5BQ0FBUVoyOEEyb2hEd3dCQ3lBQUlBQW9BZ0FvQWhSQkIzRkJoZ0ZxRVFBQUlSY2dBRUdJdkFOcUlnY3BBd0FoR1NBREtRTUFJUm9nQWlnQ0FDRUtJQUJCbmJ3RGFpRUJJQUJCb2J3RGFpRUdJQUJCK080Q2FpRUpBa0FDUUFKQUEwQUNRRUVBSkFWQkJpQUFFQVVoQkNNRklRaEJBQ1FGSUFoQkFYRU5BeUFFUlEwQUFrQUNRQUpBQWtBZ0FpZ0NBRUVDYXc0RUFBSURBUU1MREFVTERBSUxJQVlnQVN3QUFBUi9JQWtzQUFCRkJVRUFDMEVCY1RvQUFBc2dBQ2dDQUNnQ0VDRUVJQU1wQXdBaEdFRUFKQVVnQkNBQUlCaW5JQmhDSUlpblFRQVFVQ01GSVFSQkFDUUZJQVJCQVhGRkRRRU1Bd3NMREFJTElBWWdBU3dBQUFSL0lBQkJ1T2dCYWl3QUFFRUJjd1ZCQUFzNkFBQU1BUXNRRnlFR0lBQW9BZ0FvQWhBaEJFRUFKQVVnQkNBQUlCZW5JQmRDSUlpblFRQVFVQ01GSVFSQkFDUUZJQVJCQVhFRVFFRUFFQmdRV2dVZ0JoQWVDd3NnQnlBWk53TUFJQU1nR2pjREFDQUNJQW8yQWdBZ0FDZ0NBQ2dDRUNFQ1FRQWtCU0FDSUFBZ0Y2Y2dGMElnaUtkQkFCQlFJd1VoQWtFQUpBVWdBa0VCY1FSQVFRQVFHQkJhQlNBQklROExDeUFQTEFBQUJFQWdBRUdodkFOcUxBQUFSUVJBSUFVa0JFRUJEd3NMSUFCQjVMd0RhaUFBUVJocUVHb2FJQVVrQkVFQkR3c2dCU1FFUVFBTEJnQkJGeEFBQ3dZQVFSWVFBQXNHQUVFUkVBQUxDQUJCQnhBQVFRQUxMUUVCZnlBQVFUc1FyUUVpQWdSQUlBSkJCR29ReVFJaEFDQUJCRUFnQWtFQU5nSUFDd1ZCQUNFQUN5QUFDOVlCQVFKL0l3UWhBeU1FUVlBUWFpUUVBa0FnQUFSQUFrQUNRQUpBQWtBZ0FDZ0NBQTR3QUFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQkFnc01CQXNnQVVFQU5nSUFEQUVMSUFOQmdCQVF0Z05GQkVBZ0EwRUFPZ0FBQ3lBRElBRWdBaEI3R2lBQkVGa2lCQVJBSUFSQkFXb2dBa2tnQVNBRVFYOXFRUUowYWlnQ0FFRXZSM0VFUUNBQlFmd01FSVlDR2dzTEN5QUJJQUFnQWhCNEdpQURKQVFQQ3dzZ0FrVUVRQ0FESkFRUEN5QUJRUUEyQWdBZ0F5UUVDNzhCQVFKL0FrQWdBa0YvYWlJRUJFQkJBQ0VDQTBBQ1FBSkFBa0FnQUNBQ1FRSjBhaWdDQUNJRERsMEFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0VDQ3d3RUMwRXZJUU1MSUFFZ0FrRUNkR29nQXpZQ0FDQUNRUUZxSWdJZ0JFa05BQXNGUVFBaEFnc0xJQUVnQWtFQ2RHcEJBRFlDQUF0V0FRTi9JQUFvQWdRaUJVRUlkU0VFSUFWQkFYRUVRQ0FDS0FJQUlBUnFLQUlBSVFRTElBQW9BZ0FpQUNnQ0FDZ0NIQ0VHSUFBZ0FTQUNJQVJxSUFWQkFuRUVmeUFEQlVFQ0N5QUdRUWR4UVpnQ2FoRUtBQXNIQUNBQUlBRkdDd3NBSUFBUS9BRWdBQkJTQ3hJQUlBQkIyQ1UyQWdBZ0FFRUVhaENOQXd1REFRRUJmeU1FSVFFakJFRVFhaVFFUVFBa0JTQUFFQXNqQlNFQVFRQWtCU0FBUVFGeFJRUkFRUUFrQlVFWlFidnlBQ0FCRUExQkFDUUZDMEVBRUJnaUFCQVZHa0VBSkFWQkdVSGo4Z0FnQVVFSWFoQU5RUUFrQlVFQUVCZ2hBVUVBSkFWQkJCQUxJd1VoQUVFQUpBVWdBRUVCY1FSQVFRQVFHQ0lBRUZvRklBRVFXZ3NMT0FFQ2Z5TUVJUUFqQkVFUWFpUUVRYWk4QTBFREVFa0VRRUdqOFFBZ0FCQ0NBUVZCckx3REtBSUFFRWNoQVNBQUpBUWdBUThMUVFBTHVBRUJCWDhqQkNFRkl3UkJFR29rQkNBQVFRdHFJZ1lzQUFBaUEwRUFTQ0lFQkg4Z0FDZ0NDRUgvLy8vL0IzRkJmMm9GUVFvTElnY2dBa2tFUUNBQUlBY2dBaUFIYXlBRUJIOGdBQ2dDQkFVZ0EwSC9BWEVMSWdOQkFDQURJQUlnQVJDa0F3VWdCQVIvSUFBb0FnQUZJQUFMSWdNaEJDQUNCRUFnQkNBQklBSVFYUm9MSUFWQkFEb0FBQ0FESUFKcUlBVXNBQUE2QUFBZ0Jpd0FBRUVBU0FSQUlBQWdBallDQkFVZ0JpQUNPZ0FBQ3dzZ0JTUUVJQUFMcHdFQkFuOGpCQ0VGSXdSQmtBTnFKQVFnQlNBQU5nSUFJQVVnQVVGL2FqWUNCQ0FGUVFocUlnUkJBRUg4QUJCVUdpQUVRWDg2QUVzZ0JFRWVOZ0lrSUFSQmdBSTJBakFnQkNBRlFZZ0JhallDTENBRVFYODJBa3dnQkNBRk5nSlVJQUVFUUNBQlFRQklCRUJCaUx3RFFjc0FOZ0lBUVg4aEFBVWdCQ0FDSUFNUXJRTWhBQ0FFUVFCQkFCREVBUm9nQUNBQlR3UkFRWDhoQUFzTEJVRi9JUUFMSUFVa0JDQUFDNmtCQVFWL0l3UWhBaU1FUVJCcUpBUWdBaUFCUWY4QmNTSUdPZ0FBQWtBQ1FDQUFRUkJxSWdNb0FnQWlCQTBBSUFBUWpBSUVRRUYvSVFFRklBTW9BZ0FoQkF3QkN3d0JDeUFBUVJScUlnTW9BZ0FpQlNBRVNRUkFJQUZCL3dGeElnRWdBQ3dBUzBjRVFDQURJQVZCQVdvMkFnQWdCU0FHT2dBQURBSUxDeUFBSUFKQkFTQUFLQUlrUVI5eFFjb0FhaEVCQUVFQlJnUi9JQUl0QUFBRlFYOExJUUVMSUFJa0JDQUJDOUVCQVFOL0lBSkZCRUFQQ3lBQ1FYOXFJUVFnQUJCWklRTUNRQUpBQTBBQ1FDQURRUUJNQkVBZ0FDRUNEQUVMSUFBZ0EwRi9haUlDUVFKMGFpZ0NBRUV2UmcwQ0lBSWhBd3dCQ3dzTUFRc2dBQ0FEUVFKMGFpRUNDeUFFSUFJZ0FDSUZhMEVDZFU4RVFDQUFFRmtoQXdKQUFrQURRQUpBSUFOQkFFd0VRQ0FBSVFJTUFRc2dBQ0FEUVg5cUlnSkJBblJxS0FJQVFTOUdEUUlnQWlFRERBRUxDd3dCQ3lBQUlBTkJBblJxSVFJTElBSWdCV3RCQW5VaEJBc2dBU0FBSUFRUXJnRWFJQUVnQkVFQ2RHcEJBRFlDQUF0SUFRSi9JQUFvQWdBb0FnQkJVR3BCQ2trRVFBTkFJQUpCQ214QlVHb2dBQ2dDQUNJQktBSUFhaUVDSUFBZ0FVRUVhaUlCTmdJQUlBRW9BZ0JCVUdwQkNra05BQXNMSUFJTDNoSURGbjhCZmdGOEl3UWhDQ01FUVlBQmFpUUVJQWhCMkFCcUlSRWdDRUhJQUdvaEVpQUlRU2hxSVE0Z0NFRWdhaUVUSUFoQkdHb2hGQ0FJUVJCcUlSVWdDRUVJYWlFV0lBaEI4QUJxSVJjZ0NFSG9BR29oR0NBSVFld0FhaUlLSUFFMkFnQWdBRUVBUnlFUVFRQWhBUUpBQWtBRFFBSkFBa0FnQ1VGL1NnUkFJQVZCLy8vLy93Y2dDV3RNQkVBZ0JTQUphaUVKREFJTElBQW9BZ0JCSUhGRkJFQkJpTHdEUWNzQU5nSUFDMEYvSVFrTEN5QUtLQUlBSWdZb0FnQWlCMFVOQWlBR0lRVURRQUpBQWtBQ1FDQUhEaVlBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFTERBRUxJQW9nQlVFRWFpSUZOZ0lBSUFVb0FnQWhCd3dCQ3dzZ0JVSGdKQkN1QXlFRklBb2dDaWdDQUNJSElBVkJmbkZCQW5ScU5nSUFJQWNnQlVFQmRrRUNkR29nQm10QkFuVWhCU0FRQkVBZ0FDQUdJQVVReFFFTElBVU5BU0FLSUFvb0FnQWlCU0FLS0FJQUtBSUVRVkJxUVFwUEJIOUJmeUVQUVFFRklBVW9BZ2hCSkVZRWZ5QUZLQUlFUVZCcUlROUJBU0VCUVFNRlFYOGhEMEVCQ3d0QkFuUnFJZ1UyQWdBZ0JTZ0NBQ0lIUVdCcUlnWkJIMHRCQVNBR2RFR0owUVJ4UlhJRVFFRUFJUVlGUVFBaEN5QUhJUVlEUUVFQklBWkJZR3AwSUF0eUlRWWdCVUVFYWlJRktBSUFJZ2RCWUdvaUMwRWZTMEVCSUF0MFFZblJCSEZGY2tVRVFDQUdJUXNnQnlFR0RBRUxDeUFLSUFVMkFnQUxBa0FnQjBFcVJnUi9BbjhDUUNBRktBSUVRVkJxUVFwUERRQWdDaWdDQUNJRktBSUlRU1JIRFFBZ0JDQUZRUVJxSWdFb0FnQkJVR3BCQW5ScVFRbzJBZ0FnQXlBQktBSUFRVkJxUVFOMGFpa0RBS2NoQVVFQklRY2dCVUVNYWd3QkN5QUJCRUJCZnlFSkRBUUxJQkFFUUNBQ0tBSUFRUU5xUVh4eElnVW9BZ0FoQVNBQ0lBVkJCR28yQWdBRlFRQWhBUXRCQUNFSElBb29BZ0JCQkdvTElRVWdDaUFGTmdJQUlBWkJnTUFBY2lFTFFRQWdBV3NoRFNBQlFRQklJZ3hGQkVBZ0JpRUxDeUFNUlFSQUlBRWhEUXNnQnlFQklBVUZJQW9RZ3dJaURVRUFTQVJBUVg4aENRd0RDeUFHSVFzZ0NpZ0NBQXNpQmlnQ0FFRXVSZ1JBSUFZb0FnUkJLa2NFUUNBS0lBWkJCR28yQWdBZ0NoQ0RBaUVGSUFvb0FnQWhCZ3dDQ3lBR0tBSUlRVkJxUVFwSkJFQWdDaWdDQUNJR0tBSU1RU1JHQkVBZ0JDQUdRUWhxSWdVb0FnQkJVR3BCQW5ScVFRbzJBZ0FnQXlBRktBSUFRVkJxUVFOMGFpa0RBS2NoQlNBS0lBWkJFR29pQmpZQ0FBd0RDd3NnQVFSQVFYOGhDUXdEQ3lBUUJFQWdBaWdDQUVFRGFrRjhjU0lHS0FJQUlRVWdBaUFHUVFScU5nSUFCVUVBSVFVTElBb2dDaWdDQUVFSWFpSUdOZ0lBQlVGL0lRVUxDMEVBSVFjRFFDQUdLQUlBUWI5L2FpSU1RVGxMQkVCQmZ5RUpEQUlMSUFvZ0JrRUVhaUlHTmdJQUlBZEJPbXhCcnVvQWFpQU1haXdBQUNJWlFmOEJjU0lNUVg5cVFRaEpCRUFnRENFSERBRUxDeUFaUlFSQVFYOGhDUXdCQ3lBUFFYOUtJUm9DUUFKQUlCbEJFMFlFUUNBYUJFQkJmeUVKREFRRkRBSUxBQVVnR2dSQUlBUWdEMEVDZEdvZ0REWUNBQ0FJSUFNZ0QwRURkR29wQXdBM0F3QU1BZ3NnRUVVRVFFRUFJUWtNQkFzZ0NDQU1JQUlRc1FFZ0NpZ0NBQ0VHQ3d3QkN5QVFSUVJBUVFBaEJRd0RDd3NnQmtGOGFpZ0NBQ0lNUVY5eElRWUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBZEJBRWNnREVFUGNVRURSbkVFZnlBR0JTQU1JZ1lMUWNNQWF3NHhBZ1lHQmdZR0JnWUdCZ1lHQmdZR0JnTUdCZ1lHQmdZR0JnWUdCZ1lHQmdZQkJnWUdCZ1lHQmdZR0JBQUdCZ1lHQlFZTEFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBSFFmOEJjVUVZZEVFWWRRNElBQUVDQXdRSEJRWUhDeUFJS0FJQUlBazJBZ0JCQUNFRkRBOExJQWdvQWdBZ0NUWUNBRUVBSVFVTURnc2dDQ2dDQUNBSnJEY0RBRUVBSVFVTURRc2dDQ2dDQUNBSk93RUFRUUFoQlF3TUN5QUlLQUlBSUFrNkFBQkJBQ0VGREFzTElBZ29BZ0FnQ1RZQ0FFRUFJUVVNQ2dzZ0NDZ0NBQ0FKckRjREFFRUFJUVVNQ1F0QkFDRUZEQWdMSUFncEF3Q25FTGNESUFBUXJBRWFRUUVoQlF3SEN5QUlLUU1BcHlBQUVLd0JHa0VCSVFVTUJnc2dDQ2dDQUNJSFFRQWdCUkN6QXlJR0lBZHJRUUoxSVF3Z0RTQUdCSDhnREFVZ0JRc2lCa2dFZnlBR0JTQU5DeUVGSUF0QmdNQUFjUVJBSUFBZ0J5QUdFTVVCSUJVZ0JTQUdhellDQUNBVlFZeUxCRFlDQkNBQVFmN3RBQ0FWRUpBQkdnVWdGaUFGSUFack5nSUFJQlpCaklzRU5nSUVJQUJCL3UwQUlCWVFrQUVhSUFBZ0J5QUdFTVVCQ3d3RkN5QUlRWWk4QXlnQ0FCQ1NBaUlITmdJQURBSUxJQWdvQWdBaEJ3d0JDeUFHUVNCeUlnZEJzdTBBYWl3QUFDRU1JQTRnQzBFRGRrRUJjVUVCYzBHSjdnQnFOZ0lBSUE0Z0MwRUxka0VCY1VFQmMwR0w3Z0JxTmdJRUlBNGdDMEVOZGtFQmNVRUJjMEdON2dCcU5nSUlJQTRnQzBFQmNVRUJjMEdQN2dCcU5nSU1JQTRnQzBFUWRrRUJjVUVCYzBHUjdnQnFOZ0lRSUE0Z0REWUNGQ0FPSUFZMkFoZ2dGMEVRUWF2dUFDQU9FTUVER2dKQUFrQUNRQ0FIUWVFQWF3NFlBQUlDQVFBQUFBSUJBZ0lDQWdJQkFRSUNBZ0lCQWdJQkFnc2dDQ3NEQUNFY0lCSWdEVFlDQUNBU0lBVTJBZ1FnRWlBY09RTUlJQUFnRnlBU0VKQUJJUVVNQkFzZ0NDa0RBQ0ViSUJFZ0RUWUNBQ0FSSUFVMkFnUWdFU0FiTndNSUlBQWdGeUFSRUpBQklRVU1Bd3RCQUNFRkRBSUxJQWRGQkVBZ0NFR0M3Z0EyQWdCQmd1NEFJUWNMQWtBZ0JVSC8vLy8vQjBrRWZ5QUZCVUgvLy8vL0J3c2lERUVBU2dSQUlBY2hCVUVBSVFZRFFDQVlJQVZCQkJETUFTSVBRUUJLQkVBZ0JTQVBhaUVGSUFaQkFXb2lCaUFNU0EwQklBWWhCUXdEQ3dzZ0QwRUFTQVJBUVg4aENRd0RCU0FHSVFVTEJVRUFJUVVMQ3lBTklBVklCSDhnQlFVZ0RRc2hCaUFMUVlEQUFIRkJBRWNpRFVVRVFDQVVJQVlnQldzMkFnQWdGRUdNaXdRMkFnUWdBRUgrN1FBZ0ZCQ1FBUm9MSUFVRVFDQUZJUXNEUUNBSElCZ2dCMEVFRU13QmFpRUhJQmdvQWdBZ0FCQ3NBUm9nQzBGL2FpSUxEUUFMQ3lBTkJFQWdFeUFHSUFWck5nSUFJQk5CaklzRU5nSUVJQUJCL3UwQUlCTVFrQUVhQ3lBR0lRVU1BUXNMREFFTElBQkZCRUFnQVFSQVFRRWhBQU5BSUFRZ0FFRUNkR29vQWdBaUFRUkFJQU1nQUVFRGRHb2dBU0FDRUxFQklBQkJBV29oQVNBQVFRbElCRUFnQVNFQURBSUZJQUVoQUFzTEN5QUFRUXBJQkVBRFFDQUVJQUJCQW5ScUtBSUFCRUJCZnlFSkRBVUxJQUJCQVdvaEFTQUFRUWxJQkVBZ0FTRUFEQUVGUVFFaENRc0xCVUVCSVFrTEJVRUFJUWtMQ3dzZ0NDUUVJQWtMY0FFQmZ5QUFLQUpNR2lBQkJFQWdBRUg0QUdvaUFpZ0NBRVVFUUNBQ1Fhd2pLQUlBS0FJQUJIOUJqQjRGUWJDN0F3czJBZ0FMSUFCQnlnQnFJZ0FzQUFBaUFnUkFJQUloQVFVZ0FDQUJRUUJLQkg5QkFRVkJmd3NpQVRvQUFBc0ZJQUFzQUVvaEFRc2dBVUVZZEVFWWRRc1RBQ0FBSUFBUVdVRUNkR29nQVJCcUdpQUFDeUVCQW44Z0FCQnVRUUZxSWdFUWJDSUNCSDhnQWlBQUlBRVFVd1ZCQUFzaUFBc1hBRUVBSUFBZ0FTQUNCSDhnQWdWQnBMd0RDeENLQWd0Q0FRTi9JQUlFUUNBQklRTWdBQ0VCQTBBZ0EwRUVhaUVFSUFGQkJHb2hCU0FCSUFNb0FnQTJBZ0FnQWtGL2FpSUNCRUFnQkNFRElBVWhBUXdCQ3dzTElBQUw3QUlCQlg4akJDRUdJd1JCRUdva0JDQURCSDhnQXdWQm9Md0RDeUlFS0FJQUlRTUNmd0pBSUFFRWZ5QUFCSDhnQUFVZ0Jnc2hCU0FDQkVBQ1FBSkFJQU1FUUNBRElRQWdBaUVEREFFRklBRXNBQUFpQUVGL1NnUkFJQVVnQUVIL0FYRTJBZ0FnQUVFQVJ3d0hDeUFCTEFBQUlRQkJyQ01vQWdBb0FnQkZCRUFnQlNBQVFmKy9BM0UyQWdCQkFRd0hDeUFBUWY4QmNVRytmbW9pQUVFeVN3MEZJQUZCQVdvaEFTQUFRUUowUWFRZWFpZ0NBQ0VBSUFKQmYyb2lBdzBCQ3d3QkN5QUJMQUFBSWdkQi93RnhRUU4ySWdoQmNHb2dDQ0FBUVJwMWFuSkJCMHNOQXdOQUFrQWdBMEYvYWlFRElBZEIvd0Z4UVlCL2FpQUFRUVowY2lJQVFRQk9EUUFnQTBVTkFpQUJRUUZxSWdFc0FBQWlCMEhBQVhGQmdBRkdEUUVNQlFzTElBUkJBRFlDQUNBRklBQTJBZ0FnQWlBRGF3d0VDeUFFSUFBMkFnQUxRWDRGSUFNTkFVRUFDd3dCQ3lBRVFRQTJBZ0JCaUx3RFFkUUFOZ0lBUVg4TElRQWdCaVFFSUFBTFFBQWdBUVJBSUFCQkFuUkI4THNEYWlBQUlBRVF4UU1pQURZQ0FBVWdBRUVDZEVId3V3TnFLQUlBSVFBTElBQkJDR29oQVNBQUJIOGdBUVZCck9vQUN3dHJBUUovSUFCQnlnQnFJZ0lzQUFBaEFTQUNJQUZCL3dGcUlBRnlPZ0FBSUFBb0FnQWlBVUVJY1FSL0lBQWdBVUVnY2pZQ0FFRi9CU0FBUVFBMkFnZ2dBRUVBTmdJRUlBQWdBQ2dDTENJQk5nSWNJQUFnQVRZQ0ZDQUFJQUVnQUNnQ01HbzJBaEJCQUFzaUFBdnRBUUVFZndKQUFrQWdBa0VRYWlJRUtBSUFJZ01OQUNBQ0VJd0NCRUJCQUNFQ0JTQUVLQUlBSVFNTUFRc01BUXNnQXlBQ1FSUnFJZ1VvQWdBaUJHc2dBVWtFUUNBQ0lBQWdBU0FDS0FJa1FSOXhRY29BYWhFQkFDRUNEQUVMQWtBZ0Fpd0FTMEYvU2dSQUlBRWhBd05BSUFORkJFQkJBQ0VEREFNTElBQWdBMEYvYWlJR2Fpd0FBRUVLUndSQUlBWWhBd3dCQ3dzZ0FpQUFJQU1nQWlnQ0pFRWZjVUhLQUdvUkFRQWlBaUFEU1EwQ0lBQWdBMm9oQUNBQklBTnJJUUVnQlNnQ0FDRUVCVUVBSVFNTEN5QUVJQUFnQVJCVEdpQUZJQVVvQWdBZ0FXbzJBZ0FnQXlBQmFpRUNDeUFDQzVrQkFnRi9BbjRDUUFKQUFrQWdBTDBpQTBJMGlDSUVwMEgvRDNFaUFnUkFJQUpCL3c5R0JFQU1CQVVNQXdzQUN5QUJJQUJFQUFBQUFBQUFBQUJpQkg4Z0FFUUFBQUFBQUFEd1E2SWdBUkNPQWlFQUlBRW9BZ0JCUUdvRlFRQUxJZ0kyQWdBTUFnQUxBQUFMSUFFZ0JLZEIvdzl4UVlKNGFqWUNBQ0FEUXYvLy8vLy8vLytIZ0grRFFvQ0FnSUNBZ0lEd1A0Uy9JUUFMSUFBTFNBRUNmeUFBS0FJQUxBQUFRVkJxUVFwSkJFQURRQ0FDUVFwc1FWQnFJQUFvQWdBaUFTd0FBR29oQWlBQUlBRkJBV29pQVRZQ0FDQUJMQUFBUVZCcVFRcEpEUUFMQ3lBQ0MzUUJBbjhnQWdSL0FrQWdBQ3dBQUNJREJFQWdBQ0VFSUFNaEFBTkFJQUJCR0hSQkdIVWdBU3dBQUNJRFJpQUNRWDlxSWdKQkFFY2dBMEVBUjNGeFJRMENJQUZCQVdvaEFTQUVRUUZxSWdRc0FBQWlBQTBBUVFBaEFBc0ZRUUFoQUFzTElBQkIvd0Z4SUFFdEFBQnJCVUVBQ3lJQUMvc0JBUU4vQWtBZ0FVSC9BWEVpQWdSQUlBQkJBM0VFUUNBQlFmOEJjU0VEQTBBZ0FDd0FBQ0lFUlNBRUlBTkJHSFJCR0hWR2NnMERJQUJCQVdvaUFFRURjUTBBQ3dzZ0FrR0Jnb1FJYkNFREFrQWdBQ2dDQUNJQ1FZQ0Jnb1I0Y1VHQWdZS0VlSE1nQWtILy9mdDNhbkZGQkVBRFFDQUNJQU56SWdKQmdJR0NoSGh4UVlDQmdvUjRjeUFDUWYvOSszZHFjUTBDSUFCQkJHb2lBQ2dDQUNJQ1FZQ0Jnb1I0Y1VHQWdZS0VlSE1nQWtILy9mdDNhbkZGRFFBTEN3c2dBVUgvQVhFaEFnTkFJQUJCQVdvaEFTQUFMQUFBSWdORklBTWdBa0VZZEVFWWRVWnlSUVJBSUFFaEFBd0JDd3NGSUFBZ0FCQnVhaUVBQ3dzZ0FBc05BQ0FBUWF3aktBSUFFTWNEQzZRREFRWi9JQUZCQVhSQmYyb2hBeUFCUVg5cUlRUUNRQ0FBUVlDd2ZXcEJnSzRCU1NBQVFZQ2tmMnBCd1BBQlNTQUFRWUIwYWtHQUZFa2dBQkRJQTBWeWNuSkZCRUFnQVVFQVJ5SUNJQUJCNEY1cVFTNUpjUVJBSUFCQnhTRktCRUFDUUFKQUFrQWdBRUhISVdzT0J3QUJBUUVCQVFBQkN3d0JDd3dFQ3dzZ0FFSGdPR29oQUF3Q0N5QUFRWUNtZjJwQkpra2dBa0VCYzNFRVFDQUFRYUJIYWlFQURBSUZRUUFoQWdzQ1FBSkFBMEFnQUNBQ1FRSjBRZHdxYWk4QkFHc2lCU0FFSUFKQkFuUkIzaXBxTEFBQUlnWWlCM0ZySUFKQkFuUkIzeXBxTFFBQVNRMEJJQUpCQVdvaUFrRTlSdzBBQ3d3QkN5QUdRUUZHQkVBZ0FTQUFhaUFGUVFGeGF5RUFCU0FESUFkc0lBQnFJUUFMREFJTEFrQkJBU0FCYXlJRVFRRjBRZlFtYWk0QkFDSUNCRUJCQUNFREEwQWdBa0gvL3dOeElBQkhCRUFnQTBFQmFpSURRUUowUWZRbWFpQUVRUUYwYWk0QkFDSUNSUTBEREFFTEN5QURRUUowUWZRbWFpQUJRUUYwYWk4QkFDRUFEQU1MQ3lBQVFWaHFJQUZCMEFCc2FpRUNJQUJCMlBkN2FpQUJRU2hzYWtFb1NRUi9JQUlGSUFBTER3c0xJQUFMT3dFQmZ5TUVJUUVqQkVFUWFpUUVJQUVnQURZQ0FFRThJQUVRSnlJQVFZQmdTd1JBUVlpOEEwRUFJQUJyTmdJQVFYOGhBQXNnQVNRRUlBQUx5d3dCQm44Q1FDQUFJQUZxSVFVQ1FDQUFLQUlFSWdOQkFYRkZCRUFnQUNnQ0FDRUNJQU5CQTNGRkJFQVBDeUFDSUFGcUlRRkIxTGNES0FJQUlBQWdBbXNpQUVZRVFDQUZRUVJxSWdJb0FnQWlBMEVEY1VFRFJ3MENRY2kzQXlBQk5nSUFJQUlnQTBGK2NUWUNBQ0FBSUFGQkFYSTJBZ1FnQlNBQk5nSUFEd3NnQWtFRGRpRUVJQUpCZ0FKSkJFQWdBQ2dDRENJQ0lBQW9BZ2dpQTBZRVFFSEF0d05Cd0xjREtBSUFRUUVnQkhSQmYzTnhOZ0lBQlNBRElBSTJBZ3dnQWlBRE5nSUlDd3dDQ3lBQUtBSVlJUWNDUUNBQUtBSU1JZ0lnQUVZRVFDQUFRUkJxSWdOQkJHb2lCQ2dDQUNJQ0JFQWdCQ0VEQlNBREtBSUFJZ0pGQkVCQkFDRUNEQU1MQ3dOQUlBSkJGR29pQkNnQ0FDSUdCRUFnQmlFQ0lBUWhBd3dCQ3lBQ1FSQnFJZ1FvQWdBaUJnUkFJQVloQWlBRUlRTU1BUXNMSUFOQkFEWUNBQVVnQUNnQ0NDSURJQUkyQWd3Z0FpQUROZ0lJQ3dzZ0J3UkFJQUFvQWh3aUEwRUNkRUh3dVFOcUlnUW9BZ0FnQUVZRVFDQUVJQUkyQWdBZ0FrVUVRRUhFdHdOQnhMY0RLQUlBUVFFZ0EzUkJmM054TmdJQURBUUxCU0FIUVJCcUlBY29BaEFnQUVkQkFuUnFJQUkyQWdBZ0FrVU5Bd3NnQWlBSE5nSVlJQUJCRUdvaUJDZ0NBQ0lEQkVBZ0FpQUROZ0lRSUFNZ0FqWUNHQXNnQkNnQ0JDSURCRUFnQWlBRE5nSVVJQU1nQWpZQ0dBc0xDd3NnQlVFRWFpSURLQUlBSWdKQkFuRUVRQ0FESUFKQmZuRTJBZ0FnQUNBQlFRRnlOZ0lFSUFBZ0FXb2dBVFlDQUNBQklRSUZRZGkzQXlnQ0FDQUZSZ1JBUWN5M0EwSE10d01vQWdBZ0FXb2lBVFlDQUVIWXR3TWdBRFlDQUNBQUlBRkJBWEkyQWdRZ0FFSFV0d01vQWdCSEJFQVBDMEhVdHdOQkFEWUNBRUhJdHdOQkFEWUNBQThMUWRTM0F5Z0NBQ0FGUmdSQVFjaTNBMEhJdHdNb0FnQWdBV29pQVRZQ0FFSFV0d01nQURZQ0FDQUFJQUZCQVhJMkFnUWdBQ0FCYWlBQk5nSUFEd3NnQWtGNGNTQUJhaUVHSUFKQkEzWWhBd0pBSUFKQmdBSkpCRUFnQlNnQ0RDSUJJQVVvQWdnaUFrWUVRRUhBdHdOQndMY0RLQUlBUVFFZ0EzUkJmM054TmdJQUJTQUNJQUUyQWd3Z0FTQUNOZ0lJQ3dVZ0JTZ0NHQ0VIQWtBZ0JTZ0NEQ0lCSUFWR0JFQWdCVUVRYWlJQ1FRUnFJZ01vQWdBaUFRUkFJQU1oQWdVZ0FpZ0NBQ0lCUlFSQVFRQWhBUXdEQ3dzRFFDQUJRUlJxSWdNb0FnQWlCQVJBSUFRaEFTQURJUUlNQVFzZ0FVRVFhaUlES0FJQUlnUUVRQ0FFSVFFZ0F5RUNEQUVMQ3lBQ1FRQTJBZ0FGSUFVb0FnZ2lBaUFCTmdJTUlBRWdBallDQ0FzTElBY0VRQ0FGS0FJY0lnSkJBblJCOExrRGFpSURLQUlBSUFWR0JFQWdBeUFCTmdJQUlBRkZCRUJCeExjRFFjUzNBeWdDQUVFQklBSjBRWDl6Y1RZQ0FBd0VDd1VnQjBFUWFpQUhLQUlRSUFWSFFRSjBhaUFCTmdJQUlBRkZEUU1MSUFFZ0J6WUNHQ0FGUVJCcUlnTW9BZ0FpQWdSQUlBRWdBallDRUNBQ0lBRTJBaGdMSUFNb0FnUWlBZ1JBSUFFZ0FqWUNGQ0FDSUFFMkFoZ0xDd3NMSUFBZ0JrRUJjallDQkNBQUlBWnFJQVkyQWdBZ0FFSFV0d01vQWdCR0JFQkJ5TGNESUFZMkFnQVBCU0FHSVFJTEN5QUNRUU4ySVFNZ0FrR0FBa2tFUUNBRFFRTjBRZWkzQTJvaEFVSEF0d01vQWdBaUFrRUJJQU4wSWdOeEJIOGdBVUVJYWlJREtBSUFCVUhBdHdNZ0FpQURjallDQUNBQlFRaHFJUU1nQVFzaEFpQURJQUEyQWdBZ0FpQUFOZ0lNSUFBZ0FqWUNDQ0FBSUFFMkFnd1BDeUFDUVFoMklnRUVmeUFDUWYvLy93ZExCSDlCSHdVZ0FrRU9JQUVnQVVHQS9qOXFRUkIyUVFoeElnRjBJZ05CZ09BZmFrRVFka0VFY1NJRUlBRnlJQU1nQkhRaUFVR0FnQTlxUVJCMlFRSnhJZ055YXlBQklBTjBRUTkyYWlJQlFRZHFka0VCY1NBQlFRRjBjZ3NGUVFBTElnTkJBblJCOExrRGFpRUJJQUFnQXpZQ0hDQUFRUUEyQWhRZ0FFRUFOZ0lRUWNTM0F5Z0NBQ0lFUVFFZ0EzUWlCbkZGQkVCQnhMY0RJQVFnQm5JMkFnQWdBU0FBTmdJQURBRUxJQUVvQWdBaEFVRVpJQU5CQVhacklRUWdBaUFEUVI5R0JIOUJBQVVnQkF0MElRTUNRQU5BSUFFb0FnUkJlSEVnQWtZTkFTQURRUUYwSVFRZ0FVRVFhaUFEUVI5MlFRSjBhaUlES0FJQUlnWUVRQ0FFSVFNZ0JpRUJEQUVMQ3lBRElBQTJBZ0FNQVFzZ0FVRUlhaUlDS0FJQUlnTWdBRFlDRENBQ0lBQTJBZ0FnQUNBRE5nSUlJQUFnQVRZQ0RDQUFRUUEyQWhnUEN5QUFJQUUyQWhnZ0FDQUFOZ0lNSUFBZ0FEWUNDQXNFQUVFQUMxb0JBWDhqQkNFQ0l3UkJnQkJxSkFRZ0FTQUNRWUFRRUdrYUlBQkJCR29pQXlBQkVEODJBZ0FnQUVFQk9nQVNJQUJCQURZQ0RDQUFRUUE2QUJBZ0FFRVlhaUFCUVlBUUVHOGFJQU1vQWdCQkFFY2hBQ0FDSkFRZ0FBdUhBUUVDZnlNRUlRSWpCRUdBRUdva0JDQUFRWmpBQUdvaUEwRUFOZ0lBSUFFZ0FrR0FFQkJwR2lBQkVFQWlCRVVFUUVHSXZBTW9BZ0JCQWtZRVFDQURRUUUyQWdBTEN5QUFRUUE2QUJJZ0FFRUFOZ0lNSUFCQkFEb0FFQ0FFUVFCSElnTkZCRUFnQWlRRUlBTVBDeUFBSUFRMkFnUWdBRUVZYWlBQlFZQVFFRzhhSUFJa0JDQURDNHNCQVFGL0l3UWhBeU1FUVJCcUpBUWdBeUFDRU5VQklBRWdBQ2dDQUdvaUFFRUxhaUlCTEFBQVFRQklCRUFnQUNnQ0FFRUFOZ0lBSUFCQkFEWUNCQVVnQUVFQU5nSUFJQUZCQURvQUFBdEJBQ1FGUVJZZ0FFRUFFQTBqQlNFQlFRQWtCU0FCUVFGeEJFQkJBQkFZSWdBUVdnVWdBQ0FES1FJQU53SUFJQUFnQXlnQ0NEWUNDQ0FESkFRTEMyQUJBMzhnQVNBQUtBSUFhaUlCTEFBTElnSkJBRWdoQXlBQktBSUVJUUFnQWtIL0FYRWhBaUFEQkg4Z0FBVWdBaUlBQzBFQ2RFRUVhaEJzSWdJZ0FEWUNBQ0FCS0FJQUlRUWdBa0VFYWlBREJIOGdCQVVnQVFzZ0FCQ0pBaG9nQWdza0FRRi9JQUVnQUNnQ0FHb2lBeUFDS0FJQU5nSUFJQU5CQkdvZ0FrRUVhaENsQXhvTFRnQWdBU0FBS0FJQWFpRUJRUkFRWHlJQUlBRW9BZ0EyQWdCQkFDUUZRUlVnQUVFRWFpQUJRUVJxRUEwakJTRUJRUUFrQlNBQlFRRnhCRUFRRnlFQklBQVFVaUFCRUI0RklBQVBDMEVBQ3pnQkFYOGdBRVVFUUE4TElBQXNBQnRCQUVnRVFDQUFLQUlRRUZJTElBQkJCR29pQVN3QUMwRUFTQVJBSUFFb0FnQVFVZ3NnQUJCU0N5Z0JBWDhnQWtVRVFDQUFEd3NnQUNBQklBSkJmMm9pQXhER0FSb2dBQ0FEYWtFQU9nQUFJQUFMRFFBZ0FFRUhjVUVDYWhFRkFBdjJBd0VIZnlNRUlRWWpCRUdRd0FGcUpBUWdBa0VBRUs4QklRY2dCa0dJZ0FGcUlnaEJBRFlDQUNBQVFRQTJBaEFnQUNBR1FZakFBR29pQlVHQUVCRGFBVVVFUUNBR0pBUkJBQThMSUFaQkJHb2hDaUFHUVFocUlRc2dBUVJBQTBBQ2Z5QUZFTThCSWdFb0FnQkJMMFlFUUNBQlFRQTJBZ0FMQWtBQ1FDQURSUTBBSUFVb0FnQkJMMGNOQUNBSUtBSUFSUVJBSUFJZ0NFR0FFQkQzQVFzZ0JTQUlJQVFRcFFFRVFFRUJJUUZCR3d3REN3d0JDeUFGUVFBUXJ3RWlDU2dDQUVFcVJnUi9JQWtvQWdSQkwwWUVmeUFHUVM0MkFnQWdDa0V2TmdJQUlBc2dCMEdBRUJCdkdpQUdCU0FIQ3dVZ0J3c2hBU0FKSUFFZ0JCQ2xBUVJBUVFFaEFVRWJEQUlMQ3lBQUlBVkJnQkFRMmdFTkFVRUFJUUZCR3dzaEFBc0ZBMEFDZnlBRkVNOEJLQUlBUVM5R0JFQWdCVUdJSFVHQUVCQjRHZ3NDUUFKQUlBTkZEUUFnQlNnQ0FFRXZSdzBBSUFnb0FnQkZCRUFnQWlBSVFZQVFFUGNCQ3lBRklBZ2dCQkNsQVFSQVFRRWhBVUViREFNTERBRUxJQVZCQUJDdkFTSUpLQUlBUVNwR0JIOGdDU2dDQkVFdlJnUi9JQVpCTGpZQ0FDQUtRUzgyQWdBZ0N5QUhRWUFRRUc4YUlBWUZJQWNMQlNBSEN5RUJJQWtnQVNBRUVLVUJCRUJCQVNFQlFSc01BZ3NMSUFBZ0JVR0FFQkRhQVEwQlFRQWhBVUViQ3lFQUN3c2dBRUViUmdSQUlBWWtCQ0FCRHd0QkFBczRBUUovSUFCQkVHb2lBaWdDQUNJQklBQW9BZ1JQQkVCQkFBOExJQUlnQVVFQmFpQUFLQUlBSUFGQkFuUnFJZ0FRV1dvMkFnQWdBQXVNQndFR2Z5QUFRUVJxSWdWQkFSRGtBU0FBUWFpV0FXb2lCa0VBUVlBQ0VGUWFJQUJCME1ZRGFpSURRUUEyQWdBZ0FFR0l2Z0pxUVFBMkFnQWdBRUdRdmdKcVFRQTJBZ0FnQUVHTXZnSnFRUUEyQWdBZ0FFRVVhaUlDUWdBM0FnQWdBa0lBTndJSUlBSkNBRGNDRUNBQ1FnQTNBaGdnQWtJQU53SWdJQUpDQURjQ0tFRUFKQVZCSkNBQVFkRE1BMm9pQnhBTUl3VWhCRUVBSkFVQ1FDQUVRUUZ4QkVBUUZ5RUJCVUVBSkFWQkVTQUFRWWpOQTJwQkFSQU5Jd1VoQkVFQUpBVWdCRUVCY1FSQUVCY2hBU0FIRUxJQ0RBSUxJQUJCbU0wRGFpSUNRZ0EzQWdBZ0FrSUFOd0lJSUFKQ0FEY0NFQ0FDUWdBM0FoZ2dBa0lBTndJZ0lBSkNBRGNDS0NBQUlBRTJBZ0FnQUVHb21BRnFRUUE2QUFBZ0FFRzRtQUZxUVFBNkFBQWdBRUc1bUFGcVFRQTZBQUFnQUVHNm1BRnFRUUE2QUFBZ0FFSE16UU5xUVFBMkFnQWdBRUhRelFOcVFRQTJBZ0FnQUVFQU5nSTRJQUJCQURZQ0NDQUFRUUEyQWdRZ0FFSEFtQUZxUWdBM0F3QWdBRUhFQUdwQkFFSGtsUUVRVkJvZ0FFRi9OZ0p3SUFCQndLNENha0VBTmdJQUlBQkJ4SzRDYWtFQU5nSUFJQUJCdUs0Q2FrRUFOZ0lBSUFCQnZLNENha0VCTmdJQUlBQkJ5SzRDYWtFQVFmQUNFRlFhSUFCQmhLOEJha0VBUWJUL0FCQlVHaUFBUWN6TUEycEJBRG9BQUNBQVFiVEpBMnBCQUVHVUF4QlVHaUFBUWJESkEycEJBallDQUNBQVFjak1BMnBCQURZQ0FDQUFRUUFRZ3dFZ0FFSFVyZ0ZxSWdGQ0FEY0NBQ0FCUWdBM0FnZ2dBVUlBTndJUUlBQkIwSzRCYWtHQTZnQTJBZ0FnQUVHQXJ3RnFRWUhBQURZQ0FDQUFRZnl1QVdwQmdBRTJBZ0FnQUVINHJnRnFRWUFCTmdJQUlBQkI5SzRCYWtFQU5nSUFJQUJCeks0QmFrRUFOZ0lBSUFCQjdLNEJha0VBTmdJQUlBQkI4SzRCYWtFQU5nSUFJQUJCQURZQ2FFRUFJUUVEUUNBQVFjcWdBV29nQVVFQmRHb2dBVUVJZEVILy93TnhJZ0k3QVFBZ0FFSEttQUZxSUFGQkFYUnFJQUk3QVFBZ0FFSEtuQUZxSUFGQkFYUnFJQUU3QVFBZ0FFSEtwQUZxSUFGQkFYUnFRUUFnQVd0QkNIUTdBUUFnQVVFQmFpSUJRWUFDUncwQUN5QUFRY3FvQVdwQkFFR0FCaEJVR2tFQUlBQkJ5cUFCYWlBQVFjcXFBV29RbndFUEN3c2dBeWdDQUFSQUlBTkJBRFlDQUNBQVFmekhBMm9vQWdBUVVnc2dCaERZQVNBQUtBSTBJZ01FUUNBREVGSUxJQUFvQWlRaUFBUkFJQUFRVWdzZ0FpZ0NBQ0lBUlFSQUlBVVFtQUVnQVJBZUN5QUFFRklnQlJDWUFTQUJFQjRMbXcwQkUzOGpCQ0VJSXdSQjBBTnFKQVFnQWl3QUVVVUVRQ0FJSkFSQkFROExJQUZCQ0dvaUVDd0FBRVVFUUNBQktBSUFJQUJCNkFCcUlnWW9BZ0FpQkVGbmFrb0VRQ0FFSUFCQkJHb2lCeWdDQUNJRmF5SUNRUUJJQkVBZ0NDUUVRUUFQQ3lBQVFmQUFhaUlLSUFCQitBQnFJZ3NvQWdBZ0JXc2dDaWdDQUdvMkFnQWdCVUdBZ0FGS0JFQWdBa0VBU2dSQUlBQW9BaEFpQkNBRUlBVnFJQUlRWFJvTElBZEJBRFlDQUNBR0lBSTJBZ0FGSUFRaEFnc2dBa0dBZ0FKR0JFQkJBQ0VDUVlDQUFpRUVCU0FBS0FJQUlBQW9BaEFnQW1wQmdJQUNJQUpyRUY0aEFpQUdLQUlBSWdVZ0Ftb2hCQ0FDUVFCS0JFQWdCaUFFTmdJQUJTQUZJUVFMQ3lBQVFld0FhaUlHSUFSQlltb2lCRFlDQUNBTElBY29BZ0FpQlRZQ0FDQUZRWDlxSUFvb0FnQWlCMm9oQlNBSFFYOUhCRUFnQmlBRUlBVklCSDhnQkFVZ0JRczJBZ0FMSUFKQmYwWUVRQ0FJSkFSQkFBOExDd3NnQ0VHd0Eyb2hCMEVBSVFJRFFDQUJFRmhCREhZaEJDQUJRUVFRVlFKQUFrQWdCRUgvQVhGQkQwWUVRQ0FCRUZoQkRIWkIvd0Z4SVFVZ0FVRUVFRlVnQlFSQUlBVkJBbW9oQkNBSElBSnFRUUJCQUVGK0lBVnJJZ1VnQWtGc2FpSUdTd1IvSUFVRklBWUxheEJVR2dOQUlBUkJmMm9oQlNBRVFRRktJQUpCQVdvaUJrRVVTWEVFUUNBRklRUWdCaUVDREFFTEN3VkJEeUVFREFJTEJTQUVRZjhCY1NFRURBRUxEQUVMSUFjZ0Ftb2dCRG9BQUFzZ0FrRUJhaUlDUVJSSkRRQUxRUUFnQnlBRFFiRDNBR29pRVVFVUVHZ2dBRUhvQUdvaEJ5QUFRUVJxSVFvZ0FFSDRBR29oRFNBQVFmQUFhaUVMSUFCQkVHb2hEaUFBUWV3QWFpRVBJQUZCREdvaEVpQUJRUVJxSVF3Z0EwRzArQUJxSVJNZ0NFRi9haUVVUVFBaEFnSkFBa0FEUUFKQUlBSkJyZ05JSVJVZ0FrRUFTaUVXQWtBQ1FBSkFBMEFnRUN3QUFFVWhCQ0FWUlEwR0lBUUVRQ0FCS0FJQUlBY29BZ0FpQlVGN2Frb0VRQ0FGSUFvb0FnQWlCbXNpQkVFQVNBMEdJQXNnRFNnQ0FDQUdheUFMS0FJQWFqWUNBQ0FHUVlDQUFVb0VRQ0FFUVFCS0JFQWdEaWdDQUNJRklBVWdCbW9nQkJCZEdnc2dDa0VBTmdJQUlBY2dCRFlDQUFVZ0JTRUVDeUFFUVlDQUFrWUVRRUVBSVFSQmdJQUNJUVVGSUFBb0FnQWdEaWdDQUNBRWFrR0FnQUlnQkdzUVhpRUVJQWNvQWdBaUJpQUVhaUVGSUFSQkFFb0VRQ0FISUFVMkFnQUZJQVloQlFzTElBOGdCVUZpYWlJRk5nSUFJQTBnQ2lnQ0FDSUdOZ0lBSUFaQmYyb2dDeWdDQUNJSmFpRUdJQWxCZjBjRVFDQVBJQVVnQmtnRWZ5QUZCU0FHQ3pZQ0FBc2dCRUYvUmcwR0N3c2dFaWdDQUNJRUlBRW9BZ0FpQlVFQmFtb3RBQUJCQ0hRZ0JDQUZhaTBBQUVFUWRISWdCQ0FGUVFKcWFpMEFBSEpCQ0NBTUtBSUFJZ2xyZGtIKy93TnhJZ1lnQTBHMDl3QnFJQk1vQWdBaUJFRUNkR29vQWdCSkJIOGdBU0FKSUFOQnVQZ0FhaUFHUVJBZ0JHdDJJZ1JxTFFBQWFpSUdRUU4ySUFWcU5nSUFJQXdnQmtFSGNUWUNBQ0FEUWJpQUFXb2dCRUVCZEdvRkEwQUNRQ0FFUVFGcUlnUkJEMDhFUUVFUElRUU1BUXNnQmlBRFFiVDNBR29nQkVFQ2RHb29BZ0JQRFFFTEN5QUJJQVFnQ1dvaUNVRURkaUFGYWpZQ0FDQU1JQWxCQjNFMkFnQWdBMEc0a0FGcUlBWWdBeUFFUVFKMGFrR3c5d0JxS0FJQWEwRVFJQVJyZGlBRFFmVDNBR29nQkVFQ2RHb29BZ0JxSWdRZ0VTZ0NBRThFZjBFQUJTQUVDMEVCZEdvTElnUXVBUUFpQkVILy93TnhRUkJJRFFFZ0JFSC8vd054UVJKT0RRTWdBUkJZSVFVZ0JFRVFSZ1IvSUFGQkF4QlZJQVZCRFhaQkEyb0ZJQUZCQnhCVklBVkJDWFpCQzJvTElRVWdGa1VOQUF3Q0N3QUxJQWdnQW1vZ0JEb0FBQ0FDUVFGcUlRSU1Bd3NnRkNBQ2Fpd0FBQ0VKSUFJaEJBTkFJQVZCZjJvaEJpQUlJQVJxSUFrNkFBQWdCRUVCYWlFQ0lBUkJyUU5JSUFWQkFVcHhSUTBESUFZaEJTQUNJUVFNQUFzQUN5QUJFRmdoQlNBRVFSSkdCSDhnQVVFREVGVWdCVUVOZGtFRGFnVWdBVUVIRUZVZ0JVRUpka0VMYWdzaEJDQUlJQUpxUVFCQkFDQUNRWDlxSUFKQnJRTktCSDhnQWdWQnJRTUxheUlGUVg0Z0JHc2dCRUYvY3lJR1FYNUtCSDhnQmdWQmZndHJJZ1pMQkg4Z0JRVWdCZ3RyRUZRYUlBSWhCUU5BSUFSQmYyb2hCaUFGUVFGcUlRSWdCVUd0QTBnZ0JFRUJTbkZGRFFJZ0JpRUVJQUloQlF3QUN3QUxRUUFoQUFzTUFRc2dCQVJBSUFFb0FnQWdCeWdDQUVvRVFFRUFJUUFNQWdzTFFRQWdDQ0FEUWJJQ0VHaEJBQ0FJUWJJQ2FpQURRZXdkYWtIQUFCQm9RUUFnQ0VIeUFtb2dBMEhZTzJwQkVCQm9RUUFnQ0VHQ0Eyb2dBMEhFMlFCcVFTd1FhRUVCSVFBTElBZ2tCQ0FBQytjRUFRbC9JQUpCREdvaUNVRUFOZ0lBSUFFc0FBaEZCRUFnQVNnQ0FDQUFRZWdBYWlJR0tBSUFJZ1JCZVdwS0JFQWdCQ0FBUVFScUlnY29BZ0FpQldzaUEwRUFTQVJBUVFBUEN5QUFRZkFBYWlJSUlBQkIrQUJxSWdvb0FnQWdCV3NnQ0NnQ0FHbzJBZ0FnQlVHQWdBRktCRUFnQTBFQVNnUkFJQUFvQWhBaUJDQUVJQVZxSUFNUVhSb0xJQWRCQURZQ0FDQUdJQU0yQWdBRklBUWhBd3NnQTBHQWdBSkdCRUJCQUNFRFFZQ0FBaUVFQlNBQUtBSUFJQUFvQWhBZ0EycEJnSUFDSUFOckVGNGhBeUFHS0FJQUlnVWdBMm9oQkNBRFFRQktCRUFnQmlBRU5nSUFCU0FGSVFRTEN5QUFRZXdBYWlJR0lBUkJZbW9pQkRZQ0FDQUtJQWNvQWdBaUJUWUNBQ0FGUVg5cUlBZ29BZ0FpQjJvaEJTQUhRWDlIQkVBZ0JpQUVJQVZJQkg4Z0JBVWdCUXMyQWdBTElBTkJmMFlFUUVFQUR3c0xDeUFCUVFBZ0FVRUVhaUlIS0FJQWEwRUhjUkJWSUFFUVdDRUdJQUZCQ0JCVklBWkJDM1pCQTNFaUNFRURSZ1JBUVFBUEN5QUpJQWhCQTJvMkFnQWdBaUFHUVFoMklncEJCM0ZCQVdvMkFnUWdBUkJZSVFzZ0FVRUlFRlZCQUNFRVFRQWhBd05BSUFFUVdFRUlkaUFFUVFOMGRDQURhaUVESUFFZ0J5Z0NBRUVJYWlJRlFRTjJJQUVvQWdCcUlnazJBZ0FnQnlBRlFRZHhOZ0lBSUFSQkFXb2hCU0FFSUFoSEJFQWdCU0VFREFFTEN5QUNJQU0yQWdBZ0NrSGFBSE1nQzBFSWRuTWdBM01nQTBFSWRuTWdBMEVRZG5OQi93RnhCRUJCQUE4TElBSWdDVFlDQ0NBQVFld0FhaUlCS0FJQUlRQWdBU0FBSUFsQmYyb2dBMm9pQVVnRWZ5QUFCU0FCQ3pZQ0FDQUNJQVpCRG5aQkFYRTZBQkFnQWlBR1FROTJRUUZ4T2dBUlFRRUxzQkFCSEg4Q1FDTUVJUUlqQkVFZ2FpUUVJQUpCR0dvaEZpQUNRUkJxSVJjZ0FrRUlhaUVZSUFJaEVTQUFRZVFBYWlJWktBSUFJUUVnQUVIUXpRTnFJUk1nQUVIZ0FHb2lGQ2dDQUNFREFrQWdBRUdzelFOcUloSW9BZ0FpRHdSQUlBQkJxTTBEYWlFTUlBQkJ6TTBEYWlFYklBQkIwTXdEYWlFTklBQkJwSllCYWlFVklBQkJtTTBEYWlFYUlBQkJ1cGdCYWlFY0lBQkJ3SmdCYWlFT0lBTWdBV3NnRXlnQ0FDSUVjU0VGUVFBaEFnTkFBa0FDUUNBTUtBSUFJQUpCQW5ScUtBSUFJZ2NFUUNBSFFReHFJZ3NzQUFBRVFDQUxRUUE2QUFBTUFnc2dCeWdDQkNFSUlBUWdCeWdDQUNJTElBRnJjU0FGU1FSQUlBc2dBVWNFUUNBQUlBRWdDeEN6QVNBTElRRWdGQ2dDQUNBTGF5QVRLQUlBSWdSeElRVUxJQWdnQlVzTkF5QUVJQWdnQzJweElnOUJmMm9nQzBrRVFDQU5RUUFnRlNnQ0FDQUxhaUFiS0FJQUlBdHJJZ0VRdGdFZ0RTQUJJQlVvQWdBZ0R4QzJBUVVnRFVFQUlCVW9BZ0FnQzJvZ0NCQzJBUXNnR2lnQ0FDQUhLQUlRUVFKMGFpZ0NBQ0lKUVN4cUlRVWdDVUV3YWlJSUtBSUFJZ0ZCd0FCTEJIOGdCMEVzYWlFR0lBZEJOR29pQ2lnQ0FDRUVJQWRCTUdvaUF5QUJOZ0lBSUFRZ0FVa0VRQ0FIS0FJNEloQkJBRWNnQVNBUVMzRUVRQ0FSSUJBMkFnQkJyUFVDUWRnYklCRVFZRUdzOVFJUVZpQUtLQUlBSVFRZ0F5Z0NBQ0VCQ3lBR0tBSUFJQUVnQkVFZ2FpQUVRUUoyYWlJRVN3Ui9JQUVGSUFRaUFRc1FWeUlFUlFSQVFhejFBaEJXQ3lBR0lBUTJBZ0FnQ2lBQk5nSUFDeUFHS0FJQVFVQnJJQVVvQWdCQlFHc2dDQ2dDQUVGQWFoQlRHaUFEQlNBSFFUQnFDeUVFSUFkQkZHb2hBUUpBQWtBZ0JDZ0NBRVVOQUNBSElBNHBBd0NuSWdNMkFtUWdCMEVzYWlJR0tBSUFRU1JxSWdvZ0F6b0FBQ0FLSUFOQkNIWTZBQUVnQ2lBRFFSQjJPZ0FDSUFvZ0EwRVlkam9BQXlBR0tBSUFRU2hxSWdNZ0Rpa0RBRUlnaUtjaUJqb0FBQ0FESUFaQkNIWTZBQUVnQXlBR1FSQjJPZ0FDSUFNZ0JrRVlkam9BQXlBTklBRVFzUUlnQkNnQ0FDSUJRY0FBVFEwQUlBZ29BZ0FnQVVrRVFDQUpRVFJxSWdZb0FnQWhBeUFJSUFFMkFnQWdBeUFCU1FSQUlBa29BamdpQ1VFQVJ5QUJJQWxMY1FSQUlCZ2dDVFlDQUVHczlRSkIyQnNnR0JCZ1FhejFBaEJXSUFZb0FnQWhBeUFJS0FJQUlRRUxJQVVvQWdBZ0FTQURRU0JxSUFOQkFuWnFJZ05MQkg4Z0FRVWdBeUlCQ3hCWElnTkZCRUJCclBVQ0VGWUxJQVVnQXpZQ0FDQUdJQUUyQWdBTEN5QUZLQUlBUVVCcklBY29BaXhCUUdzZ0JDZ0NBRUZBYWhCVEdnd0JDeUFGS0FJQUlnRUVRQ0FCRUZJZ0JVRUFOZ0lBQ3lBSVFRQTJBZ0FnQ1VFQU5nSTBDeUFIS0FKb0lRUWdCeWdDYkNFQklBd29BZ0FpQXlBQ1FRSjBhaWdDQUNJRkJFQWdCU2dDUENJREJFQWdBeEJTQ3lBRktBSXNJZ01FUUNBREVGSUxJQVVvQWhRaUF3UkFJQU1RVWdzZ0JSQlNJQXdvQWdBaEF3c2dBeUFDUVFKMGFrRUFOZ0lBQWtBZ0FrRUJhaUlESUJJb0FnQkpCRUFEUUNBTUtBSUFJQU5CQW5ScUtBSUFJZ1ZGRFFJZ0JTZ0NBQ0FMUncwQ0lBVW9BZ1FnQVVjTkFpQUZMQUFNRFFJZ0RVRUFJQVFnQVJDMkFTQWFLQUlBSUFVb0FoQkJBblJxS0FJQUlnbEJMR29oQnlBSlFUQnFJZ2dvQWdBaUFrSEFBRXNFZnlBRlFTeHFJUVlnQlVFMGFpSUtLQUlBSVFFZ0JVRXdhaUlFSUFJMkFnQWdBU0FDU1FSQUlBVW9BamdpRUVFQVJ5QUNJQkJMY1FSQUlCY2dFRFlDQUVHczlRSkIyQnNnRnhCZ1FhejFBaEJXSUFvb0FnQWhBU0FFS0FJQUlRSUxJQVlvQWdBZ0FpQUJRU0JxSUFGQkFuWnFJZ0ZMQkg4Z0FnVWdBU0lDQ3hCWElnRkZCRUJCclBVQ0VGWUxJQVlnQVRZQ0FDQUtJQUkyQWdBTElBWW9BZ0JCUUdzZ0J5Z0NBRUZBYXlBSUtBSUFRVUJxRUZNYUlBUUZJQVZCTUdvTElRRWdCVUVVYWlFQ0FrQUNRQ0FCS0FJQVJRMEFJQVVnRGlrREFLY2lCRFlDWkNBRlFTeHFJZ1lvQWdCQkpHb2lDaUFFT2dBQUlBb2dCRUVJZGpvQUFTQUtJQVJCRUhZNkFBSWdDaUFFUVJoMk9nQURJQVlvQWdCQktHb2lCQ0FPS1FNQVFpQ0lweUlHT2dBQUlBUWdCa0VJZGpvQUFTQUVJQVpCRUhZNkFBSWdCQ0FHUVJoMk9nQURJQTBnQWhDeEFpQUJLQUlBSWdKQndBQk5EUUFDUUNBSUtBSUFJQUpKQkVBZ0NVRTBhaUlHS0FJQUlRUWdDQ0FDTmdJQUlBUWdBazhOQVNBSktBSTRJZ2xCQUVjZ0FpQUpTM0VFUUNBV0lBazJBZ0JCclBVQ1FkZ2JJQllRWUVHczlRSVFWaUFHS0FJQUlRUWdDQ2dDQUNFQ0N5QUhLQUlBSUFJZ0JFRWdhaUFFUVFKMmFpSUVTd1IvSUFJRklBUWlBZ3NRVnlJRVJRUkFRYXoxQWhCV0N5QUhJQVEyQWdBZ0JpQUNOZ0lBQ3dzZ0J5Z0NBRUZBYXlBRktBSXNRVUJySUFFb0FnQkJRR29RVXhvTUFRc2dCeWdDQUNJQ0JFQWdBaEJTSUFkQkFEWUNBQXNnQ0VFQU5nSUFJQWxCQURZQ05Bc2dCU2dDYUNFRUlBVW9BbXdoQVNBTUtBSUFJZ0lnQTBFQ2RHb29BZ0FpQlFSQUlBVW9BandpQWdSQUlBSVFVZ3NnQlNnQ0xDSUNCRUFnQWhCU0N5QUZLQUlVSWdJRVFDQUNFRklMSUFVUVVpQU1LQUlBSVFJTElBSWdBMEVDZEdwQkFEWUNBQ0FEUVFGcUlnVWdFaWdDQUVrRVFDQURJUUlnQlNFRERBRUZJQU1oQWdzTEN3c2dBQ2dDQUNBRUlBRVFaU0FjUVFFNkFBQWdEaUFPS1FNQUlBR3RmRGNEQUNBVUtBSUFJZ01nRHlJQmF5QVRLQUlBSWdSeElRVWdFaWdDQUNFUEN3c0xJQUpCQVdvaUFpQVBTUTBCREFNTEN5QUNJQklvQWdBaUFFOE5BaUFNS0FJQUlRUURRQ0FFSUFKQkFuUnFLQUlBSWdNRVFDQURRUXhxSWdNc0FBQUVRQ0FEUVFBNkFBQUxDeUFDUVFGcUlnSWdBRWtOQUFzTUFnc0xJQUFnQVNBREVMTUJJQmtnRkNnQ0FEWUNBQ0FSSkFRUEN5QVpJQUUyQWdBZ0VTUUVDNW9DQVFkL0l3UWhBaU1FUVJCcUpBUWdBRUVFYWlJRUtBSUFJZ1ZCQVdvZ0FRUi9JQUVGUWJ5MUF3c2lCaEJaYWlFQklBUWdBVFlDQUNBQklBQkJDR29pQnlnQ0FDSUlUUVJBSUFBb0FnQWdCVUVDZEdvZ0JoQnFHaUFBUVJScUlnQW9BZ0JCQVdvaEFTQUFJQUUyQWdBZ0FpUUVEd3NnQWlFRElBQW9BZ3dpQWtFQVJ5QUJJQUpMY1FSL0lBTWdBallDQUVHczlRSkIyQnNnQXhCZ1FhejFBaEJXSUFRb0FnQWhBU0FIS0FJQUJTQUlDeUVDSUFBb0FnQWdBU0FDUVNCcUlBSkJBblpxSWdKTEJIOGdBUVVnQWlJQkMwRUNkQkJYSWdKRkJFQkJyUFVDRUZZTElBQWdBallDQUNBSElBRTJBZ0FnQWlBRlFRSjBhaUFHRUdvYUlBQkJGR29pQUNnQ0FFRUJhaUVCSUFBZ0FUWUNBQ0FESkFRTDVBc0JDMzhnQUVIb3JnRnFRUUEyQWdBZ0FFSDhyZ0ZxSWdJb0FnQkJFR29oQVNBQ0lBRTJBZ0FnQVVIL0FVc0VRQ0FDUVpBQk5nSUFJQUJCK0s0QmFpSUJJQUVvQWdCQkFYWTJBZ0FMSUFCQjNLNEJhaUlFS0FJQUlRb2dBRUVFYWlJR0VGZ2hCUUpBSUFRb0FnQWlBVUg1QUVzRWYwR0F3QUlnQlVIdy93TnhJZ1ZMQkg4Z0JrRURFRlZCQXlFQlFRQUZRUU1oQVFOQUlBRkJBV29oQVNBRFFRRnFJZ0pCQW5SQjlCUnFLQUlBSUFWTkJFQWdBaUVEREFFTEN5QUdJQUVRVlNBRFFRSjBRZlFVYWlnQ0FBc2hBaUFGSUFKclFSQWdBV3QySUFGQkFuUkJuQlZxS0FJQWFnVWdBVUUvVFFSQUlBVkJnQUpKQkVBZ0JrRVFFRlVNQXdWQkFDRUJDd05BSUFGQkFXb2hBa0dBZ0FJZ0FYWWdCWEZGQkVBZ0FpRUJEQUVMQ3lBR0lBSVFWU0FCSVFVTUFndEJnSUFDSUFWQjhQOERjU0lGU3dSL0lBWkJBaEJWUVFJaEFVRUFCVUVDSVFFRFFDQUJRUUZxSVFFZ0EwRUJhaUlDUVFKMFFkQVZhaWdDQUNBRlRRUkFJQUloQXd3QkN3c2dCaUFCRUZVZ0EwRUNkRUhRRldvb0FnQUxJUUlnQlNBQ2EwRVFJQUZyZGlBQlFRSjBRZndWYWlnQ0FHb0xJUVVMSUFRZ0JDZ0NBQ0FGYWlJQklBRkJCWFpyTmdJQUlBWVFXQ0VDSUFCQjFLNEJhaUlIS0FJQUlnRkIvOUVBU3dSL1FZQWdJQUpCOFA4RGNTSUVTd1IvSUFaQkJSQlZRUVVoQVVFQUJVRUZJUUZCQUNFREEwQWdBVUVCYWlFQklBTkJBV29pQWtFQ2RFR3dGbW9vQWdBZ0JFMEVRQ0FDSVFNTUFRc0xJQVlnQVJCVklBTkJBblJCc0JacUtBSUFDeUVDSUFRZ0FtdEJFQ0FCYTNZaEFpQUJRUUowUWRBV2FnVWdBa0h3L3dOeElRUWdBVUgvRFVzRWZ5QUVRWURBQUNBRVN3Ui9JQVpCQlJCVlFRVWhBVUVBQlVFRklRRkJBQ0VEQTBBZ0FVRUJhaUVCSUFOQkFXb2lBa0VDZEVHRUYyb29BZ0FnQkUwRVFDQUNJUU1NQVFzTElBWWdBUkJWSUFOQkFuUkJoQmRxS0FJQUN5SUNhMEVRSUFGcmRpRUNJQUZCQW5SQnBCZHFCU0FFUVlDQUFpQUVTd1IvSUFaQkJCQlZRUVFoQVVFQUJVRUVJUUZCQUNFREEwQWdBVUVCYWlFQklBTkJBV29pQWtFQ2RFSFlGMm9vQWdBZ0JFMEVRQ0FDSVFNTUFRc0xJQVlnQVJCVklBTkJBblJCMkJkcUtBSUFDeUlDYTBFUUlBRnJkaUVDSUFGQkFuUkIvQmRxQ3dzaEFTQUhJQWNvQWdBZ0FTZ0NBQ0FDYWlJSmFpSUJJQUZCQ0hack5nSUFJQUJCeXFvQmFpQUFRY3FnQVdvZ0NVSC9BWEZCQVhScUlnc3VBUUFpQkVILy93TnhJZ0ZCL3dGeGFpSURMQUFBSVFJZ0F5QUNRUUZxT2dBQUlBUkJBV3BCRUhSQkVIVWlBMEgvQVhGRkJFQWdBRUhLb0FGcUlRZ2dBRUhLcWdGcUlRY0RRRUVBSUFnZ0J4Q2ZBU0FBUWNxcUFXb2dDeTRCQUNJRVFmLy9BM0VpQVVIL0FYRnFJZ01zQUFBaEFpQURJQUpCQVdvNkFBQWdCRUVCYWtFUWRFRVFkU0lEUWY4QmNVVU5BQXNMSUFCQnlxQUJhaUFKUVFGMGFpQUFRY3FnQVdvZ0FrSC9BWEZCQVhScUlnSXVBUUE3QVFBZ0FpQUJRUUZxT3dFQUlBWVFXRUVJZGlBRFFZRCtBM0Z5SWdSQkFYWWhDQ0FHUVFjUVZTQUFRZUN1QVdvaUFTZ0NBQ0VIQWtBQ1FBSkFBa0FDUUNBRkRnVUJBQUlDQUFJTERBTUxJQWdnQUVHQXJ3RnFLQUlBU3cwQklBRWdCMEVCYWlJQklBRkJDSFpyTmdJQURBSUxDeUFIQkVBZ0FTQUhRWDlxTmdJQUN3c2dDQ0FBUVlDdkFXb2lBeWdDQUVrRWYwRURCVUVFQ3lBRmFpSUNRUWhxSVFFZ0JFR0NCRThFUUNBQ0lRRUxJQU1DZndKQUlBZEJzQUZMRFFBZ0NrSEFBRWtnQUVIUXJnRnFLQUlBUWYvVEFFdHhEUUJCZ2NBQURBRUxRWUQrQVFzaUFqWUNBQ0FBUWRRQWFpSURLQUlBSVFJZ0F5QUNRUUZxTmdJQUlBQkJ4QUJxSUFKQkFuUnFJQWcyQWdBZ0F5QURLQUlBUVFOeE5nSUFJQUFnQVRZQ1dDQUFJQWcyQWx3Z0FFR3dtQUZxSWdJZ0Fpa0RBQ0FCclgwM0F3QWdBVVVFUUE4TElBQkJwSllCYWlFRUlBQkI0QUJxSWdjb0FnQWhBeUFBUWRETkEyb2lCU2dDQUNFQ0EwQWdCQ2dDQUNJQUlBTnFJQUFnQXlBSWF5QUNjV29zQUFBNkFBQWdCeUFIS0FJQVFRRnFJQVVvQWdBaUFuRWlBRFlDQUNBQlFYOXFJZ0VFUUNBQUlRTU1BUXNMQzhRRkFReC9Jd1FoQ3lNRVFZQUNhaVFFSUFzaENpQUFRY2dNYWlnQ0FDRUdJQUJCMUF4cUlnd29BZ0FpRFNnQ0JDRU9Ba0FDUUNBQkJFQWdDaUVCREFFRklBcEJCR29oQVNBS0lBMDJBZ0FnQmlnQ0RBMEJJQVloQXdzTUFRc2dCaWdDRENFR0lBSUVRQ0FHSVFNZ0FpRUlJQUVoQkVFSUlRa0ZJQUVoQnlBR0lRVUxBMEFDUUNBSlFRaEdCRUFnQ0NnQ0JDSUJJQTVIQkVBZ0FTRURJQVFoQVF3Q0N5QUVRUVJxSVFFZ0JDQUlOZ0lBSUFNb0Fnd2lCVVVOQVNBQklRY0xJQVV1QVFCQkFVWUVRQ0FGSVFNZ0JVRUVhaUVJSUFjaEJFRUlJUWtNQWdzZ0JTZ0NDQ0lJTEFBQUlBd29BZ0FzQUFBaUFVWUVRQ0FGSVFNZ0J5RUVRUWdoQ1F3Q0N3TkFJQWhCQ0dvaUNDd0FBQ0FCUmdSQUlBVWhBeUFISVFSQkNDRUpEQU1GREFFTEFBc0FDd3NnQVNBS1JnUkFJQXNrQkNBRER3c0xJQTRzQUFBaENTQURMZ0VBSWdWQkFVWUVmeUFETEFBRkJTQUFRZUNYQVdvb0FnQWdBMDhFUUNBTEpBUkJBQThMSUFNb0FnZ2lBaXdBQUNBSlJ3UkFBMEFnQWtFSWFpSUNMQUFBSUFsSERRQUxDeUFDTFFBQklnUkJmMm9pQjBFQmRDSUNJQU12QVFRZ0JVSC8vd054YTBFQklBUnJhaUlFU3dSL0lBSkJmMm9nQkVFRGJHb2dCRUVCZEc0RklBZEJCV3dnQkVzTElnSkJBV3BCL3dGeEN5RUNJQTVCQVdvaEJpQUFRWkNWQVdvaENDQUFRY1NXQVdvaERDQUFRY0NXQVdvaEJTQUFRY2lXQVdvaERTQUNRZjhCY1VFSWRDQUpRZjhCY1hJaEJBSkFBMEFnQVVGOGFpSUNLQUlBSVFjQ1FBSkFJQXdvQWdBaUFDQUZLQUlBUmdSQUlBMG9BZ0FpQUFSQUlBMGdBQ2dDQURZQ0FBVWdDRUVBRUtBQklRQUxJQUFOQVFVZ0RDQUFRWEJxSWdBMkFnQU1BUXNNQVFzZ0FDRUJJQUJCQVRzQkFDQUFJQVEyQWdRZ0FDQUdOZ0lJSUFBZ0F6WUNEQ0FISUFBMkFnUUxJQUJGQkVCQkFDRUFEQUlMSUFJZ0NrY0VRQ0FBSVFNZ0FpRUJEQUVMQ3dzZ0N5UUVJQUFMK2dJQkFuOGdBeUFBUVFocUlnVW9BZ0JCbUlBQmFpQUVFRzhhSUFVb0FnQkJtSUFCYWlJQUtBSUFCRUFnQUJEUEFTZ0NBRUV2UndSQUlBTWdCQkRJQVFzTElBVW9BZ0FpQUVHUXl3TnFMQUFBQkVBZ0F5QUJRZVM4QTJvUW13RWdCQkI0R2lBRFFRQWdCQkM2QXlBRElBUVF5QUVnQlNnQ0FDRUFDd0pBSUFCQnFJQUNhaEJaSWdZRVFDQUNJQVlnQWhCWklnRkpCSDhnQmdVZ0FRdEJBblJxSVFJRFFBSkFBa0FDUUFKQUFrQWdBaWdDQUE0d0FBSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUJBZ3NNQXdzTUFRc01CQXNnQWtFRWFpRUNEQUVMQ3lBRFFRQTJBZ0FQQ3dzQ1FBSkFJQUJCeU1zRWFpZ0NBQ0lCUWRnQVJpQUFRZUNFQTJvb0FnQkJCRVp4QkVCQkFDRUJCU0FCUWNVQVJnUkFRUUFoQVF3Q0JVRUFJUUVMQ3lBRktBSUFRZUNFQTJvb0FnQkJBVVlOQUNBRElBSWdCQkI0R2d3QkN5QURJQUlRbXdFZ0JCQjRHZ3NnQXlnQ0FCQ1RBU0VBRHd2NEFRRURmeU1FSVFNakJFSHdGbW9rQkNBRFFTUnFJUVFnQXlBQUtBSUFJZ1UyQWdBQ1FBSkFBa0FDUUNBRlFRRnJEZ01BQVFJREN5QURJQUFvQWdRMkFnUU1BZ3NnQXlBQUtBSUVRWDl6TmdJRURBRUxJQVFnQUNnQ0NCQ21CQ0FFSUFOQkJHb1FxUVFMSUFJRVFDQURJQUlRdndJTElBTW9BZ0FpQWtVRVFDQURKQVJCQVE4TElBRW9BZ0FpQUVVRVFDQURKQVJCQVE4TElBSkJBVVlnQUVFQlJuRkZCRUFnQWtFQ1JpQUFRUUpHY1VVRVFDQUNRUU5HSUFCQkEwWnhSUVJBSUFNa0JFRUFEd3NnQTBFRWFpQUJRUVJxUVNBUWEwVWhBQ0FESkFRZ0FBOExDeUFES0FJRUlBRW9BZ1JHSVFBZ0F5UUVJQUFMY2dFQmZ5QUFLQUlBSWdOQkFVWUVRQ0FBUVFScUlnTWdBeWdDQUVILy93TnhJQUVnQWhEUUJFSC8vd054TmdJQUlBQW9BZ0FoQXdzZ0EwRUNSZ1JBSUFCQkJHb2lBeUFES0FJQUlBRWdBaENaQVRZQ0FDQUFLQUlBSVFNTElBTkJBMGNFUUE4TElBQW9BZ2dnQVNBQ0VLc0VDNzRGQVFKL0lBQkJDR29pQkNnQ0FDSUNSUVJBUVFCQnpCWVFYeUlDSWdOclFUOXhJQU5xSVFNZ0FpQUROZ0x3QVNBQ0lBTkJnQUZxTmdMMEFTQUNJQU5Cb0FGcU5nTDRBU0FDSUFOQnFBRnFOZ0w4QVNBQ1FRQWdBa0dJQW1vaUEydEJQM0VnQTJvaUF6WUMrQU1nQWlBRFFZQUJhallDL0FNZ0FpQURRYUFCYWpZQ2dBUWdBaUFEUWFnQmFqWUNoQVFnQWtFQUlBSkJrQVJxSWdOclFUOXhJQU5xSWdNMkFvQUdJQUlnQTBHQUFXbzJBb1FHSUFJZ0EwR2dBV28yQW9nR0lBSWdBMEdvQVdvMkFvd0dJQUpCaUFocVFRQWdBa0dZQm1vaUEydEJQM0VnQTJvaUF6WUNBQ0FDUVl3SWFpQURRWUFCYWpZQ0FDQUNRWkFJYWlBRFFhQUJhallDQUNBQ1FaUUlhaUFEUWFnQmFqWUNBQ0FDUVpBS2FrRUFJQUpCb0FocUlnTnJRVDl4SUFOcUlnTTJBZ0FnQWtHVUNtb2dBMEdBQVdvMkFnQWdBa0dZQ21vZ0EwR2dBV28yQWdBZ0FrR2NDbW9nQTBHb0FXbzJBZ0FnQWtHWURHcEJBQ0FDUWFnS2FpSURhMEUvY1NBRGFpSUROZ0lBSUFKQm5BeHFJQU5CZ0FGcU5nSUFJQUpCb0F4cUlBTkJvQUZxTmdJQUlBSkJwQXhxSUFOQnFBRnFOZ0lBSUFKQm9BNXFRUUFnQWtHd0RHb2lBMnRCUDNFZ0Eyb2lBellDQUNBQ1FhUU9haUFEUVlBQmFqWUNBQ0FDUWFnT2FpQURRYUFCYWpZQ0FDQUNRYXdPYWlBRFFhZ0JhallDQUNBQ1FhZ1Fha0VBSUFKQnVBNXFJZ05yUVQ5eElBTnFJZ00yQWdBZ0FrR3NFR29nQTBHQUFXbzJBZ0FnQWtHd0VHb2dBMEdnQVdvMkFnQWdBa0cwRUdvZ0EwR29BV28yQWdBZ0FrR3dFbXBCQUNBQ1FjQVFhaUlEYTBFL2NTQURhaUlETmdJQUlBSkJ0QkpxSUFOQmdBRnFOZ0lBSUFKQnVCSnFJQU5Cb0FGcU5nSUFJQUpCdkJKcUlBTkJxQUZxTmdJQUlBUWdBallDQUFzZ0FDQUJOZ0lBQWtBQ1FBSkFBa0FnQVVFQmF3NERBQUVDQXdzZ0FFRUFOZ0lFRHdzZ0FFRi9OZ0lFRHdzZ0FoQ3NCQXNML2dJQkJYOGpCQ0VHSXdSQklHb2tCQ0FHUVJCcUlnTWdBQ2dDR0NJRVFSaDJPZ0FBSUFNZ0JFRVFkam9BQVNBRElBUkJDSFk2QUFJZ0F5QUVPZ0FESUFNZ0FFRVVhaUlFS0FJQUlnVkJHSFk2QUFRZ0F5QUZRUkIyT2dBRklBTWdCVUVJZGpvQUJpQURJQVU2QUFjZ0JrRUVhaUlIUVFnMkFnQWdCa0VJYWlJRlFZQi9PZ0FBSUFBZ0JVRUJJQUlRb3dFZ0JDZ0NBRUg0QTNGQndBTkhCRUFEUUNBRlFRQTZBQUFnQUNBRlFRRWdBaENqQVNBRUtBSUFRZmdEY1VIQUEwY05BQXNMSUFBZ0EwRUlJQUlRb3dFZ0FTQUFLQUlBTmdJQUlBRWdBQ2dDQkRZQ0JDQUJJQUFvQWdnMkFnZ2dBU0FBS0FJTU5nSU1JQUVnQUNnQ0VEWUNFQ0FIUVFVMkFnQWdCMEVFRUZzZ0JrRUVFRnNnQUVFY2FrSEFBQkJiSUFCQkZCQmJJQVJCQ0JCYklBTkJDQkJiSUFKRkJFQWdCaVFFRHdzZ0FFSGNBR29pQUVJQU53SUFJQUJDQURjQ0NDQUFRZ0EzQWhBZ0FFSUFOd0lZSUFCQ0FEY0NJQ0FBUWdBM0FpZ2dBRUlBTndJd0lBQkNBRGNDT0NBR0pBUUxpQUVCQW44Z0FTZ0NBRVVFUUNBQVFRQkJnUVFRVkJvUEN5QUFRUUU2QUlBRUlBQWdBU0FCRUZsQkFXb2lBVUdBQVVrRWZ5QUJCVUdBQVF0QkFuUVFVeG9qQkNFQkl3UkJFR29rQkVFVUlBRVFKU0VDSUFFa0JDQUNRY3NBYWlFQ1FRQWhBUU5BSUFBZ0FXb2lBeUFDSUFGcUlBTXRBQUJ6T2dBQUlBRkJBV29pQVVHQUJFY05BQXNMREFBZ0FFRUFRWUlFRUZRYUM5RUZBZ1IvQVg0Q1FDQUFRZWd4YWlJRkxBQUFSUVJBSUFCQnNESnFJQUFvQWdBaUF5QURLQUlBS0FJVVFRZHhRWVlCYWhFQUFEY0RBQ0FBUWJneWFrRUFPZ0FBSUFBb0FnQWlBeUFES0FJQUtBSVVRUWR4UVlZQmFoRUFBQ0VHSUFBb0FnQWlBaWdDQUNnQ0VDRUVRUUFrQlNBRUlBSWdBYWNnQVVJZ2lLZEJBQkJRSXdVaEFrRUFKQVVDUUNBQ1FRRnhSUVJBSUFBb0FnQWhBa0VBSkFWQkJpQUNFQVVoQWlNRklRUkJBQ1FGSUFSQkFYRkZCRUFnQWdSQUlBQW9BZ0FpQWtITTh3QnFLQUlBUVFOR0JFQkJBQ1FGUVFZZ0FrR1FyZ0pxUWRnTUVBWWhBaU1GSVFSQkFDUUZJQVJCQVhFTkJDQUNSUVJBSUFCQjhERnFJQUFvQWdBaUFrR0l2QU5xS1FNQU53TUFJQUlvQWdBb0FoUWhCRUVBSkFVZ0JDQUNFRTZ0SXdldFFpQ0doQ0VCSXdVaEFrRUFKQVVnQWtFQmNRMEZJQUJCK0RGcUlBRTNBd0FnQUVHQU1tb2dBQ2dDQUVIQTdnSnFLUU1BTndNQUlBVkJBVG9BQUNBREtBSUFLQUlRSVFKQkFDUUZJQUlnQXlBR3B5QUdRaUNJcDBFQUVGQWpCU0VDUVFBa0JTQUNRUUZ4UlEwSFFRQVFHQkJhQ3dzTElBTW9BZ0FvQWhBaEFrRUFKQVVnQWlBRElBYW5JQVpDSUlpblFRQVFVQ01GSVFKQkFDUUZJQUpCQVhFRVFFRUFFQmdRV2dVUEN3c0xDeEFYSVFJZ0F5Z0NBQ2dDRUNFRlFRQWtCU0FGSUFNZ0JxY2dCa0lnaUtkQkFCQlFJd1VoQTBFQUpBVWdBMEVCY1FSQVFRQVFHQkJhQlNBQ0VCNExDd3NnQUNnQ0FDSURRZnZ1QW1vc0FBQUVRQ0FEUWF6ekFHb29BZ0FpQWtHb3hBSnFMQUFBQkVBZ0FFRVlha0VBUVFVZ0FrR293QUpxSUFOQmdlOENhaUFEUVpIdkFtb2dBMEhNN3dKcUtBSUFJQU5CcSs4Q2FpQURRYUx2QW1vUXVRRWFCUThMQ3lBQVFZZ3lhaUlEUWdBM0F3QWdBMElBTndNSUlBQkJtREpxSWdNb0FnQWlBZ1JBSUFJUVVpQURRUUEyQWdBTElBQkJuREpxUVFBMkFnQWdBRUdnTW1wQkFEWUNBQ0FBUWFneWFrSUFOd01BSUFBUTRnRWFDNWNHQVFkL0l3UWhCeU1FUVJCcUpBUWdBRUVVYWlJQ0lBRkJPR29pQXlrQ0FEY0NBQ0FDSUFNcEFnZzNBZ2dnQWlBREtRSVFOd0lRSUFJZ0F5Z0NHRFlDR0NBQlFSaHFJUVlDUUFKQUlBRkJIR29pQkNnQ0FDSUNRWURBQUVrRVFDQUNCRUFNQWdWQkFDRUNDd1ZCZ01BQUlRSU1BUXNNQVFzZ0FDZ0NFRUdBZ0E5cUlBWW9BZ0FnQWhCVEdnc2dBU2dDTENJRFFZREFBQ0FDYXlJRlNRUi9JQU1GSUFVaUF3c0VRQ0FBS0FJUVFZQ0FEMm9nQW1vZ0FTZ0NLQ0FERUZNYUN5QUFRWUNBRURZQ01DQUFRUUEyQWpRZ0FTZ0NFQ0lDUlFSQUlBRW9BZ0FoQWdzZ0FFRVFhaUVEQWtBZ0FTZ0NGRUVBU2dSQUEwQUNRQUpBQWtBQ1FDQUNLQUlBUVJackRoTUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUJBZ3NNQlFzTUFRc2dBa0VvYWlFQ0RBRUxDeUFBSUFJb0Fnd1F0UVFMQ3lBREtBSUFJZ0JCb1lBUGFpMEFBRUVJZENBQVFhQ0FEMm90QUFCeUlBQkJvb0FQYWkwQUFFRVFkRUdBZ0F4eGNpRUZJQUJCbllBUGFpMEFBRUVJZENBQVFaeUFEMm90QUFCeUlBQkJub0FQYWkwQUFFRVFkRUdBZ0F4eGNpSUNJQVZxUWYvL0Qwc2lDQVJBUVFBaEFnc2dBU0FBSUFnRWYwRUFCU0FGQzJvMkFsUWdBU0FDTmdKWUlBWW9BZ0FpQWdSQUlBSVFVaUFHUVFBMkFnQWdBeWdDQUNFQUN5QUVRUUEyQWdBZ0FVRWdhaUlGUVFBMkFnQUNRQUpBSUFCQnNZQVBhaTBBQUVFSWRDQUFRYkNBRDJvdEFBQnlJQUJCc29BUGFpMEFBRUVRZEhJZ0FFR3pnQTlxTFFBQVFSaDBjaUlDUWNBL1NRUkFJQUlFUUNBRUlBSkJRR3NpQWpZQ0FDQUNCRUFnQWlFQURBTUZJQUFoQVVFQUlRSkJBQ0VBQ3dVZ0J5UUVEd3NGSUFSQmdNQUFOZ0lBUVlEQUFDRUFEQUVMREFFTElBRW9BaVFpQVVFQVJ5QUFJQUZMY1FSL0lBY2dBVFlDQUVHczlRSkIyQnNnQnhCZ1FhejFBaEJXSUFRb0FnQWhBU0FHS0FJQUlRUWdCU2dDQUFVZ0FDRUJRUUFoQkVFQUN5RUNJQVFnQVNBQ1FTQnFJQUpCQW5acUlnSkxCSDhnQVFVZ0FpSUJDeEJYSWdKRkJFQkJyUFVDRUZZTElBWWdBallDQUNBRklBRTJBZ0FnQXlnQ0FDRUJDeUFDSUFGQmdJQVBhaUFBRUZNYUlBY2tCQXNYQVFGL0lBQW9BaEFpQVFSQUlBRVFVZ3NnQUJDWUFRdFRBUUYvSXdRaEF5TUVRZEFBYWlRRUlBTkJBRFlDUkNBRFFRazJBa2dnQXlBQk5nSUFJQU5CUUd0QkFqWUNBQ0FESUFJMkFnUWdBRUVKTmdJQUlBQkJCR29pQUNBQUtBSUFRUUZxTmdJQUlBTWtCQXR3QVFGL0l3UWhBaU1FUWRBQWFpUUVJQUFzQUF0RkJFQWdBa0VBTmdKRUlBSkJDellDU0NBQ1FVQnJRUUUyQWdBZ0FpQUJOZ0lBQ3lBQUtBSUFRUUpKQkVBZ0FFRUNOZ0lBQ3lBQVFRUnFJZ0FnQUNnQ0FFRUJhallDQUVFRUVCUWlBRUVDTmdJQUlBQkJnQWhCQUJBYkMyY0JBMzhnQUNnQ0NDSUJCRUFEUUNBQktBSVFJUUlnQVNnQ0FDSURCRUFnQXhCU0N5QUJFRklnQWdSQUlBSWhBUXdCQ3dzTElBQW9BaEFpQVFSQUlBRVFVZ3NnQUVHWU1tb29BZ0FpQVVVRVFDQUFRUmhxRUk0QkR3c2dBUkJTSUFCQkdHb1FqZ0VMbndFQUlBQkJxTUFDYWhDdkFpQUFRUUJCd01zRUVGUWFJQUJCZ0lDQUVEWUNEQ0FBUWJpRUEycEJBRFlDQUNBQVFieUVBMnBCQXpZQ0FDQUFRYkNFQTJwQkFEWUNBQ0FBUVl5RkEycEJBRFlDQUNBQVFaVExBMnBCQkRZQ0FDQUFRYmlKQTJwQy8vLy8vL2YvLy8vL0FEY0RBQ0FBUWNDSkEycEMvLy8vLy9mLy8vLy9BRGNEQUNBQVFjQ0VBMnBCQWpZQ0FDQUFRWkNBQVdwQkFUWUNBQXZaQXdFRmZ5QUFRWkFCYWlJRElnRkJBRFlDQ0NBQlFRQTJBZ0JCQUNRRlFTRWdBRUdjQVdvaUJCQU1Jd1VoQVVFQUpBVWdBVUVCY1FSQUVCY2hBU0FERUkwQklBRVFIZ3RCQUNRRlFTRWdBRUdvQVdvaUJSQU1Jd1VoQVVFQUpBVWdBVUVCY1FSQUVCY2hBQVZCQUNRRlFRUkIwREVRQlNFQ0l3VWhBVUVBSkFVQ1FBSkFJQUZCQVhFTkFFRUFKQVZCR0NBQ0VBd2pCU0VCUVFBa0JTQUJRUUZ4QkVBUUZ5RUFJQUlRVWd3Q0N5QUFRVUJySUFJMkFnQkJBQ1FGUVFSQjBERVFCU0VDSXdVaEFVRUFKQVVnQVVFQmNRMEFRUUFrQlVFWUlBSVFEQ01GSVFGQkFDUUZJQUZCQVhFRVFCQVhJUUFnQWhCU0JTQUFJQUkyQWtRZ0FFRUFPZ0FBSUFCQkFEb0FEQ0FBUWdBM0F5QWdBRUVCT2dBb0lBQkJBRG9BS1NBQVFRQTZBQ29nQUVFQU9nQlFJQUJCQURvQVVTQUFRUUE2QUZJZ0FFRUFOZ0lzSUFCQkFEWUNNQ0FBUVFBMkFoZ2dBRUVBTmdJMElBQkJBRG9BdEFFZ0FFRUFPZ0MxQVNBQVFlQUFhaUlCUWdBM0F3QWdBVUlBTndNSUlBRkNBRGNERUNBQlFnQTNBeGdnQUVGL05nSklJQUJCQURZQ09DQUFRUUEyQWp3Z0FFRUFOZ0pNSUFCQmdBRnFJZ0JDQURjREFDQUFRZ0EzQXdnUEN3d0JDeEFYSVFBTElBVVFqUUVMSUFRUWpRRWdBeENOQVNBQUVCNExLUUVCZnlBQUtBSVVJZ0ZCQlVrRVFFRi9Ed3RCZnlBQUtBSUFRUVJxSUFGQmZHb1FtUUZCZjNNTDFnZ0NCSDhCZmlNRUlRWWpCRUdBRUdva0JDQUFRYWpMQkdvaUNVRUFOZ0lBQWtBQ1FBSkFBa0FDUUFKQUlBQkJxTTRLYWlnQ0FBNERBQUVBQVFzTUFRc2dBVVVFUUNBQVFmU0xDV29zQUFCRkRRRUxJQUJCcE1zRWFpQUJOZ0lBSUFCQm1JQUJhaUlIUVFBMkFnQWdBRUdraXdScUlnaEJBRFlDQUFKQUlBSUVRRUVBSkFWQkRTQUdJQUpCL2c4UUJ4b2pCU0VDUVFBa0JTQUNRUUZ4UlFSQVFRQWtCVUVSSUFZZ0IwR0FFQkFIR2lNRklRSkJBQ1FGSUFKQkFYRkZCRUJCQUNRRlFRWWdCMEdBRUJBTkl3VWhBa0VBSkFVZ0FrRUJjVVVOQXdzTERBVUxDd0pBSUFNRVFFRUFKQVZCRFNBR0lBTkIvZzhRQnhvakJTRUNRUUFrQlNBQ1FRRnhSUVJBUVFBa0JVRVJJQVlnQ0VHQUVCQUhHaU1GSVFKQkFDUUZJQUpCQVhGRkRRSUxEQVVMQ3lBRUJFQkJBQ1FGUVE4Z0J5QUVRWUFRRUFjYUl3VWhBa0VBSkFVZ0FrRUJjUTBFUVFBa0JVRUdJQWRCZ0JBUURTTUZJUUpCQUNRRklBSkJBWEVOQkFzZ0JRUkFRUUFrQlVFUUlBZ2dCVUdBRUJBSEdpTUZJUUpCQUNRRklBSkJBWEVOQkF0QkFDUUZRUVVnQUVISXl3UnFJQUZCQWtZRWYwSElEQVZCMEF3TEVBWWFJd1VoQWtFQUpBVWdBa0VCY1EwRElBQkJ5WWtEYWlBQlFRSkhPZ0FBSUFaQkFEb0FBQ0FBUWF6T0Ntb2lBaWdDQUNFRFFRQWtCVUVESUFCQndNd0phaUlFSUFCQjJNOEZhaUlCSUFNZ0JoQUlHaU1GSVFOQkFDUUZBa0FnQTBFQmNVVUVRQ0FBUWR6UEJXb2hBeUFBUWFUREJtb2hCUU5BQWtBZ0F5Z0NBRVVOQUVFQUpBVkJCaUFCRUFVaEJ5TUZJUWhCQUNRRklBaEJBWEVOQXlBSFJRMEFJQVVvQWdCQkEwY05BQ0FDS0FJQUlRZEJBQ1FGUVFNZ0JDQUJJQWNnQmhBSUdpTUZJUWRCQUNRRklBZEJBWEVOQTBFQUpBVkJGU0FCRUF3akJTRUhRUUFrQlNBSFFRRnhSUTBCREFNTEN5QUFRZUNMQ1dvcEF3QWhDa0VBSkFWQkFTQUJJQXFuSUFwQ0lJaW5RUUFRVUNNRklRQkJBQ1FGSUFCQkFYRkZEUVFMQ3d3REN5QUFRZGpQQldvaEFTQUFRZldMQ1dvc0FBQUVRQ0FBUWFUREJtb29BZ0JCQWtZRVFDQUFRWkc0QjJvc0FBQUVRRUVBSkFWQkFpQUJRUUJCQUVITUFCQUlJUUlqQlNFRFFRQWtCU0FEUVFGeERRVWdBa1VFUUNBR0pBUkJEdzhMSUFCQjRJc0phaWtEQUNFS1FRQWtCVUVCSUFFZ0NxY2dDa0lnaUtkQkFCQlFJd1VoQUVFQUpBVWdBRUVCY1EwRklBWWtCRUVBRHdzTEMwRUFKQVZCRlNBQkVBd2pCU0VBUVFBa0JTQUFRUUZ4RFFJTUFRQUxBQUFMSUFrb0FnQWhBQ0FHSkFRZ0FBOExRZGdLUVlBSUVCa2hBQ01ISVFFZ0FVSFlDaEJFUmdSQUlBQVFGUm9RRmlBR0pBUkJDdzhMSUFGQmdBZ1FSRWNFUUNBQUVCNExJQUFRRlNFQkFrQWdDU2dDQUNJQVJRUkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUVvQWdBT0RBY0lBQUVJQWdNSUJRUUlCZ2dMUVJJaEFBd0pDMEVNSVFBTUNBdEJFeUVBREFjTFFROGhBQXdHQzBFUUlRQU1CUXRCQ3lFQURBUUxRUmdoQUF3REMwRUFJUUFNQWd0QkZTRUFDd3NRRmlBR0pBUWdBQXRhQVFKL0lBQW9BaFFpQWlBQlRRUkFRUUFQQ3lBQUtBSUFJUU1nQVNFQUFrQUNRQU5BSUFNZ0FHb3NBQUJCZjB3RVFDQUFRUUZxSWdBZ0Fra0VRQXdDQlVFQUlRQU1Bd3NBQ3dzTUFRdEJBQThMUVFFZ0FXc2dBR29MTVFFQ2Z5QUFRUmhxSWdJb0FnQWlBU0FBS0FJVVR3UkFRUUFQQ3lBQ0lBRkJBV28yQWdBZ0FDZ0NBQ0FCYWl3QUFBdVFBZ0VFZnlBQUtBSUVCRUFQQ3dOQUlBUkJBWFlpQVVHZ2h1THRmbk1oQWlBRVFRRnhCSDhnQWdVZ0FTSUNDMEVCZGlJRFFhQ0c0dTErY3lFQklBSkJBWEVFZnlBQkJTQURJZ0VMUVFGMklnTkJvSWJpN1g1eklRSWdBVUVCY1FSL0lBSUZJQU1pQWd0QkFYWWlBMEdnaHVMdGZuTWhBU0FDUVFGeEJIOGdBUVVnQXlJQkMwRUJkaUlEUWFDRzR1MStjeUVDSUFGQkFYRUVmeUFDQlNBRElnSUxRUUYySWdOQm9JYmk3WDV6SVFFZ0FrRUJjUVIvSUFFRklBTWlBUXRCQVhZaUEwR2dodUx0Zm5NaEFpQUJRUUZ4Qkg4Z0FnVWdBeUlDQzBFQmRpSURRYUNHNHUxK2N5RUJJQUFnQkVFQ2RHb2dBa0VCY1FSL0lBRUZJQU1MTmdJQUlBUkJBV29pQkVHQUFrY05BQXNMM1FNQkJYOUJBQ1FGUVI4Z0FCQU1Jd1VoQVVFQUpBVWdBVUVCY1FSQUVCY2lBUkFlQzBFQUpBVkJIeUFBUWJBRWFpSUJFQXdqQlNFQ1FRQWtCU0FDUVFGeEJFQWdBU0VEQlVFQUpBVkJIeUFBUWVBSWFpSUJFQXdqQlNFQ1FRQWtCU0FDUVFGeEJFQWdBU0VEQlVFQUpBVkJIeUFBUVpBTmFpSUJFQXdqQlNFQ1FRQWtCU0FDUVFGeEJFQWdBU0VEQlVFQUpBVkJIeUFBUWNRUmFpSUVFQXdqQlNFQlFRQWtCUUpBSUFGQkFYRUVRQkFYSVFFRlFRQWtCVUVmSUFCQnZCWnFJZ0VRRENNRklRSkJBQ1FGSUFKQkFYRkZCRUJCQUNRRlFSOGdBRUcwRzJvaUFSQU1Jd1VoQWtFQUpBVWdBa0VCY1VVRVFFRUFKQVZCSHlBQVFhd2dhaUlCRUF3akJTRUNRUUFrQlNBQ1FRRnhSUVJBUVFBa0JVRWdJQUJCckNWcUVBd2pCU0VCUVFBa0JTQUJRUUZ4QkVBUUZ5RUJJd2NoQWlBQVFhd2dhaEJjSUFCQnRCdHFFRndnQUVHOEZtb1FYQ0FBUWNRUmFoQmNEQVVGSUFCQnRDZHFRUUJCZ0FnUVZCb2dBRUVBUWF3bEVGUWFEd3NBQ3dzTEVCY2hBaU1ISVFVRFFDQUJRWWg3YWlJQkVGd2dBU0FFUncwQUlBSWhBUXNMQ3lBQVFaQU5haEJjSUFCQjRBaHFFRndnQUVHd0JHb1FYQ0FBRUZ3Z0FSQWVDd3NMRUJjaEFRTkFJQU5CMEh0cUlnTVFYQ0FESUFCSERRQUxJQUVRSGd2ZkNnSURmd0YrUVFBa0JVRURJQUJCMk04RmFpSUNRUUlRQmlFREl3VWhCRUVBSkFVQ1FDQUVRUUZ4UlFSQUlBQkJyTTRLYWlBRE5nSUFJQU5CQVVnRVFDQUFRZldMQ1dvc0FBQUVRQ0FBUWFUREJtb29BZ0JCQlVZRVFDQUFRYVQ5QjJvc0FBQUVRRUVBSkFWQkFpQUNRUUJCQUVITUFCQUlJUU1qQlNFRVFRQWtCU0FFUVFGeERRVWdBMFVFUUVFUER3c2dBRUhnaXdscUtRTUFJUVZCQUNRRlFRRWdBaUFGcHlBRlFpQ0lwMEVBRUZBakJTRUNRUUFrQlNBQ1FRRnhEUVZCQUNRRlFRUWdBQ0FCRUFZaEFTTUZJUUpCQUNRRklBSkJBWEVOQlNBQkR3c0xDeUFBUVlTTUNXb3NBQUFFUUVFTUR3c2dBRUdGakFscUxBQUFCSDlCR0FWQkNnc1BDeUFBUWFqT0Ntb29BZ0JGQkVBZ0FFR1F1QWRxTEFBQUJFQkJBQ1FGUVFFZ0FFRUFRUUJCQUVFQVFRQVFDU0VDSXdVaEEwRUFKQVVnQTBFQmNRMERJQUlFUUNBQ0R3dEJBQ1FGUVFRZ0FDQUJFQVloQVNNRklRSkJBQ1FGSUFKQkFYRU5BeUFCRHdzTFFRQWtCVUVQSUFGQmdBaHFJZ0lnQUVId3p3VnFRWUFJRUFjYUl3VWhBMEVBSkFVZ0EwRUJjVVVFUUVFQUpBVkJEaUFDSUFGQmdBZ1FCeG9qQlNFQ1FRQWtCU0FDUVFGeFJRUkFRUUFrQlVFUElBRkJnREJxSWdJZ0FFR285d1pxUVlBSUVBY2FJd1VoQTBFQUpBVWdBMEVCY1VVRVFFRUFKQVZCRGlBQ0lBRkJnQ2hxUVlBSUVBY2FJd1VoQWtFQUpBVWdBa0VCY1VVRVFDQUJRWURRQUdvaUEwRUFOZ0FBSUFNZ0FFR1F1QWRxTFFBQUlnSTJBQUFnQUVHUnVBZHFMQUFBQkVBZ0F5QUNRUUp5SWdJMkFBQUxJQUJCazdnSGFpd0FBQVJBSUFNZ0FrRUVjaUlDTmdBQUN5QUFRZWk0QjJvc0FBQUVRQ0FESUFKQkVISWlBallBQUFzZ0FFSHB1QWRxTEFBQUJFQWdBeUFDUVNCeU5nQUFDeUFCUVlUUUFHb2dBRUhRdHdkcUtRTUFJZ1UrQUFBZ0FVR0kwQUJxSUFWQ0lJZytBQUFnQVVHTTBBQnFJQUJCMkxjSGFpa0RBQ0lGUGdBQUlBRkJrTkFBYWlBRlFpQ0lQZ0FBSUFGQmxOQUFhaUFBUWZTNEIyb29BZ0FFZjBFREJVRUNDellBQUNBQVFmQ0xDV29vQWdCQkEwWWhBaUFBUWFIM0Jtb3NBQUFpQTBIL0FYRWhCQ0FEQkg5QnlBRUZRVElMSVFNZ0FVR2cwQUJxSUFJRWZ5QURCU0FFQ3pZQUFDQUJRWmpRQUdvZ0FFSHN0d2RxSWdJb0FnQTJBQUJCQUNRRlFRVWdBRUc0dHdkcUVBVWhBeU1GSVFSQkFDUUZJQVJCQVhGRkJFQWdBVUdjMEFCcUlBTTJBQUFnQVVHazBBQnFJQUJCb3ZjR2FpMEFBRUV3YWpZQUFDQUJRYWpRQUdvZ0FFR2s5d1pxS0FJQU5nQUFJQUZCdE5BQWFrRUFOZ0FBSUFGQnVOQUFha0VBTmdBQUlBRkJ2TkFBYWlBQVFleTRCMm9vQWdCQkNuWTJBQUFDUUFKQUFrQUNRQ0FBUWVpM0Iyb29BZ0JCQVdzT0F3QUFBUUlMSUFGQndOQUFha0VCTmdBQURBSUxJQUZCd05BQWFrRUNOZ0FBSUFGQnhOQUFhaUlESUFJcEFBQTNBQUFnQXlBQ0tRQUlOd0FJSUFNZ0Fpa0FFRGNBRUNBRElBSXBBQmczQUJnTUFRc2dBVUhBMEFCcVFRQTJBQUFMSUFGQjVOQUFhaUFBUWZpNEIyb29BZ0FpQWpZQUFDQUNCRUFnQVVIbzBBQnFLQUFBSWdJRVFDQUJRZXpRQUdvb0FBQWlBMEYvYWtHZmpRWkpCRUJCQUNRRlFSQWdBaUFBUWZ5NEIyb2dBeEFIR2lNRklRSkJBQ1FGSUFKQkFYRU5DUXNMQ3lBQlFmRFFBR29nQUVIOCtBZHFMUUFBTmdBQVFRQVBDd3NMQ3dzTEMwR0FDQkFZSVFFakIwR0FDQkJFUndSQUlBRVFIZ3NnQVJBVklRRUNRQ0FBUWFqTEJHb29BZ0FpQUVVRVFBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJLQUlBRGd3SENBQUJDQUlEQ0FVRUNBWUlDMEVTSVFBTUNRdEJEQ0VBREFnTFFSTWhBQXdIQzBFUElRQU1CZ3RCRUNFQURBVUxRUXNoQUF3RUMwRVlJUUFNQXd0QkFDRUFEQUlMUVJVaEFBc0xFQllnQUF2RUF3RUVmeU1FSVFJakJFRkFheVFFSUFKQklHb2hBeUFBS0FJQUlnUkJBa1lFUUNBRElBQkJCR29pQlNnQ0FDSUVPZ0FBSUFNZ0JFRUlkam9BQVNBRElBUkJFSFk2QUFJZ0F5QUVRUmgyT2dBRElBRkJJQ0FEUVFRZ0FoQ25BU0FGUVFBMkFnQWdCU0FDTFFBZlFSaDBJQUl0QUI1QkVIUWdBaTBBSFVFSWRDQUNMUUFiUVJoMElBSXRBQnBCRUhRZ0FpMEFHVUVJZENBQ0xRQVhRUmgwSUFJdEFCWkJFSFFnQWkwQUZVRUlkQ0FDTFFBVFFSaDBJQUl0QUJKQkVIUWdBaTBBRVVFSWRDQUNMUUFQUVJoMElBSXRBQTVCRUhRZ0FpMEFEVUVJZENBQ0xRQUxRUmgwSUFJdEFBcEJFSFFnQWkwQUNVRUlkQ0FDTFFBSFFSaDBJQUl0QUFaQkVIUWdBaTBBQlVFSWRDQUNMUUFEUVJoMElBSXRBQUpCRUhRZ0FpMEFBVUVJZENBQ0xRQUFjbkp5SUFJdEFBUnpjM056SUFJdEFBaHpjM056SUFJdEFBeHpjM056SUFJdEFCQnpjM056SUFJdEFCUnpjM056SUFJdEFCaHpjM056SUFJdEFCeHpjM056TmdJQUlBQW9BZ0FoQkFzZ0JFRURSd1JBSUFJa0JBOExJQUZCSUNBQVFRUnFJZ0JCSUNBREVLY0JJQUFnQXlrQUFEY0FBQ0FBSUFNcEFBZzNBQWdnQUNBREtRQVFOd0FRSUFBZ0F5a0FHRGNBR0NBQ0pBUUx4Z2dCQlg4akJDRU1Jd1JCNEFScUpBUWdCa0VZU3dSQUlBd2tCQThMSUF4QndBUnFJUXNnREVHZ0JHb2hDU0FNUVlBRWFpRUtBa0FDUUNBQVFmZ1ZhaWdDQUNBR1JnUkFJQUJCeEJGcUlBSVFkd1JBSUFCQnlCVnFJQVJCRUJCclJRUkFRUUFoQWd3REN3c0xJQUJCOEJwcUtBSUFJQVpHQkVBZ0FFRzhGbW9nQWhCM0JFQWdBRUhBR21vZ0JFRVFFR3RGQkVCQkFTRUNEQU1MQ3dzZ0FFSG9IMm9vQWdBZ0JrWUVRQ0FBUWJRYmFpQUNFSGNFUUNBQVFiZ2ZhaUFFUVJBUWEwVUVRRUVDSVFJTUF3c0xDeUFBUWVBa2FpZ0NBQ0FHUmdSQUlBQkJyQ0JxSUFJUWR3UkFJQUJCc0NScUlBUkJFQkJyUlFSQVFRTWhBZ3dEQ3dzTElBTWdERUdBQkJEdEFTQU1JQXdRYmlBRVFSQWdDeUFLSUFsQkFTQUdkQkRCQWlBTVFZQUVFRnNnQUVHa0pXb2lEU2dDQUNFRElBMGdBMEVCYWpZQ0FDQUFJQU5CQTNFaUEwSDRCR3hxUWZnVmFpQUdOZ0lBSUFCQnhCRnFJQU5CK0FSc2FpQUNRWUlFRUZNYUlBQWdBMEg0Qkd4cVFjZ1ZhaUlDSUFRcEFBQTNBQUFnQWlBRUtRQUlOd0FJSUFBZ0EwSDRCR3hxUWRnVmFpSUNJQXNwQUFBM0FBQWdBaUFMS1FBSU53QUlJQUlnQ3lrQUVEY0FFQ0FDSUFzcEFCZzNBQmdnQUNBRFFmZ0ViR3BCL0JWcUlnUWdDU2tBQURjQUFDQUVJQWtwQUFnM0FBZ2dCQ0FKS1FBUU53QVFJQVFnQ1NrQUdEY0FHQ0FBSUFOQitBUnNha0djRm1vaUF5QUtLUUFBTndBQUlBTWdDaWtBQ0RjQUNDQURJQW9wQUJBM0FCQWdBeUFLS1FBWU53QVlJQUpCSUVFQlFRQVE1Z0VNQVFzZ0FDQUNRZmdFYkdwQjJCVnFJZ05CSUVFQVFRQVE1Z0VnQ3lBREtRQUFOd0FBSUFzZ0F5a0FDRGNBQ0NBTElBTXBBQkEzQUJBZ0N5QURLUUFZTndBWUlBTkJJRUVCUVFBUTVnRWdDU0FBSUFKQitBUnNha0g4RldvaUF5a0FBRGNBQUNBSklBTXBBQWczQUFnZ0NTQURLUUFRTndBUUlBa2dBeWtBR0RjQUdDQUtJQUFnQWtINEJHeHFRWndXYWlJQ0tRQUFOd0FBSUFvZ0Fpa0FDRGNBQ0NBS0lBSXBBQkEzQUJBZ0NpQUNLUUFZTndBWUN5QUhCRUFnQnlBS0tRQUFOd0FBSUFjZ0Npa0FDRGNBQ0NBSElBb3BBQkEzQUJBZ0J5QUtLUUFZTndBWUN5QUlCRUFnQ1N3QUFTQUpMQUFKY3lBSkxBQVJjeUVDSUFrc0FBSWdDU3dBQ25NZ0NTd0FFbk1oQXlBSkxBQURJQWtzQUF0eklBa3NBQk56SVFRZ0NTd0FCQ0FKTEFBTWN5QUpMQUFVY3lFR0lBa3NBQVVnQ1N3QURYTWdDU3dBRlhNaEJ5QUpMQUFHSUFrc0FBNXpJQWtzQUJaeklRb2dDU3dBQnlBSkxBQVBjeUFKTEFBWGN5RU5JQWdnQ1N3QUFDQUpMQUFJY3lBSkxBQVFjeUFKTEFBWWN6b0FBQ0FJSUFJZ0NTd0FHWE02QUFFZ0NDQURJQWtzQUJwek9nQUNJQWdnQkNBSkxBQWJjem9BQXlBSUlBWWdDU3dBSEhNNkFBUWdDQ0FISUFrc0FCMXpPZ0FGSUFnZ0NpQUpMQUFlY3pvQUJpQUlJQTBnQ1N3QUgzTTZBQWNnQ1VFZ0VGc0xJQVVFUUNBQVFhd2xhaUFCSUF0QmdBSWdCUkRsQVFzZ0MwRWdFRnNnRENRRUMrQUtBVUYvSXdRaENpTUVRY0FCYWlRRUlBcEIyQUJxSVFnZ0NrRTRhaUVKSUFwQkRHb2hEU0FLUVJocUlRc2dDa0g0QUdvaURDQUNJQU5Cd0FCSkJIOGdBd1ZCd0FBTEVGTWFJQXdnQTJwQkFEb0FBQ0FNSUFOQkFXcHFRUUE2QUFBZ0RDQURRUUpxYWtFQU9nQUFJQXdnQTBFRGFtcEJBVG9BQUNBQUlBRWdEQ0FEUVFScUlBZ1Fwd0VnQ1NBSUtRQUFOd0FBSUFrZ0NDa0FDRGNBQ0NBSklBZ3BBQkEzQUJBZ0NTQUlLUUFZTndBWUlBMGdCMEYvYWlJRE5nSUFJQTFCRURZQ0JDQU5RUkEyQWdnZ0NpQUVOZ0lBSUFvZ0JUWUNCQ0FLSUFZMkFnZ2dDRUVCYWlFcElBbEJBV29oQkNBSVFRSnFJU29nQ1VFQ2FpRUZJQWhCQTJvaEt5QUpRUU5xSVFZZ0NFRUVhaUVzSUFsQkJHb2hCeUFJUVFWcUlTMGdDVUVGYWlFT0lBaEJCbW9oTGlBSlFRWnFJUThnQ0VFSGFpRXZJQWxCQjJvaEVDQUlRUWhxSVRBZ0NVRUlhaUVSSUFoQkNXb2hNU0FKUVFscUlSSWdDRUVLYWlFeUlBbEJDbW9oRXlBSVFRdHFJVE1nQ1VFTGFpRVVJQWhCREdvaE5DQUpRUXhxSVJVZ0NFRU5haUUxSUFsQkRXb2hGaUFJUVE1cUlUWWdDVUVPYWlFWElBaEJEMm9oTnlBSlFROXFJUmdnQ0VFUWFpRTRJQWxCRUdvaEdTQUlRUkZxSVRrZ0NVRVJhaUVhSUFoQkVtb2hPaUFKUVJKcUlSc2dDRUVUYWlFN0lBbEJFMm9oSENBSVFSUnFJVHdnQ1VFVWFpRWRJQWhCRldvaFBTQUpRUlZxSVI0Z0NFRVdhaUUrSUFsQkZtb2hIeUFJUVJkcUlUOGdDVUVYYWlFZ0lBaEJHR29oUUNBSlFSaHFJU0VnQ0VFWmFpRkJJQWxCR1dvaElpQUlRUnBxSVVJZ0NVRWFhaUVqSUFoQkcyb2hReUFKUVJ0cUlTUWdDRUVjYWlGRUlBbEJIR29oSlNBSVFSMXFJVVVnQ1VFZGFpRW1JQWhCSG1vaFJpQUpRUjVxSVNjZ0NFRWZhaUZISUFsQkgyb2hLRUVBSVFJRFFDQU5JQUpCQW5ScUlVZ2dBd1JBUVFBaEF3TkFJQUFnQVNBSVFTQWdDeENuQVNBSUlBc3BBQUEzQUFBZ0NDQUxLUUFJTndBSUlBZ2dDeWtBRURjQUVDQUlJQXNwQUJnM0FCZ2dDU0FKTEFBQUlBZ3NBQUJ6T2dBQUlBUWdCQ3dBQUNBcExBQUFjem9BQUNBRklBVXNBQUFnS2l3QUFITTZBQUFnQmlBR0xBQUFJQ3NzQUFCek9nQUFJQWNnQnl3QUFDQXNMQUFBY3pvQUFDQU9JQTRzQUFBZ0xTd0FBSE02QUFBZ0R5QVBMQUFBSUM0c0FBQnpPZ0FBSUJBZ0VDd0FBQ0F2TEFBQWN6b0FBQ0FSSUJFc0FBQWdNQ3dBQUhNNkFBQWdFaUFTTEFBQUlERXNBQUJ6T2dBQUlCTWdFeXdBQUNBeUxBQUFjem9BQUNBVUlCUXNBQUFnTXl3QUFITTZBQUFnRlNBVkxBQUFJRFFzQUFCek9nQUFJQllnRml3QUFDQTFMQUFBY3pvQUFDQVhJQmNzQUFBZ05pd0FBSE02QUFBZ0dDQVlMQUFBSURjc0FBQnpPZ0FBSUJrZ0dTd0FBQ0E0TEFBQWN6b0FBQ0FhSUJvc0FBQWdPU3dBQUhNNkFBQWdHeUFiTEFBQUlEb3NBQUJ6T2dBQUlCd2dIQ3dBQUNBN0xBQUFjem9BQUNBZElCMHNBQUFnUEN3QUFITTZBQUFnSGlBZUxBQUFJRDBzQUFCek9nQUFJQjhnSHl3QUFDQStMQUFBY3pvQUFDQWdJQ0FzQUFBZ1B5d0FBSE02QUFBZ0lTQWhMQUFBSUVBc0FBQnpPZ0FBSUNJZ0lpd0FBQ0JCTEFBQWN6b0FBQ0FqSUNNc0FBQWdRaXdBQUhNNkFBQWdKQ0FrTEFBQUlFTXNBQUJ6T2dBQUlDVWdKU3dBQUNCRUxBQUFjem9BQUNBbUlDWXNBQUFnUlN3QUFITTZBQUFnSnlBbkxBQUFJRVlzQUFCek9nQUFJQ2dnS0N3QUFDQkhMQUFBY3pvQUFDQURRUUZxSWdNZ1NDZ0NBRWtOQUFzTElBb2dBa0VDZEdvb0FnQWlBeUFKS1FBQU53QUFJQU1nQ1NrQUNEY0FDQ0FESUFrcEFCQTNBQkFnQXlBSktRQVlOd0FZSUFKQkFXb2lBa0VEUndSQUlBMGdBa0VDZEdvb0FnQWhBd3dCQ3dzZ0RFSEVBQkJiSUFsQklCQmJJQWhCSUJCYklBdEJJQkJiSUFva0JBdVVDQUVNZnlNRUlRWWpCRUdRQldva0JDQUdRZmdFYWlFRklBWkI2QVJxSVFjZ0JrSGdBbW9oQ3lBR1FjUUJhaUVLSUFaQnNBRnFJUWdnQmtFVWFpRU1JQUFnQWhCM0lRa0NRQUpBSUFRRVFDQUpCRUFnQUN3QXJBUUVRQ0FBUVlRRWFpQUVRUWdRYTBVRVFFRUFJUU1NQkFzTEN5QUFRYkFFYWlBQ0VIY0VRQ0FBUWR3SWFpd0FBQVJBSUFCQnRBaHFJQVJCQ0JCclJRUkFRUUVoQXd3RUN3c0xJQUJCNEFocUlBSVFkd1JBSUFCQmpBMXFMQUFBQkVBZ0FFSGtER29nQkVFSUVHdEZCRUJCQWlFRERBUUxDd3NnQUVHUURXb2dBaEIzQkVBZ0FFRzhFV29zQUFBRVFDQUFRWlFSYWlBRVFRZ1FhMFVFUUVFRElRTU1CQXNMQ3dVZ0NRUkFJQUFzQUt3RVJRUkFRUUFoQXd3REN3c2dBRUd3QkdvZ0FoQjNCRUFnQUVIY0NHb3NBQUJGQkVCQkFTRUREQU1MQ3lBQVFlQUlhaUFDRUhjRVFDQUFRWXdOYWl3QUFFVUVRRUVDSVFNTUF3c0xJQUJCa0ExcUlBSVFkd1JBSUFCQnZCRnFMQUFBUlFSQVFRTWhBd3dEQ3dzTERBRUxJQVVnQUNBRFFiQUViR3BCakFScUlnSXBBQUEzQUFBZ0JTQUNLUUFJTndBSUlBY2dBQ0FEUWJBRWJHcEJuQVJxSWdJcEFBQTNBQUFnQnlBQ0tRQUlOd0FJSUFCQnJDVnFJQUVnQlVHQUFTQUhFT1VCSUFWQkVCQmJJQWRCRUJCYklBWWtCQThMSUFNZ0MwR0lBaEROQWhvZ0F4QlpRUUYwSVFrZ0JFRUFSeUlOQkVBZ0N5QUphaUFFS1FBQU53QUFJQWxCQ0dvaENRc2dDaEN0QkNBSVFRRnFJUTRnQ0VFQ2FpRVBJQVpCRUdvaEVFRUFJUU1EUUNBS0lBc2dDVUVBRUtNQklBZ2dBem9BQUNBT0lBTkJDSFk2QUFBZ0R5QURRUkIyT2dBQUlBb2dDRUVEUVFBUW93RWdBMEgvL3dCeFJRUkFJQXdnQ2tHY0FSQlRHaUFNSUFaQkFCQ3RBaUFISUFOQkRuWnFJQkFvQWdBNkFBQUxJQU5CQVdvaUEwR0FnQkJIRFFBTElBb2dDRUVBRUswQ0lBVWdDQ2dDQUNJRE9nQUFJQVVnQTBFSWRqb0FBU0FGSUFOQkVIWTZBQUlnQlNBRFFSaDJPZ0FESUFVZ0NDZ0NCQ0lET2dBRUlBVWdBMEVJZGpvQUJTQUZJQU5CRUhZNkFBWWdCU0FEUVJoMk9nQUhJQVVnQ0NnQ0NDSURPZ0FJSUFVZ0EwRUlkam9BQ1NBRklBTkJFSFk2QUFvZ0JTQURRUmgyT2dBTElBVWdDQ2dDRENJRE9nQU1JQVVnQTBFSWRqb0FEU0FGSUFOQkVIWTZBQTRnQlNBRFFSaDJPZ0FQSUFBZ0FFSEFFV29pQXlnQ0FFR3dCR3hxSUFKQmdnUVFVeG9nQUNBREtBSUFJZ0pCc0FSc2FpQU5PZ0NzQkNBTkJFQWdBQ0FDUWJBRWJHb2dCQ2tBQURjQWhBUUxJQUFnQWtHd0JHeHFRWXdFYWlJQ0lBVXBBQUEzQUFBZ0FpQUZLUUFJTndBSUlBQWdBeWdDQUVHd0JHeHFRWndFYWlJQ0lBY3BBQUEzQUFBZ0FpQUhLUUFJTndBSUlBTWdBeWdDQUVFQmFrRURjVFlDQUNBTFFZZ0NFRnNnQUVHc0pXb2dBU0FGUVlBQklBY1E1UUVnQlVFUUVGc2dCMEVRRUZzZ0JpUUVDKzRGQVJ4L0l3UWhCaU1FUVJCcUpBUWdBVUVCYWlJTExRQUFRUWgwSUFFdEFBQnlJQUZCQW1vaURDMEFBRUVRZEhJZ0FVRURhaUlOTFFBQVFSaDBjaUFBUWJReGFpZ0NBQ0lPY3lFQ0lBRkJCV29pRHkwQUFFRUlkQ0FCUVFScUloQXRBQUJ5SUFGQkJtb2lFUzBBQUVFUWRISWdBVUVIYWlJU0xRQUFRUmgwY2lBQVFiZ3hhaUlUS0FJQWN5RUpJQUZCQ1dvaUZDMEFBRUVJZENBQlFRaHFJaFV0QUFCeUlBRkJDbW9pRmkwQUFFRVFkSElnQVVFTGFpSVhMUUFBUVJoMGNpQUFRYnd4YWlJWUtBSUFjeUVESUFGQkRXb2lHUzBBQUVFSWRDQUJRUXhxSWhvdEFBQnlJQUZCRG1vaUd5MEFBRUVRZEhJZ0FVRVBhaUljTFFBQVFSaDBjaUFBUWNBeGFpSWRLQUlBY3lFRUlBWWdBU2tBQURjQUFDQUdJQUVwQUFnM0FBaEJIeUVIQTBBZ0FFRzBMMm9nQUVHME1Xb2dCMEVEY1VFQ2RHb29BZ0FpQ0NBRVFRdDBJQVJCRlhaeUlBTnFjeUlGUVFoMlFmOEJjV290QUFCQkNIUWdBRUcwTDJvZ0JVSC9BWEZxTFFBQWNpQUFRYlF2YWlBRlFSQjJRZjhCY1dvdEFBQkJFSFJ5SUFCQnRDOXFJQVZCR0hacUxRQUFRUmgwY2lBQ2N5RUtJQUJCdEM5cUlBZ2dBMEVSZENBRFFROTJjaUFFYzJvaUFrRUlka0gvQVhGcUxRQUFRUWgwSUFCQnRDOXFJQUpCL3dGeGFpMEFBSElnQUVHMEwyb2dBa0VRZGtIL0FYRnFMUUFBUVJCMGNpQUFRYlF2YWlBQ1FSaDJhaTBBQUVFWWRISWdDWE1oQlNBSFFYOXFJUWdnQjBFQVNnUkFJQVFoQ1NBRElRSWdDQ0VISUFvaEF5QUZJUVFNQVFzTElBRWdEaUFLY3lJQk9nQUFJQXNnQVVFSWRqb0FBQ0FNSUFGQkVIWTZBQUFnRFNBQlFSaDJPZ0FBSUJBZ0V5Z0NBQ0FGY3lJQk9nQUFJQThnQVVFSWRqb0FBQ0FSSUFGQkVIWTZBQUFnRWlBQlFSaDJPZ0FBSUJVZ0dDZ0NBQ0FEY3lJQk9nQUFJQlFnQVVFSWRqb0FBQ0FXSUFGQkVIWTZBQUFnRnlBQlFSaDJPZ0FBSUJvZ0hTZ0NBQ0FFY3lJQk9nQUFJQmtnQVVFSWRqb0FBQ0FiSUFGQkVIWTZBQUFnSENBQlFSaDJPZ0FBSUFBZ0JoRHJBU0FHSkFRTHdRVUJHbjhnQVVFQmFpSUpMUUFBUVFoMElBRXRBQUJ5SUFGQkFtb2lDaTBBQUVFUWRISWdBVUVEYWlJTExRQUFRUmgwY2lBQVFiUXhhaWdDQUNJTWN5RUNJQUZCQldvaURTMEFBRUVJZENBQlFRUnFJZzR0QUFCeUlBRkJCbW9pRHkwQUFFRVFkSElnQVVFSGFpSVFMUUFBUVJoMGNpQUFRYmd4YWlJUktBSUFjeUVJSUFGQkNXb2lFaTBBQUVFSWRDQUJRUWhxSWhNdEFBQnlJQUZCQ21vaUZDMEFBRUVRZEhJZ0FVRUxhaUlWTFFBQVFSaDBjaUFBUWJ3eGFpSVdLQUlBY3lFRElBRkJEV29pRnkwQUFFRUlkQ0FCUVF4cUloZ3RBQUJ5SUFGQkRtb2lHUzBBQUVFUWRISWdBVUVQYWlJYUxRQUFRUmgwY2lBQVFjQXhhaUliS0FJQWN5RUVBMEFnQUVHMEwyb2dBRUcwTVdvZ0IwRURjVUVDZEdvb0FnQWlCaUFFUVF0MElBUkJGWFp5SUFOcWN5SUZRUWgyUWY4QmNXb3RBQUJCQ0hRZ0FFRzBMMm9nQlVIL0FYRnFMUUFBY2lBQVFiUXZhaUFGUVJCMlFmOEJjV290QUFCQkVIUnlJQUJCdEM5cUlBVkJHSFpxTFFBQVFSaDBjaUFDY3lFRklBQkJ0QzlxSUFZZ0EwRVJkQ0FEUVE5MmNpQUVjMm9pQWtFSWRrSC9BWEZxTFFBQVFRaDBJQUJCdEM5cUlBSkIvd0Z4YWkwQUFISWdBRUcwTDJvZ0FrRVFka0gvQVhGcUxRQUFRUkIwY2lBQVFiUXZhaUFDUVJoMmFpMEFBRUVZZEhJZ0NITWhCaUFIUVFGcUlnZEJJRWNFUUNBRUlRZ2dBeUVDSUFVaEF5QUdJUVFNQVFzTElBRWdEQ0FGY3lJQ09nQUFJQWtnQWtFSWRqb0FBQ0FLSUFKQkVIWTZBQUFnQ3lBQ1FSaDJPZ0FBSUE0Z0VTZ0NBQ0FHY3lJQ09nQUFJQTBnQWtFSWRqb0FBQ0FQSUFKQkVIWTZBQUFnRUNBQ1FSaDJPZ0FBSUJNZ0ZpZ0NBQ0FEY3lJQ09nQUFJQklnQWtFSWRqb0FBQ0FVSUFKQkVIWTZBQUFnRlNBQ1FSaDJPZ0FBSUJnZ0d5Z0NBQ0FFY3lJQ09nQUFJQmNnQWtFSWRqb0FBQ0FaSUFKQkVIWTZBQUFnR2lBQ1FSaDJPZ0FBSUFBZ0FSRHJBUXVnQXdFTGZ5TUVJUUlqQkVHQUFXb2tCQ0FBUWJRbmFoQzhBaUFDSWdNZ0FVR0FBUkNlQWhvZ0F4QnVJUVFnQUVHME1XcEIrZkNPblgwMkFnQWdBRUc0TVdwQjk2VzArd00yQWdBZ0FFRzhNV3BCdGNUV3FBYzJBZ0FnQUVIQU1XcEJvK0tmcDNvMkFnQWdBRUcwTDJwQjV5eEJnQUlRVXhvZ0JFVWlDUVJBSUFNa0JBOExBMEJCQUNFRkEwQWdBRUcwSjJvZ0FTQUZhaTBBQUNBR2EwSC9BWEZCQW5ScUtBSUFJZ2RCL3dGeElnSWdBRUcwSjJvZ0JpQUJJQVZCQVhKcUxRQUFha0gvQVhGQkFuUnFLQUlBUWY4QmNTSUtSd1JBUVFFaENBTkFJQUJCdEM5cUlBSnFJZ3NzQUFBaERDQUxJQUJCdEM5cUlBY2dCV29nQ0dwQi93RnhhaUlITEFBQU9nQUFJQWNnRERvQUFDQUlRUUZxSVFnZ0FrRUJhaUlIUWY4QmNTSUNJQXBIRFFBTEN5QUZRUUpxSWdVZ0JFa05BQXNnQmtFQmFpSUdRWUFDUncwQUN5QUVRUTl4QkVBZ0JFRVBjaUVDSUFRaEFRTkFJQU1nQVdwQkFEb0FBQ0FCUVFGcUlnRWdBazBOQUFzTElBa0VRQ0FESkFRUEJVRUFJUUVMQTBBZ0FDQURJQUZxRU1RQ0lBRkJFR29pQVNBRVNRMEFDeUFESkFRTGtBSUJDSDhnQWtVRVFBOExJQUJCeURGcUlRVWdBRUhLTVdvaEJpQUFRY3d4YWlFSElBQkJ6akZxSVFnRFFDQUZJQVV1QVFBaUEwSC8vd054UWJRa2Fqc0JBQ0FHSUFCQnRDZHFJQU5CTkdwQkVIUkJFSFZCL2dOeFFRRjJRUUowYWlnQ0FDQUdMd0VBY3lJRU93RUFJQWNnQnk4QkFDQUFRYlFuYWlBRFFUUnFRUkIwUVJCMVFmNERjVUVCZGtFQ2RHb29BZ0JCRUhacklnazdBUUFnQ0NBSUx3RUFJZ3BCRDNSQmdJQUNjU0FLUVFGMmNpQUVRZi8vQTNGeklnUkJBWFlnQkVFUGRISWlCRHNCQUNBRklBUWdDVUgvL3dOeElBTkJ0Q1JxUVJCMFFSQjFRZi8vQTNGemN5SURPd0VBSUFFZ0EwRUlkaUFCTFFBQWN6b0FBQ0FCUVFGcUlRRWdBa0YvYWlJQ0RRQUxDNW9CQVFKL0lBQkZCRUJCRVE4TElBQkIyTThGYWlJQkVMSUJJUUlnQUVIQXpBbHFFS0VCSUFFUWZpQUFRZmpPQldvb0FnQWlBUVJBSUFFUVVnc2dBRUdjemdWcUtBSUFJZ0VFUUNBQkVGSUxJQUJCd00wRmFpZ0NBQ0lCQkVBZ0FSQlNDeUFBUWVUTUJXb29BZ0FpQVFSQUlBRVFVZ3NnQUVHSXpBVnFLQUlBSWdFRVFDQUJFRklMSUFBUWVTQUFFRklnQWdSL1FRQUZRUkVMQ3k4QUlBQkJxQ1ZxUVFFMkFnQWdBRUhFTVdwQkFEb0FBQ0FBUWNVeGFrRUhPZ0FBSUFCQnhqRnFRYzBBT2dBQUMya0NBbjhDZmlBQVFRUnFJUUVnQUNnQ0FFRXRSaUlDUlFSQUlBQWhBUXNnQWdSK1FuOEZRZ0VMSVFRZ0FTZ0NBQ0lBUVZCcVFRcFBCRUJCQUE4TEEwQWdBMElLZmlBQVFWQnFySHdoQXlBQlFRUnFJZ0VvQWdBaUFFRlFha0VLU1EwQUN5QURJQVIrcHdzekFRSi9JQUFvQWdBaUFnUkFJQUFoQVFVZ0FBOExBMEFnQVNBQ0VKTUJOZ0lBSUFGQkJHb2lBU2dDQUNJQ0RRQUxJQUFMTlFFQ2Z5QUFLQUlBSWdJRVFDQUFJUUVGSUFBUEN3TkFJQUVnQWtFQkVKTUNOZ0lBSUFGQkJHb2lBU2dDQUNJQ0RRQUxJQUFMVFFFQ2Z5QUNSUVJBSUFFUEN3TkFJQUVnQTBFQ2RHb2dBQ0FEUVFGMElnUkJBWEpxTFFBQVFRaDBJQUFnQkdvdEFBQnlJZ1EyQWdBZ0JFRUFSeUFEUVFGcUlnTWdBa2x4RFFBTElBRUxWUUVDZnlBQ1JRUkFJQUVQQ3dKQUEwQWdBU0FEUVFGMElnUnFJQUFvQWdBNkFBQWdBU0FFUVFGeWFpQUFLQUlBUVFoMk9nQUFJQUFvQWdCRkRRRWdBRUVFYWlFQUlBTkJBV29pQXlBQ1NRMEFDd3NnQVF1YUVRRUxmeU1FSVFZakJFR1EwQUJxSkFRZ0JrR1F3QUJxSVFJZ0JrRVFhaUVESUFCQkRHb2lDRUVBTmdBQVFRQWtCVUVFUWJET0NoQUZJUUVqQlNFRlFRQWtCUUpBQWtBZ0JVRUJjUVJBUVFBaEFVRUFJUU1NQVFWQkFDUUZRUk1nQVJBTUl3VWhCVUVBSkFVZ0JVRUJjUVJBUVlBSVFkZ0tFQmtoQUNNSElRSUZRUUFrQlVFQklBRkIyTThGYWlJRklBRVFEU01GSVFSQkFDUUZBa0FnQkVFQmNRUkFRWUFJUWRnS0VCa2hBQ01ISVFJRlFRQWtCVUVDSUFGQndNd0phaUlMSUFFUURTTUZJUVJCQUNRRklBUkJBWEVFUUVHQUNFSFlDaEFaSVFBakJ5RUNJQVVRZmd3Q0N5QUJRYWpMQkdvaUNrRUFOZ0lBSUFGQnFNNEthaUFBS0FBSU5nSUFRUUFrQlVFRElBRkJpTXdGYWlJRVFZZ2RFQTBqQlNFSFFRQWtCU0FIUVFGeEJFQWdBU0VEREFVTElBSkJBRG9BQUFKQUFrQWdBQ2dBQUNJSFJRMEFRUUFrQlVFTklBSWdCMEdBRUJBSEdpTUZJUWRCQUNRRklBZEJBWEZGRFFCQmdBaEIyQW9RR1NFQUl3Y2hBZ3dCQ3lBQUtBQUVJUWRCQUNRRlFRRWdBaUFISUFOQmdCQVFDQm9qQlNFQ1FRQWtCUUpBQWtBZ0FrRUJjUTBBUVFBa0JVRUVJQUVnQXhBTkl3VWhBa0VBSkFVZ0FrRUJjUTBBSUFGQnVJUURha0VCTmdJQUlBRkJqTXNEYWtFQk5nSUFJQUZCc01zRWFpQUFLQUFrTmdJQUlBRkJyTXNFYWlBQUtBQW9OZ0lBSUFGQm5ZVURha0VCT2dBQVFRQWtCVUVCSUFVZ0EwRUVFQWNoQWlNRklRTkJBQ1FGSUFOQkFYRU5BQUpBSUFJRVFFRUFKQVZCQVNBRlFRRVFCaUVDSXdVaEEwRUFKQVVnQTBFQmNRMENJQUpGQkVBQ1FDQUtLQUlBSWdCRkJFQkJyUFVDS0FJQUlnQkJBVTBFUUVFTklRQU1BZ3NDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCQW1zT0NnQUJCd0lEQndVRUJ3WUhDMEVTSVFBTUNBdEJEQ0VBREFjTFFSTWhBQXdHQzBFUElRQU1CUXRCRUNFQURBUUxRUXNoQUF3REMwRVlJUUFNQWd0QkZTRUFDd3NnQ0NBQU5nQUFJQXNRb1FFZ0JSQitJQUZCK000RmFpZ0NBQ0lBQkVBZ0FCQlNDeUFCUVp6T0JXb29BZ0FpQUFSQUlBQVFVZ3NnQVVIQXpRVnFLQUlBSWdBRVFDQUFFRklMSUFGQjVNd0ZhaWdDQUNJQUJFQWdBQkJTQ3lBRUtBSUFJZ0FFUUNBQUVGSUxJQUVRZVNBQkVGSkJBQ0VCREFJTElBQkJJR29pQXlBQlFmV0xDV290QUFBaUFqWUFBQ0FCUWZlTENXb3NBQUFFUUNBRElBSkJCSElpQWpZQUFBc2dBVUgwaXdscUxBQUFCRUFnQXlBQ1FRaHlJZ0kyQUFBTElBRkIrb3NKYWl3QUFBUkFJQU1nQWtFUWNpSUNOZ0FBQ3lBQlFmaUxDV29zQUFBRVFDQURJQUpCSUhJaUFqWUFBQXNnQVVIN2l3bHFMQUFBQkVBZ0F5QUNRY0FBY2lJQ05nQUFDeUFCUWZ5TENXb3NBQUFFUUNBRElBSkJnQUZ5SWdJMkFBQUxJQUZCK1lzSmFpd0FBQVJBSUFNZ0FrR0FBbkkyQUFBTElBWkNBRGNDQUNBR1FnQTNBZ2dDUUFKQUFrQUNRQ0FBUVJScUlnb29BQUJGRFFCQkFDUUZRUUlnQlNBR0VBWWhBaU1GSVFSQkFDUUZJQVJCQVhFTkFpQUNSUTBBQWtCQkFDQUdLQUlFUVFKMFFRRnlJZ0pCSUVzRWZ5QUNCVUVnQ3hCWElnUkZJZ2NFUUVFQUpBVkJGRUdzOVFJUURDTUZJUWxCQUNRRklBbEJBWEZGRFFGQmdBaEIyQW9RR1NFQUl3Y2hBZ3dGQ3dzZ0JFRUFJQUlRVkJvZ0JpZ0NBQ0VKUVFBa0JVRU9JQWtnQkNBQ1FYOXFFQWNhSXdVaEFrRUFKQVVnQWtFQmNRUkFRWUFJUWRnS0VCa2hBQ01ISVFJZ0J3MEVJQVFRVWd3RUN5QUVFRzVCQVdvaEFpQURJQU1vQUFCQkFuSTJBQUFnQUNBQ0lBb29BQUFpQTBzRWYwRVVCVUVCQ3pZQUhDQUFRUmhxSWdrZ0FpQURTUVIvSUFJaUF3VWdBd3MyQUFBZ0FFRVFhaUlBS0FBQUlBUWdBMEYvYWhCVEdpQUNJQW9vQUFCTkJFQWdBQ2dBQUNBSktBQUFRWDlxYWtFQU9nQUFDeUFIRFFFZ0JCQlNEQUVMSUFCQkFEWUFHQ0FBUVFBMkFCd0xRUUFrQlVFRklBc2dCUkFOSXdVaEFFRUFKQVVnQUVFQmNRMEFJQVlvQWdBaUFBUkFJQUFRVWdzTUF3dEJnQWhCMkFvUUdTRUFJd2NoQWdzZ0JpZ0NBQ0lEQkVBZ0F4QlNDd3dEQlNBSVFRODJBQUFnQ3hDaEFTQUZFSDRnQVVINHpnVnFLQUlBSWdBRVFDQUFFRklMSUFGQm5NNEZhaWdDQUNJQUJFQWdBQkJTQ3lBQlFjRE5CV29vQWdBaUFBUkFJQUFRVWdzZ0FVSGt6QVZxS0FJQUlnQUVRQ0FBRUZJTElBUW9BZ0FpQUFSQUlBQVFVZ3NnQVJCNUlBRVFVa0VBSVFFTEN5QUdKQVFnQVE4TFFZQUlRZGdLRUJraEFDTUhJUUlMQ3lBQklRTU1CUXNMSUFGQitNNEZhaWdDQUNJREJFQWdBeEJTQ3lBQlFaek9CV29vQWdBaUF3UkFJQU1RVWdzZ0FVSEF6UVZxS0FJQUlnTUVRQ0FERUZJTElBRkI1TXdGYWlnQ0FDSURCRUFnQXhCU0N5QUJRWWpNQldvb0FnQWlBd1JBSUFNUVVnc2dBUkI1Q3lBQkVGSkJBQ0VCUVFBaEF3c01BUXRCZ0FoQjJBb1FHU0VBSXdjaEFnc2dBa0dBQ0JCRVJ3UkFJQUpCMkFvUVJFY0VRQ0FBRUI0TElBQVFGUm9nQ0VFTE5nQUFJQUVFUUNBQlFjRE1DV29Rb1FFZ0FVSFl6d1ZxRUg0Z0FVSDR6Z1ZxS0FJQUlnQUVRQ0FBRUZJTElBRkJuTTRGYWlnQ0FDSUFCRUFnQUJCU0N5QUJRY0ROQldvb0FnQWlBQVJBSUFBUVVnc2dBVUhrekFWcUtBSUFJZ0FFUUNBQUVGSUxJQUZCaU13RmFpZ0NBQ0lBQkVBZ0FCQlNDeUFCRUhrZ0F4QlNDeEFXSUFZa0JFRUFEd3NnQUJBVktBSUFJUUFDUUFKQUlBRkJBRWNpQWdSQUlBRkJxTXNFYWlnQ0FDSUZCRUFnQ0NBRk5nQUFEQUlMQ3lBSUFuOENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBQTRNQndnQUFRZ0NBd2dGQkFnR0NBdEJFZ3dJQzBFTURBY0xRUk1NQmd0QkR3d0ZDMEVRREFRTFFRc01Bd3RCR0F3Q0MwRUFEQUVMUVJVTE5nQUFJQUlOQUF3QkN5QUJRY0RNQ1dvUW9RRWdBVUhZendWcUVINGdBVUg0emdWcUtBSUFJZ0FFUUNBQUVGSUxJQUZCbk00RmFpZ0NBQ0lBQkVBZ0FCQlNDeUFCUWNETkJXb29BZ0FpQUFSQUlBQVFVZ3NnQVVIa3pBVnFLQUlBSWdBRVFDQUFFRklMSUFGQmlNd0ZhaWdDQUNJQUJFQWdBQkJTQ3lBQkVIa2dBeEJTQ3hBV0lBWWtCRUVBQzdRS0FnNS9BWDRqQkNFREl3UkJnTThEYWlRRUlBTkJxTTREYWlFRklBQkJyTHdEYWl3QUFBUkFJQVZCQURZQ1JDQUZRUnMyQWtnZ0JVRkFhMEVCTmdJQUlBVWdBRUVZYWpZQ0FFR3M5UUpCQXhCa0lBTWtCRUVBRHdzZ0EwSFl6UU5xSVFrZ0EwSGN6UU5xSVFRZ0F5RUdJQUJCOEswQ2FpRUxJQUJCaXE0Q2FpSU1MUUFBUVFWTUJFQWdBRUdKcmdKcUlnMHRBQUFoQXlBQVFaaThBMm9vQWdCQkEwWUVmMEV5QlVFZEN5QURUd1JBSUFCQnVPNENhaUlPS1FNQVFnQlJCRUFnQUVINTdnSnFMQUFBUlFSQUlBWWtCRUVCRHdzTElBQkI4UEVBYWlJSUVNSUVJQVlnQ0JDaUFpQUFRZFR2QW1vb0FnQWhBMEVBSkFWQkJTQUdJQU5CQUJBT0l3VWhBMEVBSkFVQ1FDQURRUUZ4UlFSQUFuOENRQ0FDRFFBZ0FFSEE3Z0pxSWc4cEF3QWlFVUtBZ0lBSVZRUkFJQVJCQURZQ1JDQUVRUncyQWtnZ0JFRkFhMEVCTmdJQUlBUWdBRUVZYWpZQ0FFRUFKQVVqQlNFQlFRQWtCU0FCUVFGeERRUkJBQXdDQ3lBQlJRUkFJQUJCbWZJQWFrRUJPZ0FBREFFTElBRkJDR29pQ2lnQ0FDRUVJQUZCQkdvaUVDQVJweUlETmdJQUlCR25JUWNnQkNBRFNRUi9JQUVvQWd3aUIwRUFSeUFISUFOSmNRUkFRUUFrQlNBSklBYzJBZ0JCQWtHczlRSkIyQnNnQ1JBT0l3VWhBMEVBSkFVZ0EwRUJjUTBGUVFBa0JVRVVRYXoxQWhBTUl3VWhBMEVBSkFVZ0EwRUJjUTBGSUFvb0FnQWhCQ0FRS0FJQUlRTUxJQUVvQWdBZ0F5QUVRU0JxSUFSQkFuWnFJZ1JMQkg4Z0F3VWdCQ0lEQ3hCWElnUkZCRUJCQUNRRlFSUkJyUFVDRUF3akJTRUhRUUFrQlNBSFFRRnhEUVVMSUFFZ0JEWUNBQ0FLSUFNMkFnQWdEeWtEQUtjRklBY0xJUU1nQVNnQ0FDRUVRUUFrQlVFTElBZ2dCQ0FERUE0akJTRURRUUFrQlNBRFFRRnhEUU1MSUFCQisrNENhaXdBQUFSQVFRQWdBRUdzOHdCcUtBSUFJZ05CcU1RQ2Fpd0FBRVVOQVJvZ0EwR293QUpxSVFRZ0FFSDg3Z0pxS0FJQUlRY2dBRUdCN3dKcUlRTWdBRUdBN3dKcUxBQUFSUVJBUVFBaEF3c2dBRUhNN3dKcUtBSUFJUWxCQUNRRlFRRWdDRUVBSUFjZ0JDQURJQUJCa2U4Q2FpQUpJQUJCcSs4Q2FpQUFRYUx2QW1vUUVpTUZJUU5CQUNRRklBTkJBWEVOQXdzZ0FFSFE3Z0pxSWdNb0FnQWhCRUVBSkFWQkJDQUFRWmp6QUdvaUJ5QUVRUUVRRGlNRklRUkJBQ1FGSUFSQkFYRU5BaUFBUVpEeUFHb2dEaWtEQURjREFDQUFRWmp5QUdwQkFEb0FBRUVBSkFWQkF5QUlJQUFnQWhBT0l3VWhBa0VBSkFVZ0FrRUJjUTBDSUFCQndmSUFhaUFBUWZudUFtb3NBQUE2QUFBZ0FFR284Z0JxSUFzMkFnQWdBRUdzOGdCcVFRQTJBZ0FnQmtHd21BRnFJQUJCd080Q2Fpa0RBQ0lSTndNQUlBWkJ5SmdCYWtFQU9nQUFJQXdzQUFBRVFDQU5MUUFBSVFKQkFDUUZRUVlnQmlBQ1FRQVFEZ1ZCQUNRRlFRSWdDQ0FScHlBUlFpQ0lweEJQQ3lNRklRSkJBQ1FGSUFKQkFYRU5BaUFBUWF2dkFtb2hBaUFBUWFydkFtb3NBQUJGQkVCQkFDRUNDMEVBSkFWQkZ5QUhJQU1nQWhBSElRSWpCU0VEUVFBa0JTQURRUUZ4RFFJZ0FnUi9RUUVGSUFWQkFEWUNSQ0FGUVIwMkFrZ2dCU0FBUVJocU5nSUFJQVZCUUd0QkFqWUNBQ0FGSUFCQmtLNENhallDQkVFQUpBVWpCU0VDUVFBa0JTQUNRUUZ4RFFOQkFDUUZRUXBCclBVQ1FRTVFEU01GSVFKQkFDUUZJQUpCQVhFTkF5QUJCRUFnQVNnQ0FDSUFCRUFnQUJCU0lBRkJBRFlDQUFzZ0FVRUFOZ0lFSUFGQkFEWUNDQXRCQUFzTElRQWdCaENWQVNBR0pBUWdBQThMQ3hBWElRRWdCaENWQVNBQkVCNExDeUFGUVFBMkFrUWdCVUVjTmdKSUlBVkJRR3RCQVRZQ0FDQUZJQUJCR0dvMkFnQWdCaVFFUVFBTFh3SUJmd0YrSUFCQnRLWUJhaWdDQUNBQVFhaThBMm9vQWdCcXJTRUNJQUJCbUx3RGFpZ0NBRUVDUmdSK0lBQkJ4S1lCYWlnQ0FLMGdBbndGSUFCQmhLY0JhaWdDQUNFQklBQWdBRUhFcGdGcUtBSUFFUEFCSUFGcXJTQUNmQXNMRHdBZ0FFR1I2UUZxTEFBQVFRQkhDNVFCQVFWL0lBQVFmQ0lDUlFSQVFRQVBDeUFBUWN6ekFHb2hBeUFBUVpDdUFtb2hCUUpBQTBBZ0F5Z0NBQ0lFUVFWR0JFQkJBQ0VDREFJTElBWkJBV29pQmtIL0FIRkZCRUFRaFFFZ0F5Z0NBQ0VFQ3lBRVFRTkdCRUFnQlNBQkVITkZEUUlMSUFBZ0FFR1F2QU5xS1FNQVFRQWdBQ2dDQUNnQ0VFRURjVUc0QW1vUkFnQWdBQkI4SWdJTkFFRUFJUUlMQ3lBQ0M3QU5BalIvQTM0akJDRUZJd1JCb01FQWFpUUVJQUZCRkdvaUNTZ0NBQ0FDYXlJRUlBRkJHR29pQnlnQ0FFa0VRQ0FGSkFRUEN5QUhJQVEyQWdBZ0FrRUJUUVJBSUFVa0JBOExJQVZCK0FCcUlSRWdCVUh3QUdvaEVpQUZRWURCQUdvaEV5QURRUVJxSVFvZ0EwRWVhaUVjSUFCQmlMd0RhaUVVSUFOQk1Hb2hIU0FEUVNCcUlRc2dBMEd4d1FCcUlRZ2dBMEc2d1FCcUlSNGdBMEhjd1FCcUlSOGdBRUVZYWlFVklBVkJnQUZxSWdSQlFHc2hJQ0FFUWNRQWFpRWhJQVJCeUFCcUlTSWdCRUVFYWlFaklBTkJrY0VBYWlFa0lBTkJvY0VBYWlFbElBTkJrTUVBYWlFbUlBTkJqTUVBYWlFbklBTkJpOEVBYWlFb0lBTkJzc0VBYWlFTUlBUkJRR3NoS1NBRVFjUUFhaUVxSUFSQnlBQnFJU3NnQkVFRWFpRXNJQU5CNE1BQWFpSXRRUVJxSVM0Z0EwSEF3QUJxSVJZZ0EwRzR3QUJxSVJjZ0EwR3d3QUJxSVJnZ0EwSGp3UUJxSVM4Z0FFSFFwd0ZxSVRBZ0EwSHd3UUJxSVRFZ0EwSDBnUUZxSVRJZ0EwSDB3UUJxSVRNZ0EwSDJnUUZxSVJrZ0EwSDNnUUZxSVJvZ0EwSDRnd0ZxSVEwZ0EwSDRnUUZxSVE0Z0EwSDFnUUZxSVRRZ0EwSDhoUUZxSVRVZ0EwSDRoUUZxSVRZZ0EwR2d3QUJxSWdaQkNHb2hEeUFHUVFScUlSc2dCa0VNYWlFM0FrQURRQ0FCRUdFaU9FSUFVUTBCSUFrb0FnQWdCeWdDQUNJQWF5SUNSU0E0SUFLdFZYSU5BU0FCRUdFaE9pQUhLQUlBSVFNZ09rSUJVU0FLS0FJQUlnSkJBVVp4QkVBZ0hFRUJPZ0FBSUFFUVlhY2lBa0VCY1FSQUlBRVFZU0k1UWdCU0JFQWdDeUFVS1FNQUlEbDhOd01BQ3dzZ0FrRUNjUVJBSUFFUVlTSTVRZ0JTQkVBZ0hTQVVLUU1BSURsOE53TUFDd3NnQ2lnQ0FDRUNDeUE0SUFDdGZLY2lFQ0FEYXlFQUFrQWdBa0YrY1VFQ1JnUkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQTZRZ0Y5SWpoQ0lJaW5EUWNnT0tjT0J3QUJBZ01FQlFZSEN5QUJFR0duQkVBZ0trRUFOZ0lBSUN0QklEWUNBQ0FFSUJVMkFnQWdLVUVDTmdJQUlDd2dDellDQUVHczlRSkJBUkJrREFrTElBZ2dBUkJocHlJQVFRRnhPZ0FBSUI0Z0FFRUJka0VCY1RvQUFDQWZJQUVRdXdJaUFFSC9BWEUyQWdBZ0FFSC9BWEZCR0VvRVFDQWhRUUEyQWdBZ0lrRWdOZ0lBSUFRZ0ZUWUNBQ0FnUVFJMkFnQWdJeUFMTmdJQVFhejFBa0VCRUdRTElBRWdKRUVRRUhvYUlBRWdKVUVRRUhvYUlBZ3NBQUFFUUNBQklBeEJDQkI2R2lBQklBUkJCQkI2R2lBRkVLSUJJQVVnREVFSUVIMGdCU0FURUpjQklBZ2dCQ0FUUVFRUWEwVTZBQUFnQ2lnQ0FFRURSZ1JBSUF4QnRMd0RRUWdRYTBVRVFDQUlRUUE2QUFBTEN3c2dKa0VCT2dBQUlDZEJCVFlDQUNBb1FRRTZBQUFNQ0FzZ0FSQmhwdzBISUMxQkF6WUNBQ0FCSUM1QklCQjZHZ3dIQ3lBQVFRaE5EUVlnQVJCaHB5SUFRUUZ4UVFCSElRSWdBRUVDY1FSQUlBSUVRQ0FZSUFFUXBnR3NRb0N0NGdSK1FvQ0ErcW50dSt6T0FYdzNBd0FGSUJnZ0FSRG9BVGNEQUFzTElBQkJCSEVFUUNBQ0JFQWdGeUFCRUtZQnJFS0FyZUlFZmtLQWdQcXA3YnZzemdGOE53TUFCU0FYSUFFUTZBRTNBd0FMQ3lBQVFRaHhSUTBHSUFJRVFDQVdJQUVRcGdHc1FvQ3Q0Z1IrUW9DQStxbnR1K3pPQVh3M0F3QUZJQllnQVJEb0FUY0RBQXNNQmdzZ0FFVU5CU0FCRUdFYUlBRVFZYWNpQUVVTkJTQXZRUUU2QUFBZ0VpQUFOZ0lBSUFSQkZFR2NEaUFTRUtvREdpQXdJQVJCZ0JBUWVCb01CUXNnTVNBQkVHRStBZ0FnTWlBQkVHR25RUUZ4T2dBQUlBRVFZYWNoQUNBRVFRQTZBQUFnQUVIL1Awa0VRQ0FCSUFRZ0FCQjZHaUFFSUFCcVFRQTZBQUFMSUFRZ00wR0FFQkM2QVJvTUJBc2dHU0FCRUdHbklnSkJBblpCQVhFNkFBQWdHaUFDUVFOMlFRRnhPZ0FBSUExQkFEb0FBQ0FPUVFBNkFBQWdBa0VCY1FSQUlBRWdEaUFCRUdHbklnQkIvd0ZKQkg4Z0FBVkIvd0VpQUFzUWVob2dEaUFBYWtFQU9nQUFDeUFDUVFKeEJFQWdBU0FOSUFFUVlhY2lBRUgvQVVrRWZ5QUFCVUgvQVNJQUN4QjZHaUFOSUFCcVFRQTZBQUFMSUJrc0FBQUVRQ0EySUFFUVlUNENBQXNnR2l3QUFBUkFJRFVnQVJCaFBnSUFDeUEwUVFFNkFBQU1Bd3NnQWtFRFJnUkFJQUFnQ1NnQ0FDQVFhMEVCUm1vaEFBc2dEeWdDQUNFRElCc2dBRFlDQUNBRElBQkpCRUFnTnlnQ0FDSUNRUUJISUFBZ0FrdHhCSDhnRVNBQ05nSUFRYXoxQWtIWUd5QVJFR0JCclBVQ0VGWWdEeWdDQUNFRElCc29BZ0FGSUFBTElRSWdCaWdDQUNBQ0lBTkJJR29nQTBFQ2Rtb2lBMHNFZnlBQ0JTQURJZ0lMRUZjaUEwVUVRRUdzOVFJUVZnc2dCaUFETmdJQUlBOGdBallDQUFzZ0FTQUdLQUlBSUFBUWVob0xDd3NnQnlBUU5nSUFJQWtvQWdBZ0VHdEJBVXNOQUFzTElBVWtCQXZCQWdFRmZ5TUVJUUVqQkVHQUJXb2tCQ0FBUWF6ekFHb2lBeWdDQUNJRVFhakVBbW9zQUFBRVFDQUJKQVFQQ3lBQlFZQUVhaUVDQW44Q1FDQUVRYkRMQkdvb0FnQWlCVVVOQUNBQlFRQTJBZ0FDUUFKQVFRUWdCRUdzeXdScUtBSUFJQUZCZ0FFZ0JVRVBjVUhxQUdvUkF3QkJmMFlFUUNBQlFRQTJBZ0FNQVFVZ0FTZ0NBRVVOQVFzTUFRc2dBa0VBT2dBQVFRSWdBeWdDQUNJRVFhekxCR29vQWdBZ0FrR0FBU0FFUWJETEJHb29BZ0JCRDNGQjZnQnFFUU1BUVg5R0JFQWdBa0VBT2dBQUN5QUNRUUFnQVVHQUFSRERBUm9nQWtHQUFSQmJDeUFES0FJQVFhakFBbW9nQVJDdUFpQUJRWUFFRUZzZ0F5Z0NBQ0lDUWFqRUFtb3NBQUJGRFFBZ0Fnd0JDeUFBRUxJQkdpQURLQUlBUWFqTEJHcEJGallDQUVHczlRSkIvd0VRcEFFZ0F5Z0NBQXNpQUVHdHhBSnFRUUU2QUFBZ0FTUUVDODhwQWhOL0EzNGpCQ0VCSXdSQjRNY0FhaVFFSUFGQjJBZHFJUTBnQVNJSFFZZ0hhaUVESUFkQnZBWnFJUVFnQjBId0JXb2hEaUFIUWFRRmFpRVFJQWRCMkFScUlRb2dCMEdNQkdvaEFTQUhRY0FEYWlFTElBZEI5QUpxSVF3Z0IwR29BbW9oQWlBSFFkd0JhaUVJSUFkQmtBRnFJUVlnQjBId0FHb2lCU0FBRUxnQkFrQUNRQUpBSUFCQnBMd0RhaUlTTEFBQUJFQWdBRUdJdkFOcUlnOHBBd0FnQUVHb3ZBTnFLQUlBclVJSWZGVUVRRUVBSkFWQkhDQUFFQXdqQlNFSlFRQWtCU0FKUVFGeEJFQVFGeUVBREFVTElBQW9BZ0FvQWd3aENVRUFKQVVnQ1NBQUlBMUJFQkFISVFrakJTRVJRUUFrQlFKL0FrQWdFVUVCY1EwQUlBbEJFRWNFUUVFQUpBVkJCU0FBRUU2dEl3ZXRRaUNHaENFVUl3VWhBVUVBSkFVZ0FVRUJjUTBCQWtBQ1FDQVBLUU1BSUJSU0RRQWdBRUdRdkFOcUtRTUFJQlJTRFFBTUFRc2dCa0VBTmdKRUlBWkJOellDU0NBR1FVQnJRUUUyQWdBZ0JpQUFRUmhxTmdJQVFRQWtCU01GSVFCQkFDUUZJQUJCQVhFTkFrRUFKQVZCQ2tHczlRSkJBUkFOSXdVaEFFRUFKQVVnQUVFQmNRMENDMEVBSVFBTUJnc2dBRUdzOHdCcUtBSUFRYWpBQW1vaEJpQUFRWkNuQVdvb0FnQWhEMEVBSkFWQkFTQUFRWnpBQUdvaUNVRUFRUVVnQmlBQVFaU25BV29nRFNBUFFRQWdCeEFLR2lNRklRWkJBQ1FGQWtBZ0JrRUJjVVVFUUNBQVFZeW5BV29zQUFBRVFDQUhJQUJCcEtjQmFrRUlFR3NFUUNBSVFRQTJBa1FnQ0VFR05nSklJQWhCUUd0QkFUWUNBQ0FJSUFCQkdHbzJBZ0JCQUNRRkl3VWhBVUVBSkFVZ0FVRUJjUTBESUFCQnJid0Rha0VCT2dBQVFRQWtCVUVLUWF6MUFrRUxFQTBqQlNFQVFRQWtCU0FBUVFGeERRTkJBQ0VBREFrTEN5QUZJQWsyQWh4QkFTRUlEQVlMQ3hBWERBRUxFQmNMSVFBTUJBVkJBQ0VJQ3dWQkFDRUlDd3RCQUNRRlFRb2dCVUVIRUFZaEJpTUZJUTlCQUNRRkFrQWdEMEVCY1VVRVFDQUdRUWRKQkVCQkFDUUZRUVVnQUJCT3JTTUhyVUlnaG9RaEZDTUZJUUZCQUNRRklBRkJBWEVOQWlBQVFZaThBMm9wQXdBZ0ZGRUVRQ0FBUVpDOEEyb3BBd0FnRkZFRVFFRUFJUUFNQlFzTElBSkJBRFlDUkNBQ1FUYzJBa2dnQWtGQWEwRUJOZ0lBSUFJZ0FFRVlhallDQUVFQUpBVWpCU0VBUVFBa0JTQUFRUUZ4RFFKQkFDUUZRUXBCclBVQ1FRRVFEU01GSVFCQkFDUUZJQUJCQVhFTkFrRUFJUUFNQXdzZ0FFR1lwZ0ZxSVFJZ0FFR29wZ0ZxSWc5QkFEb0FBRUVBSkFWQkRDQUZFQVVoQmlNRklRbEJBQ1FGSUFsQkFYRkZCRUFnQWlBR05nSUFRUUFrQlVFTklBVkJCQkFHSVFZakJTRUpRUUFrQlNBSlFRRnhCRUFRRnlFQURBVUxRUUFrQlVFRElBVVFUcTBqQjYxQ0lJYUVJUlFqQlNFSlFRQWtCUUpBSUFsQkFYRkZCRUFnQmtVZ0ZFSUFVWElFUUNBTVFRQTJBa1FnREVFWU5nSklJQXhCUUd0QkFUWUNBQ0FNSUFCQkdHbzJBZ0JCQUNRRkl3VWhBVUVBSkFVZ0FVRUJjUTBDSUFCQnJMd0Rha0VCT2dBQVFRQWtCVUVLUWF6MUFrRURFQTBqQlNFQVFRQWtCU0FBUVFGeERRSkJBQ0VBREFZTEFrQWdCa0Y5YWlBVXB5SU1haUlKUVFCSUlBWkJCR29nREdvaUJrRUhTWElFUUNBTFFRQTJBa1FnQzBFWU5nSklJQXRCUUd0QkFUWUNBQ0FMSUFCQkdHbzJBZ0JCQUNRRkl3VWhBVUVBSkFVZ0FVRUJjVVVFUUNBQVFheThBMnBCQVRvQUFFRUFKQVZCQ2tHczlRSkJBeEFOSXdVaEFFRUFKQVVnQUVFQmNVVUVRRUVBSVFBTUNRc0xCVUVBSkFWQkNpQUZJQWtRQmhvakJTRUxRUUFrQlNBTFFRRnhSUVJBSUFWQkZHb2lDU2dDQUNBR1NRUkFRUUFrQlVFRklBQVFUcTBqQjYxQ0lJYUVJUlFqQlNFQ1FRQWtCU0FDUVFGeERRTWdBRUdJdkFOcUtRTUFJQlJSQkVBZ0FFR1F2QU5xS1FNQUlCUlJCRUJCQUNFQURBc0xDeUFCUVFBMkFrUWdBVUUzTmdKSUlBRkJRR3RCQVRZQ0FDQUJJQUJCR0dvMkFnQkJBQ1FGSXdVaEFFRUFKQVVnQUVFQmNRMERRUUFrQlVFS1FhejFBa0VCRUEwakJTRUFRUUFrQlNBQVFRRnhEUU5CQUNFQURBa0xRUUFrQlVFUElBVVFCU0VSSXdVaEFVRUFKQVVnQVVFQmNVVUVRRUVBSkFWQkF5QUZFRTZ0SXdldFFpQ0doQ0VVSXdVaEFVRUFKQVVnQVVFQmNVVUVRQ0FBUVp5bUFXb2lDeUFVUGdJQVFRQWtCVUVESUFVUVRxMGpCNjFDSUlhRUlSUWpCU0VCUVFBa0JTQUJRUUZ4UlFSQUlBQkJvS1lCYWlJTUlCU25JZ0UyQWdBZ0R5QUJRUUoyUVFGeE9nQUFJQUJCcEtZQmFpSVBJQVkyQWdBZ0FFSE04d0JxSWdZZ0N5Z0NBRFlDQUFKQUlBSW9BZ0FnRVVjaUVRUkFJQXBCQURZQ1JDQUtRUmcyQWtnZ0NrRkFhMEVCTmdJQUlBb2dBRUVZYWlJQk5nSUFRUUFrQlNNRklRcEJBQ1FGQWtBZ0NrRUJjVVVFUUNBQVFheThBMm9pQ2tFQk9nQUFRUUFrQlVFS1FhejFBa0VERUEwakJTRVRRUUFrQlNBVFFRRnhEUUVnQ2tFQk9nQUFRUUFrQlVFS1FhejFBa0VERUEwakJTRUtRUUFrQlNBS1FRRnhEUUVnQ0VVRVFDQU1LQUlBSVFFTUJBc2dFRUVBTmdKRUlCQkJCRFlDU0NBUUlBRTJBZ0FnRUVGQWEwRUNOZ0lBSUJBZ0FUWUNCRUVBSkFVakJTRUJRUUFrQlNBQlFRRnhEUUVnQUVHdHZBTnFRUUU2QUFCQkFDRUFEQThMQ3hBWElRQU1EZ3NMQWtBZ0FVRUJjUVJBUVFBa0JVRURJQVVRVHEwakI2MUNJSWFFSVJRakJTRUJRUUFrQlFKQUlBRkJBWEZGQkVBZ0ZDQVBLQUlBclZRRVFDQU1LQUlBSVFFTUJBc2dEa0VBTmdKRUlBNUJHRFlDU0NBT1FVQnJRUUUyQWdBZ0RpQUFRUmhxTmdJQVFRQWtCU01GSVFGQkFDUUZJQUZCQVhFTkFTQUFRYXk4QTJwQkFUb0FBRUVBSkFWQkNrR3M5UUpCQXhBTkl3VWhBRUVBSkFVZ0FFRUJjVVVFUUVFQUlRQU1FQXNMQ3hBWElRQU1EZ1ZDQUNFVUN3c0NRQUpBSUFGQkFuRkZEUUJCQUNRRlFRTWdCUkJPclNNSHJVSWdob1FoRlNNRklRRkJBQ1FGSUFGQkFYRkZEUUFNQVFzZ0FFR0l2QU5xSWhBcEF3QWhGaUFQS0FJQUlRRkJBQ1FGUVFzZ0FDQUJFQVloQVNNRklRNUJBQ1FGSUE1QkFYRU5BQ0FBUVpDOEEyb2lEaUFXSUJWOElBR3RmRGNEQUFKQUFrQUNRQUpBQWtBZ0N5Z0NBQ0lLUVFGckRnVUJBZ0lBQXdRTElBQkIrS1lCYWlJQklBSXBBZ0EzQWdBZ0FTQUNLUUlJTndJSUlBRWdBaWdDRURZQ0VFRUFKQVZCQXlBRkVFNnRJd2V0UWlDR2hDRVVJd1VoQVVFQUpBVUNRQ0FCUVFGeFJRUkFJQlNuQkVBZ0JFRUFOZ0pFSUFSQklEWUNTQ0FFSUFCQkdHb2lBRFlDQUNBRVFVQnJRUUkyQWdBZ0JDQUFOZ0lFUVFBa0JTTUZJUUJCQUNRRklBQkJBWEVOQWtFQUpBVkJDa0dzOVFKQkFSQU5Jd1VoQUVFQUpBVWdBRUVCY1EwQ1FRQWhBQXdUQzBFQUpBVkJBeUFGRUU2dEl3ZXRRaUNHaENFVUl3VWhBVUVBSkFVQ1FDQUJRUUZ4UlFSQUlBQkJqS2NCYWlJQklCU25RUUZ4T2dBQVFRQWtCVUVMSUFVUUJTRUNJd1VoQkVFQUpBVWdCRUVCY1EwQklBQkJrS2NCYWlBQ1FmOEJjVFlDQUNBQ1FmOEJjVUVZU2dSQUlBTkJBRFlDUkNBRFFTQTJBa2dnQXlBQVFSaHFJZ0EyQWdBZ0EwRkFhMEVDTmdJQUlBTWdBRFlDQkVFQUpBVWpCU0VBUVFBa0JTQUFRUUZ4RFFKQkFDUUZRUXBCclBVQ1FRRVFEU01GSVFCQkFDUUZJQUJCQVhFTkFrRUFJUUFNRlF0QkFDUUZRUklnQlNBQVFaU25BV3BCRUJBSEdpTUZJUUpCQUNRRklBSkJBWEVOQVFKQUlBRXNBQUFFUUVFQUpBVkJFaUFGSUFCQnBLY0JhaUlDUVFnUUJ4b2pCU0VFUVFBa0JTQUVRUUZ4RFFOQkFDUUZRUklnQlNBTlFRUVFCeG9qQlNFRVFRQWtCU0FFUVFGeEJFQVFGeUVBQlVFQUpBVkJIaUFIRUF3akJTRUVRUUFrQlFKQUFrQWdCRUVCY1EwQVFRQWtCVUVKSUFjZ0FrRUlFQTRqQlNFQ1FRQWtCU0FDUVFGeERRQkJBQ1FGUVEwZ0J5QURFQTBqQlNFQ1FRQWtCU0FDUVFGeEJFQVFGeUVBQlNBQklBMGdBMEVFRUd0Rk9nQUFEQVVMREFFTEVCY2hBQXNMREJjTEN5QVNRUUU2QUFBTUJ3c0xFQmNoQUF3VEN3c1FGeUVBREJFTFFRQWtCVUViSUFCQnVLWUJhaUlERUF3akJTRUJRUUFrQlNBQlFRRnhEUU1nQXlBQ0tRSUFOd0lBSUFNZ0Fpa0NDRGNDQ0NBRElBSW9BaEEyQWhCQkFDUUZRUU1nQlJCT3JTTUhyVUlnaG9RaEZTTUZJUUZCQUNRRkFrQWdBVUVCY1VVRVFDQUFRWjI4QTJvaUJDQVZweUlDUVFGeElnRTZBQUFnQUVHY3ZBTnFJQUpCQW5aQkFYRTZBQUFnQUVHZnZBTnFJQUpCQkhaQkFYRTZBQUFnQUVHanZBTnFJQUpCQTNaQkFYRTZBQUFnQUVHZ3ZBTnFRUUE2QUFBZ0FFR2l2QU5xUVFFNkFBQWdBa0VDY1FSL1FRQWtCVUVESUFVUVRxMGpCNjFDSUlhRUlSVWpCU0VCUVFBa0JTQUJRUUZ4RFFJZ0JDd0FBQ0VCSUJXbkJVRUFDeUVDSUFCQndMd0RhaUFDTmdJQUlBQkJvYndEYWlBQ1JTQUJRZjhCY1VFQVIzRTZBQUFnRkVJQVVnUkFRUUFrQlVFRklBQWdCU0FVcHlBREVBOGpCU0VCUVFBa0JTQUJRUUZ4RFFJTElBQkIxcVlCYWl3QUFFVU5CQ0FBUWRpbUFXb2lBU2tEQUVJQVVRMEVJQUJCclBNQWFpZ0NBRUdRZ0FGcUtBSUFSUTBFSUJBcEF3QWhGQ0FPS1FNQUlSVWdCaWdDQUNFQ1FRQWtCVUVLSUFCQjJQTUFhaUlESUFCQkFCQU9Jd1VoQkVFQUpBVWdCRUVCY1EwQklBRXBBd0FoRmtFQUpBVkJBU0FESUJhbklCWkNJSWluRUU4akJTRUJRUUFrQlNBQlFRRnhEUUVnRUNBVU53TUFJQTRnRlRjREFDQUdJQUkyQWdBTUJBc0xFQmNoQUF3UUN5QUFRYkNuQVdvaEFTQUFRZkN0QW1vaEEwRUFKQVZCQ0NBS1FRSkdCSDhnQVFVZ0F5SUJDMEVBRUEwakJTRURRUUFrQlNBRFFRRnhCRUFRRnlFQURCQUxJQUVnQWlrQ0FEY0NBQ0FCSUFJcEFnZzNBZ2dnQVNBQ0tBSVFOZ0lRSUFzb0FnQkJBa1loQ2lBQlFlbkJBR3BCQVRvQUFDQUJRY2pBQUdvaUFpQVZOd01BUVFBa0JVRURJQVVRVHEwakI2MUNJSWFFSVJVakJTRURRUUFrQlFKQUlBTkJBWEZGQkVBZ0FVR0V3UUJxSWdNZ0ZUNENBRUVBSkFWQkF5QUZFRTZ0SXdldFFpQ0doQ0VWSXdVaEJFRUFKQVVnQkVFQmNRMEJJQUZCME1BQWFpSUVJQlUzQXdBZ0FVR0t3UUJxSUFNb0FnQkJDSEVpQzBFRGRqb0FBQ0FMQkVBZ0JFTC8vLy8vOS8vLy8vOEFOd01BUXYvLy8vLzMvLy8vL3dBaEZRc2dBVUhZd0FCcUlBSXBBd0FpRmlBVlZRUitJQllGSUJVTE53TUFRUUFrQlVFRElBVVFUcTBqQjYxQ0lJYUVJUlVqQlNFQ1FRQWtCU0FDUVFGeERRRWdBVUVjYWlJTElCVStBZ0FnQXlnQ0FDSUNRUUp4QkVCQkFDUUZRUXdnQlJBRklRSWpCU0VFUVFBa0JTQUVRUUZ4RFFKQkFDUUZRUTRnQVVHd3dBQnFJQUlRQmhvakJTRUNRUUFrQlNBQ1FRRnhEUUlnQXlnQ0FDRUNDeUFCUWVEQUFHb2lCRUVBTmdJQUlBSkJCSEVFUUNBRVFRSTJBZ0JCQUNRRlFRd2dCUkFGSVFJakJTRUVRUUFrQlNBRVFRRnhEUUlnQVVIa3dBQnFJQUkyQWdBTElBRkI4TUVBYWtFQU5nSUFRUUFrQlVFRElBVVFUcTBqQjYxQ0lJYUVJUlVqQlNFQ1FRQWtCUUpBSUFKQkFYRkZCRUFnQVNBVnB5SUVRUWQyUVFkeE9nQWFJQUZCR1dvaUJpQUVRVDl4UVRKcU9nQUFRUUFrQlVFRElBVVFUcTBqQjYxQ0lJYUVJUlVqQlNFQ1FRQWtCU0FDUVFGeERRRWdBVUVZYWlJSUlCVThBQUJCQUNRRlFRTWdCUkJPclNNSHJVSWdob1FoRlNNRklRSkJBQ1FGSUFKQkFYRUVRQkFYSVFBTUZBc2dGYWNoQWlBQlFlakJBR29nRENnQ0FFRUdka0VCY1RvQUFDQUJRZXpCQUdvaURFRUNOZ0lBQWtBQ1FBSkFBa0FDUUNBSUxBQUFEZ0lCQUFJTFFRRWhDQXdDQzBFQUlRZ01BUXNNQVFzZ0RDQUlOZ0lBQ3lBQlFZakJBR29nQVNnQ0NDSUlRUU4yUVFGeE9nQUFJQUZCaWNFQWFpQUlRUVIyUVFGeE9nQUFJQUZCNnNFQWFpQUlRUVYyUVFGeE9nQUFJQUZCNE1FQWFpQUtJQVJCd0FCeFFRQkhjVG9BQUNBQlFlSEJBR29pQ0NBREtBSUFRUUZ4SWdNNkFBQkJnSUFJSUFSQkNuWkJEM0YwSVFRZ0FVSGt3UUJxSUFNRWYwRUFCU0FFQ3pZQ0FDQUJRWXpCQUdvZ0FVR0x3UUJxTEFBQUJIOUJCUVZCQUFzMkFnQkJBQ1FGUVJJZ0JTQU5JQUpCL3o5SkJIOGdBZ1ZCL3o4aUFnc1FCeG9qQlNFRFFRQWtCUUpBSUFOQkFYRkZCRUFnRFNBQ2FrRUFPZ0FBUVFBa0JVRVZJQTBnQVVFZ2FpSUNRWUFRRUFjYUl3VWhBMEVBSkFVZ0EwRUJjUTBCSUJSQ0FGSUVRRUVBSkFWQkJTQUFJQVVnRktjZ0FSQVBJd1VoQVVFQUpBVWdBVUVCY1EwQ0N3SkFJQW9FUUNBQVFhenpBR29pQXlnQ0FFR01oUU5xS0FJQUlnRkJBVVlFUUVFQUpBVkJEU0FDRUFVYUl3VWhBVUVBSkFVZ0FVRUJjUTBFSUFNb0FnQkJqSVVEYWlnQ0FDRUJDeUFCUVFKR0JFQkJBQ1FGUVE0Z0FoQUZHaU1GSVFGQkFDUUZJQUZCQVhFTkJBc0NRQ0FBUVppOEEyb2lCQ2dDQUVFQ1JnUkFJQVl0QUFCQkZFNE5BU0FMS0FJQVFSQnhSUTBCSUFoQkFUb0FBQXNMSUF3b0FnQWlBVUVDUmdSQUlBc2dDQ3dBQUFSL1FSQUZRU0FMTmdJQVFRSWhBUXNnQWlFREEwQUNRQUpBQWtBQ1FBSkFBa0FnQXlnQ0FBNWRBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01DQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01CQXdzTUJ3c2dCQ2dDQUVFRFJ3MENJQUVOQXlBRFFkOEFOZ0lBUVFBaEFRd0RDd3dCQ3d3QkN5QURRUzgyQWdBTElBTkJCR29oQXd3QUN3QUZRUUFrQlVFR0lBSkJqQTRRQmlFQkl3VWhBMEVBSkFVZ0EwRUJjUTBESUFFTkFTQUFRWjY4QTJwQkFUb0FBQXNMSUJFRVFDQUhRUUEyQWtRZ0IwRWFOZ0pJSUFjZ0FFRVlhallDQUNBSFFVQnJRUUkyQWdBZ0J5QUNOZ0lFUVFBa0JTTUZJUUZCQUNRRklBRkJBWEVOQWdzTUJ3c0xFQmNoQUF3VEN3c1FGeUVBREJFTEN4QVhJUUFNRHdzZ0FFR3dyUUpxSWdFZ0Fpa0NBRGNDQUNBQklBSXBBZ2czQWdnZ0FTQUNLQUlRTmdJUVFRQWtCVUVESUFVUVRxMGpCNjFDSUlhRUlSUWpCU0VCUVFBa0JTQUJRUUZ4QkVBUUZ5RUFEQThGSUFCQnpLMENhaUFVcDBFQmNUb0FBQ0FBUWMrdEFtcEJBRG9BQUNBQVFjMnRBbXBCQURvQUFDQUFRYzZ0QW1wQkFEb0FBQXNMSUE0cEF3QWdFQ2tEQUZVRVFDQUpLQUlBSVFBTURRc2dEVUVBTmdKRUlBMUJHRFlDU0NBTlFVQnJRUUUyQWdBZ0RTQUFRUmhxTmdJQVFRQWtCU01GSVFGQkFDUUZJQUZCQVhFTkFDQUFRYXk4QTJwQkFUb0FBRUVBSkFWQkNrR3M5UUpCQXhBTkl3VWhBRUVBSkFVZ0FFRUJjVVVFUUVFQUlRQU1EUXNMRUJjaEFBd01Dd3NMRUJjaEFBd0pDd3NMRUJjaEFBd0dDd3NRRnlFQURBUUxDd3NRRnlFQURBRUxJQVVvQWdBaUFVVUVRQ0FISkFRZ0FBOExJQUVRVWlBSEpBUWdBQThMSUFVb0FnQWlBVVVFUUNBQUVCNExJQUVRVWlBQUVCNUJBQXZkUXdJYmZ3SitJd1FoQVNNRVFiRERBR29rQkNBQkloQkJxQU5xSVEwZ0VFSFlBbW9oQ3lBUVFZd0NhaUVPSUJCQndBRnFJUUlnRUVIMEFHb2hBU0FRUVNocUlRTWdFRUVJYWlJRUlBQVF1QUVDUUFKQUFrQUNRQ0FBUWFTOEEyb2lDQ3dBQUVVTkFDQUFRWWk4QTJvaUJTa0RBQ0FBUWFpOEEyb29BZ0N0UWdkOFZ3MEFRUUFrQlVFY0lBQVFEQ01GSVFaQkFDUUZJQVpCQVhFTkFTQUFLQUlBS0FJTUlRWkJBQ1FGSUFZZ0FDQU5RUWdRQnlFR0l3VWhCMEVBSkFVQ1FDQUhRUUZ4UlFSQUlBWkJDRVlFUUNBQVFhenpBR29vQWdCQnFNQUNhaUVEUVFBa0JVRUJJQUJCbk1BQWFpSUZRUUJCQkNBRElBMUJBRUVBUVFCQkFCQUtHaU1GSVFOQkFDUUZJQU5CQVhFTkFpQUVJQVUyQWh4QkFTRVdEQU1MUVFBa0JVRUZJQUFRVHEwakI2MUNJSWFFSVJ3akJTRUJRUUFrQlNBQlFRRnhSUVJBQWtBQ1FDQUZLUU1BSUJ4U0RRQWdBRUdRdkFOcUtRTUFJQnhTRFFBTUFRc2dBMEVBTmdKRUlBTkJOellDU0NBRFFVQnJRUUUyQWdBZ0F5QUFRUmhxTmdJQVFRQWtCU01GSVFCQkFDUUZJQUJCQVhFTkEwRUFKQVZCQ2tHczlRSkJBUkFOSXdVaEFFRUFKQVVnQUVFQmNRMERDMEVBSVFBTUJRc0xDeEFYSVFBTUF3dEJBQ1FGUVFvZ0JFRUhFQVlhSXdVaEEwRUFKQVVnQTBFQmNRMEFJQVJCRkdvaUZ5Z0NBRVVFUUVFQUpBVkJCU0FBRUU2dEl3ZXRRaUNHaENFY0l3VWhBa0VBSkFVZ0FrRUJjUTBCSUFCQmlMd0RhaWtEQUNBY1VRUkFJQUJCa0x3RGFpa0RBQ0FjVVFSQVFRQWhBQXdFQ3dzZ0FVRUFOZ0pFSUFGQk56WUNTQ0FCUVVCclFRRTJBZ0FnQVNBQVFSaHFOZ0lBUVFBa0JTTUZJUUJCQUNRRklBQkJBWEVOQVVFQUpBVkJDa0dzOVFKQkFSQU5Jd1VoQUVFQUpBVWdBRUVCY1EwQlFRQWhBQXdDQzBFQUpBVkJDaUFFRUFVaEFTTUZJUU5CQUNRRklBTkJBWEVOQUNBQVFaaW1BV29pQnlBQlFmLy9BM0UyQWdBZ0FFR29wZ0ZxSWdaQkFEb0FBRUVBSkFWQkN5QUVFQVVoQXlNRklRRkJBQ1FGQWtBZ0FVRUJjVVVFUUNBRFFmOEJjU0VCUVFBa0JVRUtJQVFRQlNFS0l3VWhCVUVBSkFVZ0JVRUJjVVVFUUNBQVFhQ21BV29pQlNBS1FmLy9BM0VpQ2pZQ0FDQUdJQXBCRG5aQkFYRTZBQUJCQUNRRlFRb2dCQkFGSVFZakJTRUtRUUFrQlNBS1FRRnhSUVJBSUFCQnBLWUJhaUlLSUFaQi8vOERjU0lKTmdJQUlBQkJuS1lCYWlJVUlBRTJBZ0FnQmtILy93TnhRUWRJQkVBZ0FrRUFOZ0pFSUFKQkdEWUNTQ0FDUVVCclFRRTJBZ0FnQWlBQVFSaHFOZ0lBUVFBa0JTTUZJUUZCQUNRRklBRkJBWEVOQkNBQVFheThBMnBCQVRvQUFFRUFKQVZCQ2tHczlRSkJBeEFOSXdVaEFFRUFKQVVnQUVFQmNRMEVRUUFoQUF3R0N3SkFBa0FDUUFKQUFrQUNRQUpBSUFOQkdIUkJHSFZCOHdCckRna0FBUVFFQkFRRUFnTUVDMEVCSVFFTUJBdEJBaUVCREFNTFFRTWhBUXdDQzBFRklRRU1BUXNNQVFzZ0ZDQUJOZ0lBQ3lBQVFjenpBR29nQVRZQ0FBSkFBa0FDUUFKQUlBRkJBV3NPZFFFQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUFJTFFRQWtCVUVLSUFSQkJoQUdHZ3dDQ3lBRktBSUFRUUp4UlEwQVFRQWtCVUVLSUFSQkJoQUdHZ3dCQzBFQUpBVkJDaUFFSUFsQmVXb1FCaG9MSXdVaEFVRUFKQVVnQVVFQmNRMERJQUJCaUx3RGFpSVlLUU1BSVJ3Z0NpZ0NBQ0VCUVFBa0JVRUxJQUFnQVJBR0lRRWpCU0VDUVFBa0JTQUNRUUZ4UlFSQUlBQkJrTHdEYWlJS0lCd2dBYTE4TndNQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdGQ2dDQUNJQlFRRnJEbmtBQVFFSUFnZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQU1GQndZRUNBdEJBQ1FGUVJzZ0FFRzRwZ0ZxSWdFUURDTUZJUUpCQUNRRklBSkJBWEVORFNBQklBY3BBZ0EzQWdBZ0FTQUhLUUlJTndJSUlBRWdCeWdDRURZQ0VFRUFKQVZCQ2lBRUVBVWhBU01GSVFKQkFDUUZJQUpCQVhFTkRTQUFRY3ltQVdvaUF5QUJPd0VBUVFBa0JVRU1JQVFRQlNFQ0l3VWhBVUVBSkFVZ0FVRUJjUTBOSUFCQjBLWUJhaUFDTmdJQUlBQkJuYndEYWlBQVFjQ21BV29vQWdBaUFVRUJjVG9BQUNBQVFaeThBMm9nQVVFRGRrRUJjVG9BQUNBQVFaKzhBMm9nQVVFQ2RrRUJjVG9BQUNBQVFhTzhBMm9nQVVFR2RrRUJjVG9BQUNBSUlBRkJCM1pCQVhFNkFBQWdBRUdndkFOcUlBSUVmMEVCQlNBRExnRUFRUUJIQzBFQmNUb0FBQ0FBUWRTbUFXb2dBVUVCZGtFQmNUb0FBQ0FBUWFHOEEyb2dBVUVJZGtFQmNUb0FBQ0FBUWFLOEEyb2dBVUVFZGtFQmNUb0FBQXdJQ3lBQVFiQ25BV29oQXlBQVFmQ3RBbW9oQWtFQUpBVkJDQ0FCUVFKR0lnOEVmeUFEQlNBQ0lnTUxRUUFRRFNNRklRRkJBQ1FGSUFGQkFYRkZCRUFnQXlBSEtRSUFOd0lBSUFNZ0J5a0NDRGNDQ0NBRElBY29BaEEyQWhBZ0EwR0l3UUJxSUFOQkNHb2lDU2dDQUNJQlFRRnhPZ0FBSUFOQmljRUFhaUFCUVFGMlFRRnhPZ0FBSUFOQmk4RUFhaUlHSUFGQkFuWkJBWEU2QUFBZ0EwR1F3UUJxSUFGQkNuWkJBWEU2QUFBZ0EwSGd3UUJxSUE4RWYwRUFJUVVnQVVFRWRrRUJjUVVnQVVFUWNVRUFSeUVGUVFBTE9nQUFJQU5CNnNFQWFpQUZRUUZ4T2dBQUlBTkI0Y0VBYWlJTUlBRkI0QUZ4UWVBQlJpSUNPZ0FBSUFOQjVNRUFhaUFDQkg5QkFBVkJnSUFFSUFGQkJYWkJCM0YwQ3pZQ0FDQURRZUxCQUdvaUdTQUJRUU4yUVFGeE9nQUFJQU5CNDhFQWFpQUJRUXQyUVFGeE9nQUFRUUFrQlVFTUlBUVFCU0VCSXdVaEFrRUFKQVVnQWtFQmNVVUVRQ0FEUVJScUlob2dBVFlDQUVFQUpBVkJEQ0FFRUFVaEFpTUZJUUZCQUNRRkFrQWdBVUVCY1VVRVFFRUFKQVZCQ3lBRUVBVWhBU01GSVFWQkFDUUZJQVZCQVhGRkJFQWdBMEVZYWlJSUlBRTZBQUFnQTBIZ3dBQnFRUUkyQWdCQkFDUUZRUXdnQkJBRklRRWpCU0VGUVFBa0JTQUZRUUZ4RFFJZ0EwSGt3QUJxSUFFMkFnQkJBQ1FGUVF3Z0JCQUZJUnNqQlNFQlFRQWtCUUpBSUFGQkFYRkZCRUJCQUNRRlFRc2dCQkFGSVFFakJTRUZRUUFrQlNBRlFRRnhEUUVnQTBFWmFpSVJJQUU2QUFCQkFDUUZRUXNnQkJBRklRRWpCU0VGUVFBa0JTQUZRUUZ4RFFFZ0F5QUJRZjhCY1VIUUFXbzZBQnBCQUNRRlFRb2dCQkFGSVJJakJTRUJRUUFrQlFKQUlBRkJBWEZGQkVCQkFDUUZRUXdnQkJBRklRVWpCU0VCUVFBa0JTQUJRUUZ4RFFFZ0EwRWNhaUlUSUFVMkFnQWdBMEdNd1FCcUloVkJBRFlDQUNBR0xBQUFCRUFnRlFKL0FrQUNRQUpBQWtBZ0VTd0FBRUVOYXc0T0FBTUJBd01EQXdJREF3TURBd0lEQzBFQkRBTUxRUUlNQWd0QkF3d0JDMEVFQ3pZQ0FBc2dFa0gvL3dOeElRRWdBMEhzd1FCcUloSkJBallDQUFKQUFrQUNRQUpBSUFnc0FBQWlCa0VEYXc0REFBRUFBUXRCQVNFSURBRUxJQVpCL3dGeFFRWklCRUJCQUNFSURBRUxJQU5COE1FQWFrRUFOZ0lBREFFTElCSWdDRFlDQUNBRFFmREJBR29pQ0VFQU5nSUFJQVpCQTBZZ0JVR0E0QU54UVlEQUFrWnhSUTBBSUFoQkFUWUNBQ0FEUWZUQkFHcEJBRFlDQUFzZ0EwSG93UUJxSUFWQkFFZ2dEMEVCYzNFNkFBQWdBMEhwd1FCcUlBa29BZ0JCZ0FKeElnVkJDSFk2QUFBQ1FDQUZCRUJCQUNRRlFRd2dCQkFGSVFVakJTRUdRUUFrQlFKQUlBWkJBWEZGQkVCQkFDUUZRUXdnQkJBRklRWWpCU0VJUVFBa0JTQUlRUUZ4RFFFZ0JpQUNjU0VJREFNTEN4QVhJUUFNR2dWQkFDRUZRUUFoQmlBQ0lRZ0xDeUFEUVlyQkFHb2dDRUYvUmlJSU9nQUFJQU5CeU1BQWFpSVZJQVd0UWlDR0lCb29BZ0N0aERjREFDQUdyVUlnaGlBQ3JZUWhIQ0FEUWREQUFHb2dDQVIrUXYvLy8vLzMvLy8vL3dBRklCd0xOd01BUVFBa0JVRVNJQVFnRFNBQlFmOC9TUVIvSUFFRlFmOC9DeUlDRUFjYUl3VWhCVUVBSkFVQ2Z3SkFJQVZCQVhFTkFDQU5JQUpxUVFBNkFBQUNRQ0FQQkVBQ1FBSkFJQWtvQWdCQmdBUnhCRUJCQUNRRlFSMGdDeEFNSXdVaEFrRUFKQVVDUUNBQ1FRRnhSUVJBSUEwUWJrRUJhaUVDUVFBa0JVRUVJQXNnRFNBTklBSnFJQUVnQW1zZ0EwRWdhaUlCUVlBUUVCRWpCU0VDUVFBa0JTQUNRUUZ4RFFFZ0FTZ0NBRVVOQXd3RUN3c1FGd3dHQlNBRFFTQnFJZ0ZCQURZQ0FBc0xRUUFrQlVFRUlBMGdBVUdBRUVFQkVBOGpCU0VDUVFBa0JTQUNRUUZ4RFFNTElBQkJyUE1BYWlJRktBSUFRWXlGQTJvb0FnQWlBa0VCUmdSQVFRQWtCVUVOSUFFUUJSb2pCU0VDUVFBa0JTQUNRUUZ4RFFNZ0JTZ0NBRUdNaFFOcUtBSUFJUUlMSUFKQkFrWUVRRUVBSkFWQkRpQUJFQVVhSXdVaEFrRUFKQVVnQWtFQmNRMERDd0pBSUFCQm1Md0RhaUlHS0FJQVFRSkdCRUFnRVMwQUFFRVVUZzBCSUJNb0FnQkJFSEZGRFFFZ0RFRUJPZ0FBQ3dzZ0VpZ0NBQ0lGUVFKR0JIOGdFeUFNTEFBQUJIOUJFQVZCSUFzMkFnQWdBU0VDUVFJRklBRWhBaUFGQ3lFQkEwQUNRQUpBQWtBQ1FBSkFBa0FnQWlnQ0FBNWRBQU1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01DQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01CQXdzTUJ3c2dCaWdDQUVFRFJ3MENJQUVOQXlBQ1FkOEFOZ0lBUVFBaEFRd0RDd3dCQ3d3QkN5QUNRUzgyQWdBTElBSkJCR29oQWd3QUN3QUZRUUFrQlVFUklBMGdBMEVnYWlJSVFZQVFFQWNhSXdVaEFrRUFKQVVnQWtFQmNRMENBa0FDUUNBREtBSU1JQUZyUVZocUlBa29BZ0JCQjNaQkNIRkJDSE5xSWdKQkFFd05BQ0FEUWFEQUFHb2hCaUFEUWFqQUFHb2lEeWdDQUNFRklBTkJwTUFBYWlJTUlBSTJBZ0FnQlNBQ1NRUkFJQU5Cck1BQWFpZ0NBQ0lCUVFCSElBSWdBVXR4Qkg5QkFDUUZJQkFnQVRZQ0FFRUNRYXoxQWtIWUd5QVFFQTRqQlNFQlFRQWtCU0FCUVFGeERRTkJBQ1FGUVJSQnJQVUNFQXdqQlNFQlFRQWtCU0FCUVFGeERRTWdEeWdDQUNFRklBd29BZ0FGSUFJTElRRWdCaWdDQUNBQklBVkJJR29nQlVFQ2Rtb2lCVXNFZnlBQkJTQUZJZ0VMRUZjaUJVVUVRRUVBSkFWQkZFR3M5UUlRRENNRklReEJBQ1FGSUF4QkFYRU5Bd3NnQmlBRk5nSUFJQThnQVRZQ0FBc2dCaWdDQUNFQlFRQWtCVUVTSUFRZ0FTQUNFQWNhSXdVaEFVRUFKQVVnQVVFQmNRMEJRUUFrQlVFR0lBaEJyQTRRQmlFQkl3VWhBa0VBSkFVZ0FrRUJjUTBCSUFFTkFDQUFRYkR6QUdvaUFpQUdLQUlBSWdFdEFBbEJDSFFnQVMwQUNISWdBUzBBQ2tFUWRISWdBUzBBQzBFWWRIS3RRZ21HTndNQUlBQW9BZ0FvQWhRaEFVRUFKQVVnQVNBQUVFNnRJd2V0UWlDR2hDRWNJd1VoQVVFQUpBVWdBVUVCY1EwQklBSXBBd0FoSFVFQUpBVkJBU0FkcHlBZFFpQ0lweUFjcHlBY1FpQ0lweEJOSVFVakJTRUJRUUFrQlNBQlFRRnhEUUVnQUVHNDh3QnFJZ0VnQlRZQ0FDQUNLUU1BSUJ4Q3lBRi9mQ0VkUVFBa0JVRUJJQjJuSUIxQ0lJaW5JQnluSUJ4Q0lJaW5FRTBoQWlNRklRVkJBQ1FGSUFWQkFYRU5BU0FDSUFFb0FnQWlBa3dOQUNBQklBSkJBV28yQWdBTFFRQWtCVUVHSUFoQmpBNFFCaUVCSXdVaEFrRUFKQVVnQWtFQmNRMEFJQUVOQWlBQVFaNjhBMnBCQVRvQUFBd0NDeEFYREFNTEFBc2dDU2dDQUVHQUNIRUVRRUVBSkFWQkVpQUVJQU5Ca2NFQWFrRUlFQWNhSXdVaEFVRUFKQVVnQVVFQmNRMEJDMEVBSkFWQkNTQURRYkRBQUdvZ0d4QU5Jd1VoQVVFQUpBVWdBVUVCY1EwQUFrQWdDU2dDQUVHQUlIRUVRRUVBSkFWQkNpQUVFQVVoQVNNRklRSkJBQ1FGSUFKQkFYRUVRQkFYREFRTElBQkI0T2NCYWlFSklBQkI2T2NCYWlFR0lBQkI4T2NCYWlFSUlBdEJHR29oQWlBTFFSUnFJUVVDUUNBQlFmLy9BM0VpRDBFTWRpSUJRUWh4QkVCQkFDUUZRUXNnQ1NBTEVBMGpCU0VNUVFBa0JTQU1RUUZ4RFFFZ0FVRUVjUVJBSUFVZ0JTZ0NBRUVCYWpZQ0FBc2dBa0VBTmdJQUlBRkJBM0VpREFSQUlBeEJBM01oRVVFQUlRRURRRUVBSkFWQkN5QUVFQVVoRXlNRklSSkJBQ1FGSUJKQkFYRU5BeUFDSUFJb0FnQWdFMEgvQVhFZ0VTQUJha0VEZEhSeU5nSUFJQUZCQVdvaUFTQU1TQTBBQ3d0QkFDUUZRUXdnQ1NBTEVBMGpCU0VCUVFBa0JTQUJRUUZ4RFFFTEFrQWdEMEVJZGlJQlFRaHhCRUJCQUNRRlFRd2dCQkFGSVFrakJTRU1RUUFrQlNBTVFRRnhEUUZCQUNRRlFRa2dCaUFKRUEwakJTRUpRUUFrQlNBSlFRRnhEUUZCQUNRRlFRc2dCaUFMRUEwakJTRUpRUUFrQlNBSlFRRnhEUUlnQVVFRWNRUkFJQVVnQlNnQ0FFRUJhallDQUFzZ0FrRUFOZ0lBSUFGQkEzRWlDUVJBSUFsQkEzTWhERUVBSVFFRFFFRUFKQVZCQ3lBRUVBVWhFU01GSVJOQkFDUUZJQk5CQVhFTkJDQUNJQUlvQWdBZ0VVSC9BWEVnRENBQmFrRURkSFJ5TmdJQUlBRkJBV29pQVNBSlNBMEFDd3RCQUNRRlFRd2dCaUFMRUEwakJTRUJRUUFrQlNBQlFRRnhEUUlMSUE5QkJIWWlBVUVJY1VVTkEwRUFKQVZCRENBRUVBVWhCaU1GSVFsQkFDUUZJQWxCQVhFTkFFRUFKQVZCQ1NBSUlBWVFEU01GSVFaQkFDUUZJQVpCQVhFTkFFRUFKQVZCQ3lBSUlBc1FEU01GSVFaQkFDUUZJQVpCQVhFTkFTQUJRUVJ4QkVBZ0JTQUZLQUlBUVFGcU5nSUFDeUFDUVFBMkFnQWdBVUVEY1NJRkJFQWdCVUVEY3lFR1FRQWhBUU5BUVFBa0JVRUxJQVFRQlNFSkl3VWhEMEVBSkFVZ0QwRUJjUTBESUFJZ0FpZ0NBQ0FKUWY4QmNTQUdJQUZxUVFOMGRISTJBZ0FnQVVFQmFpSUJJQVZJRFFBTEMwRUFKQVZCRENBSUlBc1FEU01GSVFGQkFDUUZJQUZCQVhFTkFRd0RDeEFYREFRTEVCY01Bd3NMSUFvZ0Npa0RBQ0FWS1FNQWZEY0RBQ0FaTEFBQVFRQkhJUUZCQUNRRlFRd2dCQ0FCRUFZaEFTTUZJUUpCQUNRRkFrQWdBa0VCY1VVRVFDQURLQUlBSUFGQi8vOERjVWNFUUNBQVFheThBMnBCQVRvQUFFRUFKQVZCQ2tHczlRSkJBUkFOSXdVaEFVRUFKQVVnQVVFQmNRMENJQllORlNBT1FRQTJBa1FnRGtFYU5nSklJQTRnQUVFWWFqWUNBQ0FPUVVCclFRSTJBZ0FnRGlBRFFTQnFOZ0lFUVFBa0JTTUZJUUZCQUNRRklBRkJBWEVOQWdzTUZBc0xFQmNNQVFzUUZ3c2hBQXdZQ3dzUUZ5RUFEQllMQ3hBWElRQU1GQXNMQ3hBWElRQU1FUXNMRUJjaEFBd1BDeUFBUWJDdEFtb2lBU0FIS1FJQU53SUFJQUVnQnlrQ0NEY0NDQ0FCSUFjb0FoQTJBaEFnQUVITXJRSnFJQUJCdUswQ2FpZ0NBQ0lCUVFGeE9nQUFJQUJCemEwQ2FpQUJRUUYyUVFGeElnSTZBQUFnQUVIT3JRSnFJQUZCQW5aQkFYRTZBQUFnQUVIUHJRSnFJZ01nQVVFRGRrRUJjU0lCT2dBQUlBSkIvd0Z4QkVCQkFDUUZRUXdnQkJBRklRRWpCU0VDUVFBa0JTQUNRUUZ4RFF3Z0FFSEVyUUpxSUFFMkFnQWdBeXdBQUNFQkN5QUJRZjhCY1FSQVFRQWtCVUVLSUFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwTUlBQkJ5SzBDYWlBQlFmLy9BM0VpQVRZQ0FDQUFRY0M4QTJvZ0FUWUNBQXNNQmdzZ0FFSHdzd05xSWdFZ0J5a0NBRGNDQUNBQklBY3BBZ2czQWdnZ0FTQUhLQUlRTmdJUVFRQWtCVUVLSUFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwS0lBQkJoTFFEYWlBQk93RUFRUUFrQlVFTElBUVFCU0VCSXdVaEFrRUFKQVVnQWtFQmNRMEtJQUJCaHJRRGFpQUJPZ0FBUVFBa0JVRUxJQVFRQlNFQkl3VWhBa0VBSkFVZ0FrRUJjUTBLSUFCQmg3UURhaUFCT2dBQVFRQWtCVUVLSUFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwS0lBQkJpTFFEYWlBQk93RUFEQVVMSUFCQjBMUURhaUlCSUFjcEFnQTNBZ0FnQVNBSEtRSUlOd0lJSUFFZ0J5Z0NFRFlDRUVFQUpBVkJEQ0FFRUFVaEFTTUZJUUpCQUNRRklBSkJBWEVOQ1NBQVFlUzBBMm9nQVRZQ0FFRUFKQVZCQ2lBRUVBVWhBU01GSVFKQkFDUUZJQUpCQVhFTkNTQUFRZWkwQTJvZ0FUc0JBRUVBSkFWQkNpQUVFQVVoQVNNRklRSkJBQ1FGSUFKQkFYRU5DU0FBUWVxMEEyb2dBVHNCQUF3RUN5QUFRYlMwQTJvaUFTQUhLUUlBTndJQUlBRWdCeWtDQ0RjQ0NDQUJJQWNvQWhBMkFoQkJBQ1FGUVFzZ0JCQUZJUUVqQlNFQ1FRQWtCU0FDUVFGeERRZ2dBRUhJdEFOcUlBRTZBQUJCQUNRRlFRc2dCQkFGSVFFakJTRUNRUUFrQlNBQ1FRRnhEUWdnQUVISnRBTnFJQUU2QUFCQkFDUUZRUXNnQkJBRklRRWpCU0VDUVFBa0JTQUNRUUZ4RFFnZ0FFSEt0QU5xSUFFNkFBQkJBQ1FGUVF3Z0JCQUZJUUVqQlNFQ1FRQWtCU0FDUVFGeERRZ2dBRUhNdEFOcUlBRTJBZ0FNQXdzZ0FFR010QU5xSWdFZ0J5a0NBRGNDQUNBQklBY3BBZ2czQWdnZ0FTQUhLQUlRTmdJUVFRQWtCVUVNSUFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwSElBQkJvTFFEYWlJQ0lBRTJBZ0JCQUNRRlFRc2dCQkFGSVFFakJTRURRUUFrQlNBRFFRRnhEUWNnQUVHa3RBTnFJQUU2QUFCQkFDUUZRUW9nQkJBRklRRWpCU0VEUVFBa0JTQURRUUZ4RFFjZ0FFR210QU5xSWdNZ0FUc0JBRUVBSkFWQkRDQUVFQVVoQVNNRklRVkJBQ1FGSUFWQkFYRU5CeUFBUWFpMEEyb2dBVFlDQUVFQUpBVkJFaUFFSUFCQnJMUURha0VJRUFjYUl3VWhBVUVBSkFVZ0FVRUJjUTBISUFvZ0Npa0RBQ0FDS0FJQXJYdzNBd0FnQUVHdzh3QnFJQU12QVFCQkNYU3ROd01BREFJTElBQkIwSzBDYWlJQklBY3BBZ0EzQWdBZ0FTQUhLUUlJTndJSUlBRWdCeWdDRURZQ0VFRUFKQVZCRENBRUVBVWhBaU1GSVFOQkFDUUZJQU5CQVhFTkJpQUFRZVN0QW1vZ0FqWUNBQ0FLSUFvcEF3QWdBcTE4TndNQVFRQWtCVUVLSUFRUUJTRUNJd1VoQTBFQUpBVWdBMEVCY1EwR0lBQkI2SzBDYWlJRElBSTdBUUJCQUNRRlFRc2dCQkFGSVFJakJTRUZRUUFrQlNBRlFRRnhEUVlnQUVIcXJRSnFJQUk2QUFBQ1FBSkFBa0FDUUFKQUlBTXVBUUJCZ0FKckRnWUNBQUVDQWdNRUN5QUFRZXkwQTJvaUFpQUJLUUlBTndJQUlBSWdBU2tDQ0RjQ0NDQUNJQUVwQWhBM0FoQWdBaUFCTGdFWU93RVlJQUlnQVN3QUdqb0FHa0VBSkFWQkNpQUVFQVVoQVNNRklRSkJBQ1FGSUFKQkFYRU5DaUFBUVlpMUEyb2lBaUFCT3dFQVFRQWtCVUVLSUFRUUJTRUZJd1VoQVVFQUpBVWdBVUVCY1EwS0lBQkJpclVEYWlJRElBVTdBUUFnQWk0QkFDSUJRZi8vQTNGQi93RktCRUFnQWtIL0FUc0JBRUgvQVNFQkN5QUZRZi8vQTNGQi93RktCRUFnQTBIL0FUc0JBQXRCQUNRRlFSSWdCQ0FBUVl5MUEyb2dBVUgvL3dOeEVBY2FJd1VoQVVFQUpBVWdBVUVCY1EwS0lBTXZBUUFoQVVFQUpBVkJFaUFFSUFCQmpMY0RhaUFCRUFjYUl3VWhBVUVBSkFVZ0FVRUJjUTBLSUFCQmpMVURhaUFDTHdFQWFrRUFPZ0FBSUFCQmpMY0RhaUFETHdFQWFrRUFPZ0FBREFVTElBQkJqTGtEYWlJQ0lBRXBBZ0EzQWdBZ0FpQUJLUUlJTndJSUlBSWdBU2tDRURjQ0VDQUNJQUV1QVJnN0FSZ2dBaUFCTEFBYU9nQWFRUUFrQlVFTUlBUVFCU0VCSXdVaEFrRUFKQVVnQWtFQmNRMEpJQUJCcUxrRGFpQUJOZ0lBUVFBa0JVRU1JQVFRQlNFQkl3VWhBa0VBSkFVZ0FrRUJjUTBKSUFCQnJMa0RhaUFCTmdJQURBUUxJQUJCc0xrRGFpSUNJQUVwQWdBM0FnQWdBaUFCS1FJSU53SUlJQUlnQVNrQ0VEY0NFQ0FDSUFFdUFSZzdBUmdnQWlBQkxBQWFPZ0FhUVFBa0JVRU1JQVFRQlNFQkl3VWhBa0VBSkFVZ0FrRUJjUTBJSUFCQnpMa0RhaUFCTmdJQVFRQWtCVUVMSUFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwSUlBQkIwTGtEYWlBQk9nQUFRUUFrQlVFTElBUVFCU0VCSXdVaEFrRUFKQVVnQWtFQmNRMElJQUJCMGJrRGFpQUJPZ0FBUVFBa0JVRU1JQVFRQlNFQkl3VWhBa0VBSkFVZ0FrRUJjUTBJSUFCQjFMa0RhaUFCTmdJQURBTUxJQUJCMkxrRGFpSUNJQUVwQWdBM0FnQWdBaUFCS1FJSU53SUlJQUlnQVNrQ0VEY0NFQ0FDSUFFdUFSZzdBUmdnQWlBQkxBQWFPZ0FhUVFBa0JVRU1JQVFRQlNFQkl3VWhBa0VBSkFVZ0FrRUJjUTBISUFCQjlMa0RhaUFCTmdJQVFRQWtCVUVMSUFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwSElBQkIrTGtEYWlBQk9nQUFRUUFrQlVFTElBUVFCU0VCSXdVaEFrRUFKQVVnQWtFQmNRMEhJQUJCK2JrRGFpQUJPZ0FBUVFBa0JVRU1JQVFRQlNFQkl3VWhBa0VBSkFVZ0FrRUJjUTBISUFCQi9Ma0RhaUFCTmdJQVFRQWtCVUVLSUFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwSElBQkJnTG9EYWlJQ0lBRkIvLzhEY1VHREFrZ0VmeUFCQlVHREFpSUJDenNCQUVFQUpBVkJFaUFFSUFCQmdyb0RhaUFCUWYvL0EzRVFCeG9qQlNFQlFRQWtCU0FCUVFGeERRY2dBRUdDdWdOcUlBSXZBUUJxUVFBNkFBQU1BZ3NNQVFzZ0JTZ0NBRUdBZ0FKeEJFQkJBQ1FGUVF3Z0JCQUZJUUVqQlNFQ1FRQWtCU0FDUVFGeERRWWdDaUFLS1FNQUlBR3RmRGNEQUFzTFFRQWtCVUVNSUFSQkFCQUdJUUVqQlNFQ1FRQWtCU0FDUVFGeFJRUkFBa0FnQnlnQ0FDQUJRZi8vQTNGSEJFQUNRQUpBQWtBZ0ZDZ0NBRUVGYXc1MUFRSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdJQUFnc01Bd3NnQUVIT3JRSnFMQUFBQkVBZ0FDZ0NBQ2dDRkNFQlFRQWtCU0FCSUFBUVRxMGpCNjFDSUlhRUlSd2pCU0VCUVFBa0JTQUJRUUZ4QkVBUUZ5RUFEQTBMSUFBb0FnQW9BaFFoQVVFQUpBVWdBU0FBRUU2dEl3ZXRRaUNHaENFZEl3VWhBVUVBSkFVQ1FDQUJRUUZ4UlFSQUlBQW9BZ0FvQWhBaEFVRUFKQVVnQVNBQUlCMUNlWHdpSGFjZ0hVSWdpS2RCQUJCUUl3VWhBVUVBSkFVZ0FVRUJjUTBCUVFBa0JVRUlJQUFRQlNFQkl3VWhBa0VBSkFVZ0FrRUJjUTBCUVFBa0JVRUlJQUFRQlNFQ0l3VWhBMEVBSkFVZ0EwRUJjUTBCUVFBa0JVRUlJQUFRQlNFREl3VWhCVUVBSkFVZ0JVRUJjUTBCUVFBa0JVRUlJQUFRQlNFRkl3VWhCa0VBSkFVZ0JrRUJjUTBCUVFBa0JVRUlJQUFRQlNFR0l3VWhDRUVBSkFVZ0NFRUJjUTBCUVFBa0JVRUlJQUFRQlNFSUl3VWhCMEVBSkFVZ0IwRUJjUTBCUVFBa0JVRUlJQUFRQlNFSEl3VWhEa0VBSkFVZ0RrRUJjUTBCSUFBb0FnQW9BaEFoRGtFQUpBVWdEaUFBSUJ5bklCeENJSWluUVFBUVVDTUZJUTVCQUNRRklBNUJBWEVFUUVFQUVCZ1FXZ1VnQnlBSUlBWWdCU0FESUFJZ0FYSnljbkp5Y2tIL0FYRkZEUVlNQkFzTEN4QVhJUUVnQUNnQ0FDZ0NFQ0VDUVFBa0JTQUNJQUFnSEtjZ0hFSWdpS2RCQUJCUUl3VWhBa0VBSkFVZ0FrRUJjVVVFUUNBQklRQU1EUXRCQUJBWUVGb0xDeUFBUWF5OEEycEJBVG9BQUVFQUpBVkJDa0dzOVFKQkF4QU5Jd1VoQVVFQUpBVWdBVUVCY1VVRVFDQVdSUTBDSUF0QkFEWUNSQ0FMUVFRMkFrZ2dDeUFBUVJocUlnRTJBZ0FnQzBGQWEwRUNOZ0lBSUFzZ0FUWUNCRUVBSkFVakJTRUJRUUFrQlNBQlFRRnhSUVJBSUFCQnJid0Rha0VCT2dBQVFRQWhBQXdMQ3dzUUZ5RUFEQW9MQ3lBS0tRTUFJQmdwQXdCVkJFQWdGeWdDQUNFQURBZ0xJQTFCQURZQ1JDQU5RUmcyQWtnZ0RVRkFhMEVCTmdJQUlBMGdBRUVZYWpZQ0FFRUFKQVVqQlNFQlFRQWtCU0FCUVFGeFJRUkFJQUJCckx3RGFrRUJPZ0FBUVFBa0JVRUtRYXoxQWtFREVBMGpCU0VBUVFBa0JTQUFRUUZ4UlFSQVFRQWhBQXdKQ3dzTEVCY2hBQXdIQ3dzTEN3c1FGeUVBREFJTEVCY2hBQXdCQ3lBRUtBSUFJZ0ZGQkVBZ0VDUUVJQUFQQ3lBQkVGSWdFQ1FFSUFBUEN5QUVLQUlBSWdGRkJFQWdBQkFlQ3lBQkVGSWdBQkFlUVFBTGxBc0NDbjhDZmlNRUlRTWpCRUdnRUdva0JDQURRU0JxSVFJZ0F5QUFFTGdCQWtBQ1FBSkFJQUJCaUx3RGFpSUhLUU1BSUFCQnFMd0RhaWdDQUsxVkJIOUJBQ1FGUVFvZ0EwRVZFQVlhSXdVaEFVRUFKQVVnQVVFQmNRMEJRUUFrQlVFSUlBQkJzS2NCYWtFQUVBMGpCU0VCUVFBa0JTQUJRUUZ4RFFFZ0FFRzBwd0ZxUVFJMkFnQkJBQ1FGUVF3Z0F4QUZJUUVqQlNFRVFRQWtCU0FFUVFGeERRRWdBRUhFcHdGcUlnVWdBVFlDQUVFQUpBVkJEQ0FERUFVaEFTTUZJUVJCQUNRRklBUkJBWEVOQVNBQVFZRG9BV29nQWEwM0F3QWdBRUdRNkFGcVFRRTJBZ0JCQUNRRlFRb2dBeEFGSVFFakJTRUVRUUFrQlNBRVFRRnhEUUVnQUVHVTZBRnFJQUZCLy84RGNUWUNBRUVBSkFWQkNpQURFQVVoQVNNRklRUkJBQ1FGSUFSQkFYRU5BU0FBUWJ5bkFXb2lDQ0FCUWYvL0EzRTJBZ0JCQUNRRlFRd2dBeEFGSVFrakJTRUJRUUFrQlNBQlFRRnhSUVJBUVFBa0JVRUxJQU1RQlNFQkl3VWhCRUVBSkFVZ0JFRUJjVVVFUUNBQVFjeW5BV29nQVVIL0FYRTJBZ0JCQUNRRlFRc2dBeEFGSVFFakJTRUVRUUFrQlNBRVFRRnhSUVJBSUFCQnVLY0JhaUlFSUFGQi93RnhRWUNBQW5JMkFnQkJBQ1FGUVFzZ0F4QUZJUUVqQlNFR1FRQWtCU0FHUVFGeFJRUkFJQUJCeWFjQmFpQUJRZjhCY1VFQ1JnUi9RUTBGUVFvTE9nQUFRUUFrQlVFTElBTVFCU0VCSXdVaEJrRUFKQVVnQmtFQmNVVUVRQ0FCUWY4QmNTRUJRUUFrQlVFTElBTVFCU0VHSXdVaENrRUFKQVVnQ2tFQmNVVUVRQ0FBUWNxbkFXb2dCam9BQUNBQVFiam9BV29nQkNnQ0FDSUVRUUZ4T2dBQUlBQkJ1ZWdCYWlBRVFRRjJRUUZ4T2dBQUlBQkJ1K2dCYWlBRVFRSjJRUUZ4SWdRNkFBQWdBRUc4NkFGcUlBUTJBZ0FnQUVINDV3RnFJZ1FnQlNnQ0FLMDNBd0FnQUVHVTZRRnFRWUNBQkRZQ0FFRUFKQVZCQ1NBQVFlRG5BV29nQ1JBTkl3VWhCVUVBSkFVZ0JVRUJjVVVFUUVFQUpBVkJDaUFESUFFUUJob2pCU0VGUVFBa0JTQUZRUUZ4UlFSQVFRQWtCVUVTSUFNZ0FpQUJFQWNhSXdVaEJVRUFKQVVDUUNBRlFRRnhSUVJBSUFJZ0FXcEJBRG9BQUVFQUpBVkJDQ0FDSUFKQmdCQVFEaU1GSVFGQkFDUUZJQUZCQVhFTkFVRUFKQVZCRVNBQ0lBQkIwS2NCYWlJQlFZQVFFQWNhSXdVaEFrRUFKQVVnQWtFQmNRMEJJQUJCclBNQWFpSUZLQUlBUVl5RkEyb29BZ0FpQWtFQlJnUkFRUUFrQlVFTklBRVFCUm9qQlNFQ1FRQWtCU0FDUVFGeERRSWdCU2dDQUVHTWhRTnFLQUlBSVFJTElBSkJBa1lFUUVFQUpBVkJEaUFCRUFVYUl3VWhBa0VBSkFVZ0FrRUJjUTBDQ3lBREtBSVVJZ0lFUUNBQVFaQzhBMm9nQnlrREFDSU1JQWdvQWdDdGZDQUVLUU1BZkNJTE53TUFCU0FBUVpDOEEyb3BBd0FoQ3lBSEtRTUFJUXdMSUFCQnpQTUFha0VDTmdJQUlBSWhBQXdNQ3dzUUZ5RUFEQXNMQ3dzTEVCY2hBQXdIQ3dzTEN4QVhCVUVBSkFWQkNpQURRUWNRQmhvakJTRUJRUUFrQlNBQlFRRnhEUUZCQUNRRlFSc2dBRUc0cGdGcUVBd2pCU0VCUVFBa0JTQUJRUUZ4RFFGQkFDUUZRUklnQXlBQ1FRUVFCeG9qQlNFQ1FRQWtCU0FDUVFGeFJRUkFRUUFrQlVFS0lBTVFCU0VDSXdVaEFVRUFKQVVnQVVFQmNVVUVRRUVBSkFWQkN5QURFQVVoQVNNRklRUkJBQ1FGSUFSQkFYRkZCRUFnQUVHUXZBTnFJQWNwQXdBaURDQUNRZi8vQTNHdGZDSUxOd01BSUFCQnpQTUFha0VCTmdJQUlBQkJuYndEYWlBQlFmOEJjU0lDUVFGeE9nQUFJQUJCbkx3RGFpQUNRUU4yUVFGeE9nQUFJQUJCbjd3RGFpQUNRUUoyUVFGeE9nQUFJQUJCMUtZQmFpQUNRUUYyUVFGeE9nQUFJQUJCMWFZQmFpQUNRUVIyUVFGeE9nQUFJQU1vQWhRaEFBd0ZDd3NMRUJjTElRQU1BZ3NRRnlFQURBRUxJQXNnREZjRVFFRUFJUUFMSUFNb0FnQWlBa1VFUUNBREpBUWdBQThMSUFJUVVpQURKQVFnQUE4TElBTW9BZ0FpQTBVRVFDQUFFQjRMSUFNUVVpQUFFQjVCQUFzaUFDQUFJQUJCa0x3RGFpa0RBRUVBSUFBb0FnQW9BaEJCQTNGQnVBSnFFUUlBQzF3QkFYOGpCQ0VDSXdSQjBBQnFKQVFnQUNBQkVQRUJCRUFnQWlRRUR3c2dBRUd0dkFOcUxBQUFSUVJBSUFKQkFEWUNSQ0FDUVRnMkFrZ2dBa0ZBYTBFQk5nSUFJQUlnQUVFWWFqWUNBQXRCclBVQ1FRSVFwQUVnQWlRRUM2UUdBUWQvSUFBUTBnRWdBRUgwRFRZQ0FFRUFKQVZCR0NBQVFaekFBR29pQkJBTUl3VWhBa0VBSkFVZ0FrRUJjUVJBRUJjaEFpQUFFSEFnQWhBZUMwRUFKQVZCRmlBQVFmRHhBR29pQlJBTUl3VWhBa0VBSkFVZ0FrRUJjUVJBRUJjaEFnVWdBRUhBOHdCcUlnWkNBRGNEQUVFQUpBVkJHU0FBUWRqekFHb2lCeEFNSXdVaEFrRUFKQVVDUUNBQ1FRRnhCRUFRRnlFQ0JTQUFRZERuQVdvaUFrSUFOd0lBSUFKQ0FEY0NDQ0FDUWdBM0FoQWdBa0lBTndJWUlBSkNBRGNDSUNBQVFaRHVBbW9pQWtJQU53SUFJQUpDQURjQ0NDQUNRZ0EzQWhBZ0FrSUFOd0lZSUFKQ0FEY0NJQ0FBUWF6ekFHb2lDRUVBTmdJQUlBQkJxUE1BYWlBQlJTSUNPZ0FBQWtBZ0FnUkFRUUFrQlVFRVFjRExCQkFGSVFNakJTRUJRUUFrQlNBQlFRRnhCRUFRRnlFQ0JVRUFKQVZCR2lBREVBd2pCU0VCUVFBa0JTQUJRUUZ4UlFSQUlBTWhBUXdEQ3hBWElRSWdBeEJTSUFCQmtPNENhaWdDQUNJREJFQWdBeEJTQ3dzZ0FFSFE1d0ZxS0FJQUlnTUVRQ0FERUZJTElBY1F0UUlNQXdzTElBZ2dBVFlDQUNBQUlBRkJuWVVEYWl3QUFEb0FGU0FBUVppOEEycEJBallDQUNBQVFhaThBMnBCQURZQ0FDQUdRZ0EzQXdBZ0FFR3R2QU5xUVFBNkFBQWdBRUdzdkFOcVFRQTZBQUFnQUVISTh3QnFRUUEyQWdBZ0FFR0l2QU5xSWdGQ0FEY0RBQ0FCUWdBM0F3Z2dBRUdjdkFOcUlnRkNBRGNDQUNBQlFRQTZBQWdnQUVHdzh3QnFRbjgzQXdBZ0FFRzQ4d0JxUVg4MkFnQWdBRUd3clFKcUlnRkNBRGNEQUNBQlFnQTNBd2dnQVVJQU53TVFJQUZDQURjREdDQUFRY0M4QTJwQkFEWUNBQ0FBUWVTOEEycEJBRFlDQUNBQVFiNjhBMnBCQURvQUFDQUFRZER6QUdwQkFEb0FBQ0FBUWJpbUFXb2lBVUlBTndNQUlBRkNBRGNEQ0NBQlFnQTNBeEFnQVVJQU53TVlJQUZDQURjRElDQUJRZ0EzQXlnZ0FVSUFOd013SUFGQ0FEY0RPQ0FCUVVCclFnQTNBd0FnQVVJQU53TklJQUZDQURjRFVDQUJRZ0EzQTFnZ0FVSUFOd05nSUFGQ0FEY0RhQ0FCUVFBMkFuQWdBRUhJdkFOcUlnQkNBRGNEQUNBQVFnQTNBd2dnQUVJQU53TVFJQUJCQURvQUdBOExDeUFGRUlRQkN5QUVFSTRCSUFBUWNDQUNFQjRMandnQkMzOGpCQ0VDSXdSQk1Hb2tCQ0FDUVJCcUlRb2dBa0VJYWlFSElBSWlDVUVZYWlJRlFnQTNBZ0FnQlVJQU53SUlRUUFrQlVFVUlBQWdCVUVBRUFjaEFpTUZJUU5CQUNRRkFrQWdBMEVCY1VVRVFDQUNCSDhnQlVFRWFpSUdLQUlBSWd0QkFXb2hBaUFHSUFJMkFnQWdBaUFGUVFocUlnZ29BZ0FpQkVzRWZ5QUZLQUlNSWdOQkFFY2dBaUFEUzNFRWYwRUFKQVVnQ1NBRE5nSUFRUUpCclBVQ1FkZ2JJQWtRRGlNRklRTkJBQ1FGSUFOQkFYRU5CRUVBSkFWQkZFR3M5UUlRRENNRklRTkJBQ1FGSUFOQkFYRU5CQ0FJS0FJQUlRUWdCaWdDQUFVZ0Fnc2hBeUFGS0FJQUlBTWdCRUVnYWlBRVFRSjJhaUlFU3dSL0lBTWlCQVVnQkFzUVZ5SURSUVJBUVFBa0JVRVVRYXoxQWhBTUl3VWhERUVBSkFVZ0RFRUJjUTBFQ3lBRklBTTJBZ0FnQ0NBRU5nSUFJQVlvQWdBRklBVW9BZ0FoQXlBQ0N5RUVJQU1nQkVGL2FtcEJBRG9BQUNBQlFRaHFJZ1FvQWdBaEF5QUJRUVJxSWdZZ0FqWUNBQ0FESUFKSkJFQWdBU2dDRENJSVFRQkhJQUlnQ0V0eEJFQkJBQ1FGSUFjZ0NEWUNBRUVDUWF6MUFrSFlHeUFIRUE0akJTRUNRUUFrQlNBQ1FRRnhEUVJCQUNRRlFSUkJyUFVDRUF3akJTRUNRUUFrQlNBQ1FRRnhEUVFnQkNnQ0FDRURJQVlvQWdBaEFnc2dBU2dDQUNBQ0lBTkJJR29nQTBFQ2Rtb2lBMHNFZnlBQ0JTQURJZ0lMUVFKMEVGY2lBMFVFUUVFQUpBVkJGRUdzOVFJUURDTUZJUWRCQUNRRklBZEJBWEVOQkFzZ0FTQUROZ0lBSUFRZ0FqWUNBQXNDZnlBQVFaaThBMm9vQWdCQkEwWUVRQ0FGS0FJQUlRQWdBU2dDQUNFQ0lBWW9BZ0FoQTBFQUpBVkJGU0FBSUFJZ0F4QUhHaU1GSVFCQkFDUUZJQUJCQVhFTkJBVWdCU2dDQUNFQ0lBRW9BZ0FoQXlBQVFZeXVBbW9vQWdCQkFYRkZCRUFnQmlnQ0FDRUFRUUFrQlVFUklBSWdBeUFBRUFjYUl3VWhBRUVBSkFVZ0FFRUJjUTBGSUFFTUFndEJBQ1FGUVJZZ0FpQURJQXRCQVhZaUFCQUhHaU1GSVFKQkFDUUZJQUpCQVhFTkJDQUJLQUlBSUFCQkFuUnFRUUEyQWdBTElBRUxJZ0FvQWdBaUF4QlpJUUFnQkNnQ0FDRUNJQVlnQURZQ0FDQUNJQUJKQkVBZ0FTZ0NEQ0lIUVFCSElBQWdCMHR4QkVCQkFDUUZJQW9nQnpZQ0FFRUNRYXoxQWtIWUd5QUtFQTRqQlNFQVFRQWtCU0FBUVFGeERRUkJBQ1FGUVJSQnJQVUNFQXdqQlNFQVFRQWtCU0FBUVFGeERRUWdBU2dDQUNFRElBUW9BZ0FoQWlBR0tBSUFJUUFMSUFNZ0FDQUNRU0JxSUFKQkFuWnFJZ0pMQkg4Z0FBVWdBaUlBQzBFQ2RCQlhJZ0pGQkVCQkFDUUZRUlJCclBVQ0VBd2pCU0VEUVFBa0JTQURRUUZ4RFFRTElBRWdBallDQUNBRUlBQTJBZ0FMUVFFRlFRQUxJUUFnQlNnQ0FDSUJSUVJBSUFra0JDQUFEd3NnQVJCU0lBa2tCQ0FBRHdzTEVCY2hBQ0FGS0FJQUlnRkZCRUFnQUJBZUN5QUJFRklnQUJBZVFRQUxCZ0FnQUNRSEM2OFhBZ3gvQW40akJDRUlJd1JCZ05BRGFpUUVJQUJCbnJ3RGFpd0FBRVVFUUNBSUpBUkJBQThMSUFoQnFNOERhaUVLSUFoQm9NOERhaUVNSUFoQm1NOERhaUVMSUFoQmtNOERhaUVOSUFoQjJNMERhaUVISUFoQnNNOERhaUVFSUFoQnJNOERhaUVKSUFBZ0FDZ0NBQ2dDRkVFSGNVR0dBV29SQUFBaER3SkFBa0FDUUFKQUFrQWdBRUdZdkFOcUlnWW9BZ0JCQVVZRVFDQUFLQUlBS0FJUUlRSWdBRUdvdkFOcUtBSUFRUWRxclNFT1FRQWtCU0FDSUFBZ0RxY2dEa0lnaUtkQkFCQlFJd1VoQWtFQUpBVWdBa0VCY1VVRVFFRUFKQVZCQ0NBQUVBVWhBaU1GSVFOQkFDUUZJQU5CQVhGRkJFQkJBQ1FGUVFnZ0FCQUZJUU1qQlNFRlFRQWtCU0FGUVFGeFJRUkFJQU5CL3dGeFFRaDBJQUpCL3dGeGNpRUNEQVVMQ3dzRklBQW9BZ0FvQWhBaEFpQUFRZFNtQVdvc0FBQkZCRUJCQUNRRlFRUWdBQkJPclNNSHJVSWdob1FoRGlNRklRTkJBQ1FGSUFOQkFYRU5Ba0VBSkFVZ0FpQUFJQTZuSUE1Q0lJaW5RUUFRVUNNRklRSkJBQ1FGSUFKQkFYRU5Ba0VBSkFWQkNDQUFRWXdPRUFZaEFpTUZJUU5CQUNRRklBTkJBWEVOQWlBQ1JRUkFRUUFoQVF3RkMwRUFKQVZCQ1NBQUlBRVFCaUVCSXdVaEFrRUFKQVVnQWtFQmNRMENEQVFMSUFCQnFMd0RhaWdDQUVFVWFxMGhEa0VBSkFVZ0FpQUFJQTZuSUE1Q0lJaW5RUUFRVUNNRklRSkJBQ1FGSUFKQkFYRkZCRUJCQUNRRlFRWWdBQkFGR2lNRklRSkJBQ1FGSUFKQkFYRkZCRUFnQUVHc3ZBTnFMQUFBUlFSQUlBQkIvTE1EYWlnQ0FFSHovd05xSVFJTUJRc2dDRUVBTmdKRUlBaEJPVFlDU0NBSVFVQnJRUUUyQWdBZ0NDQUFRUmhxTmdJQVFRQWtCU01GSVFGQkFDUUZJQUZCQVhGRkJFQkJBQ0VCREFZTEN3c0xDeEFYSVFFTUFnc0NRQUpBSUFZb0FnQkJBVVlFUUNBQVFkV21BV29zQUFCRkRRRUZJQUJCaDdRRGFpd0FBRUV3UmcwQklBQkJoclFEYWl3QUFFRnhha0VZZEVFWWRVSC9BWEZCRGtvRVFFRUFJUUVNQkFzZ0FFR0h0QU5xTFFBQVFUVktCRUJCQUNFQkRBUUxDMEVBSkFWQkZpQUhFQXdqQlNFRFFRQWtCU0FEUVFGeEJFQVFGeUVCQlNBSFFRRTZBQ2tDUUFKQUlBWW9BZ0JCQVVZRWYwRUFKQVZCQ0NBQUVBVWhBeU1GSVFWQkFDUUZJQVZCQVhFTkFVRUFKQVZCQ0NBQUVBVWhCU01GSVFwQkFDUUZJQXBCQVhFTkFVRUFKQVZCRnlBSEVBd2pCU0VLUVFBa0JTQUtRUUZ4RFFFZ0FFR0d0QU5xUVE4NkFBQWdBa0grL3dOcUlRSWdCVUgvQVhGQkNIUWdBMEgvQVhGeUJTQUFRWVMwQTJvdkFRQUxJUU5CQUNRRlFRTWdCeUFBUVFBUURpTUZJUVZCQUNRRklBVkJBWEVOQUNBSFFRQTZBQ2dnQnlBQ1FmLy9BM0d0TndNZ1FRQWtCVUVFSUFkQnFBRnFJZ0pCQWtFQkVBNGpCU0VGUVFBa0JTQUZRUUZ4RFFCQkFDUUZRUWNnQ0NBSEVBMGpCU0VGUVFBa0JTQUZRUUZ4QkVBUUZ5RUJCVUVBSkFWQkJTQUlRWUNBQkVFQUVBNGpCU0VGUVFBa0JRSkFBa0FnQlVFQmNRMEFJQWhCc0pnQmFpQURyVGNEQUNBSVFjaVlBV3BCQURvQUFDQUFRWWEwQTJvdEFBQWhBMEVBSkFWQkJpQUlJQU5CQUJBT0l3VWhBMEVBSkFVZ0EwRUJjUTBBSUFZb0FnQkJBVWNFUUVFQUpBVkJDU0FDRUFVaEFpTUZJUU5CQUNRRklBTkJBWEVOQVNBQVFZaTBBMm92QVFBZ0FrSC8vd054UndSQUlBUkJBRFlDUkNBRVFUazJBa2dnQkVGQWEwRUJOZ0lBSUFRZ0FFRVlhallDQUVFQUpBVWpCU0VCUVFBa0JTQUJRUUZ4RFFJZ0NCQ1ZBU0FIRUlRQlFRQWhBUXdLQ3d0QkFDUUZRUWNnQnlBRUlBa1FEaU1GSVFKQkFDUUZBa0FnQWtFQmNVVUVRQ0FCUVFocUlnVW9BZ0FoQmlBQlFRUnFJZ01nQ1NnQ0FFRUJhaUlDTmdJQUlBWWdBa2tFUUNBQktBSU1JZ3BCQUVjZ0FpQUtTM0VFUUVFQUpBVWdEU0FLTmdJQVFRSkJyUFVDUWRnYklBMFFEaU1GSVFKQkFDUUZJQUpCQVhFTkEwRUFKQVZCRkVHczlRSVFEQ01GSVFKQkFDUUZJQUpCQVhFTkF5QUZLQUlBSVFZZ0F5Z0NBQ0VDQ3lBQktBSUFJQUlnQmtFZ2FpQUdRUUoyYWlJR1N3Ui9JQUlGSUFZaUFndEJBblFRVnlJR1JRUkFRUUFrQlVFVVFhejFBaEFNSXdVaENrRUFKQVVnQ2tFQmNRMERDeUFCSUFZMkFnQWdCU0FDTmdJQUlBTW9BZ0FoQWdzZ0FTZ0NBRUVBSUFKQkFuUVFWQm9nQkNnQ0FDRUNJQUVvQWdBaEJpQUpLQUlBSVFSQkFDUUZRUkVnQWlBR0lBUVFCeG9qQlNFQ1FRQWtCU0FDUVFGeERRRWdBU2dDQUNJRUVGa2hBaUFGS0FJQUlRWWdBeUFDTmdJQUlBWWdBa2tFUUNBQktBSU1JZ2xCQUVjZ0FpQUpTM0VFUUVFQUpBVWdDeUFKTmdJQVFRSkJyUFVDUWRnYklBc1FEaU1GSVFKQkFDUUZJQUpCQVhFTkEwRUFKQVZCRkVHczlRSVFEQ01GSVFKQkFDUUZJQUpCQVhFTkF5QUZLQUlBSVFZZ0F5Z0NBQ0VDSUFFb0FnQWhCQXNnQkNBQ0lBWkJJR29nQmtFQ2Rtb2lCa3NFZnlBQ0JTQUdJZ0lMUVFKMEVGY2lCa1VFUUVFQUpBVkJGRUdzOVFJUURDTUZJUVJCQUNRRklBUkJBWEVOQXdzZ0FTQUdOZ0lBSUFVZ0FqWUNBQXNnQ0JDVkFTQUhFSVFCSUFNaEFRd0pDd3NRRnlFQkRBRUxFQmNoQVFzZ0NCQ1ZBUXNNQVFzUUZ5RUJDeUFIRUlRQkN3d0RDeUFDUWYvL0EzRWlCUVJBUVFBZ0JVRWdTd1IvSUFVRlFTQUxJZ01RVnlJQ1JRUkFRUUFrQlVFVVFhejFBaEFNSXdVaEFrRUFKQVVnQWtFQmNRUkFFQmNoQVF3RkJVRUFJUUlMQ3dWQkFDRUNRUUFoQXdzZ0FDZ0NBQ2dDRENFRVFRQWtCU0FFSUFBZ0FpQUZFQWNhSXdVaEJFRUFKQVVDUUNBRVFRRnhCRUFnQWlFQkJTQUdLQUlBUVFGSEJFQWdBRUdJdEFOcUx3RUFJUVpCQUNRRlFSTkJmeUFDSUFVUUJ5RUVJd1VoQ1VFQUpBVWdDVUVCY1FSQUlBSWhBUXdEQ3lBRVFmLy9BM0ZCLy84RGN5QUdRZi8vQTNGSEJFQWdCMEVBTmdKRUlBZEJPVFlDU0NBSFFVQnJRUUUyQWdBZ0J5QUFRUmhxTmdJQVFRQWtCU01GSVFGQkFDUUZJQUZCQVhFRVFDQUNJUUVNQkFzZ0FrVUVRRUVBSVFFTUJnc2dBaEJTUVFBaEFRd0ZDd3NnQVVFSWFpSUxLQUlBSVFrZ0FVRUVhaUlHSUFWQkFXb2lCellDQUNBSklBVk5CRUFnQVNnQ0RDSUVRUUJISUFVZ0JFOXhCSDlCQUNRRklBd2dCRFlDQUVFQ1FhejFBa0hZR3lBTUVBNGpCU0VFUVFBa0JTQUVRUUZ4QkVBZ0FpRUJEQVFMUVFBa0JVRVVRYXoxQWhBTUl3VWhCRUVBSkFVZ0JFRUJjUVJBSUFJaEFRd0VDeUFMS0FJQUlRa2dCaWdDQUFVZ0J3c2hCQ0FCS0FJQUlBUWdDVUVnYWlBSlFRSjJhaUlKU3dSL0lBUUZJQWtpQkF0QkFuUVFWeUlKUlFSQVFRQWtCVUVVUWF6MUFoQU1Jd1VoREVFQUpBVWdERUVCY1FSQUlBSWhBUXdFQ3dzZ0FTQUpOZ0lBSUFzZ0JEWUNBQXNnQlNBRFR3UkFJQUlnQnlBRFFTQnFJQU5CQW5acUlnTkxCSDhnQndVZ0F3c1FWeUlEQkVBZ0F5RUNCVUVBSkFWQkZFR3M5UUlRRENNRklRTkJBQ1FGSUFOQkFYRUVRQ0FDSVFFTUJBVkJBQ0VDQ3dzTElBSWdCV3BCQURvQUFDQUJLQUlBSVFOQkFDUUZRUkVnQWlBRElBVVFCeG9qQlNFRFFRQWtCU0FEUVFGeEJFQWdBaUVCQlNBQktBSUFJZ2NRV1NFRUlBc29BZ0FoQlNBR0lBUTJBZ0FnQlNBRVNRUkFJQUVvQWd3aUEwRUFSeUFFSUFOTGNRUi9RUUFrQlNBS0lBTTJBZ0JCQWtHczlRSkIyQnNnQ2hBT0l3VWhBMEVBSkFVZ0EwRUJjUVJBSUFJaEFRd0ZDMEVBSkFWQkZFR3M5UUlRRENNRklRTkJBQ1FGSUFOQkFYRUVRQ0FDSVFFTUJRc2dBU0VESUFzb0FnQWhCU0FHS0FJQUlRRWdBeWdDQUFVZ0FTRURJQVFoQVNBSEN5QUJJQVZCSUdvZ0JVRUNkbW9pQkVzRWZ5QUJCU0FFSWdFTFFRSjBFRmNpQkVVRVFFRUFKQVZCRkVHczlRSVFEQ01GSVFWQkFDUUZJQVZCQVhFRVFDQUNJUUVNQlFzTElBTWdCRFlDQUNBTElBRTJBZ0FMSUFKRkJFQWdCaUVCREFRTElBSVFVaUFHSVFFTUF3c0xDeEFYSVFJZ0FVVUVRQ0FDSVFFTUF3c2dBUkJTSUFJaEFRd0NDeUFCS0FJQVFRQkhJUUVMSUFBb0FnQW9BaEFoQWtFQUpBVWdBaUFBSUErbklBOUNJSWluUVFBUVVDTUZJUUJCQUNRRklBQkJBWEVFUUVFQUVCZ1FXZ1VnQ0NRRUlBRVBDd3dCQ3lBQUtBSUFLQUlRSVFKQkFDUUZJQUlnQUNBUHB5QVBRaUNJcDBFQUVGQWpCU0VBUVFBa0JTQUFRUUZ4QkVCQkFCQVlFRm9GSUFFUUhnc0xRUUFMVUFJQ2Z3RitJd1FoQVNNRVFSQnFKQVFDZjBFQUlBQkIyUE1BYWlJQ1FlZ3hhaXdBQUVVTkFCb2dBU0FDUWJBeWFpa0RBRGNEQUVFQkN3UitJQUVwQXdBRklBQVEwd0VMSVFNZ0FTUUVJQU1MSFFBZ0FFSFk4d0JxSUFFZ0FoQ1FCQVJBRHdzZ0FDQUJJQUlRbkFFTE93RUJmeU1FSVFNakJFRVFhaVFFSUFCQjJQTUFhaUFCSUFJZ0F4Q3FCQVJBSUFNb0FnQWhBQVVnQUNBQklBSVExQUVoQUFzZ0F5UUVJQUFMRndBZ0FFSEFwUUZxUVFBNkFBQWdBQ0FCSUFJUW1BSUxDZ0FnQUJCK0lBQVFVZ3NjQUNBQklBS3RJQU90UWlDR2hDQUVJQUJCQTNGQnVBSnFFUUlBQ3hvQUlBRWdBcTBnQTYxQ0lJYUVJQUJCQTNGQnRBSnFFUmNBQ3gwQkFYNGdBU0FBUVFkeFFZWUJhaEVBQUNJQ1FpQ0lweVFISUFLbkN5SUFJQUd0SUFLdFFpQ0doQ0FEclNBRXJVSWdob1FnQUVFQmNVR0VBV29SRWdBTEpnQWdBU0FDSUFNZ0JDQUZJQWF0SUFldFFpQ0doQ0FJSUFrZ0FFRUJjVUdDQVdvUkVRQUxCZ0JCRlJBQUN3WUFRUlFRQUFzbUFFR3M5UUpCQURZQ0FFR3c5UUpCQURZQ0FFRzA5UUpCQVRvQUFFRzE5UUpCQURZQUFBc0dBRUVQRUFBTENBQkJDaEFBUVFBTENBQkJDUkFBUVFBTEl3QWdBU0FBVXdSL1FlUUFCU0FCUWdCUkJIOUJBQVVnQUVMa0FINGdBWCtuQ3dzTEVBQWpCVVVFUUNBQUpBVWdBU1FHQ3dzSUFFRUlFQUJCQUFzSUFFRUdFQUJCQUFzSUFFRUVFQUJCQUFzUEFFRUFFQUJFQUFBQUFBQUFBQUFMSWdBZ0FTQUNJQU1nQkNBRklBWWdCeUFJSUFrZ0NpQUFRUUZ4UWJJQ2FoRVdBQXNnQUNBQklBSWdBeUFFSUFVZ0JpQUhJQWdnQ1NBQVFRRnhRYkFDYWhFVkFBc2FBQ0FCSUFJZ0F5QUVJQVVnQmlBQVFRZHhRYWdDYWhFTEFBc1lBQ0FCSUFJZ0F5QUVJQVVnQUVFSGNVR2dBbW9SREFBTEZnQWdBU0FDSUFNZ0JDQUFRUWR4UVpnQ2FoRUtBQXNVQUNBQklBSWdBeUFBUVI5eFFmZ0JhaEVIQUFzVUFDQUJJQUlnQXlBQVFRRnhRZllCYWhFVUFBc1NBQ0FCSUFJZ0FFRWZjVUhXQVdvUkJnQUxFQUFnQVNBQVFUOXhRWllCYWhFVEFBc09BQ0FBUVFkeFFZNEJhaEVJQUFzZ0FDQUJJQUlnQXlBRUlBVWdCaUFISUFnZ0NTQUFRUUZ4UVlBQmFoRVFBQXNhQUNBQklBSWdBeUFFSUFVZ0JpQUFRUU54UWZ3QWFoRVBBQXNZQUNBQklBSWdBeUFFSUFVZ0FFRUJjVUg2QUdvUkRnQUxGZ0FnQVNBQ0lBTWdCQ0FBUVE5eFFlb0FhaEVEQUFzVUFDQUJJQUlnQXlBQVFSOXhRY29BYWhFQkFBc1JBQ0FCSUFJZ0FFRWZjVUVxYWhFRUFBc1BBQ0FCSUFCQkgzRkJDbW9SQ1FBTERnQWdBU0FDSUFCQkFYRVJEUUFMR2dBZ0FBUi9JQUJCc0FwQm1BdEJBQkNhQVVFQVJ3VkJBQXNMU1FFQmZ5TUVJUU1qQkVFUWFpUUVJQU1nQWlnQ0FEWUNBQ0FBSUFFZ0F5QUFLQUlBS0FJUVFSOXhRY29BYWhFQkFDSUFCRUFnQWlBREtBSUFOZ0lBQ3lBREpBUWdBRUVCY1F0MUFRSi9Ba0FnQUNBQktBSUlSZ1JBUVFBZ0FTQUNJQU1Rd1FFRklBQkJFR29nQUNnQ0RDSUVRUU4wYWlFRklBQkJFR29nQVNBQ0lBTVErUUVnQkVFQlNnUkFJQUZCTm1vaEJDQUFRUmhxSVFBRFFDQUFJQUVnQWlBREVQa0JJQVFzQUFBTkF5QUFRUWhxSWdBZ0JVa05BQXNMQ3dzTHJBVUJDWDhDUUNBQUlBRW9BZ2hHQkVBZ0FTZ0NCQ0FDUmdSQUlBRkJIR29pQUNnQ0FFRUJSd1JBSUFBZ0F6WUNBQXNMQlNBQUlBRW9BZ0JIQkVBZ0FDZ0NEQ0VGSUFCQkVHb2dBU0FDSUFNZ0JCQ3JBU0FGUVFGTURRSWdBRUVRYWlBRlFRTjBhaUVISUFCQkdHb2hCU0FBS0FJSUlnWkJBbkZGQkVBZ0FVRWthaUlBS0FJQVFRRkhCRUFnQmtFQmNVVUVRQ0FCUVRacUlRWURRQ0FHTEFBQURRWWdBQ2dDQUVFQlJnMEdJQVVnQVNBQ0lBTWdCQkNyQVNBRlFRaHFJZ1VnQjBrTkFBd0dDd0FMSUFGQkdHb2hCaUFCUVRacUlRZ0RRQ0FJTEFBQURRVWdBQ2dDQUVFQlJnUkFJQVlvQWdCQkFVWU5CZ3NnQlNBQklBSWdBeUFFRUtzQklBVkJDR29pQlNBSFNRMEFEQVVMQUFzTElBRkJObW9oQUFOQUlBQXNBQUFOQXlBRklBRWdBaUFESUFRUXF3RWdCVUVJYWlJRklBZEpEUUFNQXdzQUN5QUJLQUlRSUFKSEJFQWdBVUVVYWlJTEtBSUFJQUpIQkVBZ0FTQUROZ0lnSUFGQkxHb2lEQ2dDQUVFRVJnMERJQUJCRUdvZ0FDZ0NERUVEZEdvaERTQUJRVFJxSVFjZ0FVRTFhaUVHSUFGQk5tb2hDQ0FBUVFocUlRa2dBVUVZYWlFS1FRQWhBeUFBUVJCcUlRVkJBQ0VBQW44Q1FBSkFBMEFnQlNBTlR3MEJJQWRCQURvQUFDQUdRUUE2QUFBZ0JTQUJJQUlnQWtFQklBUVF2d0VnQ0N3QUFBMEJBa0FnQml3QUFBUkFJQWNzQUFCRkJFQWdDU2dDQUVFQmNRUkFRUUVoQXd3REJVRUJJUU1NQlFzQUN5QUtLQUlBUVFGR0RRUWdDU2dDQUVFQ2NVVU5CRUVCSVFOQkFTRUFDd3NnQlVFSWFpRUZEQUFMQUFzZ0FFVUVRQ0FMSUFJMkFnQWdBVUVvYWlJQUlBQW9BZ0JCQVdvMkFnQWdBU2dDSkVFQlJnUkFJQW9vQWdCQkFrWUVRQ0FJUVFFNkFBQWdBdzBEUVFRTUJBc0xDeUFERFFCQkJBd0JDMEVEQ3lFQUlBd2dBRFlDQUF3REN3c2dBMEVCUmdSQUlBRkJBVFlDSUFzTEN3dUFBZ0VJZnlBQUlBRW9BZ2hHQkVCQkFDQUJJQUlnQXlBRUVNQUJCU0FCUVRScUlnWXNBQUFoQ1NBQlFUVnFJZ2NzQUFBaENpQUFRUkJxSUFBb0Fnd2lDRUVEZEdvaEN5QUdRUUE2QUFBZ0IwRUFPZ0FBSUFCQkVHb2dBU0FDSUFNZ0JDQUZFTDhCQWtBZ0NFRUJTZ1JBSUFGQkdHb2hEQ0FBUVFocUlRZ2dBVUUyYWlFTklBQkJHR29oQUFOQUlBMHNBQUFOQWlBR0xBQUFCRUFnRENnQ0FFRUJSZzBESUFnb0FnQkJBbkZGRFFNRklBY3NBQUFFUUNBSUtBSUFRUUZ4UlEwRUN3c2dCa0VBT2dBQUlBZEJBRG9BQUNBQUlBRWdBaUFESUFRZ0JSQy9BU0FBUVFocUlnQWdDMGtOQUFzTEN5QUdJQWs2QUFBZ0J5QUtPZ0FBQ3d1MkFRRUNmd0pBSUFKQmYyb2lCQVJBUVFBaEFnTkFBa0FDUUFKQUlBQWdBbW9zQUFBaUF3NWRBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lCQWdzTUJBdEJMeUVEQ3lBQklBSnFJQU02QUFBZ0FrRUJhaUlDSUFSSkRRQUxCVUVBSVFJTEN5QUJJQUpxUVFBNkFBQUw0d0lCQW44akJDRURJd1JCUUdza0JDQUNJQUlvQWdBb0FnQTJBZ0FnQUNBQlJnUi9RUUVGSUFGQndBdEdDd1IvUVFFRklBRUVmeUFCUWJBS1FaZ0xRUUFRbWdFaUFRUi9JQUVvQWdnZ0FDZ0NDRUYvYzNFRWYwRUFCU0FBUVF4cUlnQW9BZ0FnQVVFTWFpSUJLQUlBUmdSL1FRRUZJQUFvQWdCQnVBdEdCSDlCQVFVZ0FDZ0NBQ0lBQkg4Z0FFR3dDa0dnQ2tFQUVKb0JJZ1FFZnlBQktBSUFJZ0FFZnlBQVFiQUtRYUFLUVFBUW1nRWlBUVIvSUFOQkJHb2lBRUlBTndJQUlBQkNBRGNDQ0NBQVFnQTNBaEFnQUVJQU53SVlJQUJDQURjQ0lDQUFRZ0EzQWlnZ0FFRUFOZ0l3SUFNZ0FUWUNBQ0FESUFRMkFnZ2dBMEYvTmdJTUlBTkJBVFlDTUNBQklBTWdBaWdDQUVFQklBRW9BZ0FvQWh4QkIzRkJtQUpxRVFvQUlBTW9BaGhCQVVZRWZ5QUNJQU1vQWhBMkFnQkJBUVZCQUFzRlFRQUxCVUVBQ3dWQkFBc0ZRUUFMQ3dzTEJVRUFDd1ZCQUFzTElRQWdBeVFFSUFBTE1RRUNmeUFBS0FJQVFYUnFJZ0ZCQ0dvaUFpZ0NBQ0VBSUFJZ0FFRi9hallDQUNBQVFYOXFRUUJJQkVBZ0FSQlNDd3NLQUNBQVFRUnFLQUlBQ3dZQVFaWHpBQXRwQVFKL1FRQWtCVUVGRUFRaEFDTUZJUUZCQUNRRklBRkJBWEVFUUVFQUVCZ1FXZ3NnQUFSQUlBQW9BZ0FpQUFSQUlBQXBBekJDZ0g2RFFvRFdySm4weUpPbXd3QlJCRUFnQUNnQ0RCRDlBUXNMQ3dKL1FlZ2tRZWdrS0FJQUlnQTJBZ0FnQUFzUS9RRUxMd0VCZnlNRUlRRWpCRUVRYWlRRUlBQVFVa0dzdkFNb0FnQkJBQkJLQkVCQmh2SUFJQUVRZ2dFRklBRWtCQXNMZ2dFQkFuOGdBQ2dDQUNJQ1JRUkFEd3NnQVFSL1FjUU5CVUhnRFFzaEF5QUJCRUFnQWlFQkJTQUNJUUVEUUNBRElBRVFkQVJBSUFCQjN3QTJBZ0FMSUFCQkJHb2lBQ2dDQUNJQkRRQUxEd3NEUUFKQUFrQWdBeUFCRUhRTkFDQUFLQUlBUVNCSkRRQU1BUXNnQUVIZkFEWUNBQXNnQUVFRWFpSUFLQUlBSWdFTkFBc0xLQUVCZnlNRUlRQWpCRUVRYWlRRVFheThBMEV0RUVnRVFFSFU4UUFnQUJDQ0FRVWdBQ1FFQ3dzNkFRRi9JQUFnQVNnQ0NFWUVRRUVBSUFFZ0FpQURFTUVCQlNBQUtBSUlJZ1FnQVNBQ0lBTWdCQ2dDQUNnQ0hFRUhjVUdZQW1vUkNnQUxDOGNDQVFOL0FrQWdBQ0FCS0FJSVJnUkFJQUVvQWdRZ0FrWUVRQ0FCUVJ4cUlnQW9BZ0JCQVVjRVFDQUFJQU0yQWdBTEN3VWdBQ0FCS0FJQVJ3UkFJQUFvQWdnaUFDQUJJQUlnQXlBRUlBQW9BZ0FvQWhoQkIzRkJvQUpxRVF3QURBSUxJQUVvQWhBZ0FrY0VRQ0FCUVJScUlnVW9BZ0FnQWtjRVFDQUJJQU0yQWlBZ0FVRXNhaUlES0FJQVFRUkdEUU1nQVVFMGFpSUdRUUE2QUFBZ0FVRTFhaUlIUVFBNkFBQWdBQ2dDQ0NJQUlBRWdBaUFDUVFFZ0JDQUFLQUlBS0FJVVFRZHhRYWdDYWhFTEFBSkFBa0FnQnl3QUFBUkFJQVlzQUFBRVFFRURJUUFGUVFNaEFBd0NDd1ZCQkNFQURBRUxEQUVMSUFVZ0FqWUNBQ0FCUVNocUlnSWdBaWdDQUVFQmFqWUNBQ0FCS0FJa1FRRkdCRUFnQVNnQ0dFRUNSZ1JBSUFGQkFUb0FOZ3NMQ3lBRElBQTJBZ0FNQXdzTElBTkJBVVlFUUNBQlFRRTJBaUFMQ3dzTFFBRUJmeUFBSUFFb0FnaEdCRUJCQUNBQklBSWdBeUFFRU1BQkJTQUFLQUlJSWdZZ0FTQUNJQU1nQkNBRklBWW9BZ0FvQWhSQkIzRkJxQUpxRVFzQUN3c1lBQ0FBSUFFb0FnaEdCRUJCQUNBQklBSWdBeERCQVFzTHJnRUFBa0FnQUNBQktBSUlSZ1JBSUFFb0FnUWdBa1lFUUNBQlFSeHFJZ0FvQWdCQkFVY0VRQ0FBSUFNMkFnQUxDd1VnQUNBQktBSUFSZ1JBSUFFb0FoQWdBa2NFUUNBQlFSUnFJZ0FvQWdBZ0FrY0VRQ0FCSUFNMkFpQWdBQ0FDTmdJQUlBRkJLR29pQUNBQUtBSUFRUUZxTmdJQUlBRW9BaVJCQVVZRVFDQUJLQUlZUVFKR0JFQWdBVUVCT2dBMkN3c2dBVUVFTmdJc0RBUUxDeUFEUVFGR0JFQWdBVUVCTmdJZ0N3c0xDd3NhQUNBQUlBRW9BZ2hHQkVCQkFDQUJJQUlnQXlBRUVNQUJDd3ZJQVFFQ2Z5TUVJUU1qQkVGQWF5UUVJQUFnQVVZRWYwRUJCU0FCQkg4Z0FVR3dDa0dnQ2tFQUVKb0JJZ0VFZnlBRFFRUnFJZ1JDQURjQ0FDQUVRZ0EzQWdnZ0JFSUFOd0lRSUFSQ0FEY0NHQ0FFUWdBM0FpQWdCRUlBTndJb0lBUkJBRFlDTUNBRElBRTJBZ0FnQXlBQU5nSUlJQU5CZnpZQ0RDQURRUUUyQWpBZ0FTQURJQUlvQWdCQkFTQUJLQUlBS0FJY1FRZHhRWmdDYWhFS0FDQURLQUlZUVFGR0JIOGdBaUFES0FJUU5nSUFRUUVGUVFBTEJVRUFDd1ZCQUFzTElRQWdBeVFFSUFBTGxBSUNCWDhCZmlNRUlRRWpCRUV3YWlRRUlBRkJHR29oQWlBQlFSQnFJUU1nQVVFa2FpRUVFUDRCSWdBRVFDQUFLQUlBSWdBRVFDQUFLUU13SWdWQ2dINkRRb0RXckpuMHlKT213d0JTQkVBZ0FrR1k4QUEyQWdCQjV1OEFJQUlRZ2dFTElBQkIwQUJxSVFJZ0JVS0IxcXlaOU1pVHBzTUFVUVJBSUFBb0Fpd2hBZ3NnQkNBQ05nSUFJQUFvQWdBaUFDZ0NCQ0VDUVpnS0lBQWdCRUdZQ2lnQ0FDZ0NFRUVmY1VIS0FHb1JBUUFFUUNBRUtBSUFJZ0FnQUNnQ0FDZ0NDRUVmY1VFS2FoRUpBQ0VBSUFGQm1QQUFOZ0lBSUFFZ0FqWUNCQ0FCSUFBMkFnaEJrTzhBSUFFUWdnRUZJQU5CbVBBQU5nSUFJQU1nQWpZQ0JFRzk3d0FnQXhDQ0FRc0xDMEdNOEFBZ0FVRWdhaENDQVFzTkFDQUFJQUVnQVJCWkVLQURDN0FFQVFsL0lBRkI3Ly8vL3dOTEJFQWdBQkNLQVFzZ0FFRUlhaUlJUVFOcUlnb3NBQUFpQlVFQVNDSUpCSDhnQ0NnQ0FFSC8vLy8vQjNGQmYyb2hBaUFBS0FJRUJVRUJJUUlnQlVIL0FYRUxJZ2NnQVVzRWZ5QUhJZ0VGSUFFTFFRSkpJUU1nQVVFRWFrRjhjVUYvYWlFQkFrQWdBd1IvUVFFaUFRVWdBUXNnQWtjRVFBSkFBbjhnQXdSQUlBQW9BZ0FoQkNBSkJFQWdCQ0VEUVFBaEJTQUFJUVFGSUFBZ0JDQUZRZjhCY1VFQmFoQ1BBUm9nQkJCU0RBTUxCU0FCUVFGcUlnTkIvLy8vL3dOTElRWUNRQ0FCSUFKTEJFQWdCa1VFUUNBRFFRSjBFRjhoQkF3Q0MwRUlFQlFoQWtFQUpBVkJGeUFDUWN6dUFCQU5Jd1VoQmtFQUpBVWdCa0VCY1FSQUVCY2hCaUFDRUJvZ0JoQWVCU0FDUWV3bE5nSUFJQUpCK0FwQkRCQWJDd1VDUUFKQUlBWUVRRUVJRUJRaEFVRUFKQVZCRnlBQlFjenVBQkFOSXdVaEFFRUFKQVVnQUVFQmNRUkFRUUFRR0NFQUlBRVFHZ1VnQVVIc0pUWUNBRUVBSkFWQkdDQUJRZmdLUVF3UURrRUFKQVVNQWdzRlFRQWtCVUVFSUFOQkFuUVFCU0VFSXdVaEFrRUFKQVVnQWtFQmNRMEJEQVFMREFFTFFRQVFHQ0VBQ3lBQUVCVWFFQllNQmdzTElBa0VRQ0FBS0FJQUlRTkJBU0VGQlNBRUlBQWdCVUgvQVhGQkFXb1Fqd0VhSUFCQkJHb01BZ3NMSUFRZ0F5QUFRUVJxSWdJb0FnQkJBV29RandFYUlBTVFVaUFGUlEwQklBRkJBV29oQXlBQ0N5RUJJQWdnQTBHQWdJQ0FlSEkyQWdBZ0FTQUhOZ0lBSUFBZ0JEWUNBQXdDQ3lBS0lBYzZBQUFMQ3d2NUFnRUZmeU1FSVFrakJFRVFhaVFFUWU3Ly8vOERJQUZySUFKSkJFQWdBQkNLQVFzZ0FFRUlhaUlNTEFBRFFRQklCSDhnQUNnQ0FBVWdBQXNoQ2lBQlFlZi8vLzhCU1FSQUlBSWdBV29pQ0NBQlFRRjBJZ0pKQkg4Z0FnVWdDQ0lDQzBFRWFrRjhjU0VJSUFKQkFra0VmMEVDQlNBSUN5SUNRZi8vLy84RFN3UkFRUWdRRkNFQ1FRQWtCVUVYSUFKQnpPNEFFQTBqQlNFSVFRQWtCU0FJUVFGeEJFQVFGeUVJSUFJUUdpQUlFQjRGSUFKQjdDVTJBZ0FnQWtINENrRU1FQnNMQlNBQ0lRc0xCVUh2Ly8vL0F5RUxDeUFMUVFKMEVGOGhBaUFFQkVBZ0FpQUtJQVFRandFYUN5QUdCRUFnQWlBRVFRSjBhaUFISUFZUWp3RWFDeUFESUFWcklnTWdCR3NpQndSQUlBSWdCRUVDZEdvZ0JrRUNkR29nQ2lBRVFRSjBhaUFGUVFKMGFpQUhFSThCR2dzZ0FVRUJSd1JBSUFvUVVnc2dBQ0FDTmdJQUlBd2dDMEdBZ0lDQWVISTJBZ0FnQUNBRElBWnFJZ0EyQWdRZ0NVRUFOZ0lBSUFJZ0FFRUNkR29nQ1NnQ0FEWUNBQ0FKSkFRTFBBRUJmeUFDQkVCQkFDUUZRUjhnQUNBQklBSVFCeG9qQlNFQlFRQWtCU0FCUVFGeEJFQkJBQkFZSWdBUVdnVWdBQ0VEQ3dVZ0FDRURDeUFEQzdnQkFRVi9Jd1FoQlNNRVFSQnFKQVFnQUVFSWFpSUVRUU5xSWdZc0FBQWlBMEVBU0NJSEJIOGdCQ2dDQUVILy8vLy9CM0ZCZjJvRlFRRUxJZ1FnQWtrRVFDQUFJQVFnQWlBRWF5QUhCSDhnQUNnQ0JBVWdBMEgvQVhFTElnTkJBQ0FESUFJZ0FSQ2VBd1VnQndSL0lBQW9BZ0FGSUFBTElnTWdBU0FDRUo4REdpQUZRUUEyQWdBZ0F5QUNRUUowYWlBRktBSUFOZ0lBSUFZc0FBQkJBRWdFUUNBQUlBSTJBZ1FGSUFZZ0Fqb0FBQXNMSUFVa0JDQUFDKzBCQVFSL0lBQWdBQkJaUVFKMGFpRUNBMEFnQWtGOGFpSUNJQUJMSUFJb0FnQkJVR3BCQ2tsQkFYTnhCRUFNQVFVZ0FpRUJDd3NEUUNBQlFYeHFJUVFnQVNBQVN5SURJQUVvQWdCQlVHcEJDa2x4QkVBZ0JDRUJEQUVMQ3lBRFJRUkFJQUlQQ3dKQUFrQURRQ0FCS0FJQUlnUkJMa1lOQWlBRVFWQnFRUXBKRFFFZ0FVRjhhaUlCSUFCTERRQU1BZ3NBQ3lBQUVGa2hBd0pBQWtBRFFDQURRUUJLQkVBZ0FDQURRWDlxSWdSQkFuUnFLQUlBUVM5R0RRSWdCQ0VEREFFTEN3d0JDeUFBSUFOQkFuUnFJUUFMSUFCQkxoQjBJZ0JCQUVjZ0FDQUJTWEVFZnlBQkJTQUNDdzhMSUFJTERRQWdBQ0FCSUFFUWJoRC9BUXZtQWdFSWZ5QUJRVzlMQkVBZ0FCQ0tBUXNnQUVFTGFpSUpMQUFBSWdWQkFFZ2lCQVIvSUFBb0FnaEIvLy8vL3dkeFFYOXFJUVlnQUNnQ0JBVkJDaUVHSUFWQi93RnhDeUlISUFGTEJIOGdCeUlCQlNBQkMwRUxTU0VESUFGQkVHcEJjSEZCZjJvaEFRSkFJQU1FZjBFS0JTQUJDeUlJSUFaSEJFQUNRQUpBSUFNRVFDQUFLQUlBSVFJZ0JBUkFRUUFoQkNBQUlRRUZJQUFnQWlBRlFmOEJjVUVCYWhDSkFSb2dBaEJTREFNTEJTQUlRUUZxSVFJZ0NDQUdTd1JBSUFJUVh5RUJCVUVBSkFWQkJDQUNFQVVoQVNNRklRTkJBQ1FGSUFOQkFYRUVRRUVBRUJnUUZSb1FGZ3dHQ3dzZ0JBUkFJQUFvQWdBaEFrRUJJUVFGSUFFZ0FDQUZRZjhCY1VFQmFoQ0pBUm9nQUVFRWFpRUREQUlMQ3lBQklBSWdBRUVFYWlJREtBSUFRUUZxRUlrQkdpQUNFRklnQkVVTkFTQUlRUUZxSVFJTElBQWdBa0dBZ0lDQWVISTJBZ2dnQXlBSE5nSUFJQUFnQVRZQ0FBd0NDeUFKSUFjNkFBQUxDd3VDQWdFRGZ5TUVJUWtqQkVFUWFpUUVRVzRnQVdzZ0Fra0VRQ0FBRUlvQkN5QUFMQUFMUVFCSUJIOGdBQ2dDQUFVZ0FBc2hDaUFCUWVmLy8vOEhTUVIvSUFJZ0FXb2lDQ0FCUVFGMElnSkpCSDhnQWdVZ0NDSUNDMEVRYWtGd2NTRUlJQUpCQzBrRWYwRUxCU0FJQ3dWQmJ3c2lBaEJmSVFnZ0JBUkFJQWdnQ2lBRUVJa0JHZ3NnQmdSQUlBZ2dCR29nQnlBR0VJa0JHZ3NnQXlBRmF5SURJQVJySWdjRVFDQUlJQVJxSUFacUlBb2dCR29nQldvZ0J4Q0pBUm9MSUFGQkNrY0VRQ0FLRUZJTElBQWdDRFlDQUNBQUlBSkJnSUNBZ0hoeU5nSUlJQUFnQXlBR2FpSUFOZ0lFSUFsQkFEb0FBQ0FJSUFCcUlBa3NBQUE2QUFBZ0NTUUVDMG9CQkg4Z0FDQUJSd1JBSUFFc0FBc2lBa0VBU0NFRElBRW9BZ0FoQkNBQktBSUVJUVVnQWtIL0FYRWhBaUFBSUFNRWZ5QUVCU0FCQ3lBREJIOGdCUVVnQWdzUS93RWFDeUFBQzdRQkFRUi9Jd1FoQXlNRVFSQnFKQVFnQUVJQU53SUFJQUJCQURZQ0NDQUJMQUFMUVFCSUJFQWdBU2dDQUNFRUlBRW9BZ1FpQWtGdlN3UkFJQUFRaWdFTElBSkJDMGtFUUNBQUlBSTZBQXNGSUFBZ0FrRVFha0Z3Y1NJRkVGOGlBVFlDQUNBQUlBVkJnSUNBZ0hoeU5nSUlJQUFnQWpZQ0JDQUJJUUFMSUFBZ0JDQUNFSWtCR2lBRFFRQTZBQUFnQUNBQ2FpQURMQUFBT2dBQUJTQUFJQUVwQWdBM0FnQWdBQ0FCS0FJSU5nSUlDeUFESkFRTEx3QWdBRUhZSlRZQ0FFRUFKQVZCR0NBQVFRUnFJQUVRRFNNRklRQkJBQ1FGSUFCQkFYRUVRQkFYSWdBUUhnc0xQQUVDZnlBQkVHNGlBMEVOYWhCZklnSWdBellDQUNBQ0lBTTJBZ1FnQWtFQU5nSUlJQUpCREdvaUFpQUJJQU5CQVdvUVV4b2dBQ0FDTmdJQUN3WUFJQUFRWHdzcEFRRi9Jd1FoQkNNRVFSQnFKQVFnQkNBRE5nSUFJQUFnQVNBQ0lBUVFnQUloQUNBRUpBUWdBQXRpQVFSL0FuOENRQ0FCS0FKTVFRQklEUUFNQUFzZ0FFSC9BWEVoQXlBQVFmOEJjU0lFSUFFc0FFdEhCRUFnQVVFVWFpSUZLQUlBSWdJZ0FTZ0NFRWtFUUNBRklBSkJBV28yQWdBZ0FpQURPZ0FBSUFRTUFnc0xJQUVnQUJDQkFnc2lBQXVMQWdFR2Z5TUVJUVFqQkVFUWFpUUVRYXdqS0FJQUlRVWdBU3dBU2tFQlNBUkFJQUZCQVJDRkFob0xRYXdqSUFFb0FuZzJBZ0FDUUFKQUlBQkJnQUZKQkVBZ0FFSC9BWEVoQmlBQVFmOEJjU0lDSUFFc0FFdEhCRUFnQVVFVWFpSUhLQUlBSWdNZ0FTZ0NFRWtFUUNBSElBTkJBV28yQWdBZ0F5QUdPZ0FBSUFJaEFBd0VDd3NnQVNBQUVJRUNJUUFGSUFGQkZHb2lBaWdDQUNJRFFRUnFJQUVvQWhCSkJFQWdBeUFBRUxBQklnTkJBRWdOQWlBQ0lBSW9BZ0FnQTJvMkFnQUZJQVFnQUJDd0FTSUNRUUJJRFFJZ0JDQUNJQUVRalFJZ0Fra05BZ3NMSUFCQmYwWU5BQXdCQ3lBQklBRW9BZ0JCSUhJMkFnQkJmeUVBQzBHc0l5QUZOZ0lBSUFRa0JDQUFDN2tCQVFSL0l3UWhCQ01FUVlBQmFpUUVJQVJCeUFCcUlnTkNBRGNDQUNBRFFnQTNBZ2dnQTBJQU53SVFJQU5DQURjQ0dDQURRUUEyQWlBZ0JFSHdBR29pQlNBQ0tBSUFOZ0lBUVFBZ0FTQUZJQVFnQXhDRUFrRUFTQVIvUVg4RkFuOGdBQ2dDVEJwQkFBc2hBaUFBUVFFUWhRSWFJQUFnQUNnQ0FDSUdRVjl4TmdJQUlBQWdBU0FGSUFRZ0F4Q0VBaUVCSUFBZ0FDZ0NBQ0lESUFaQklIRnlOZ0lBSUFOQklIRUVmMEYvQlNBQkN3c2hBQ0FFSkFRZ0FBczhBUUovQWtBZ0FDZ0NBQ0lEQkVBZ0FDRUNBMEFnQVNBREVIUkZEUUlnQWtFRWFpSUNLQUlBSWdNTkFBc0ZJQUFoQWdzTElBSWdBR3RCQW5VTGJ3RURmeUFBSUFGclFRSjFJQUpKQkVBRFFDQUFJQUpCZjJvaUFrRUNkR29nQVNBQ1FRSjBhaWdDQURZQ0FDQUNEUUFMQlNBQ0JFQWdBQ0VEQTBBZ0FVRUVhaUVFSUFOQkJHb2hCU0FESUFFb0FnQTJBZ0FnQWtGL2FpSUNCRUFnQkNFQklBVWhBd3dCQ3dzTEN5QUFDekFCQW44Z0FnUkFJQUFoQXdOQUlBTkJCR29oQkNBRElBRTJBZ0FnQWtGL2FpSUNCRUFnQkNFRERBRUxDd3NnQUF1VEFnRUJmd0pBQWtBZ0FTQUFjMEVEY1EwQUlBSkJBRWNpQXlBQlFRTnhRUUJIY1FSQUEwQWdBQ0FCTEFBQUlnTTZBQUFnQTBVTkF5QUFRUUZxSVFBZ0FrRi9haUlDUVFCSElnTWdBVUVCYWlJQlFRTnhRUUJIY1EwQUN3c2dBd1JBSUFFc0FBQUVRQ0FDUVFOTEJFQURRQ0FCS0FJQUlnTkJnSUdDaEhoeFFZQ0Jnb1I0Y3lBRFFmLzkrM2RxY1EwRUlBQWdBellDQUNBQlFRUnFJUUVnQUVFRWFpRUFJQUpCZkdvaUFrRURTdzBBQ3dzTUFnc0ZRUUFoQWdzTUFRc2dBZ1JBSUFFaEF5QUNJUUVEUUNBQUlBTXNBQUFpQWpvQUFDQUNSUVJBSUFFaEFnd0RDeUFEUVFGcUlRTWdBRUVCYWlFQUlBRkJmMm9pQVEwQVFRQWhBZ3NGUVFBaEFnc0xJQUJCQUNBQ0VGUWFJQUFMYVFFRGZ5QUFJQUFRV1VFQ2RHb2hBd0pBSUFJRVFDQUNJUVFnQVNFQ0lBTWhBUU5BSUFJb0FnQWlCVVVOQWlBQ1FRUnFJUUlnQVVFRWFpRURJQUVnQlRZQ0FDQUVRWDlxSWdRRVFDQURJUUVNQVFVZ0F5RUJDd3NGSUFNaEFRc0xJQUZCQURZQ0FDQUFDeklBQWtBZ0FnUkFBMEFnQUNnQ0FDQUJSZzBDSUFCQkJHb2hBQ0FDUVg5cUlnSU5BRUVBSVFBTEJVRUFJUUFMQ3lBQUMzVUJBbjhDZnlBQktBSUFJZ0lFZnlBQktBSUVSUVJBSUFBZ0FoQjBJZ0VFUUNBQklBQnJRUUoxREFNRklBQVFXUXdEQ3dBTEFrQWdBQ2dDQUNJREJFQWdBQ0VDQTBBZ0FTQURFSFFOQWlBQ1FRUnFJZ0lvQWdBaUF3MEFDd1VnQUNFQ0N3c2dBaUFBYTBFQ2RRVWdBQkJaQ3dzaUFBdERBUUYvSXdRaEFpTUVRUkJxSkFRZ0FpQUFOZ0lBSUFJZ0FUWUNCRUhUQUNBQ0VDZ2lBRUdBWUVzRVFFR0l2QU5CQUNBQWF6WUNBRUYvSVFBTElBSWtCQ0FBQzVRQkFRSi9Jd1FoQWlNRVFaQWdhaVFFSUFKQkNHb2hBd0pBQWtBZ0FBUkFJQUVFUUF3Q0JVR0l2QU5CRmpZQ0FFRUFJUUFMQlVHQUlDRUJJQU1oQUF3QkN3d0JDeUFDSUFBMkFnQWdBaUFCTmdJRVFiY0JJQUlRSXlJQlFZQmdTd1IvUVlpOEEwRUFJQUZyTmdJQVFYOEZJQUVMUVFCSUJFQkJBQ0VBQlNBQUlBTkdCRUFnQXhDSEFpRUFDd3NMSUFJa0JDQUFDejBCQVg4Z0FFSC9BWEVpQVVHQUFVa0VmeUFCQlNBQVFSaDBRUmgxUWYrL0EzRWhBU0FBUVg5SFFhd2pLQUlBS0FJQVJYRUVmeUFCQlVGL0N3c0x6Z01CQTM4akJDRUdJd1JCRUdva0JBSkFJQUFFUUFKQUlBSkJBMHNFUUNBQ0lRUWdBU2dDQUNFREEwQUNRQ0FES0FJQUlnVkJmMnBCL2dCTEJIOGdCVVVOQVNBQUlBVkJBQkNSQVNJRlFYOUdCRUJCZnlFQ0RBY0xJQVFnQldzaEJDQUFJQVZxQlNBQUlBVTZBQUFnQkVGL2FpRUVJQUVvQWdBaEF5QUFRUUZxQ3lFQUlBRWdBMEVFYWlJRE5nSUFJQVJCQTBzTkFTQUVJUU1NQXdzTElBQkJBRG9BQUNBQlFRQTJBZ0FnQWlBRWF5RUNEQU1GSUFJaEF3c0xJQU1FUUNBQUlRUWdBU2dDQUNFQUFrQUNRQU5BSUFBb0FnQWlCVUYvYWtIK0FFc0VmeUFGUlEwQ0lBWWdCVUVBRUpFQklnVkJmMFlFUUVGL0lRSU1Cd3NnQXlBRlNRMERJQVFnQUNnQ0FFRUFFSkVCR2lBRUlBVnFJUVFnQXlBRmF3VWdCQ0FGT2dBQUlBUkJBV29oQkNBQktBSUFJUUFnQTBGL2Fnc2hBeUFCSUFCQkJHb2lBRFlDQUNBRERRQU1CUXNBQ3lBRVFRQTZBQUFnQVVFQU5nSUFJQUlnQTJzaEFnd0RDeUFDSUFOcklRSUxCU0FCS0FJQUlnQW9BZ0FpQVFSQVFRQWhBZ05BSUFGQi93QkxCRUFnQmlBQlFRQVFrUUVpQVVGL1JnUkFRWDhoQWd3RkN3VkJBU0VCQ3lBQklBSnFJUUlnQUVFRWFpSUFLQUlBSWdFTkFBc0ZRUUFoQWdzTEN5QUdKQVFnQWd2bENnRVRmeUFCS0FJQUlRUUNmd0pBSUFORkRRQWdBeWdDQUNJRlJRMEFJQUFFZnlBRFFRQTJBZ0FnQlNFUElBQWhDeUFDSVJJZ0JDRUhRU3NGSUFVaENTQUVJUWdnQWlFTlFSa0xEQUVMSUFCQkFFY2hBMEdzSXlnQ0FDZ0NBQVJBSUFNRVFDQUFJUlFnQWlFVElBUWhEa0VQREFJRklBUWhGU0FDSVJaQkRnd0NDd0FMSUFORkJFQWdCQkJ1SVF4Qk93d0JDd0pBSUFJRVFDQUVJUU1nQUNFRklBSWhCQU5BSUFNc0FBQWlDZ1JBSUFOQkFXb2hBeUFGUVFScUlRWWdCU0FLUWYrL0EzRTJBZ0FnQkVGL2FpSUVSUTBESUFZaEJRd0JDd3NnQlVFQU5nSUFJQUZCQURZQ0FDQUNJQVJySVF4Qk93d0NCU0FFSVFNTEN5QUJJQU0yQWdBZ0FpRU1RVHNMSVFNRFFBSkFBa0FDUUNBRFFRNUdCRUFnRlNFRUlCWWhBd05BSUFRc0FBQWlCVUgvQVhGQmYycEIvd0JKQkVBZ0JFRURjVVVFUUNBRUtBSUFJZ1pCL3dGeElRVWdCa0gvL2Z0M2FpQUdja0dBZ1lLRWVIRkZCRUFEUUNBRFFYeHFJUU1nQkVFRWFpSUVLQUlBSWdWQi8vMzdkMm9nQlhKQmdJR0NoSGh4UlEwQUN5QUZRZjhCY1NFRkN3c0xJQVZCL3dGeElnVkJmMnBCL3dCSkJFQWdCRUVCYWlFRUlBTkJmMm9oQXd3QkN3c2dCVUcrZm1vaUJVRXlTd1JBSUFRaEJTQUFJUVlNQXdVZ0JVRUNkRUdrSG1vb0FnQWhDU0FFUVFGcUlRZ2dBeUVOUVJraEF3d0ZDd0FGSUFOQkQwWUVRQUpBSUJNRVFDQVVJUVFnRXlFRElBNGhCUU5BQWtBQ1FDQUZMQUFBSWdaQi93RnhRWDlxUWY4QVNRUkFJQU5CQkVzZ0JVRURjVVZ4QkVBQ1FBTkFJQVVvQWdBaUJrSC8vZnQzYWlBR2NrR0FnWUtFZUhFTkFTQUVJQVpCL3dGeE5nSUFJQVFnQlMwQUFUWUNCQ0FFSUFVdEFBSTJBZ2dnQlVFRWFpRUtJQVJCRUdvaEJpQUVJQVV0QUFNMkFnd2dBMEY4YWlJRFFRUkxCRUFnQmlFRUlBb2hCUXdCQ3dzZ0JpRUVJQW9pQlN3QUFDRUdEQU1MSUFaQi93RnhJUVlMQ3dzZ0JrSC9BWEVpQ2tGL2FrSC9BRThOQUNBRlFRRnFJUVVnQkVFRWFpRUdJQVFnQ2pZQ0FDQURRWDlxSWdORkRRTWdCaUVFREFFTEN5QUtRYjUrYWlJR1FUSkxCRUFnQkNFR0RBWUxJQVpCQW5SQnBCNXFLQUlBSVE4Z0JDRUxJQU1oRWlBRlFRRnFJUWRCS3lFRERBY0ZJQTRoQlFzTElBRWdCVFlDQUNBQ0lReEJPeUVEREFVRklBTkJHVVlFUUNBSUxRQUFRUU4ySWdOQmNHb2dBeUFKUVJwMWFuSkJCMHNFUUNBQUlRTWdDU0VHSUFnaEJTQU5JUVFNQkFVZ0NFRUJhaUVESUFsQmdJQ0FFSEVFZnlBRExBQUFRY0FCY1VHQUFVY0VRQ0FBSVFNZ0NTRUdJQWdoQlNBTklRUU1CZ3NnQ0VFQ2FpRURJQWxCZ0lBZ2NRUi9JQU1zQUFCQndBRnhRWUFCUndSQUlBQWhBeUFKSVFZZ0NDRUZJQTBoQkF3SEN5QUlRUU5xQlNBREN3VWdBd3NoRlNBTlFYOXFJUlpCRGlFRERBY0xBQVVnQTBFclJnUkFJQWN0QUFBaUJVRURkaUlEUVhCcUlBTWdEMEVhZFdweVFRZExCRUFnQ3lFRElBOGhCaUFISVFVZ0VpRUVEQVVGSUFkQkFXb2hCQ0FGUVlCL2FpQVBRUVowY2lJRFFRQklCRUFnQkMwQUFFR0FmMm9pQlVFL1N3UkFJQWRCZjJvaEVDQUxJUkVNQ1FzZ0IwRUNhaUVFSUFVZ0EwRUdkSElpQTBFQVNBUkFJQVF0QUFCQmdIOXFJZ1JCUDBzRVFDQUhRWDlxSVJBZ0N5RVJEQW9GSUFkQkEyb2hEaUFFSUFOQkJuUnlJUU1MQlNBRUlRNExCU0FFSVE0TElBc2dBellDQUNBTFFRUnFJUlFnRWtGL2FpRVRRUThoQXd3SUN3QUZJQU5CTzBZRVFDQU1Ed3NMQ3dzTERBSUxJQVZCZjJvaEJTQUdCRUFnQlNFUUlBTWhFUVVnQXlFR0lBUWhBd3dCQ3d3QkN5QUZMQUFBQkVBZ0JTRVFJQVloRVFVZ0JnUkFJQVpCQURZQ0FDQUJRUUEyQWdBTElBSWdBMnNoREVFN0lRTU1BZ3NMUVlpOEEwSFVBRFlDQUNBUkJFQWdBU0FRTmdJQUMwRi9JUXhCT3lFRERBQUxBQXVKQVFFQ2Z5QUFSUVJBRHdzZ0FDZ0NBRVVFUUE4TElBQVFXU0VFQWtBQ1FBTkFBa0FnQkVFQVRBUkFJQUFoQXd3QkN5QUFJQVJCZjJvaUEwRUNkR29vQWdCQkwwWU5BaUFESVFRTUFRc0xEQUVMSUFBZ0JFRUNkR29oQXdzZ0EwRXVFSzBCSWdNRVFDQURRUUEyQWdBTElBRkZCRUFQQ3lBQVFlUU1JQUlRZUJvZ0FDQUJJQUlRZUJvTHBRSUJBMzhqQkNFRUl3UkJFR29rQkFKQUlBQkJCa3NFZjBFQUJVR1l2QU1RSENBQVFRWkhCRUFnQUNBQkVJc0NJUUJCbUx3REVDb01BZ3NnQVFSQUlBUkJuT29BS1FBQU53QUFJQVJCcE9vQUtRQUFOd0FJUVFBaEFBTkFJQUZCT3hDUkFpSURJQUZySWdKQkVFZ0VRQ0FFSUFFZ0FoQlRHaUFFSUFKcVFRQTZBQUFnQTBFQmFpRUNJQU1zQUFBRVFDQUNJUUVMQ3lBQUlBUVFpd0lhSUFCQkFXb2lBRUVHUncwQUN3dEJBQ0VCUWF5S0JDRUFBMEFnQVVFQ2RFSHd1d05xS0FJQUlnSkJDR29oQXlBQ0JIOGdBd1ZCck9vQUlnTUxFRzRoQWlBQUlBTWdBaEJUR2lBQUlBSnFJZ05CT3pvQUFDQUFJQUpCQVdwcUlRQWdBVUVCYWlJQlFRWkhEUUFMSUFOQkFEb0FBRUdZdkFNUUtrR3NpZ1FMSVFBTElBUWtCQ0FBQ3pvQkFuOGdBQ2dDRUNBQVFSUnFJZ01vQWdBaUJHc2lBQ0FDU3dSQUlBSWhBQXNnQkNBQklBQVFVeG9nQXlBREtBSUFJQUJxTmdJQUlBSUwvQmNERTM4Q2ZnSjhJd1FoRFNNRVFiQUVhaVFFSUExQkFEWUNBQ0FCdlVJQVV3UkFJQUdhSVFGQkFTRVJRZWZwQUNFT0JTQUVRWUFRY1VVaEJpQUVRUUZ4Qkg5Qjdla0FCVUhvNlFBTElRNGdCRUdCRUhGQkFFY2hFU0FHUlFSQVFlcnBBQ0VPQ3dzZ0RVRUlhaUVKSUExQmpBUnFJZzhoRWlBTlFZQUVhaUlJUVF4cUlSTUNmeUFCdlVLQWdJQ0FnSUNBK1A4QWcwS0FnSUNBZ0lDQStQOEFVUVIvSUFWQklIRkJBRWNpQXdSL1FmcnBBQVZCL3VrQUN5RUZJQUVnQVdJaEJpQURCSDlCZ3VvQUJVR0c2Z0FMSVFrZ0FFRWdJQUlnRVVFRGFpSURJQVJCLy85N2NSQm1JQUFnRGlBUkVHTWdBQ0FHQkg4Z0NRVWdCUXRCQXhCaklBQkJJQ0FDSUFNZ0JFR0F3QUJ6RUdZZ0F3VWdBU0FORUk0Q1JBQUFBQUFBQUFCQW9pSUJSQUFBQUFBQUFBQUFZaUlHQkVBZ0RTQU5LQUlBUVg5cU5nSUFDeUFGUVNCeUlndEI0UUJHQkVBZ0RrRUphaUVHSUFWQklIRWlCd1JBSUFZaERnc2dBMEVMUzBFTUlBTnJJZ1pGY2tVRVFFUUFBQUFBQUFBZ1FDRWJBMEFnRzBRQUFBQUFBQUF3UUtJaEd5QUdRWDlxSWdZTkFBc2dEaXdBQUVFdFJnUjhJQnNnQVpvZ0c2R2dtZ1VnQVNBYm9DQWJvUXNoQVF0QkFDQU5LQUlBSWdscklRWWdDVUVBU0FSL0lBWUZJQWtMckNBVEVKSUJJZ1lnRTBZRVFDQUlRUXRxSWdaQk1Eb0FBQXNnRVVFQ2NpRUlJQVpCZjJvZ0NVRWZkVUVDY1VFcmFqb0FBQ0FHUVg1cUlna2dCVUVQYWpvQUFDQURRUUZJSVFvZ0JFRUljVVVoRENBUElRVURRQ0FGSUFjZ0Fhb2lCa0dLNmdCcUxRQUFjam9BQUNBQklBYTNvVVFBQUFBQUFBQXdRS0loQVNBRlFRRnFJZ1lnRW10QkFVWUVmeUFNSUFvZ0FVUUFBQUFBQUFBQUFHRnhjUVIvSUFZRklBWkJMam9BQUNBRlFRSnFDd1VnQmdzaEJTQUJSQUFBQUFBQUFBQUFZZzBBQ3dKL0FrQWdBMFVOQUVGK0lCSnJJQVZxSUFOT0RRQWdBMEVDYWlFRElBVWdFbXNNQVFzZ0JTQVNheUlEQ3lFR0lBQkJJQ0FDSUJNZ0NXc2lCeUFJYWlBRGFpSUZJQVFRWmlBQUlBNGdDQkJqSUFCQk1DQUNJQVVnQkVHQWdBUnpFR1lnQUNBUElBWVFZeUFBUVRBZ0F5QUdhMEVBUVFBUVppQUFJQWtnQnhCaklBQkJJQ0FDSUFVZ0JFR0F3QUJ6RUdZZ0JRd0NDeUFHQkVBZ0RTQU5LQUlBUVdScUlnYzJBZ0FnQVVRQUFBQUFBQUN3UWFJaEFRVWdEU2dDQUNFSEN5QUpRYUFDYWlFR0lBZEJBRWdFZnlBSkJTQUdJZ2tMSVFnRFFDQUlJQUdySWdZMkFnQWdDRUVFYWlFSUlBRWdCcmloUkFBQUFBQmx6YzFCb2lJQlJBQUFBQUFBQUFBQVlnMEFDeUFIUVFCS0JFQWdDU0VHQTBBZ0IwRWRTQVIvSUFjRlFSMExJUXdnQ0VGOGFpSUhJQVpQQkVBZ0RLMGhHVUVBSVFvRFFDQUhJQWNvQWdDdElCbUdJQXF0ZkNJYVFvQ1U2OXdEZ2o0Q0FDQWFRb0NVNjl3RGdLY2hDaUFIUVh4cUlnY2dCazhOQUFzZ0NnUkFJQVpCZkdvaUJpQUtOZ0lBQ3dzRFFDQUlJQVpMQkVBZ0NFRjhhaUlIS0FJQVJRUkFJQWNoQ0F3Q0N3c0xJQTBnRFNnQ0FDQU1heUlITmdJQUlBZEJBRW9OQUFzRklBa2hCZ3NnQTBFQVNBUi9RUVlGSUFNTElRb2dCMEVBU0FSQUlBcEJHV3BCQ1cxQkFXb2hFQ0FMUWVZQVJpRVZJQVloQXlBSUlRWURRRUVBSUFkcklneEJDVTRFUUVFSklRd0xJQU1nQmtrRVFFRUJJQXgwUVg5cUlSWkJnSlRyM0FNZ0RIWWhGRUVBSVFjZ0F5RUlBMEFnQ0NBSUtBSUFJaGNnREhZZ0IybzJBZ0FnRnlBV2NTQVViQ0VISUFoQkJHb2lDQ0FHU1EwQUN5QURRUVJxSVFnZ0F5Z0NBRVVFUUNBSUlRTUxJQWNFUUNBR0lBYzJBZ0FnQmtFRWFpRUdDd1VnQTBFRWFpRUlJQU1vQWdCRkJFQWdDQ0VEQ3dzZ0ZRUi9JQWtGSUFNTElnZ2dFRUVDZEdvaEJ5QUdJQWhyUVFKMUlCQktCRUFnQnlFR0N5QU5JQTBvQWdBZ0RHb2lCellDQUNBSFFRQklEUUFnQmlFSEN3VWdCaUVESUFnaEJ3c2dDU0VNSUFNZ0Iwa0VRQ0FNSUFOclFRSjFRUWxzSVFZZ0F5Z0NBQ0lJUVFwUEJFQkJDaUVKQTBBZ0JrRUJhaUVHSUFnZ0NVRUtiQ0lKVHcwQUN3c0ZRUUFoQmdzZ0MwSG5BRVloRlNBS1FRQkhJUllnQ2lBTFFlWUFSd1IvSUFZRlFRQUxheUFXSUJWeFFSOTBRUjkxYWlJSklBY2dER3RCQW5WQkNXeEJkMnBJQkg4Z0NVR0F5QUJxSWdsQkNXMGhFQ0FKUVFsdklnbEJDRWdFUUVFS0lRZ0RRQ0FKUVFGcUlRc2dDRUVLYkNFSUlBbEJCMGdFUUNBTElRa01BUXNMQlVFS0lRZ0xJQXdnRUVFQ2RHcEJoR0JxSWdrb0FnQWlFQ0FJY0NFTElBbEJCR29nQjBZaUZDQUxSWEZGQkVBZ0VDQUlia0VCY1FSOFJBRUFBQUFBQUVCREJVUUFBQUFBQUFCQVF3c2hIQ0FMSUFoQkFtMGlGMGtoR0NBVUlBc2dGMFp4Qkh4RUFBQUFBQUFBOEQ4RlJBQUFBQUFBQVBnL0N5RUJJQmdFUUVRQUFBQUFBQURnUHlFQkN5QVJCRUFnSEpvaEd5QU9MQUFBUVMxR0loUUVRQ0FiSVJ3TElBR2FJUnNnRkVVRVFDQUJJUnNMQlNBQklSc0xJQWtnRUNBTGF5SUxOZ0lBSUJ3aUFTQWJvQ0FCWWdSQUlBa2dDeUFJYWlJR05nSUFJQVpCLzVQcjNBTkxCRUFEUUNBSlFRQTJBZ0FnQ1VGOGFpSUpJQU5KQkVBZ0EwRjhhaUlEUVFBMkFnQUxJQWtnQ1NnQ0FFRUJhaUlHTmdJQUlBWkIvNVByM0FOTERRQUxDeUFNSUFOclFRSjFRUWxzSVFZZ0F5Z0NBQ0lMUVFwUEJFQkJDaUVJQTBBZ0JrRUJhaUVHSUFzZ0NFRUtiQ0lJVHcwQUN3c0xDeUFHSVFnZ0J5QUpRUVJxSWdaTkJFQWdCeUVHQ3lBREJTQUdJUWdnQnlFR0lBTUxJUWtEUUFKQUlBWWdDVTBFUUVFQUlSQU1BUXNnQmtGOGFpSURLQUlBQkVCQkFTRVFCU0FESVFZTUFnc0xDMEVBSUFocklSUWdGUVJBSUFvZ0ZrRUJjMEVCY1dvaUF5QUlTaUFJUVh0S2NRUi9JQVZCZjJvaEJTQURRWDlxSUFockJTQUZRWDVxSVFVZ0EwRi9hZ3NoQXlBRVFRaHhJZ3BGQkVBZ0VBUkFJQVpCZkdvb0FnQWlDd1JBSUF0QkNuQUVRRUVBSVFjRlFRQWhCMEVLSVFvRFFDQUhRUUZxSVFjZ0N5QUtRUXBzSWdwd1JRMEFDd3NGUVFraEJ3c0ZRUWtoQndzZ0JpQU1hMEVDZFVFSmJFRjNhaUVLSUFWQklISkI1Z0JHQkVBZ0F5QUtJQWRySWdkQkFFb0VmeUFIQlVFQUlnY0xUZ1JBSUFjaEF3c0ZJQU1nQ2lBSWFpQUhheUlIUVFCS0JIOGdCd1ZCQUNJSEMwNEVRQ0FISVFNTEMwRUFJUW9MQlNBS0lRTWdCRUVJY1NFS0N5QUZRU0J5UWVZQVJpSVZCRUJCQUNFSElBaEJBRXdFUUVFQUlRZ0xCU0FUSUFoQkFFZ0VmeUFVQlNBSUM2d2dFeENTQVNJSGEwRUNTQVJBQTBBZ0IwRi9haUlIUVRBNkFBQWdFeUFIYTBFQ1NBMEFDd3NnQjBGL2FpQUlRUjkxUVFKeFFTdHFPZ0FBSUFkQmZtb2lCeUFGT2dBQUlCTWdCMnNoQ0FzZ0FFRWdJQUlnRVVFQmFpQURhaUFESUFweUloWkJBRWRxSUFocUlnc2dCQkJtSUFBZ0RpQVJFR01nQUVFd0lBSWdDeUFFUVlDQUJITVFaaUFWQkVBZ0QwRUphaUlPSVFvZ0QwRUlhaUVJSUFrZ0RFc0VmeUFNQlNBSkN5SUhJUWtEUUNBSktBSUFyU0FPRUpJQklRVWdDU0FIUmdSQUlBVWdEa1lFUUNBSVFUQTZBQUFnQ0NFRkN3VWdCU0FQU3dSQUlBOUJNQ0FGSUJKckVGUWFBMEFnQlVGL2FpSUZJQTlMRFFBTEN3c2dBQ0FGSUFvZ0JXc1FZeUFKUVFScUlnVWdERTBFUUNBRklRa01BUXNMSUJZRVFDQUFRWnJxQUVFQkVHTUxJQVVnQmtrZ0EwRUFTbkVFUUFOQUlBVW9BZ0N0SUE0UWtnRWlDU0FQU3dSQUlBOUJNQ0FKSUJKckVGUWFBMEFnQ1VGL2FpSUpJQTlMRFFBTEN5QUFJQWtnQTBFSlNBUi9JQU1GUVFrTEVHTWdBMEYzYWlFSklBVkJCR29pQlNBR1NTQURRUWxLY1FSQUlBa2hBd3dCQlNBSklRTUxDd3NnQUVFd0lBTkJDV3BCQ1VFQUVHWUZJQWxCQkdvaEJTQVFCSDhnQmdVZ0JRc2hEQ0FEUVg5S0JFQWdDa1VoRVNBUFFRbHFJZ29oRUVFQUlCSnJJUklnRDBFSWFpRU9JQU1oQlNBSklRWURRQ0FHS0FJQXJTQUtFSklCSWdNZ0NrWUVRQ0FPUVRBNkFBQWdEaUVEQ3dKQUlBWWdDVVlFUUNBRFFRRnFJUWdnQUNBRFFRRVFZeUFSSUFWQkFVaHhCRUFnQ0NFRERBSUxJQUJCbXVvQVFRRVFZeUFJSVFNRklBTWdEMDBOQVNBUFFUQWdBeUFTYWhCVUdnTkFJQU5CZjJvaUF5QVBTdzBBQ3dzTElBQWdBeUFGSUJBZ0Eyc2lBMG9FZnlBREJTQUZDeEJqSUFaQkJHb2lCaUFNU1NBRklBTnJJZ1ZCZjBweERRQWdCU0VEQ3dzZ0FFRXdJQU5CRW1wQkVrRUFFR1lnQUNBSElCTWdCMnNRWXdzZ0FFRWdJQUlnQ3lBRVFZREFBSE1RWmlBTEN3c2hBQ0FOSkFRZ0FDQUNTQVIvSUFJRklBQUxDeTRBSUFCQ0FGSUVRQU5BSUFGQmYyb2lBU0FBcDBFSGNVRXdjam9BQUNBQVFnT0lJZ0JDQUZJTkFBc0xJQUVMTmdBZ0FFSUFVZ1JBQTBBZ0FVRi9haUlCSUFDblFROXhRWXJxQUdvdEFBQWdBbkk2QUFBZ0FFSUVpQ0lBUWdCU0RRQUxDeUFCQy9RQ0FRTi9Jd1FoQkNNRVFZQUJhaVFFSUFSQi9BQnFJUVVnQkVIa0l5a0NBRGNDQUNBRVFld2pLUUlBTndJSUlBUkI5Q01wQWdBM0FoQWdCRUg4SXlrQ0FEY0NHQ0FFUVlRa0tRSUFOd0lnSUFSQmpDUXBBZ0EzQWlnZ0JFR1VKQ2tDQURjQ01DQUVRWndrS1FJQU53STRJQVJCUUd0QnBDUXBBZ0EzQWdBZ0JFR3NKQ2tDQURjQ1NDQUVRYlFrS1FJQU53SlFJQVJCdkNRcEFnQTNBbGdnQkVIRUpDa0NBRGNDWUNBRVFjd2tLUUlBTndKb0lBUkIxQ1FwQWdBM0FuQWdCRUhjSkNnQ0FEWUNlQUpBQWtBZ0FVRi9ha0grLy8vL0IwME5BQ0FCQkVCQmlMd0RRY3NBTmdJQVFYOGhBQVVnQlNFQVFRRWhBUXdCQ3d3QkN5QUVJQUZCZmlBQWF5SUZTd1IvSUFVaUFRVWdBUXMyQWpBZ0JFRVVhaUlGSUFBMkFnQWdCQ0FBTmdJc0lBUkJFR29pQmlBQUlBRnFJZ0EyQWdBZ0JDQUFOZ0ljSUFRZ0FpQURFTTRCSVFBZ0FRUkFJQVVvQWdBaUFTQUJJQVlvQWdCR1FSOTBRUjkxYWtFQU9nQUFDd3NnQkNRRUlBQUxLUUVCZnlNRUlRUWpCRUVRYWlRRUlBUWdBellDQUNBQUlBRWdBaUFFRU1BRElRQWdCQ1FFSUFBTDFnRUJBbjhDUUNBQklBQnpRUU54UlFSQUlBRkJBM0VFUUFOQUlBQWdBU3dBQUNJQ09nQUFJQUpGRFFNZ0FFRUJhaUVBSUFGQkFXb2lBVUVEY1EwQUN3c2dBU2dDQUNJQ1FZQ0Jnb1I0Y1VHQWdZS0VlSE1nQWtILy9mdDNhbkZGQkVBRFFDQUFRUVJxSVFNZ0FDQUNOZ0lBSUFGQkJHb2lBU2dDQUNJQ1FZQ0Jnb1I0Y1VHQWdZS0VlSE1nQWtILy9mdDNhbkVFUUNBRElRQUZJQU1oQUF3QkN3c0xDeUFBSUFFc0FBQWlBam9BQUNBQ0JFQURRQ0FBUVFGcUlnQWdBVUVCYWlJQkxBQUFJZ0k2QUFBZ0FnMEFDd3NMSUFBTGp3SUJBMzhnQVVIL0FYRWhCQUpBQWtBZ0FrRUFSeUlESUFCQkEzRkJBRWR4QkVBZ0FVSC9BWEVoQlFOQUlBQXRBQUFnQlVZTkFpQUNRWDlxSWdKQkFFY2lBeUFBUVFGcUlnQkJBM0ZCQUVkeERRQUxDeUFERFFCQkFDRUJEQUVMSUFBdEFBQWdBVUgvQVhFaUEwWUVRQ0FDSVFFRklBUkJnWUtFQ0d3aEJBSkFBa0FnQWtFRFN3UkFJQUloQVFOQUlBQW9BZ0FnQkhNaUFrR0FnWUtFZUhGQmdJR0NoSGh6SUFKQi8vMzdkMnB4UlFSQUlBQkJCR29oQUNBQlFYeHFJZ0ZCQTBzTkFRd0RDd3NGSUFJaEFRd0JDd3dCQ3lBQlJRUkFRUUFoQVF3REN3c0RRQ0FBTFFBQUlBTkdEUUlnQUVFQmFpRUFJQUZCZjJvaUFRMEFRUUFoQVFzTEN5QUJCSDhnQUFWQkFBc0xRd0VCZnlNRUlRSWpCRUVRYWlRRUlBSWdBRFlDQUNBQ0lBRTJBZ1JCMndBZ0FoQXBJZ0JCZ0dCTEJFQkJpTHdEUVFBZ0FHczJBZ0JCZnlFQUN5QUNKQVFnQUF1V0JnRUpmeU1FSVFJakJFR1FBbW9rQkNBQ1FRaHFJUVVnQWlFR0FrQWdBU3dBQUVVRVFFR2U1UUFRT3lJQkJFQWdBU3dBQUEwQ0N5QUFRUXhzUWFYbEFHb1FPeUlCQkVBZ0FTd0FBQTBDQzBIdDVRQVFPeUlCQkVBZ0FTd0FBQTBDQzBIeTVRQWhBUXNMUVFBaEFnTkFBa0FDUUFKQUlBRWdBbW9zQUFBT01BQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVMSUFJaEJBd0JDeUFDUVFGcUlnSkJEMGtOQVNBQ0lRUUxDd0pBQWtBQ1FDQUJMQUFBSWdKQkxrWUVRRUh5NVFBaEFRVWdBU0FFYWl3QUFBUkFRZkxsQUNFQkJTQUNRY01BUncwQ0N3c2dBU3dBQVVVTkFRc2dBVUh5NVFBUWl3RkZEUUFnQVVINjVRQVFpd0ZGRFFCQmpMd0RLQUlBSWdJRVFBTkFJQUVnQWtFSWFoQ0xBVVVOQXlBQ0tBSVlJZ0lOQUFzTFFaQzhBeEFjQWtCQmpMd0RLQUlBSWdJRVFBTkFJQUVnQWtFSWFoQ0xBUVJBSUFJb0FoZ2lBa1VOQXd3QkN3dEJrTHdERUNvTUF3c0xBa0FDUUVIUXV3TW9BZ0FOQUVHQTVnQVFPeUlDUlEwQUlBSXNBQUJGRFFCQi9nRWdCR3NoQ1NBRVFRRnFJUW9EUUFKQUlBSkJPaENSQWlJSExBQUFJUU1nQnlBQ2F5QURRUUJIUVI5MFFSOTFhaUlJSUFsSkJFQWdCU0FDSUFnUVV4b2dCU0FJYWlJQ1FTODZBQUFnQWtFQmFpQUJJQVFRVXhvZ0JTQUtJQWhxYWtFQU9nQUFJQVVnQmhBZElnTU5BU0FITEFBQUlRTUxJQWNnQTBIL0FYRkJBRWRxSWdJc0FBQU5BUXdDQ3d0QkhCQnNJZ0lFUUNBQ0lBTTJBZ0FnQWlBR0tBSUFOZ0lFSUFKQkNHb2lBeUFCSUFRUVV4b2dBeUFFYWtFQU9nQUFJQUpCakx3REtBSUFOZ0lZUVl5OEF5QUNOZ0lBSUFJaEFRVWdBeUFHS0FJQUVNUURHZ3dCQ3d3QkMwRWNFR3dpQWdSQUlBSkIzQjBvQWdBMkFnQWdBa0hnSFNnQ0FEWUNCQ0FDUVFocUlnTWdBU0FFRUZNYUlBTWdCR3BCQURvQUFDQUNRWXk4QXlnQ0FEWUNHRUdNdkFNZ0FqWUNBQXNnQWlFQkMwR1F2QU1RS2lBQUlBRnlCSDhnQVFWQjNCMExJUUlNQVFzZ0FFVUVRQ0FCTEFBQlFTNUdCRUJCM0IwaEFnd0NDd3RCQUNFQ0N5QUdKQVFnQWd1S0F3RUtmeUFBS0FJSUlBQW9BZ0JCb3RydjF3WnFJZ1lRakFFaEJDQUFLQUlNSUFZUWpBRWhBeUFBS0FJUUlBWVFqQUVoQndKQUlBUWdBVUVDZGtrRVFDQURJQUVnQkVFQ2RHc2lCVWtnQnlBRlNYRUVRQ0FISUFOeVFRTnhCRUJCQUNFQkJTQURRUUoySVFvZ0IwRUNkaUVMUVFBaEJRTkFBa0FnQUNBRklBUkJBWFlpQjJvaURFRUJkQ0lJSUFwcUlnTkJBblJxS0FJQUlBWVFqQUVoQ1NBQUlBTkJBV3BCQW5ScUtBSUFJQVlRakFFaUF5QUJTU0FKSUFFZ0EydEpjVVVFUUVFQUlRRU1CZ3NnQUNBRElBbHFhaXdBQUFSQVFRQWhBUXdHQ3lBQ0lBQWdBMm9RaXdFaUEwVU5BQ0FFUVFGR0lRZ2dCQ0FIYXlFRUlBTkJBRWdpQXdSQUlBY2hCQXNnQTBVRVFDQU1JUVVMSUFoRkRRRkJBQ0VCREFVTEN5QUFJQWdnQzJvaUFrRUNkR29vQWdBZ0JoQ01BU0VGSUFBZ0FrRUJha0VDZEdvb0FnQWdCaENNQVNJQ0lBRkpJQVVnQVNBQ2EwbHhCRUFnQUNBQ2FpRUJJQUFnQWlBRmFtb3NBQUFFUUVFQUlRRUxCVUVBSVFFTEN3VkJBQ0VCQ3dWQkFDRUJDd3NnQVF1ZUFRRUNmd0pBQWtBQ1FBTkFJQUpCdXRZQWFpMEFBQ0FBUmcwQklBSkJBV29pQWtIWEFFY05BRUdTMXdBaEFFSFhBQ0VDREFJTEFBc2dBZ1JBUVpMWEFDRUFEQUVGUVpMWEFDRUFDd3dCQ3dOQUlBQWhBd05BSUFOQkFXb2hBQ0FETEFBQUJFQWdBQ0VEREFFTEN5QUNRWDlxSWdJTkFBc0xJQUVvQWhRaUFRUi9JQUVvQWdBZ0FTZ0NCQ0FBRU1ZREJVRUFDeUlCQkg4Z0FRVWdBQXNMUEFBZ0FFR0FnQWhKQkg4Z0FFRUlka0dhUDJvdEFBQkJCWFFnQUVFRGRrRWZjWEpCbWo5cUxRQUFJQUJCQjNGMlFRRnhCU0FBUWY3L0Mwa0xDN0lEQVF0L0l3UWhCaU1FUVRCcUpBUWdCa0VRYWlFSElBWkJJR29pQXlBQVFSeHFJZ2tvQWdBaUJEWUNBQ0FESUFCQkZHb2lDaWdDQUNBRWF5SUVOZ0lFSUFNZ0FUWUNDQ0FESUFJMkFnd2dCaUlJSUFCQlBHb2lEQ2dDQURZQ0FDQUlJQU0yQWdRZ0NFRUNOZ0lJQWtBQ1FDQUVJQUpxSWdaQmtnRWdDQkFpSWdWQmdHQkxCSDlCaUx3RFFRQWdCV3MyQWdCQmZ5SUZCU0FGQzBZTkFFRUNJUVFnQXlFQklBVWhBd05BSUFOQkFFNEVRQ0FHSUFOcklRWWdBVUVJYWlFRklBTWdBU2dDQkNJTlN5SUxCRUFnQlNFQkN5QUVJQXRCSDNSQkgzVnFJUVFnQVNBQktBSUFJQU1nQ3dSL0lBMEZRUUFMYXlJRGFqWUNBQ0FCUVFScUlnVWdCU2dDQUNBRGF6WUNBQ0FISUF3b0FnQTJBZ0FnQnlBQk5nSUVJQWNnQkRZQ0NDQUdRWklCSUFjUUlpSURRWUJnU3dSL1FZaThBMEVBSUFOck5nSUFRWDhpQXdVZ0F3dEdEUUlNQVFzTElBQkJBRFlDRUNBSlFRQTJBZ0FnQ2tFQU5nSUFJQUFnQUNnQ0FFRWdjallDQUNBRVFRSkdCSDlCQUFVZ0FpQUJLQUlFYXdzaEFnd0JDeUFBSUFBb0Fpd2lBU0FBS0FJd2FqWUNFQ0FKSUFFMkFnQWdDaUFCTmdJQUN5QUlKQVFnQWdzR0FFR0l2QU1MZUFFQmZ5TUVJUU1qQkVFZ2FpUUVJQU1nQUNnQ1BEWUNBQ0FEUVFBMkFnUWdBeUFCTmdJSUlBTWdBMEVVYWlJQU5nSU1JQU1nQWpZQ0VFR01BU0FERUNBaUFVR0FZRXNFZjBHSXZBTkJBQ0FCYXpZQ0FFRi9CU0FCQzBFQVNBUi9JQUJCZnpZQ0FFRi9CU0FBS0FJQUN5RUFJQU1rQkNBQUMvNEJBUVovSXdRaEJDTUVRU0JxSkFRZ0JFRVFhaUlGSUFFMkFnQWdCVUVFYWlJSElBSWdBRUV3YWlJSUtBSUFJZ05CQUVkck5nSUFJQVVnQUVFc2FpSUdLQUlBTmdJSUlBVWdBellDRENBRUlBQW9BancyQWdBZ0JDQUZOZ0lFSUFSQkFqWUNDRUdSQVNBRUVDRWlBMEdBWUVzRWYwR0l2QU5CQUNBRGF6WUNBRUYvSWdNRklBTUxRUUZJQkVBZ0FDQUFLQUlBSUFOQk1IRkJFSE55TmdJQUlBTWhBZ1VnQXlBSEtBSUFJZ1ZMQkVBZ0FFRUVhaUlISUFZb0FnQWlCallDQUNBQUlBWWdBeUFGYTJvMkFnZ2dDQ2dDQUFSQUlBY2dCa0VCYWpZQ0FDQUJJQUpCZjJwcUlBWXNBQUE2QUFBTEJTQURJUUlMQ3lBRUpBUWdBZ3MrQVFGL0l3UWhBU01FUVJCcUpBUWdBU0FBS0FJOE5nSUFRUVlnQVJBbUlnQkJnR0JMQkVCQmlMd0RRUUFnQUdzMkFnQkJmeUVBQ3lBQkpBUWdBQXV5QndFS2Z3SkFJQUJCQkdvaUJ5Z0NBQ0lHUVhoeElRSWdCa0VEY1VVRVFDQUJRWUFDU1EwQklBSWdBVUVFYWs4RVFDQUNJQUZyUWFDN0F5Z0NBRUVCZEUwRVFDQUFEd3NMREFFTElBQWdBbW9oQkNBQ0lBRlBCRUFnQWlBQmF5SUNRUTlOQkVBZ0FBOExJQWNnQmtFQmNTQUJja0VDY2pZQ0FDQUFJQUZxSWdFZ0FrRURjallDQkNBRVFRUnFJZ01nQXlnQ0FFRUJjallDQUNBQklBSVFsUUlnQUE4TFFkaTNBeWdDQUNBRVJnUkFRY3kzQXlnQ0FDQUNhaUlDSUFGTkRRRWdCeUFHUVFGeElBRnlRUUp5TmdJQUlBQWdBV29pQXlBQ0lBRnJJZ0ZCQVhJMkFnUkIyTGNESUFNMkFnQkJ6TGNESUFFMkFnQWdBQThMUWRTM0F5Z0NBQ0FFUmdSQVFjaTNBeWdDQUNBQ2FpSURJQUZKRFFFZ0F5QUJheUlDUVE5TEJFQWdCeUFHUVFGeElBRnlRUUp5TmdJQUlBQWdBV29pQVNBQ1FRRnlOZ0lFSUFBZ0Eyb2lBeUFDTmdJQUlBTkJCR29pQXlBREtBSUFRWDV4TmdJQUJTQUhJQVpCQVhFZ0EzSkJBbkkyQWdBZ0FDQURha0VFYWlJQklBRW9BZ0JCQVhJMkFnQkJBQ0VCUVFBaEFndEJ5TGNESUFJMkFnQkIxTGNESUFFMkFnQWdBQThMSUFRb0FnUWlBMEVDY1EwQUlBTkJlSEVnQW1vaUNDQUJTUTBBSUFnZ0FXc2hDaUFEUVFOMklRVUNRQ0FEUVlBQ1NRUkFJQVFvQWd3aUFpQUVLQUlJSWdOR0JFQkJ3TGNEUWNDM0F5Z0NBRUVCSUFWMFFYOXpjVFlDQUFVZ0F5QUNOZ0lNSUFJZ0F6WUNDQXNGSUFRb0FoZ2hDUUpBSUFRb0Fnd2lBaUFFUmdSQUlBUkJFR29pQTBFRWFpSUZLQUlBSWdJRVFDQUZJUU1GSUFNb0FnQWlBa1VFUUVFQUlRSU1Bd3NMQTBBZ0FrRVVhaUlGS0FJQUlnc0VRQ0FMSVFJZ0JTRUREQUVMSUFKQkVHb2lCU2dDQUNJTEJFQWdDeUVDSUFVaEF3d0JDd3NnQTBFQU5nSUFCU0FFS0FJSUlnTWdBallDRENBQ0lBTTJBZ2dMQ3lBSkJFQWdCQ2dDSENJRFFRSjBRZkM1QTJvaUJTZ0NBQ0FFUmdSQUlBVWdBallDQUNBQ1JRUkFRY1MzQTBIRXR3TW9BZ0JCQVNBRGRFRi9jM0UyQWdBTUJBc0ZJQWxCRUdvZ0NTZ0NFQ0FFUjBFQ2RHb2dBallDQUNBQ1JRMERDeUFDSUFrMkFoZ2dCRUVRYWlJRktBSUFJZ01FUUNBQ0lBTTJBaEFnQXlBQ05nSVlDeUFGS0FJRUlnTUVRQ0FDSUFNMkFoUWdBeUFDTmdJWUN3c0xDeUFLUVJCSkJFQWdCeUFJSUFaQkFYRnlRUUp5TmdJQUlBQWdDR3BCQkdvaUFTQUJLQUlBUVFGeU5nSUFCU0FISUFaQkFYRWdBWEpCQW5JMkFnQWdBQ0FCYWlJQklBcEJBM0kyQWdRZ0FDQUlha0VFYWlJQ0lBSW9BZ0JCQVhJMkFnQWdBU0FLRUpVQ0N5QUFEd3RCQUFzS0FDQUFLQUlFRUljQ0M1c0RBRUc0QzBHM05SQTRRY2dMUWJ3MVFRRkJBVUVBRUN4QjBBdEJ3VFZCQVVHQWYwSC9BQkF5UWVBTFFjWTFRUUZCZ0g5Qi93QVFNa0hZQzBIU05VRUJRUUJCL3dFUU1rSG9DMEhnTlVFQ1FZQ0Fma0gvL3dFUU1rSHdDMEhtTlVFQ1FRQkIvLzhERURKQitBdEI5VFZCQkVHQWdJQ0FlRUgvLy8vL0J4QXlRWUFNUWZrMVFRUkJBRUYvRURKQmlBeEJoalpCQkVHQWdJQ0FlRUgvLy8vL0J4QXlRWkFNUVlzMlFRUkJBRUYvRURKQm1BeEJtVFpCQkJBeFFhQU1RWjgyUVFnUU1VSElDRUdtTmhBMFFaZ0pRYkkyRURSQjZBaEJCRUhUTmhBMVFiQUpRZUEyRURCQnVBbEJBRUh3TmhBelFjQUpRUUJCampjUU0wSElDVUVCUWJNM0VETkIwQWxCQWtIYU54QXpRZGdKUVFOQitUY1FNMEhnQ1VFRVFhRTRFRE5CNkFsQkJVRytPQkF6UWZBSlFRUkI1RGdRTTBINENVRUZRWUk1RUROQndBbEJBRUdwT1JBelFjZ0pRUUZCeVRrUU0wSFFDVUVDUWVvNUVETkIyQWxCQTBHTE9oQXpRZUFKUVFSQnJUb1FNMEhvQ1VFRlFjNDZFRE5CZ0FwQkJrSHdPaEF6UVlnS1FRZEJqenNRTTBHUUNrRUhRYTg3RURNTEJ3QkJBQkRRQXdzRUFFRUJDendCQVg4akJDRUJJd1JCRUdva0JDQUJRUUE2QUFBZ0FDQUJRUUVnQUNnQ0FDZ0NERUVmY1VIS0FHb1JBUUFhSUFFc0FBQWhBQ0FCSkFRZ0FBc1dBQ0FDUlFSQVFRRVBDeUFBS0FJRUlBRWdBaEJEQ3lzQUlBQWdBVUVBSUFBb0FnQW9BZ2hCSDNGQnlnQnFFUUVBQkVCQkFROExRYXoxQWlBQkVMZ0VRUUFMNWdJQ0EzOERmaUFBUVFScUlnVW9BZ0FpQkVVRVFFRUJEd3NnQWFjaEF5QUJRZ0JUSUFKQkFFZHhCRUFnQUNBQUtBSUFLQUlVUVFkeFFZWUJhaEVBQUNFR0FrQWdBa0VCUmdSQUlBWWhCd1VnQUNnQ0FDZ0NFQ0VDUVFBa0JTQUNJQUJCQUVFQVFRSVFVQ01GSVFKQkFDUUZJQUpCQVhGRkJFQWdBQ2dDQUNnQ0ZDRUNRUUFrQlNBQ0lBQVFUcTBqQjYxQ0lJYUVJUWdqQlNFQ1FRQWtCU0FDUVFGeFJRUkFJQUFvQWdBb0FoQWhBa0VBSkFVZ0FpQUFJQWFuSUFaQ0lJaW5RUUFRVUNNRklRSkJBQ1FGSUFKQkFYRkZCRUFnQ0NFSERBUUxRUUFRR0JCYUN3c1FGeUVDSUFBb0FnQW9BaEFoQTBFQUpBVWdBeUFBSUFhbklBWkNJSWluUVFBUVVDTUZJUU5CQUNRRklBTkJBWEVFUUVFQUVCZ1FXZ1VnQWhBZUN3c0xRUUFoQWlBSElBRjhweUVESUFVb0FnQWhCQXNnQUVFQU9nQUlJQUpCQVVZaEFDQUNCSDlCcVRVRlFhVTFDeUVDSUFRZ0F5QUFCSDlCclRVRklBSUxFRUlMWEFFQmZ5QUFRY1FkTmdJQUlBQW9BZ1FpQVVVRVFDQUFFRklQQ3lBQUxBQVFCRUFnQUJCU0R3c2dBQ3dBRWdSQVFRQWtCUVZCQUNRRlFTd2dBUkFNQ3lNRklRRkJBQ1FGSUFGQkFYRkZCRUFnQUJCU0R3dEJBQkFZRUZvTEdRQWdBRUVDUndSQVFRRVBDeUFDUVp5QkJCRFFBUnBCQVFzUEFDQUJJQUFvQWdCcUlBSTVBd0FMRFFBZ0FTQUFLQUlBYWlzREFBdE5BUUYvUWNnQUVGOGlBRUlBTndNQUlBQkNBRGNEQ0NBQVFnQTNBeEFnQUVJQU53TVlJQUJDQURjRElDQUFRZ0EzQXlnZ0FFSUFOd013SUFCQ0FEY0RPQ0FBUVVCclFnQTNBd0FnQUFzMEFDQURRUUpHQkg4Z0FDQUJJQUlRdWdFRklBQWdBU0FDRUhzTEdpQUNSUVJBRHdzZ0FTQUNRWDlxUVFKMGFrRUFOZ0lBQ3lZQkFYOUJJQkJmSWdCQ0FEY0RBQ0FBUWdBM0F3Z2dBRUlBTndNUUlBQkNBRGNER0NBQUM1UUNBUVYvSXdRaEJTTUVRUkJxSkFRZ0FpZ0NBQ0VFSUFVaUEwSUFOd0lBSUFOQkFEWUNDQ0FFUVc5TEJFQWdBeENLQVFzZ0FrRUVhaUVHQWtBQ1FDQUVRUXRKQkVBZ0F5QUVPZ0FMSUFRRVFDQURJUUlNQWdVZ0F5RUNDd1VnQXlBRVFSQnFRWEJ4SWdjUVh5SUNOZ0lBSUFNZ0IwR0FnSUNBZUhJMkFnZ2dBeUFFTmdJRURBRUxEQUVMSUFJZ0JpQUVFRk1hQ3lBQ0lBUnFRUUE2QUFBZ0FTQUFLQUlBYWlJQVFRdHFJZ0VzQUFCQkFFZ0VRQ0FBS0FJQVFRQTZBQUFnQUVFQU5nSUVCU0FBUVFBNkFBQWdBVUVBT2dBQUMwRUFKQVZCRkNBQVFRQVFEU01GSVFGQkFDUUZJQUZCQVhFRVFFRUFFQmdpQUJCYUJTQUFJQU1wQWdBM0FnQWdBQ0FES0FJSU5nSUlJQVVrQkFzTGVnRUVmeUFCSUFBb0FnQnFJZ0lzQUFzaUFVRUFTQ0lFQkg4Z0FpZ0NCQ0lBUVFScUVHd2hBeUFCUWY4QmNTRUJJQUFGSUFGQi93RnhJZ0ZCQkdvUWJDRURJQUVoQUNBQ0tBSUVDeUVGSUFNZ0FEWUNBQ0FDS0FJQUlRQWdBMEVFYWlBRUJIOGdBQVVnQWdzZ0JBUi9JQVVGSUFFTEVGTWFJQU1MSmdFQmZ5QUFSUVJBRHdzZ0FFRUVhaUlCTEFBTFFRQklCRUFnQVNnQ0FCQlNDeUFBRUZJTEdBRUJmMEVRRUY4aUFFSUFOd01BSUFCQ0FEY0RDQ0FBQzc4QkFRSi9Jd1FoQXlNRVFSQnFKQVFnQUNnQ0FDRUVJQUVnQUNnQ0JDSUFRUUYxYWlFQklBQkJBWEVFUUNBQktBSUFJQVJxS0FJQUlRUUxJQU1pQUNBQklBSWdCRUVmY1VINEFXb1JCd0JCQUNRRlFRUkJFQkFGSVFFakJTRUNRUUFrQlNBQ1FRRnhSUVJBSUFFZ0FDZ0NBRFlDQUNBQlFRUnFJZ0lnQUVFRWFpSURLUUlBTndJQUlBSWdBeWdDQ0RZQ0NDQUFKQVFnQVE4TEVCY2hBU0FBUVFScUlnQXNBQXRCQUU0RVFDQUJFQjRMSUFBb0FnQVFVaUFCRUI1QkFBdU9BUUVCZnlBQVFRUnFJZ05DQURjQ0FDQURRUUEyQWdnZ0FTZ0NBQ0VCUVFBa0JVRUlJQUVnQWdSL1FRQUZRUUlMUVFCQkFCQUlJUUVqQlNFQ1FRQWtCU0FDUVFGeFJRUkFJQUFnQVRZQ0FFRUFKQVZCR3lBRFFkMDBFQVlhSXdVaEFFRUFKQVVnQUVFQmNVVUVRQThMQ3hBWElRQWdBeXdBQzBFQVRnUkFJQUFRSGdzZ0F5Z0NBQkJTSUFBUUhndlJBZ0VDZnlNRUlRSWpCRUhRQUdva0JDQUFLQUlBSVFNZ0FTQUFLQUlFSWdCQkFYVnFJUUVnQUVFQmNRUkFJQUVvQWdBZ0Eyb29BZ0FoQXdzZ0FpSUFJQUVnQTBFZmNVSFdBV29SQmdCQkFDUUZRUVJCeUFBUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1VVRVFDQUJJQUFvQWdBMkFnQWdBVUVFYWlJRElBQkJCR29pQWlrQ0FEY0NBQ0FESUFJb0FnZzJBZ2dnQWtJQU53SUFJQUpCQURZQ0NDQUJRUkJxSWdNZ0FFRVFhaUlDS1FJQU53SUFJQU1nQWlnQ0NEWUNDQ0FDUWdBM0F3QWdBa0VBTmdJSUlBRkJIR29pQWlBQVFSeHFJZ01wQWdBM0FnQWdBaUFES1FJSU53SUlJQUlnQXlrQ0VEY0NFQ0FDSUFNcEFoZzNBaGdnQWlBREtRSWdOd0lnSUFJZ0F5Z0NLRFlDS0NBQUpBUWdBUThMRUJjaEFTQUFMQUFiUVFCSUJFQWdBQ2dDRUJCU0N5QUFRUVJxSWdBc0FBdEJBRTRFUUNBQkVCNExJQUFvQWdBUVVpQUJFQjVCQUF1RUF3RURmeU1FSVFJakJFR0E4QUJxSkFRZ0FrRUFRZnp2QUJCVUdpQUJLQUlBSUFJUXZnSWhCQ0FBUVFScUlnTkNBRGNDQUNBRFFnQTNBZ2dnQTBJQU53SVFJQUFnQkRZQ0FFRUFKQVZCR3lBRFFlazBFQVlhSXdVaEFVRUFKQVVnQVVFQmNVVUVRQ0FFQkVBZ0FpUUVEd3RCQUNRRlFSd2dBRUVRYWlBQ1FZQXdhaEFHR2lNRklRRkJBQ1FGSUFGQkFYRkZCRUFnQUNBQ1FZRFFBR29vQUFBMkFod2dBQ0FDUVlqUUFHb29BQUM0UkFBQUFBQUFBUEJCb2lBQ1FZVFFBR29vQUFDNG9Ea0RJQ0FBSUFKQmtOQUFhaWdBQUxoRUFBQUFBQUFBOEVHaUlBSkJqTkFBYWlnQUFMaWdPUU1vSUFBZ0FrR1UwQUJxS0FBQU5nSXdJQUFnQWtHWTBBQnFLQUFBTmdJMElBQWdBa0djMEFCcUtBQUFOZ0k0SUFBZ0FrR2cwQUJxS0FBQU5nSThJQUJCUUdzZ0FrR2swQUJxS0FBQU5nSUFJQUFnQWtHbzBBQnFLQUFBTmdKRUlBSWtCQThMQ3hBWElRRWdBQ3dBRzBFQVNBUkFJQUFvQWhBUVVnc2dBeXdBQzBFQVRnUkFJQUVRSGdzZ0F5Z0NBQkJTSUFFUUhndXVBd0VFZnlNRUlRVWpCRUZBYXlRRUlBQW9BZ0FoQ0NBQklBQW9BZ1FpQVVFQmRXb2hBQ0FCUVFGeEJFQWdBQ2dDQUNBSWFpZ0NBQ0VJQ3lBRlFSaHFJUVlnQlVFTWFpSUhJQUlRMVFGQkFDUUZRUk1nQlNBREVBMGpCU0VCUVFBa0JTQUJRUUZ4QkVBUUZ5RUFCVUVBSkFVZ0NDQUdJQUFnQnlBRklBUVFFQ01GSVFCQkFDUUZBa0FnQUVFQmNRUkFFQmNoQUFWQkFDUUZRUVJCSUJBRklRQWpCU0VCUVFBa0JTQUJRUUZ4QkVBUUZ5RUFJQVlzQUJ0QkFFZ0VRQ0FHS0FJUUVGSUxJQVpCQkdvaUFpd0FDMEVBVGcwQ0lBSW9BZ0FRVWd3Q0N5QUFJQVlvQWdBMkFnQWdBRUVFYWlJQ0lBWkJCR29pQVNrQ0FEY0NBQ0FDSUFFb0FnZzJBZ2dnQVVJQU53SUFJQUZCQURZQ0NDQUFRUkJxSWdJZ0JrRVFhaUlCS1FJQU53SUFJQUlnQVNnQ0NEWUNDQ0FCUWdBM0FnQWdBVUVBTmdJSUlBQWdCaWdDSERZQ0hDQUZMQUFMUVFCSUJFQWdCU2dDQUJCU0N5QUhMQUFMUVFCT0JFQWdCU1FFSUFBUEN5QUhLQUlBRUZJZ0JTUUVJQUFQQ3dzZ0JTd0FDMEVBU0FSQUlBVW9BZ0FRVWdzTElBY3NBQXRCQUU0RVFDQUFFQjRMSUFjb0FnQVFVaUFBRUI1QkFBdmtBd0VEZndKQUl3UWhCU01FUWFDQkFXb2tCQ0FGUWFBQmFpRUhJQVZCQUVHY0FSQlVHaUFDS0FJQUlRWWdCU0FDTEFBTFFRQklCSDhnQmdVZ0FnczJBQVFnQlNBSE5nQVFJQVZCZ0lBQk5nQVVJQVVnQkVFQmMwRUJjVFlBQ0NBRlFRYzJBQ1FnQlVFQU5nQW9JQU1vQWdBaEFpQURMQUFMUVFCSUJIOGdBZ1VnQXd0Qm5JRUVRWUFCRU8wQklBRWdCUkRPQWpZQ0FDQUFRUVJxSWdaQ0FEY0NBQ0FHUWdBM0FnZ2dCa0lBTndJUVFRQWtCVUViSUFaQjhqUVFCaG9qQlNFQlFRQWtCUUpBSUFGQkFYRUVRQkFYSVFFRklBVW9BQXdpQVFSQUlBQWdBVFlDQUF3REN5QUFRUUEyQWdBZ0FDQUZLQUFnTmdJY0lBVW9BQnhCQVVjTkFpQUZLQUFZSWdRRWYwRUFJQVJCSUVzRWZ5QUVCVUVnQzBFQ2RCQlhJZ0pGQkVCQkFDUUZRUlJCclBVQ0VBd2pCU0VCUVFBa0JTQUJRUUZ4QkVBUUZ5RUJEQVFMQ3lBQ0JVRUFJUUpCQUFzaEEwRUFKQVZCRVNBSElBSWdCRUVDZEJBSEdpTUZJUUZCQUNRRklBRkJBWEZGQkVCQkFDUUZRUndnQUVFUWFpQUNFQVlhSXdVaEFVRUFKQVVnQVVFQmNVVUVRQ0FDUlEwRUlBTVFVZ3dFQ3dzUUZ5RUJJQUlFUUNBREVGSUxDd3NnQUN3QUcwRUFTQVJBSUFBb0FoQVFVZ3NnQml3QUMwRUFUZ1JBSUFFUUhnc2dCaWdDQUJCU0lBRVFIZzhMSUFVa0JBdEFBUUovUVFRUVh5SUJRUUEyQWdCQkFDUUZRUnBCQmtIeTVRQVFCaG9qQlNFQVFRQWtCU0FBUVFGeEJFQVFGeUVBSUFFUVVpQUFFQjRGSUFFUEMwRUFDem9CQVg4Z0FFVUVRQThMSUFBb0FnQWlBUVJBUVFBa0JVRVlJQUVRQlJvakJTRUJRUUFrQlNBQlFRRnhCRUJCQUJBWUVGb0xDeUFBRUZJTEJRQkJtQWdMelJJQkFuOUJtQWhCb0FoQnNBaEJBRUhKTVVFV1Fjd3hRUUJCekRGQkFFSE9NVUhaTVVFbkVDMUJtQWhCQVVHUUhVSEpNVUVYUVFFUUxrRUlFRjhpQUVFRk5nSUFJQUJCQURZQ0JFR1lDRUhjTVVFRlFaUWRRZUV4UVFFZ0FFRUFFQzlCQ0JCZklnQkJFallDQUNBQVFRQTJBZ1JCbUFoQjZERkJBa0dvSFVIMk1VRVJJQUJCQUJBdlFRZ1FYeUlBUVE4MkFnQWdBRUVBTmdJRVFaZ0lRZm94UVFOQnNCMUJnekpCSENBQVFRQVFMMEhBQ0VHSU1rR09Na0VDUWRreFFTZ1FOa0VBSkFWQkJFRUVFQVVoQUNNRklRRkJBQ1FGSUFGQkFYRkZCRUFnQUVFQU5nSUFRUUFrQlVFRVFRUVFCU0VCSXdVaEFrRUFKQVVnQWtFQmNVVUVRQ0FCUVFBMkFnQkJBQ1FGUVFGQndBaEJrREpCZ0F4QjlqRkJFaUFBUVlBTVFaZ3lRUkFnQVJBVEl3VWhBRUVBSkFVZ0FFRUJjVVVFUUVFQUpBVkJCRUVFRUFVaEFDTUZJUUZCQUNRRklBRkJBWEZGQkVBZ0FFRUVOZ0lBUVFBa0JVRUVRUVFRQlNFQkl3VWhBa0VBSkFVZ0FrRUJjVVVFUUNBQlFRUTJBZ0JCQUNRRlFRRkJ3QWhCblRKQnlBaEI5akZCRXlBQVFjZ0lRWmd5UVJFZ0FSQVRJd1VoQUVFQUpBVWdBRUVCY1VVRVFFRUFKQVZCS1VIQUNCQU1Jd1VoQUVFQUpBVWdBRUVCY1FSQVFRQVFHQ0lBRUZvTFFlQUlRYVV5UVk0eVFRTkIyVEZCS2hBMlFRQWtCVUVFUVFRUUJTRUFJd1VoQVVFQUpBVWdBVUVCY1VVRVFDQUFRUUEyQWdCQkFDUUZRUVJCQkJBRklRRWpCU0VDUVFBa0JTQUNRUUZ4UlFSQUlBRkJBRFlDQUVFQUpBVkJBVUhnQ0VHdk1rSEFDRUgyTVVFVUlBQkJ3QWhCbURKQkVpQUJFQk1qQlNFQVFRQWtCU0FBUVFGeFJRUkFRUUFrQlVFRVFRUVFCU0VBSXdVaEFVRUFKQVVnQVVFQmNVVUVRQ0FBUVJBMkFnQkJBQ1FGUVFSQkJCQUZJUUVqQlNFQ1FRQWtCU0FDUVFGeFJRUkFJQUZCRURZQ0FFRUFKQVZCQVVIZ0NFRzFNa0hvQ0VIMk1VRVZJQUJCNkFoQm1ESkJFeUFCRUJNakJTRUFRUUFrQlNBQVFRRnhSUVJBUVFBa0JVRUVRUVFRQlNFQUl3VWhBVUVBSkFVZ0FVRUJjVVVFUUNBQVFSdzJBZ0JCQUNRRlFRUkJCQkFGSVFFakJTRUNRUUFrQlNBQ1FRRnhSUVJBSUFGQkhEWUNBRUVBSkFWQkFVSGdDRUc5TWtHQURFSDJNVUVXSUFCQmdBeEJtREpCRkNBQkVCTWpCU0VBUVFBa0JTQUFRUUZ4UlFSQVFRQWtCVUVwUWVBSUVBd2pCU0VBUVFBa0JTQUFRUUZ4QkVCQkFCQVlJZ0FRV2d0QmdBbEJ3ekpCampKQkJFSFpNVUVyRURaQkFDUUZRUVJCQkJBRklRQWpCU0VCUVFBa0JRSkFJQUZCQVhGRkJFQWdBRUVBTmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJBRFlDQUVFQUpBVkJBVUdBQ1VHdk1rSEFDRUgyTVVFWElBQkJ3QWhCbURKQkZTQUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUVRTmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJFRFlDQUVFQUpBVkJBVUdBQ1VIUk1rSG9DRUgyTVVFWUlBQkI2QWhCbURKQkZpQUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUVjTmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJIRFlDQUVFQUpBVkJBVUdBQ1VHOU1rR0FERUgyTVVFWklBQkJnQXhCbURKQkZ5QUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUVnTmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJJRFlDQUVFQUpBVkJBVUdBQ1VIV01rR2dERUhmTWtFQklBQkJvQXhCNHpKQkFTQUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUVvTmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJLRFlDQUVFQUpBVkJBVUdBQ1VIb01rR2dERUhmTWtFQklBQkJvQXhCNHpKQkFTQUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUV3TmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJNRFlDQUVFQUpBVkJBVUdBQ1VId01rR0FERUgyTVVFWklBQkJnQXhCbURKQkZ5QUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUUwTmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJORFlDQUVFQUpBVkJBVUdBQ1VIM01rR0FERUgyTVVFWklBQkJnQXhCbURKQkZ5QUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUU0TmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJPRFlDQUVFQUpBVkJBVUdBQ1VIN01rR0FERUgyTVVFWklBQkJnQXhCbURKQkZ5QUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUU4TmdJQVFRQWtCVUVFUVFRUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1EwQklBRkJQRFlDQUVFQUpBVkJBVUdBQ1VHQU0wR0FERUgyTVVFWklBQkJnQXhCbURKQkZ5QUJFQk1qQlNFQVFRQWtCU0FBUVFGeERRRkJBQ1FGUVFSQkJCQUZJUUFqQlNFQlFRQWtCU0FCUVFGeERRRWdBRUhBQURZQ0FFRUFKQVZCQkVFRUVBVWhBU01GSVFKQkFDUUZJQUpCQVhFTkFTQUJRY0FBTmdJQVFRQWtCVUVCUVlBSlFZY3pRWUFNUWZZeFFSa2dBRUdBREVHWU1rRVhJQUVRRXlNRklRQkJBQ1FGSUFCQkFYRU5BVUVBSkFWQkJFRUVFQVVoQUNNRklRRkJBQ1FGSUFGQkFYRU5BU0FBUWNRQU5nSUFRUUFrQlVFRVFRUVFCU0VCSXdVaEFrRUFKQVVnQWtFQmNRMEJJQUZCeEFBMkFnQkJBQ1FGUVFGQmdBbEJqak5CZ0F4QjlqRkJHU0FBUVlBTVFaZ3lRUmNnQVJBVEl3VWhBRUVBSkFVZ0FFRUJjUTBCUVFBa0JVRXBRWUFKRUF3akJTRUFRUUFrQlNBQVFRRnhCRUJCQUJBWUlnQVFXZ1VQQ3dzTEVCY2hBRUVBSkFWQktVR0FDUkFNSXdVaEFVRUFKQVVnQVVFQmNRUkFRUUFRR0NJQUVGb0ZJQUFRSGdzTEN3c0xDd3NMQ3dzUUZ5RUFRUUFrQlVFcFFlQUlFQXdqQlNFQlFRQWtCU0FCUVFGeEJFQkJBQkFZSWdBUVdnVWdBQkFlQ3dzTEN3c0xDeEFYSVFCQkFDUUZRU2xCd0FnUURDTUZJUUZCQUNRRklBRkJBWEVFUUVFQUVCZ2lBQkJhQlNBQUVCNExDeTBCQVg4Z0FTQUFSZ1JBRHdzZ0FrVUVRQThMSUFFZ0FDQUNRWDlxSWdNUXhnRWFJQUVnQTJwQkFEb0FBQXNIQUVFQUVPc0RDd1FBUVFFTERnQWdBRUdjemdWcUlBRVFwZ0lMbUFNQ0JIOENmZ0pBSUFSQkFFY2lDU0FGUVFCSGNRUkFJQVJCQURZQ0FBc2dBVUVnYWlJSEVGbEIvdzlMRFFBZ0FFSGt6QVZxSUFGQjRjRUFhaXdBQUVFQVJ5SUdJQWRCQUVFRkVLQUNEUUFnQUVIVXpRVnFLQUlBQkVBZ0FFSEF6UVZxSUFZZ0IwRUFRUVVRb0FKRkRRRUxJQUZCc01BQWFpRUlJQUJCcUlrRGFpa0RBQ0lLUWdCU0JFQWdDQ2tEQUNBS1dnMEJDeUFBUWJDSkEyb3BBd0FpQ2tJQVVnUkFJQWdwQXdBZ0NsZ05BUXNnQUNnQ0FDQUJLQUljSWdoeERRQWdBQ3dBQ0FSQUlBQW9BZ1FnQ0hGRkRRRUxJQVpGQkVBZ0FFRzRpUU5xS1FNQUlncEMvLy8vLy9mLy8vLy9BRkVnQ2lBQlFkREFBR29wQXdBaUNsVnlSUTBCSUFCQndJa0RhaWtEQUNJTElBcFpJQXRDLy8vLy8vZi8vLy8vQUZKeERRRUxJQUJCaU13RmFpSUdRUUEyQWhBZ0JoQ2hBaUlCUlEwQVFRRWhBQUpBQWtBRFFDQUJJQWNnQXhDbEFVVUVRQ0FBUVFGcUlRQWdCaENoQWlJQkRRRU1BZ3NMREFFTFFRQVBDeUFDQkVBZ0FpQUJJQWNRblFGRk9nQUFDeUFKUlFSQUlBQVBDeUFFSUFFZ0JSQnZHaUFBRHd0QkFBdkZBUUVDZnlBQUVMc0VJQUJCeU1zRWFrRUFOZ0lBSUFCQmlJd0Zha0VBTmdJQUlBQkJ2TXNFYWtFQU9nQUFJQUJCd01zRWFrRUFOZ0lBSUFCQnhNc0Vha0VBT2dBQUlBQkJpTXdGYWhDZUFTQUFRZVRNQldvUW5nRWdBRUhBelFWcUVKNEJJQUJCK000RmFoQ2VBU0FBUVp6T0JXb1FuZ0VnQUVId2hBTnFJZ0VvQWdBaUFrVUVRQ0FBUWZTRUEycEJBRFlDQUNBQVFmaUVBMnBCQURZQ0FBOExJQUlRVWlBQlFRQTJBZ0FnQUVIMGhBTnFRUUEyQWdBZ0FFSDRoQU5xUVFBMkFnQUwxUUlCQjM4Z0FCQzJBa0VBSkFWQkpTQUFRWWpNQldvaUJ4QU1Jd1VoQVVFQUpBVWdBVUVCY1FSQUVCY2hBU0FBRUhrZ0FSQWVDMEVBSkFWQkpTQUFRZVRNQldvaUF4QU1Jd1VoQVVFQUpBVWdBVUVCY1FSQUVCY2hBUVZCQUNRRlFTVWdBRUhBelFWcUlnUVFEQ01GSVFGQkFDUUZJQUZCQVhFRVFCQVhJUUVqQnlFQ0JVRUFKQVZCSlNBQVFaek9CV29pQlJBTUl3VWhBVUVBSkFVZ0FVRUJjUVJBRUJjaEFTTUhJUUlGUVFBa0JVRWxJQUJCK000RmFpSUdFQXdqQlNFQlFRQWtCU0FCUVFGeEJFQVFGeUVCSXdjaEFnVkJBQ1FGUVNZZ0FCQU1Jd1VoQVVFQUpBVWdBVUVCY1VVRVFBOExFQmNoQVNNSElRSWdCaWdDQUNJR0JFQWdCaEJTQ3dzZ0JTZ0NBQ0lGQkVBZ0JSQlNDd3NnQkNnQ0FDSUVCRUFnQkJCU0N3c2dBeWdDQUNJREJFQWdBeEJTQ3dzZ0J5Z0NBQ0lDUlFSQUlBQVFlU0FCRUI0TElBSVFVaUFBRUhrZ0FSQWVDMFlCQVg4Z0FFRUFPd0VVSUFCQkdHb2lBVUVBTmdJQUlBRkJBRHNCQkNBQlFRQTZBQVlnQUVFZ2FpSUFRZ0EzQXdBZ0FFSUFOd01JSUFCQ0FEY0RFQ0FBUWdBM0F4Z0wxUUlCQlg4akJDRURJd1JCRUdva0JDQUFRYWpBQUdvaUJTZ0NBQ0VDSUFCQnBNQUFhaUlFSUFFMkFnQWdBaUFCU1FSQUlBQkJyTUFBYWlnQ0FDSUdRUUJISUFZZ0FVbHhCRUFnQXlBR05nSUFRYXoxQWtIWUd5QURFR0JCclBVQ0VGWWdCU2dDQUNFQ0lBUW9BZ0FoQVFzZ0FFR2d3QUJxSWdRb0FnQWdBU0FDUVNCcUlBSkJBblpxSWdKTEJIOGdBUVVnQWlJQkN4QlhJZ0pGQkVCQnJQVUNFRllMSUFRZ0FqWUNBQ0FGSUFFMkFnQUxJQUJCQURvQUVDQUFRZURBQUdwQkFCQ29CQ0FBUVFBMkFod2dBRUd4d1FCcVFRQTZBQUFnQUVHNndRQnFRUUE2QUFBZ0FFSHd3UUJxUVFBMkFnQWdBRUgxZ1FGcVFRQTZBQUFnQUVHd3dBQnFJZ0ZDQURjREFDQUJRZ0EzQXdnZ0FVSUFOd01RSUFCQmlNRUFhaUlCUWdBM0F3QWdBVUVBT2dBSUlBQkIzTUVBYWlJQVFnQTNBZ0FnQUVFQU5nSUlJQUJCQURzQkRDQUFRUUE2QUE0Z0F5UUVDNFlCQUFKQUFrQUNRQUpBQWtBZ0FVRVBhdzRrQUFRRUJBUUJCQVFFQkFRQkJBUUNCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFEQkFzZ0FFR29tQUZxTEFBQUJFQVBDeUFBSUFJUWhnUVBDeUFBUWFpWUFXb3NBQUFFUUE4TElBQWdBaENFQkE4TElBQkJxSmdCYWl3QUFBUkFEd3NnQUNBQ0VJRUVEd3NnQUNBQ0VQc0RDd3VMQXdFSWZ5QUJSUVJBUWF6MUFoQldDeUFCUVlDQUVFc0VmeUFCQlVHQWdCQUxJZ01nQUVITXpRTnFJZ1lvQWdBaUJFMEVRQThMQWtBQ1FBSkFJQUlFUUNBQVFhU1dBV29vQWdCQkFFY2hBaUFBUWFpWUFXb2lBU3dBQUVVTkFVRUVFQlFpQVVIRUpUWUNBQ0FCUWRnS1FRb1FHd1VnQUVHb21BRnFJZ0VzQUFBRVFFRUFJUUlNQXdWQkFDRUNEQUlMQUFzTUFnc2dBeEJzSWdWRkRRQWdCVUVBSUFNUVZCb2dCRVVnQWtFQmMzSkZCRUFnQTBGL2FpRUNJQUJCcEpZQmFpZ0NBQ0VISUFBb0FtQWhDQ0FFUVg5cUlRbEJBU0VCQTBBZ0JTQUlJQUZySWdvZ0FuRnFJQWNnQ2lBSmNXb3NBQUE2QUFBZ0FVRUJhaUlCSUFSTkRRQUxDeUFBUWFTV0FXb2lBU2dDQUNJQ0JFQWdBaEJTQ3lBQklBVTJBZ0FNQVFzZ0EwR0FnSUFJU1NBQ2NnUkFRUVFRRkNJQ1FjUWxOZ0lBSUFKQjJBcEJDaEFiQ3lBQVFhU1dBV29pQWlnQ0FDSUVCRUFnQkJCU0lBSkJBRFlDQUFzZ0FFR29sZ0ZxSUFNUTl3TWdBVUVCT2dBQUN5QUdJQU0yQWdBZ0FFSFF6UU5xSUFOQmYybzJBZ0FMMUFFQkJYOGdBQkRZQVNBQlJRUkFEd3NDUUFKQUFrQURRQ0FCSUFScklnSkJJQ0FEYTI0aUJVR0FnSUFDVFFSQVFZQ0FnQUloQlFzZ0FpQUZTUTBCQTBBZ0FoQnNJZ1pGQkVBZ0FpQUNRUVYyYXlJQ0lBVkpEUU1NQVFzTElBWkJBQ0FDRUZRYUlBQWdBMEVDZEdvZ0JqWUNBQ0FBUVlBQmFpQURRUUowYWlBQ0lBUnFJZ1EyQWdBZ0JDQUJTU0lDSUFOQkFXb2lBMEVnU1hFTkFBd0NDd0FMUVFRUUZDSUFRY1FsTmdJQUlBQkIyQXBCQ2hBYkRBRUxJQUlFUUVFRUVCUWlBRUhFSlRZQ0FDQUFRZGdLUVFvUUd3c0xDNlFHQWdsL0FYNENRQ01FSVFRakJFRVFhaVFFSUFRaEJ3SkFBa0FDUUFKQUlBTXNBQUFpQkE0RUFnQUFBUU1MSUFCQndKZ0JhaWtEQUNFTklBSkJCRXdOQXlBTnB5RUtJQUpCZkdvaEN5QUVRUUpHQkg5QjZRRUZRZWdCQ3lFTUlBRWhBRUVBSVFJRFFDQUFRUUZxSVFNZ0FrRUJhaUVFSUFBc0FBQWlCVUZvUmlBTUlBVkIvd0Z4Um5JRWZ5QUVJQXBxUWYvLy93ZHhJUVVnQUVFQ2FpSUdMUUFBUVFoMElBTXRBQUJ5SUFCQkEyb2lDQzBBQUVFUWRISWdBRUVFYWlJSkxRQUFRUmgwY2lJRVFRQklCRUFnQkNBRmFrRi9TZ1JBSUFNZ0JFR0FnSUFJYWlJRE9nQUFJQVlnQTBFSWRqb0FBQ0FJSUFOQkVIWTZBQUFnQ1NBRFFSaDJPZ0FBQ3dVZ0JFR0FnSUI0YWtFQVNBUkFJQU1nQkNBRmF5SURPZ0FBSUFZZ0EwRUlkam9BQUNBSUlBTkJFSFk2QUFBZ0NTQURRUmgyT2dBQUN3c2dBa0VGYWlFQ0lBQkJCV29GSUFRaEFpQURDeUVBSUFJZ0MwZ05BQXNNQXdzZ0FFSEFtQUZxS1FNQUlRMGdBa0VEVEEwQ1FRQWhBQ0FOcHlFRElBSkJmV29oQkFOQUlBRWdBR29pQWl3QUEwRnJSZ1JBSUFJZ0FrRUJhaUlGTFFBQVFRaDBJQUl0QUFCeUlBSkJBbW9pQmkwQUFFRVFkSElnQUNBRGFrRUNkbXNpQWpvQUFDQUZJQUpCQ0hZNkFBQWdCaUFDUVJCMk9nQUFDeUFBUVFScUlnQWdCRWdOQUFzTUFnc2dBeXdBRENFRklBQkJKR29oQkNBQVFTeHFJZ1lvQWdBaEF5QUFRU2hxSWdnZ0FqWUNBQ0FESUFKSkJFQWdBQ2dDTUNJQVFRQkhJQUFnQWtseEJIOGdCeUFBTmdJQVFhejFBa0hZR3lBSEVHQkJyUFVDRUZZZ0JpZ0NBQ0VESUFnb0FnQUZJQUlMSVFBZ0JDZ0NBQ0FBSUFOQklHb2dBMEVDZG1vaUEwc0VmeUFBQlNBRElnQUxFRmNpQTBVRVFFR3M5UUlRVmdzZ0JDQUROZ0lBSUFZZ0FEWUNBQXNnQkNnQ0FDRUdJQVVFUUVFQUlRTkJBQ0VBQlNBSEpBUWdCZzhMSUFWQi93RnhJUWtEUUNBRElBSkpCRUFnQXlFRVFRQWhDQU5BSUFCQkFXb2hCU0FHSUFScUlBaEIvd0Z4SUFFZ0FHb3RBQUJySWdnNkFBQWdCQ0FKYWlJRUlBSkpCRUFnQlNFQURBRUZJQVVoQUFzTEN5QURRUUZxSWdNZ0NVY05BQ0FHSVFFTERBRUxJQWNrQkVFQUR3c2dCeVFFSUFFTHRBTUJDWDhqQkNFQ0l3UkJJR29rQkNBQVFUaHFJZ1VvQWdBaUEwSC9QMHNFUUNBQUVOa0JJQVVvQWdBaUEwSC9QMHNFUUNBRlFRQTJBZ0JCQUNFREN3c2dBQ2dDWkNJR0lBQW9BbUFpQ0VZRWZ5QUJRUVJxSWdRaEJ5QUVLQUlBSVFRZ0FFSFF6UU5xS0FJQUlRbEJBQVVnQUVIUXpRTnFLQUlBSWdrZ0JpQUlhM0VnQVVFRWFpSUhLQUlBSWdSTkN5RUtJQUJCTkdvaEJpQUJJQW82QUEwZ0J5QUlJQVJxSUFseE5nSUFJQUlnQVNrQ0FEY0NBQ0FDSUFFcEFnZzNBZ2dnQlNBRFFRRnFJZ0UyQWdBZ0FTQUFRVHhxSWdjb0FnQWlBMDBFUUNBR0tBSUFJQUZCZjJwQkJIUnFJZ0FnQWlrQ0FEY0NBQ0FBSUFJcEFnZzNBZ2dnQWlRRVFRRVBDeUFDUVJCcUlRUWdBRUZBYXlnQ0FDSUFRUUJISUFFZ0FFdHhCSDhnQkNBQU5nSUFRYXoxQWtIWUd5QUVFR0JCclBVQ0VGWWdCeWdDQUNFRElBVW9BZ0FGSUFFTElRQWdCaWdDQUNBQUlBTkJJR29nQTBFQ2Rtb2lBVXNFZnlBQUJTQUJJZ0FMUVFSMEVGY2lBVVVFUUVHczlRSVFWZ3NnQmlBQk5nSUFJQWNnQURZQ0FDQUJJQVVvQWdCQmYycEJCSFJxSWdBZ0Fpa0NBRGNDQUNBQUlBSXBBZ2czQWdnZ0FpUUVRUUVMK1FRQkIzOGdBU3dBQ0VVRVFDQUJLQUlBSUFCQjZBQnFJZ1lvQWdBaUEwRndha29FUUNBRElBQkJCR29pQnlnQ0FDSUZheUlFUVFCSUJFQkJBQThMSUFCQjhBQnFJZ2dnQUVINEFHb2lDU2dDQUNBRmF5QUlLQUlBYWpZQ0FDQUZRWUNBQVVvRVFDQUVRUUJLQkVBZ0FDZ0NFQ0lESUFNZ0JXb2dCQkJkR2dzZ0IwRUFOZ0lBSUFZZ0JEWUNBQVVnQXlFRUN5QUVRWUNBQWtZRVFFRUFJUVJCZ0lBQ0lRTUZJQUFvQWdBZ0FDZ0NFQ0FFYWtHQWdBSWdCR3NRWGlFRUlBWW9BZ0FpQlNBRWFpRURJQVJCQUVvRVFDQUdJQU0yQWdBRklBVWhBd3NMSUFCQjdBQnFJZ1VnQTBGaWFpSUFOZ0lBSUFrZ0J5Z0NBQ0lETmdJQUlBTkJmMm9nQ0NnQ0FDSUdhaUVESUFaQmYwY0VRQ0FGSUFBZ0EwZ0VmeUFBQlNBREN6WUNBQXNnQkVGL1JnUkFRUUFQQ3dzTElBRVFXRUVPZGlFR0lBRWdBVUVFYWlJRktBSUFRUUpxSWdCQkEzWWdBU2dDQUdvMkFnQWdCU0FBUVFkeE5nSUFRUUFoQkVFQUlRQURRQ0FCRUZoQkNIWWdBRUVEZEhRZ0JHb2hCQ0FCSUFVb0FnQkJDR29pQTBFRGRpQUJLQUlBYWpZQ0FDQUZJQU5CQjNFMkFnQWdBRUVCYWlFRElBQWdCa2NFUUNBRElRQU1BUXNMSUFJZ0JEWUNCQ0FCRUZoQkRuWWhCaUFCSUFVb0FnQkJBbW9pQUVFRGRpQUJLQUlBYWpZQ0FDQUZJQUJCQjNFMkFnQkJBQ0VFUVFBaEFBTkFJQUVRV0VFSWRpQUFRUU4wZENBRWFpRUVJQUVnQlNnQ0FFRUlhaUlEUVFOMklBRW9BZ0JxTmdJQUlBVWdBMEVIY1RZQ0FDQUFRUUZxSVFNZ0FDQUdSd1JBSUFNaEFBd0JDd3NnQWlBRU5nSUlJQUlnQVJCWVFRMTJPZ0FBSUFGQkF4QlZJQUlzQUFBRVFFRUJEd3NnQWlBQkVGaEJDM1pCQVdvNkFBd2dBVUVGRUZWQkFRdVlId0V0ZndKQUl3UWhCQ01FUVJCcUpBUWdBRUhJbUFGcUloNUJBVG9BQUNBQVFiaVlBV29pSHl3QUFBUkFJQUJCN0FCcUlRNGdBRUVJYWlFSElBQkJ3SmdCYWlFYUlBQkI4QUJxSVJNZ0FFSDRBR29oRWlBQVFZUUJhaUViSUFCQjZBQnFJUWdnQUVFRWFpRVhJQUJCOEFCcUlSZ2dBRUVFYWlFTUJTQUJSUVJBSUFCQmhBRnFRUUJCbkpVQkVGUWFJQUJCeEFCcUlnSkNBRGNDQUNBQ1FnQTNBZ2dnQWtJQU53SVFJQUpDQURjQ0dDQUNRUUEyQWlBZ0FFR2dsZ0ZxSUFCQnpNMERhaWdDQUNJQ1FZQ0FnQUpKQkg4Z0FnVkJnSUNBQWdzZ0FFSFF6UU5xS0FJQWNUWUNBQXNnQUVFQU5nSTRJQUJCQ0dvaUIwRUFOZ0lBSUFCQkJHb2lCVUVBTmdJQUlBQkJ3SmdCYWlJYVFnQTNBd0FnQUVIb0FHb2lBMElBTndNQUlBTkNBRGNEQ0NBRFFnQTNBeEFnQTBFQU5nSVlJQUJCOEFCcUlnWkJmellDQUNBQlJRUkFJQUJCd0s0Q2FrRUFOZ0lBSUFCQnhLNENha0VBTmdJQUlBQkJ1SzRDYWtFQU5nSUFJQUJCdks0Q2FrRUJOZ0lBSUFCQnlLNENha0VBUWZBQ0VGUWFJQUJCaEs4QmFrRUFRYlQvQUJCVUdpQUFRY3pNQTJwQkFEb0FBQ0FBUWJUSkEycEJBRUdVQXhCVUdpQUFRYkRKQTJwQkFqWUNBQ0FBUWNqTUEycEJBRFlDQUFzZ0FDQUJFSU1CSUFNb0FnQWlBaUFGS0FJQUlnaHJJZ0ZCQUVnTkFTQUdJQUJCK0FCcUloSW9BZ0FnQ0dzZ0JpZ0NBR28yQWdBZ0NFR0FnQUZLQkVBZ0FVRUFTZ1JBSUFBb0FoQWlBaUFDSUFocUlBRVFYUm9MSUFWQkFEWUNBQ0FESUFFMkFnQUZJQUloQVFzZ0FVR0FnQUpHQkVCQkFDRUJRWUNBQWlFQ0JTQUFLQUlBSUFBb0FoQWdBV3BCZ0lBQ0lBRnJFRjRoQVNBREtBSUFJZ2dnQVdvaEFpQUJRUUJLQkVBZ0F5QUNOZ0lBQlNBSUlRSUxDeUFBUWV3QWFpSU9JQUpCWW1vaUFqWUNBQ0FTSUFVb0FnQWlDRFlDQUNBSVFYOXFJQVlvQWdBaURHb2hDQ0FNUVg5SEJFQWdEaUFDSUFoSUJIOGdBZ1VnQ0FzMkFnQUxJQUZCZjBZTkFTQUFJQUJCQkdvaURDQUFRZkFBYWlJVEVLUUNSUTBCSUFBZ0RDQVRJQUJCaEFGcUloc1Fvd0pGRFFFQ1FDQURJUWdnQlNFWElBWWhHQXNMSUFRaER5QUFRZEROQTJvaEVDQUFRZUFBYWlFSklBQkJCR29oQ2lBQVFhQ1dBV29oSUNBQVFSQnFJUlFnQUVHSUFtb2hJU0FBUWFpWUFXb2hGU0FBUWFTV0FXb2hJaUFBUWFpV0FXb2hEU0FBUWZRZmFpRWpJQUJCekFCcUlSd2dBRUhRQUdvaEpDQUFRY2dBYWlFZElBQkJ4QUJxSVJZZ0FFSFlBR29oR1NBQVFlQTlhaUVsSUFCQjNEeHFJU1lnQUVId0htb2hKeUFBUWN6YkFHb2hLQ0FBUWNqYUFHb2hLU0FBUVlRQmFpRXFJQUJCc0pnQmFpRXJJQUJCOEFCcUlTd2dBRUgwQUdvaExTQUFRWUFCYWlFdUFrQUNRQUpBQTBBQ1FDQUpJQWtvQWdBZ0VDZ0NBQ0lFY1NJQ05nSUFJQW9vQWdBaUFTQU9LQUlBVGdSQUEwQUNRQ0FCSUN3b0FnQWlBeUFTS0FJQUlnVnFJZ0pJQkVBZ0FTQUNRWDlxUncwQklBY29BZ0FnTFNnQ0FFZ05BUXNnTGl3QUFBMERJQUFnRENBVEVLUUNSUTBHSUFBZ0RDQVRJQnNRb3dKRkRRWWdDaWdDQUNFQkRBRUxDeUFJS0FJQUlnUWdBV3NpQWtFQVNBMEJJQmdnQlNBQmF5QURhallDQUNBQlFZQ0FBVW9FZnlBQ1FRQktCRUFnRkNnQ0FDSUVJQVFnQVdvZ0FoQmRHZ3NnRjBFQU5nSUFJQWdnQWpZQ0FDQUNCU0FFQ3lJQlFZQ0FBa1lFUUVFQUlRRkJnSUFDSVFJRklBQW9BZ0FnRkNnQ0FDQUJha0dBZ0FJZ0FXc1FYaUVCSUFnb0FnQWlCQ0FCYWlFQ0lBRkJBRW9FUUNBSUlBSTJBZ0FGSUFRaEFnc0xJQTRnQWtGaWFpSUNOZ0lBSUJJZ0Z5Z0NBQ0lETmdJQUlBTkJmMm9nR0NnQ0FDSUZhaUVFSUFWQmYwY0VRQ0FPSUFJZ0JFZ0VmeUFDQlNBRUN6WUNBQXNnQVVGL1JnMEJJQWtvQWdBaEFpQVFLQUlBSVFRZ0F5RUJDeUFnS0FJQUlnTWdBa1lnQXlBQ2F5QUVjVUdESUV0eUJIOGdBUVVnQUJEWkFTQWFLUU1BSUNzcEF3QlZEUVFnSHl3QUFBMERJQW9vQWdBTElRSWdGQ2dDQUNJR0lBSkJBV3BxTFFBQVFRaDBJQVlnQW1vdEFBQkJFSFJ5SUFZZ0FrRUNhbW90QUFCeVFRZ2dCeWdDQUNJRWEzWkIvdjhEY1NJRElBQkJpQUZxSUNFb0FnQWlBVUVDZEdvb0FnQkpCRUFnQ2lBRUlBQkJqQUpxSUFOQkVDQUJhM1lpQkdvdEFBQnFJZ05CQTNZZ0Ftb2lBVFlDQUNBSElBTkJCM0VpQWpZQ0FDQUFRWXdLYWlBRVFRRjBhaUVEQlFOQUFrQWdBVUVCYWlJQlFROVBCRUJCRHlFQkRBRUxJQU1nQUVHSUFXb2dBVUVDZEdvb0FnQlBEUUVMQ3lBS0lBRWdCR29pQkVFRGRpQUNhaUlDTmdJQUlBY2dCRUVIY1NJRU5nSUFJQUJCakJwcUlBTWdBQ0FCUVFKMGFpZ0NoQUZyUVJBZ0FXdDJJQUJCeUFGcUlBRkJBblJxS0FJQWFpSUJJQ29vQWdCUEJIOUJBQVVnQVF0QkFYUnFJUU1nQWlFQklBUWhBZ3NnQXk0QkFDSUVRZi8vQTNGQmdBSklCRUFnRlN3QUFBUi9JQWtnQ1NnQ0FDSUJRUUZxTmdJQUlBMGdBUkIxQlNBaUtBSUFJUUVnQ1NBSktBSUFJZ0pCQVdvMkFnQWdBU0FDYWdzaUFTQUVPZ0FBREFJTElBUkIvLzhEY1NFRElBUkIvLzhEY1VHRkFrd0VRQUpBQWtBQ1FDQUVRWUFDYXc0Q0FBRUNDeUFBSUF3Z0R4RDZBMFVOQnlBQUlBOFErUU1hREFRTElCa29BZ0FpQVVVTkF5QVdLQUlBSVFRZ0ZTd0FBRVVFUUNBQUlBRWdCQkIyREFRTElCQW9BZ0FoQXlBSktBSUFJZ0lnQkdzaEJBTkFJQTBnQkNBRGNSQjFMQUFBSVFVZ0RTQUNFSFVnQlRvQUFDQUpJQWtvQWdCQkFXb2dBM0VpQWpZQ0FDQUJRWDlxSWdGRkRRUWdCRUVCYWlFRURBQUxBQXNnQUVIRUFHb2dBMEgrZldvaUJFRUNkR29vQWdBaEF5QUVCSDhnQkNFQkEwQWdBRUhFQUdvZ0FVRUNkR29nQUVIRUFHb2dBVUYvYWlJQlFRSjBhaWdDQURZQ0FDQUJEUUFMSUJRb0FnQWhCaUFIS0FJQUlRSWdDaWdDQUFVZ0FRc2hCQ0FXSUFNMkFnQWdCaUFFUVFGcWFpMEFBRUVJZENBR0lBUnFMUUFBUVJCMGNpQUdJQVJCQW1wcUxRQUFja0VJSUFKcmRrSCsvd054SWdVZ0FFSE0yZ0JxSUNnb0FnQWlBVUVDZEdvb0FnQkpCRUFnQ2lBQ0lBQkIwTnNBYWlBRlFSQWdBV3QySWdWcUxRQUFhaUlDUVFOMklBUnFJZ0UyQWdBZ0J5QUNRUWR4SWdJMkFnQWdBRUhRNHdCcUlBVkJBWFJxSVFVRkEwQUNRQ0FCUVFGcUlnRkJEMDhFUUVFUElRRU1BUXNnQlNBQVFjemFBR29nQVVFQ2RHb29BZ0JQRFFFTEN5QUtJQUVnQW1vaUMwRURkaUFFYWlJQ05nSUFJQWNnQzBFSGNTSUVOZ0lBSUFCQjBQTUFhaUFGSUFBZ0FVRUNkR3BCeU5vQWFpZ0NBR3RCRUNBQmEzWWdBRUdNMndCcUlBRkJBblJxS0FJQWFpSUJJQ2tvQWdCUEJIOUJBQVVnQVF0QkFYUnFJUVVnQWlFQklBUWhBZ3NnQlM4QkFDSUxJZ1JCQW5ZaUVVRi9haUVGSUJrZ0MwSC8vd054UVFoSUJIOGdCRUVDYWdVZ0JFRURjVUVFY2lBRmRFRUNhaUVFSUFVRVFDQUdJQUZCQVdwcUxRQUFRUWgwSUFZZ0FXb3RBQUJCRUhSeUlBWWdBVUVDYW1vdEFBQnlRUWdnQW10MlFmLy9BM0ZCRVNBUmEzWWdCR29oQkNBS0lBSWdCV29pQWtFRGRpQUJhallDQUNBSElBSkJCM0UyQWdBTElBUUxJZ0UyQWdBZ0ZTd0FBRVVFUUNBQUlBRWdBeEIyREFNTElCQW9BZ0FoQlNBSktBSUFJUUlnQVVVTkFpQUNJQU5ySVFRRFFDQU5JQVFnQlhFUWRTd0FBQ0VESUEwZ0FoQjFJQU02QUFBZ0NTQUpLQUlBUVFGcUlBVnhJZ0kyQWdBZ0FVRi9haUlCUlEwRElBUkJBV29oQkF3QUN3QUxJQU5CK24xcUlndEJBbllpRVVGL2FpRUZJQXRCQ0VrRVFDQURRZng5YWlFRUJTQUVRUUpxUVJCMFFSQjFRUU54UVFSeUlBVjBRUUpxSVFRZ0JRUkFJQVlnQVVFQmFtb3RBQUJCQ0hRZ0JpQUJhaTBBQUVFUWRISWdCaUFCUVFKcWFpMEFBSEpCQ0NBQ2EzWkIvLzhEY1VFUklCRnJkaUFFYWlFRUlBb2dBaUFGYWlJQ1FRTjJJQUZxSWdFMkFnQWdCeUFDUVFkeElnSTJBZ0FMQ3lBR0lBRkJBV3BxTFFBQVFRaDBJQVlnQVdvdEFBQkJFSFJ5SUFZZ0FVRUNhbW90QUFCeVFRZ2dBbXQyUWY3L0EzRWlCU0FBUWZRZWFpQWpLQUlBSWdOQkFuUnFLQUlBU1FSL0lBb2dBaUFBUWZnZmFpQUZRUkFnQTJ0MklnTnFMUUFBYWlJQ1FRTjJJQUZxSWdFMkFnQWdCeUFDUVFkeElnSTJBZ0FnQUVINEoyb2dBMEVCZEdvRkEwQUNRQ0FEUVFGcUlnTkJEMDhFUUVFUElRTU1BUXNnQlNBQVFmUWVhaUFEUVFKMGFpZ0NBRThOQVFzTElBb2dBeUFDYWlJQ1FRTjJJQUZxSWdFMkFnQWdCeUFDUVFkeElnSTJBZ0FnQUVINE4yb2dCU0FBSUFOQkFuUnFRZkFlYWlnQ0FHdEJFQ0FEYTNZZ0FFRzBIMm9nQTBFQ2RHb29BZ0JxSWdNZ0p5Z0NBRThFZjBFQUJTQURDMEVCZEdvTElnTXZBUUFpRVNJRFFRRjJJZ3RCZjJvaEJTQVJRZi8vQTNGQkJFZ0VRQ0FEUVFGcUlRRUZJQU5CQVhGQkFuSWdCWFJCQVdvaEF3Si9JQVVFZnlBRlFRTk5CRUFnQmlBQlFRRnFhaTBBQUVFUWRDQUdJQUZxTFFBQVFSaDBjaUFHSUFGQkFtcHFMUUFBUVFoMGNpQUdJQUZCQTJwcUxRQUFjaUFDZENBR0lBRkJCR3BxTFFBQVFRZ2dBbXQyY2tFaElBdHJkaUFEYWlFRElBb2dBaUFGYWlJQ1FRTjJJQUZxTmdJQUlBY2dBa0VIY1RZQ0FDQUREQUlMSUFWQkJFWUVRQ0FESVFVZ0FTRURCU0FHSUFGQkFXcHFMUUFBUVJCMElBWWdBV290QUFCQkdIUnlJQVlnQVVFQ2Ftb3RBQUJCQ0hSeUlBWWdBVUVEYW1vdEFBQnlJQUowSUFZZ0FVRUVhbW90QUFCQkNDQUNhM1p5UVNVZ0MydDJRUVIwSUFOcUlRVWdDaUFMUVh0cUlBSnFJZ0pCQTNZZ0FXb2lBellDQUNBSElBSkJCM0VpQWpZQ0FBc2dCU0FHSUFOQkFXcHFMUUFBUVFoMElBWWdBMm90QUFCQkVIUnlJQVlnQTBFQ2Ftb3RBQUJ5UVFnZ0FtdDJRZjcvQTNFaUJpQUFRZUE4YWlBbEtBSUFJZ0ZCQW5ScUtBSUFTUVIvSUFvZ0FpQUFRZVE5YWlBR1FSQWdBV3QySWdGcUxRQUFhaUlDUVFOMklBTnFOZ0lBSUFjZ0FrRUhjVFlDQUNBQVFlVEZBR29nQVVFQmRHb0ZBMEFDUUNBQlFRRnFJZ0ZCRDA4RVFFRVBJUUVNQVFzZ0JpQUFRZUE4YWlBQlFRSjBhaWdDQUU4TkFRc0xJQW9nQVNBQ2FpSUNRUU4ySUFOcU5nSUFJQWNnQWtFSGNUWUNBQ0FBUWVUVkFHb2dCaUFBSUFGQkFuUnFRZHc4YWlnQ0FHdEJFQ0FCYTNZZ0FFR2dQV29nQVVFQ2RHb29BZ0JxSWdFZ0ppZ0NBRThFZjBFQUJTQUJDMEVCZEdvTElnRXZBUUJxQlNBREN3c2lBVUdBQWtzRVFDQUJRWURBQUVzaEFpQUJRWUNBRUVzRWYwRURCVUVDQ3lFRElBSUVmeUFEQlVFQkN5QUVhaUVFQ3dzZ0pDQWNLQUlBTmdJQUlCd2dIU2dDQURZQ0FDQWRJQllvQWdBMkFnQWdGaUFCTmdJQUlCa2dCRFlDQUNBVkxBQUFSUVJBSUFBZ0JDQUJFSFlNQWdzZ0VDZ0NBQ0VGSUFrb0FnQWhBaUFFUlEwQklBSWdBV3NoQXlBQ0lRRURRQ0FOSUFNZ0JYRVFkU3dBQUNFQ0lBMGdBUkIxSUFJNkFBQWdDU0FKS0FJQVFRRnFJQVZ4SWdFMkFnQWdCRUYvYWlJRVJRMENJQU5CQVdvaEF3d0FDd0FMQ3d3Q0N5QWVRUUE2QUFBZ0R5UUVEd3NnRHlRRUR3c2dBQkRaQVNBUEpBUVBDeUFFSkFRTGhnVUJBWDhDUUNBQUtBS0FBU0lESUFGTEJFQWdBeUVBQlNBQUtBS0VBU0lESUFGTEJFQWdBeUVBQlNBQUtBS0lBU0lESUFGTEJFQWdBeUVBQlNBQUtBS01BU0lESUFGTEJFQWdBeUVBQlNBQUtBS1FBU0lESUFGTEJFQWdBeUVBQlNBQUtBS1VBU0lESUFGTEJFQWdBeUVBQlNBQUtBS1lBU0lESUFGTEJFQWdBeUVBQlNBQUtBS2NBU0lESUFGTEJFQWdBeUVBQlNBQUtBS2dBU0lESUFGTEJFQWdBeUVBQlNBQUtBS2tBU0lESUFGTEJFQWdBeUVBQlNBQUtBS29BU0lESUFGTEJFQWdBeUVBQlNBQUtBS3NBU0lESUFGTEJFQWdBeUVBQlNBQUtBS3dBU0lESUFGTEJFQWdBeUVBQlNBQUtBSzBBU0lESUFGTEJFQWdBeUVBQlNBQUtBSzRBU0lESUFGTEJFQWdBeUVBQlNBQUtBSzhBU0lESUFGTEJFQWdBeUVBQlNBQUtBTEFBU0lESUFGTEJFQWdBeUVBQlNBQUtBTEVBU0lESUFGTEJFQWdBeUVBQlNBQUtBTElBU0lESUFGTEJFQWdBeUVBQlNBQUtBTE1BU0lESUFGTEJFQWdBeUVBREJRTElBQW9BdEFCSWdNZ0FVc0VRQ0FESVFBTUZBc2dBQ2dDMUFFaUF5QUJTd1JBSUFNaEFBd1VDeUFBS0FMWUFTSURJQUZMQkVBZ0F5RUFEQlFMSUFBb0F0d0JJZ01nQVVzRVFDQURJUUFNRkFzZ0FDZ0M0QUVpQXlBQlN3UkFJQU1oQUF3VUN5QUFLQUxrQVNJRElBRkxCRUFnQXlFQURCUUxJQUFvQXVnQklnTWdBVXNFUUNBRElRQU1GQXNnQUNnQzdBRWlBeUFCU3dSQUlBTWhBQXdVQ3lBQUtBTHdBU0lESUFGTEJFQWdBeUVBREJRTElBQW9BdlFCSWdNZ0FVc0VRQ0FESVFBTUZBc2dBQ2dDK0FFaUF5QUJTd1JBSUFNaEFBd1VDeUFBS0FMOEFTSUFJQUZMRFJOQkFDRUFRUUFQQ3dzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dzZ0FDQUJheUlBSUFKSkJIOGdBQVVnQWdzTDVBRUJCbjhqQkNFQ0l3UkJFR29rQkNBQVFRUnFJZ1FvQWdCQkFXb2hBeUFFSUFNMkFnQWdBeUFBUVFocUlnWW9BZ0FpQjAwRVFDQUFLQUlBSUFOQmYycEJBblJxSUFFMkFnQWdBaVFFRHdzZ0FpRUZJQUFvQWd3aUFrRUFSeUFESUFKTGNRUi9JQVVnQWpZQ0FFR3M5UUpCMkJzZ0JSQmdRYXoxQWhCV0lBUW9BZ0FoQXlBR0tBSUFCU0FIQ3lFQ0lBQW9BZ0FnQXlBQ1FTQnFJQUpCQW5acUlnSkxCSDhnQXdVZ0FpSURDMEVDZEJCWElnSkZCRUJCclBVQ0VGWUxJQUFnQWpZQ0FDQUdJQU0yQWdBZ0FpQUVLQUlBUVg5cVFRSjBhaUFCTmdJQUlBVWtCQXVBRndFVGZ3SkFBa0FqQkNFRkl3UkJNR29rQkNBRlFTQnFJUkVnQlVFWWFpRVNJQVZCRUdvaEV5QUZRUWhxSVJRZ0JTRU1JQUJCak0wRGFrRUFOZ0lBSUFCQmlNMERhaUlJUVFBMkFnQWdBRUdVelFOcUtBSUFJQUlnQTBHQWdBSklCSDhnQXdWQmdJQUNDeEJUR2lBQVFkRE1BMm9pRlVFUWFpSUNLQUlBUlFSQUlBSkJoSUFRRUY4MkFnQUxBa0FDUUNBQlFZQUJjUVJBSUFnUWNpSUNCRUFnQWtGL2FpRUhEQUlGSUFCQkFCQ0RBU0FBUWJ6TkEyb2hDeUFBUVp6TkEyb2lBaWdDQUNFREN3VWdBRUhJelFOcUtBSUFJUWNNQVFzTUFRc2dCeUFBUVp6TkEyb2lBaWdDQUNJRFN3MENJQWNnQUVHOHpRTnFJZ3NvQWdCTERRSUxJQUJCbU0wRGFpRUVJQUJCdU0wRGFpRU9JQUJCeU0wRGFpQUhOZ0lBUWZBQUVGOGlCa0VVYWlFSklBWkJBRFlDYkNBSlFnQTNBZ0FnQ1VJQU53SUlJQWxDQURjQ0VDQUpRZ0EzQWhnZ0NVSUFOd0lnSUFsQ0FEY0NLQ0FKUWdBM0FqQWdCeUFEUmlJV0JFQWdCMEdBd0FCTERRRWdBaUFIUVFGcUlnTTJBZ0FnQXlBQVFhRE5BMm9pQ2lnQ0FDSUZTd1IvSUFCQnBNMERhaWdDQUNJTlFRQkhJQU1nRFV0eEJFQWdEQ0FOTmdJQVFhejFBa0hZR3lBTUVHQkJyUFVDRUZZZ0NpZ0NBQ0VGSUFJb0FnQWhBd3NnQkNnQ0FDQURJQVZCSUdvZ0JVRUNkbW9pQlVzRWZ5QURJZ1VGSUFVTFFRSjBFRmNpQTBVRVFFR3M5UUlRVmdzZ0JDQUROZ0lBSUFvZ0JUWUNBQ0FESVFVZ0FpZ0NBQVVnQkNnQ0FDRUZJQU1MSVFKQjhBQVFYeUlEUVJScUlRUWdBMEVBTmdKc0lBUkNBRGNDQUNBRVFnQTNBZ2dnQkVJQU53SVFJQVJDQURjQ0dDQUVRZ0EzQWlBZ0JFSUFOd0lvSUFSQ0FEY0NNQ0FGSUFKQmYyb2lBa0VDZEdvZ0F6WUNBQ0FHSUFJMkFoQWdEa0VBRVAwRElBTkJBRFlDQ0FVZ0JDZ0NBQ0FIUVFKMGFpZ0NBQ0VESUFZZ0J6WUNFQ0FEUVFocUlnSWdBaWdDQUVFQmFqWUNBQXNnQUVHb3pRTnFJUW9DUUFKQUlBQkJyTTBEYWlJTktBSUFJZ1VFUUVFQUlRSkJBQ0VFQTBBZ0NpZ0NBQ0lRSUFRZ0FtdEJBblJxSUJBZ0JFRUNkR29vQWdBMkFnQWdBaUFLS0FJQUlBUkJBblJxSWhBb0FnQkZhaUlDUVFCS0JFQWdFRUVBTmdJQUN5QUVRUUZxSWdRZ0JVa05BQXNnQWdSQUlBSWhCQ0FGSVFJRklBVkJnTUFBU3dSQUlBWW9BandpQUFSQUlBQVFVZ3NnQmlnQ0xDSUFCRUFnQUJCU0N5QUpLQUlBSWdBRVFDQUFFRklMREFVRkRBTUxBQXNGUVFBaEJRd0JDd3dCQ3lBTklBVkJBV29pQWpZQ0FDQUNJQUJCc00wRGFpSUVLQUlBSWdWTEJFQWdBRUcwelFOcUtBSUFJZ2xCQUVjZ0FpQUpTM0VFUUNBVUlBazJBZ0JCclBVQ1FkZ2JJQlFRWUVHczlRSVFWaUFFS0FJQUlRVWdEU2dDQUNFQ0N5QUtLQUlBSUFJZ0JVRWdhaUFGUVFKMmFpSUZTd1IvSUFJRklBVWlBZ3RCQW5RUVZ5SUZSUVJBUWF6MUFoQldDeUFLSUFVMkFnQWdCQ0FDTmdJQUlBMG9BZ0FoQWd0QkFTRUVDeUFLS0FJQUlBSWdCR3RCQW5ScUlBWTJBZ0FnQmtFSWFpSUpJQU1vQWdnMkFnQWdDQkJ5SWdKQmdnSnFJUVVnQmlBQlFjQUFjUVIvSUFVRklBSWlCUXNnQUVIZ0FHb2lCQ2dDQUNJQ2FpQUFRZEROQTJvaUNpZ0NBSEUyQWdBZ0FVRWdjUVJBSUFZZ0NCQnlJZ0kyQWdRZ0RpZ0NBQ0FIUVFKMGFpQUNOZ0lBSUFRb0FnQWhBZ1VnQmlBSElBc29BZ0JKQkg4Z0RpZ0NBQ0FIUVFKMGFpZ0NBQVZCQUFzMkFnUUxJQVlnQUNnQ1pDSUFJQUpHQkg5QkFBVWdDaWdDQUNBQUlBSnJjU0FGVFF0QkFYRTZBQXdnQmtITUFHb2lCRUlBTndJQUlBUkNBRGNDQ0NBRVFnQTNBaEFnQkVFQU5nSVlJQVpCZ0lBUE5nSllJQVlnQmtFRWFpSU9LQUlBTmdKY0lBWWdDU2dDQURZQ1lDQUJRUkJ4QkVBZ0NCQllRUWwySVFBZ0NFRUhFRlVnQUVFQmNRUkFJQVFnQ0JCeU5nSUFDeUFBUVFKeEJFQWdCaUFJRUhJMkFsQUxJQUJCQkhFRVFDQUdJQWdRY2pZQ1ZBc2dBRUVJY1FSQUlBWWdDQkJ5TmdKWUN5QUFRUkJ4QkVBZ0JpQUlFSEkyQWx3TElBQkJJSEVFUUNBR0lBZ1FjallDWUFzZ0FFSEFBSEVFUUNBR0lBZ1FjallDWkFzTEFrQWdGZ1JBSUFnUWNpSUZRWDlxUWY3L0Ewc05BMEVBSUFWQklFc0VmeUFGQlVFZ0N4QlhJZ0pGQkVCQnJQVUNFRlpCQUNFQ0MwRUFJUUFDUUFKQUFrQUNRQU5BSUFnb0FnQkJBMnBCLy84QlN3MEJRUUFrQlVFVklBZ1FCU0VISXdVaEMwRUFKQVVnQzBFQmNRMENJQUlnQUdvZ0IwRUlkam9BQUVFQUpBVkJFQ0FJUVFnUURTTUZJUWRCQUNRRklBZEJBWEVOQXlBQVFRRnFJZ0FnQlVrTkFBdEJBQ1FGUVFZZ0ZTQUNJQVVnQTBFVWFoQVBJd1VoQUVFQUpBVWdBRUVCY1EwQ0lBSVFVZ3dGQ3lBQ1JRMEdJQUlRVWd3R0N4QVhJUUFnQWdSQUlBQWhEd1VnQUJBZUN3d0JDeEFYSVE4TElBSVFVaUFQRUI0TEN5QUdJQU1vQWhRMkFpUWdCaUFES0FJb05nSW9JQU5CUUdzb0FnQWlCMEYvYWtIL1Awa0VRQ0FHUVR4cUlRVWdCa0ZBYXlJTEtBSUFJQWRxSVFBZ0N5QUFOZ0lBSUFBZ0JrSEVBR29pRHlnQ0FDSUNTd1JBSUFZb0FrZ2lDa0VBUnlBQUlBcExjUVJBSUJNZ0NqWUNBRUdzOVFKQjJCc2dFeEJnUWF6MUFoQldJQThvQWdBaEFpQUxLQUlBSVFBTElBVW9BZ0FnQUNBQ1FTQnFJQUpCQW5acUlnSkxCSDhnQUNJQ0JTQUNDeEJYSWdCRkJFQkJyUFVDRUZZTElBVWdBRFlDQUNBUElBSTJBZ0FGSUFVb0FnQWhBQXNnQUNBREtBSThJQWNRVXhvTElBWkJMR29pQXlnQ0FDRUFJQVpCTUdvaUJTZ0NBRUhBQUVrRVFDQUFCRUFnQUJCU0lBTkJBRFlDQUFzZ0JrRTBhaUlIUVFBMkFnQWdCVUhBQURZQ0FDQUdLQUk0SWdCQmYycEJQMGtFZnlBU0lBQTJBZ0JCclBVQ1FkZ2JJQklRWUVHczlRSVFWaUFIS0FJQUlRSWdBeWdDQUNFTElBVW9BZ0FGUVFBaEFrRUFJUXRCd0FBTElRQWdDeUFBSUFKQklHb2dBa0VDZG1vaUFrc0VmeUFBSWdJRklBSUxFRmNpQUVVRVFFR3M5UUlRVmdzZ0F5QUFOZ0lBSUFjZ0FqWUNBQXNnQUNBRUtBSUFJZ0k2QUFBZ0FDQUNRUWgyT2dBQklBQWdBa0VRZGpvQUFpQUFJQUpCR0hZNkFBTWdBRUVFYWlJQ0lBWW9BbEFpQkRvQUFDQUNJQVJCQ0hZNkFBRWdBaUFFUVJCMk9nQUNJQUlnQkVFWWRqb0FBeUFBUVFocUlnSWdCaWdDVkNJRU9nQUFJQUlnQkVFSWRqb0FBU0FDSUFSQkVIWTZBQUlnQWlBRVFSaDJPZ0FESUFCQkRHb2lBaUFHS0FKWUlnUTZBQUFnQWlBRVFRaDJPZ0FCSUFJZ0JFRVFkam9BQWlBQ0lBUkJHSFk2QUFNZ0FFRVFhaUlDSUFZb0Fsd2lCRG9BQUNBQ0lBUkJDSFk2QUFFZ0FpQUVRUkIyT2dBQ0lBSWdCRUVZZGpvQUF5QUFRUlJxSWdJZ0JpZ0NZQ0lFT2dBQUlBSWdCRUVJZGpvQUFTQUNJQVJCRUhZNkFBSWdBaUFFUVJoMk9nQURJQUJCR0dvaUFpQUdLQUprSWdRNkFBQWdBaUFFUVFoMk9nQUJJQUlnQkVFUWRqb0FBaUFDSUFSQkdIWTZBQU1nQUVFY2FpSUNJQTRvQWdBaUJEb0FBQ0FDSUFSQkNIWTZBQUVnQWlBRVFSQjJPZ0FDSUFJZ0JFRVlkam9BQXlBQVFTQnFJZ0pCQURvQUFDQUNRUUE2QUFFZ0FrRUFPZ0FDSUFKQkFEb0FBeUFBUVN4cUlnSWdDU2dDQUNJRU9nQUFJQUlnQkVFSWRqb0FBU0FDSUFSQkVIWTZBQUlnQWlBRVFSaDJPZ0FESUFCQk1Hb2lBRUlBTndBQUlBQkNBRGNBQ0NBQlFRaHhSUVJBSUF3a0JFRUJEd3NnQ0NnQ0FFRURha0gvL3dGTERRRWdDQkJ5SWdKQndEOUxEUUVnQWtGQWF5SUFJQVVvQWdCTEJFQWdCU0FBTmdJQUlBQWdCa0UwYWlJRUtBSUFJZ0ZMQkVBZ0JpZ0NPQ0lIUVFCSElBQWdCMHR4QkVBZ0VTQUhOZ0lBUWF6MUFrSFlHeUFSRUdCQnJQVUNFRllnQkNnQ0FDRUJJQVVvQWdBaEFBc2dBeWdDQUNBQUlBRkJJR29nQVVFQ2Rtb2lBVXNFZnlBQUJTQUJJZ0FMRUZjaUFVVUVRRUdzOVFJUVZnc2dBeUFCTmdJQUlBUWdBRFlDQUFzTElBTW9BZ0FoQVNBQ0JFQkJBQ0VBQlNBTUpBUkJBUThMSUFGQlFHc2hBUUpBQTBBZ0NDZ0NBRUVEYWtILy93RkxCRUJCQUNFQURBSUxJQUVnQUdvZ0NCQllRUWgyT2dBQUlBaEJDQkJWSUFCQkFXb2lBQ0FDU1EwQVFRRWhBQXNMSUF3a0JDQUFEd3NnQmhCU0N5QU1KQVJCQUF1U0JnRU5meUFBUVJCcUlna29BZ0FpQVNBQVFRUnFJZ2NvQWdBaUJVRUJhbW90QUFCQkNIUWdBU0FGYWkwQUFFRVFkSElnQVNBRlFRSnFhaTBBQUhKQkNDQUFRUWhxSWdnb0FnQWlBMnQyUVFoMklnWkIvd0Z4SVFzZ0J5QURRUWhxSWdKQkEzWWdCV29pQXpZQ0FDQUlJQUpCQjNFaUFqWUNBQ0FHUVFkeFFRRnFJUVVDUUFKQUFrQUNRQUpBQWtBQ1FDQUdRUWR4UVFackRnSUFBUUlMSUFFZ0EwRUJhaUlHYWkwQUFFRUlkQ0FCSUFOcUxRQUFRUkIwY2lBQklBTkJBbXBxTFFBQWNrRUlJQUpyZGtFSWRrSC9BWEZCQjJvaEJTQUhJQVkyQWdBZ0NDQUNOZ0lBREFJTElBRWdBMEVCYW1vdEFBQkJDSFFnQVNBRGFpMEFBRUVRZEhJZ0FTQURRUUpxSWdGcUxRQUFja0VJSUFKcmRrSC8vd054SVFVZ0J5QUJOZ0lBSUFnZ0FqWUNBQ0FGUlFSQVFRQWhCVUVBSVFNTUF3c0xDMEVBSUFWQklFc0VmeUFGQlVFZ0N4QlhJZ05GQkVCQnJQVUNFRlpCQUNFREN5QUZRWDlxSVF3Z0FFSHNBR29oRFVFQUlRWWdBRUhvQUdvaUNpZ0NBQ0VCSUFjb0FnQWhBZ05BSUFJZ0FVRi9hazRFUUNBQklBSnJJZ1JCQUVnRWYwRUFCU0FDUVlDQUFVb0VRQ0FFUVFCS0JFQWdDU2dDQUNJQklBRWdBbW9nQkJCZEdnc2dCMEVBTmdJQUlBb2dCRFlDQUNBRUlRRUxJQUFvQWdBaEFpQUpLQUlBSUFGcUlRUkJBQ1FGUVJzZ0FpQUVRWUNBQWlBQmF4QUhJUVFqQlNFQlFRQWtCU0FCUVFGeERRVWdDaWdDQUNJQ0lBUnFJUUVnQkVFQVNnUkFJQW9nQVRZQ0FBVWdBaUVCQ3lBTklBRkJZbW8yQWdBZ0JFRi9Sd3NoQWlBR0lBeElJQUpCQVhOeEJFQkJBQ0VBREFRTElBY29BZ0FoQWdzZ0F5QUdhaUFKS0FJQUlnUWdBa0VCYW1vdEFBQkJDSFFnQkNBQ2FpMEFBRUVRZEhJZ0JDQUNRUUpxYWkwQUFISkJDQ0FJS0FJQUlnUnJka0VJZGpvQUFDQUhJQVJCQ0dvaUJFRURkaUFDYWlJQ05nSUFJQWdnQkVFSGNUWUNBQ0FHUVFGcUlnWWdCVWdOQUFzTFFRQWtCVUVHSUFBZ0N5QURJQVVRQ0NFQUl3VWhBVUVBSkFVZ0FVRUJjUTBCQ3lBRFJRUkFJQUFQQ3lBREVGSWdBQThMRUJjaEFDQURSUVJBSUFBUUhnc2dBeEJTSUFBUUhrRUFDNGNEQVFkL0FrQWdBRUhBc1FKcUlnTVFjU0lFUVg5R0RRQWdCRUVIY1VFQmFpRUJBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUVRUWR4UVFackRnSUFBUUlMSUFNUWNTSUNRWDlIQkVBZ0FrRUhhaUVCREFNTERBY0xJQU1RY1NJQ1FYOUdEUVlnQXhCeElnRkJmMGNFUUNBQklBSkJDSFJxSVFFTUFnc01CZ3NNQVFzZ0FVVUVRRUVBSVFGQkFDRUNEQUlMQzBFQUlBRkJJRXNFZnlBQkJVRWdDeEJYSWdKRkJFQkJyUFVDRUZaQkFDRUNDeUFCUVFCS0JFQURRQUpBUVFBa0JVRVVJQU1RQlNFR0l3VWhCMEVBSkFVZ0IwRUJjUTBGSUFaQmYwWU5BQ0FDSUFWcUlBWTZBQUFnQlVFQmFpSUZJQUZJRFFFTUF3c0xRUUFrQlVFaklBTVFEQ01GSVFGQkFDUUZJQUZCQVhFTkF5QUFRY2pNQTJwQkFEWUNBRUVBSVFBTUFnc0xRUUFrQlVFR0lBQWdCQ0FDSUFFUUNDRUFJd1VoQVVFQUpBVWdBVUVCY1EwQkN5QUNSUVJBSUFBUEN5QUNFRklnQUE4TEVCY2hBQ0FDUlFSQUlBQVFIZ3NnQWhCU0lBQVFIa0VBRHdzZ0F4Q1dBU0FBUWNqTUEycEJBRFlDQUVFQUM2RWhBU3AvUWNTMUF5Z0NBRVVFUUFOQUlBTkJFVVlFZjBFU0JTQURDeUlJUWY4QmNTRURRUUVnQ0hRaERpQUNRZHlBQkdvZ0F5QUlRUUowUVl3YmFpZ0NBQ0lKUVFGS0JIOGdDUVZCQVFzUVZCcEJBQ0VISUFvaEF3TkFJQUpCQW5SQndMVURhaUFETmdJQUlBSkJBV29oQWlBRElBNXFJUU1nQjBFQmFpSUhJQWxJRFFBTElBaEJBV29pQjBFVFJ3UkFJQU1oQ2lBSElRTU1BUXNMQ3lBQVFjaVlBV29pSFVFQk9nQUFBa0FnQUVHNG1BRnFJaDRzQUFBRVFDQUFRZWdBYWlFSklBQkJFR29oRGlBQUlRb2dBRUVJYWlFSUlBQkJ3SmdCYWlFYUlBQkJCR29oQndVZ0FVVUVRQ0FBUVlRQmFrRUFRWnlWQVJCVUdpQUFRY1FBYWlJQ1FnQTNBZ0FnQWtJQU53SUlJQUpDQURjQ0VDQUNRZ0EzQWhnZ0FrRUFOZ0lnSUFCQm9KWUJhaUFBUWN6TkEyb29BZ0FpQWtHQWdJQUNTUVIvSUFJRlFZQ0FnQUlMSUFCQjBNMERhaWdDQUhFMkFnQUxJQUJCQURZQ09DQUFRUWhxSWdoQkFEWUNBQ0FBUVFScUlnZEJBRFlDQUNBQVFjQ1lBV29pR2tJQU53TUFJQUJCNkFCcUlnSkNBRGNEQUNBQ1FnQTNBd2dnQWtJQU53TVFJQUpCQURZQ0dDQUFRWDgyQW5BZ0FVVUVRQ0FBUWNDdUFtcEJBRFlDQUNBQVFjU3VBbXBCQURZQ0FDQUFRYml1QW1wQkFEWUNBQ0FBUWJ5dUFtcEJBVFlDQUNBQVFjaXVBbXBCQUVId0FoQlVHaUFBUVlTdkFXcEJBRUcwL3dBUVZCb2dBRUhNekFOcVFRQTZBQUFnQUVHMHlRTnFRUUJCbEFNUVZCb2dBRUd3eVFOcVFRSTJBZ0FnQUVISXpBTnFRUUEyQWdBTElBQWdBUkNEQVNBQ0tBSUFJZ29nQnlnQ0FDSUpheUlEUVFCSUJFQVBDeUFKUVlDQUFVb0VRQ0FEUVFCS0JFQWdBQ2dDRUNJS0lBb2dDV29nQXhCZEdnc2dCMEVBTmdJQUlBSWdBellDQUFVZ0NpRURDeUFBS0FJQUlBQkJFR29pRGlnQ0FDQURha0dBZ0FJZ0Eyc1FYaUVESUFJb0FnQWlDU0FEYWlFS0lBTkJBRW9FUUNBQ0lBbzJBZ0FnQUNBS1FXSnFOZ0pzQlNBQUlBbEJZbW8yQW13Z0EwRi9SZ1JBRHdzTElBRUVRQ0FBUWN6TUEyb3NBQUFFUUNBQ0lRa2dBQ0VLREFNTEN5QUFFTnNCQkVBZ0FpRUpJQUFoQ2dVUEN3c0xJQUJCME0wRGFpRVJJQUJCNEFCcUlRc2dBRUhzQUdvaEZ5QUFRZVFBYWlFZklBQkJ5TXdEYWlFU0lBQkJ3TEVDYWlFTUlBQkJzTWtEYWlFZ0lBQkJwSllCYWlFVElBQkJpQUpxSVNFZ0FFSDBIMm9oSWlBQVFjd0FhaUVVSUFCQjBBQnFJUnNnQUVISUFHb2hGU0FBUWNRQWFpRVBJQUJCMkFCcUlSWWdBRUc4c1FKcUlSZ2dBRUc0c1FKcUlSa2dBRUhnUFdvaEl5QUFRZHc4YWlFa0lBQkI4QjVxSVNVZ0FFSE0yd0JxSVNZZ0FFSEkyZ0JxSVNjZ0FFSE16UU5xSVNnZ0FFSE16QU5xSVJ3Z0FFR0VBV29oS1NBQVFiQ1lBV29oS2tFQUlRRUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUEwQUNRQ0FMSUFzb0FnQWdFU2dDQUhFMkFnQWdCeWdDQUNJRUlCY29BZ0JLQkVBZ0NTZ0NBQ0lESUFScklnSkJBRWdOQVNBRVFZQ0FBVW9FUUNBQ1FRQktCRUFnRGlnQ0FDSURJQU1nQkdvZ0FoQmRHZ3NnQjBFQU5nSUFJQWtnQWpZQ0FBVWdBeUVDQ3lBS0tBSUFJQTRvQWdBZ0FtcEJnSUFDSUFKckVGNGhBaUFKS0FJQUlnUWdBbW9oQXlBQ1FRQktCRUFnQ1NBRE5nSUFJQmNnQTBGaWFqWUNBQVVnRnlBRVFXSnFOZ0lBSUFKQmYwWU5BZ3NMSUI4b0FnQWlBaUFMS0FJQUlnTkdJQUlnQTJzZ0VTZ0NBSEZCZ3dKTGNrVUVRQ0FBRUtVQ0lCb3BBd0FnS2lrREFGVU5DU0FlTEFBQURRTUxJQklvQWdCQkFVWUVRQ0FNRUhFaUFrRi9SZzBFSUFJZ0lDZ0NBRVlFUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQXdRY1VGL2F3NEhBUUlHQUFRRkF3WUxEQWdMREFzTElBQVEyd0ZGRFFZTUJ3c2dEQkJ4SWdKQmYwWU5DeUFBSUFKQkJHcEJBUkIyREFZTElBQVFnQVJGRFFRTUJRc2dEQkJ4SWdKQmYwWU5DQ0FNRUhFaUEwRi9SZzBJSUF3UWNTSUVRWDlHRFFnZ0RCQnhJZ0ZCZjBZTkNDQUFJQUZCL3dGeElnRkJJR29nQkVIL0FYRWdBMEgvQVhFZ0FrSC9BWEZCQ0hSeVFRaDBja0VDYWhCMkRBUUxDeUFUS0FJQUlRTWdDeUFMS0FJQUlnUkJBV28yQWdBZ0F5QUVhaUFDT2dBQURBSUxJQTRvQWdBaUJpQUhLQUlBSWdOQkFXcHFMUUFBUVFoMElBWWdBMm90QUFCQkVIUnlJQVlnQTBFQ2Ftb3RBQUJ5UVFnZ0NDZ0NBQ0lFYTNaQi92OERjU0lGSUFCQmlBRnFJQ0VvQWdBaUFrRUNkR29vQWdCSkJFQWdCeUFFSUFCQmpBSnFJQVZCRUNBQ2EzWWlCR290QUFCcUlnVkJBM1lnQTJvaUFqWUNBQ0FJSUFWQkIzRWlBellDQUNBQVFZd0thaUFFUVFGMGFpRUZCUU5BQWtBZ0FrRUJhaUlDUVE5UEJFQkJEeUVDREFFTElBVWdBRUdJQVdvZ0FrRUNkR29vQWdCUERRRUxDeUFISUFJZ0JHb2lCRUVEZGlBRGFpSUROZ0lBSUFnZ0JFRUhjU0lFTmdJQUlBQkJqQnBxSUFVZ0FDQUNRUUowYWlnQ2hBRnJRUkFnQW10MklBQkJ5QUZxSUFKQkFuUnFLQUlBYWlJQ0lDa29BZ0JQQkg5QkFBVWdBZ3RCQVhScUlRVWdBeUVDSUFRaEF3c2dCUzRCQUNJRlFmLy9BM0ZCZ0FKSUJFQWdFeWdDQUNFQ0lBc2dDeWdDQUNJRFFRRnFOZ0lBSUFJZ0Eyb2dCVG9BQUF3Q0N5QUZRZi8vQTNFaEJDQUZRZi8vQTNGQmpnSk1CRUFDUUFKQUFrQUNRQ0FGUVlBQ2F3NERBQUVDQXdzZ0JpQUNRUUZxYWkwQUFFRUlkQ0FHSUFKcUxRQUFRUkIwY2lBR0lBSkJBbXBxTFFBQWNrRUlJQU5yZGlJRVFZQ0FBbkZGRFFzZ0J5QURRUUZxSWdOQkEzWWdBbW8yQWdBZ0NDQURRUWR4TmdJQUlCeEJBRG9BQUNBQUVOc0JSUTBFREFVTElBQVEvd05GRFFNTUJBc2dGaWdDQUNJQ1JRMERJQUFnQWlBUEtBSUFFSFlNQXdzZ0JVSC8vd054UVljQ1RnUkFJQVJCK1gxcUlnVkJ3VEZxTFFBQUlRUWdCVUc1TVdvdEFBQkJBV29nQmlBQ1FRRnFhaTBBQUVFSWRDQUdJQUpxTFFBQVFSQjBjaUFHSUFKQkFtcHFMUUFBY2tFSUlBTnJka0gvL3dOeFFSQWdCR3QyYWlFRklBY2dBeUFFYWlJRFFRTjJJQUpxTmdJQUlBZ2dBMEVIY1RZQ0FDQWJJQlFvQWdBMkFnQWdGQ0FWS0FJQU5nSUFJQlVnRHlnQ0FEWUNBQ0FQSUFVMkFnQWdGa0VDTmdJQUlBc29BZ0FpQWlBRmF5SURJQ2dvQWdCQi8xOXFJZ1JKSUFJZ0JFbHhCRUFnRXlnQ0FDSUVJQU5xSVFNZ0N5QUNRUUpxTmdJQUlBUWdBbW9pQWlBRExBQUFPZ0FBSUFJZ0F5d0FBVG9BQVFVZ0V5Z0NBQ0lFSUFKcUlBUWdBeUFSS0FJQWNXb3NBQUE2QUFBZ0N5QUxLQUlBUVFGcUlCRW9BZ0FpQW5FaUJEWUNBQ0FUS0FJQUlnVWdCR29nQlNBRFFRRnFJQUp4YWl3QUFEb0FBQ0FMSUFzb0FnQkJBV29nRVNnQ0FIRTJBZ0FMREFNTElBQkJ4QUJxSUFSQi9YMXFJZ1JCQW5ScUtBSUFJUkFnQlVILy93TnhRWU1DU2dSL0lBUWhBZ05BSUFCQnhBQnFJQUpCQW5ScUlBQkJ4QUJxSUFKQmYyb2lBMEVDZEdvb0FnQTJBZ0FnQWtFQlNnUkFJQU1oQWd3QkN3c2dEaWdDQUNFR0lBZ29BZ0FoQXlBSEtBSUFCU0FDQ3lFRUlBOGdFRFlDQUNBR0lBUkJBV3BxTFFBQVFRaDBJQVlnQkdvdEFBQkJFSFJ5SUFZZ0JFRUNhbW90QUFCeVFRZ2dBMnQyUWY3L0EzRWlCU0FBUWN6YUFHb2dKaWdDQUNJQ1FRSjBhaWdDQUVrRVFDQUhJQU1nQUVIUTJ3QnFJQVZCRUNBQ2EzWWlCV290QUFCcUlnTkJBM1lnQkdvaUFqWUNBQ0FJSUFOQkIzRWlBellDQUNBQVFkRGpBR29nQlVFQmRHb2hCUVVEUUFKQUlBSkJBV29pQWtFUFR3UkFRUThoQWd3QkN5QUZJQUJCek5vQWFpQUNRUUowYWlnQ0FFOE5BUXNMSUFjZ0FpQURhaUlOUVFOMklBUnFJZ00yQWdBZ0NDQU5RUWR4SWdRMkFnQWdBRUhROHdCcUlBVWdBQ0FDUVFKMGFrSEkyZ0JxS0FJQWEwRVFJQUpyZGlBQVFZemJBR29nQWtFQ2RHb29BZ0JxSWdJZ0p5Z0NBRThFZjBFQUJTQUNDMEVCZEdvaEJTQURJUUlnQkNFREN5QUZMd0VBSWdWQjBUQnFMUUFBUVFKcUlRUWdCVUh0TUdvdEFBQWhEU0FGUVhocVFSUkpCRUFnQmlBQ1FRRnFhaTBBQUVFSWRDQUdJQUpxTFFBQVFSQjBjaUFHSUFKQkFtcHFMUUFBY2tFSUlBTnJka0gvL3dOeFFSQWdEV3QySUFScUlRUWdCeUFESUExcUlnTkJBM1lnQW1vMkFnQWdDQ0FEUVFkeE5nSUFDeUFXSUFRaUFqWUNBQ0FBSUFJZ0VCQjJEQUlMSUFSQjhYMXFJZ1ZCMFRCcUxRQUFRUU5xSVJBZ0JVSHRNR290QUFBaEJTQUVRZWw5YWtFVVNRUkFJQVlnQWtFQmFtb3RBQUJCQ0hRZ0JpQUNhaTBBQUVFUWRISWdCaUFDUVFKcWFpMEFBSEpCQ0NBRGEzWkIvLzhEY1VFUUlBVnJkaUFRYWlFUUlBY2dBeUFGYWlJRFFRTjJJQUpxSWdRMkFnQWdDQ0FEUVFkeElnTTJBZ0FGSUFJaEJBc2dCaUFFUVFGcWFpMEFBRUVJZENBR0lBUnFMUUFBUVJCMGNpQUdJQVJCQW1wcUxRQUFja0VJSUFOcmRrSCsvd054SWdVZ0FFSDBIbW9nSWlnQ0FDSUNRUUowYWlnQ0FFa0VRQ0FISUFNZ0FFSDRIMm9nQlVFUUlBSnJkaUlGYWkwQUFHb2lBMEVEZGlBRWFpSUNOZ0lBSUFnZ0EwRUhjU0lETmdJQUlBQkIrQ2RxSUFWQkFYUnFJUVVGQTBBQ1FDQUNRUUZxSWdKQkQwOEVRRUVQSVFJTUFRc2dCU0FBUWZRZWFpQUNRUUowYWlnQ0FFOE5BUXNMSUFjZ0FpQURhaUlOUVFOMklBUnFJZ00yQWdBZ0NDQU5RUWR4SWdRMkFnQWdBRUg0TjJvZ0JTQUFJQUpCQW5ScVFmQWVhaWdDQUd0QkVDQUNhM1lnQUVHMEgyb2dBa0VDZEdvb0FnQnFJZ0lnSlNnQ0FFOEVmMEVBQlNBQ0MwRUJkR29oQlNBRElRSWdCQ0VEQ3lBRkx3RUFJaXNpQlVFQ2RFSEF0UU5xS0FJQVFRRnFJUVFnQlVIY2dBUnFMQUFBSWdWQi93RnhJUTBDZnlBRkJIOGdLMEVKVEFSQUlBWWdBa0VCYW1vdEFBQkJDSFFnQmlBQ2FpMEFBRUVRZEhJZ0JpQUNRUUpxYWkwQUFISkJDQ0FEYTNaQi8vOERjVUVRSUExcmRpQUVhaUVFSUFjZ0F5QU5haUlEUVFOMklBSnFOZ0lBSUFnZ0EwRUhjVFlDQUNBRURBSUxJQVZCL3dGeFFRUktCRUFnQmlBQ1FRRnFhaTBBQUVFSWRDQUdJQUpxTFFBQVFSQjBjaUFHSUFKQkFtcHFMUUFBY2tFSUlBTnJka0gvL3dOeFFSUWdEV3QyUVFSMElBUnFJUVVnQnlBTlFYeHFJQU5xSWdOQkEzWWdBbW9pQkRZQ0FDQUlJQU5CQjNFaUF6WUNBQVVnQkNFRklBSWhCQXNnR0NnQ0FDSUNRUUJLQkVBZ0dDQUNRWDlxTmdJQUlCa29BZ0FnQldvTUFnc2dCaUFFUVFGcWFpMEFBRUVJZENBR0lBUnFMUUFBUVJCMGNpQUdJQVJCQW1wcUxRQUFja0VJSUFOcmRrSCsvd054SWdZZ0FFSGdQR29nSXlnQ0FDSUNRUUowYWlnQ0FFa0VmeUFISUFNZ0FFSGtQV29nQmtFUUlBSnJkaUlDYWkwQUFHb2lBMEVEZGlBRWFqWUNBQ0FJSUFOQkIzRTJBZ0FnQUVIa3hRQnFJQUpCQVhScUJRTkFBa0FnQWtFQmFpSUNRUTlQQkVCQkR5RUNEQUVMSUFZZ0FFSGdQR29nQWtFQ2RHb29BZ0JQRFFFTEN5QUhJQUlnQTJvaUEwRURkaUFFYWpZQ0FDQUlJQU5CQjNFMkFnQWdBRUhrMVFCcUlBWWdBQ0FDUVFKMGFrSGNQR29vQWdCclFSQWdBbXQySUFCQm9EMXFJQUpCQW5ScUtBSUFhaUlDSUNRb0FnQlBCSDlCQUFVZ0FndEJBWFJxQ3lJQ0xnRUFJZ05CLy84RGNTRUNJQU5CRUVZRVFDQVlRUTgyQWdBZ0dTZ0NBQ0VDQlNBWklBSTJBZ0FMSUFJZ0JXb0ZJQVFMQ3lJQ1FmOC9TeUVESUFKQi8vOFBTd1IvUVFJRlFRRUxJUVFnR3lBVUtBSUFOZ0lBSUJRZ0ZTZ0NBRFlDQUNBVklBOG9BZ0EyQWdBZ0R5QUNOZ0lBSUJZZ0F3Ui9JQVFGUVFBTElCQnFJZ00yQWdBZ0FDQURJQUlRZGd3QkN3c01Cd3NnSFVFQU9nQUFEd3NnREJDV0FTQVNRUUEyQWdBTUJRc2dEQkNXQVNBU1FRQTJBZ0FNQkFzZ0RCQ1dBU0FTUVFBMkFnQU1Bd3NnREJDV0FTQVNRUUEyQWdBTUFnc2dCeUFEUVFKcUlnRkJBM1lnQW1vMkFnQWdDQ0FCUVFkeE5nSUFJQndnQkVFT2RrRUJjVUVCY3pvQUFBd0JDdzhMSUFBUXBRSUw1Z1VCQjM4Z0FDZ0NhQ0FBUVFScUlnTW9BZ0FpQkVFRmFrZ0VRQThMSUFCQnVLNENhaWdDQUFSQUlBQWdBRUhBcmdKcUtBSUFJZ0pCN0Ixc2FrR0lzQUZxS0FJQUlRRWdBQ2dDRUNJRklBUkJBV3BxTFFBQVFRaDBJQVVnQkdvdEFBQkJFSFJ5SUFVZ0JFRUNhbW90QUFCeVFRZ2dBRUVJYWlJR0tBSUFJZ2RyZGtIKy93TnhJZ1VnQUNBQ1Fld2RiR3BCaUs4QmFpQUJRUUowYWlnQ0FFa0VmeUFESUFjZ0FDQUNRZXdkYkdwQmpMQUJhaUFGUVJBZ0FXdDJJZ0ZxTFFBQWFpSURRUU4ySUFScU5nSUFJQVlnQTBFSGNUWUNBQ0FBSUFKQjdCMXNha0dNdUFGcUlBRkJBWFJxQlFOQUFrQWdBVUVCYWlJQlFROVBCRUJCRHlFQkRBRUxJQVVnQUNBQ1Fld2RiR3BCaUs4QmFpQUJRUUowYWlnQ0FFOE5BUXNMSUFNZ0FTQUhhaUlEUVFOMklBUnFOZ0lBSUFZZ0EwRUhjVFlDQUNBQUlBSkI3QjFzYWtHTXlBRnFJQVVnQUNBQ1Fld2RiR29nQVVFQ2RHcEJoSzhCYWlnQ0FHdEJFQ0FCYTNZZ0FDQUNRZXdkYkdwQnlLOEJhaUFCUVFKMGFpZ0NBR29pQVNBQVFZU3ZBV29nQWtIc0hXeHFLQUlBVHdSL1FRQUZJQUVMUVFGMGFnc2lBUzRCQUVHQUFrY0VRQThMQlNBQUtBSVFJZ0VnQkVFQmFtb3RBQUJCQ0hRZ0FTQUVhaTBBQUVFUWRISWdBU0FFUVFKcWFpMEFBSEpCQ0NBQVFRaHFJZ1VvQWdBaUJtdDJRZjcvQTNFaUFpQUFRWWdCYWlBQUtBS0lBaUlCUVFKMGFpZ0NBRWtFZnlBRElBWWdBRUdNQW1vZ0FrRVFJQUZyZGlJQmFpMEFBR29pQWtFRGRpQUVhallDQUNBRklBSkJCM0UyQWdBZ0FFR01DbW9nQVVFQmRHb0ZBMEFDUUNBQlFRRnFJZ0ZCRDA4RVFFRVBJUUVNQVFzZ0FpQUFRWWdCYWlBQlFRSjBhaWdDQUU4TkFRc0xJQU1nQVNBR2FpSURRUU4ySUFScU5nSUFJQVVnQTBFSGNUWUNBQ0FBUVl3YWFpQUNJQUFnQVVFQ2RHb29Bb1FCYTBFUUlBRnJkaUFBUWNnQmFpQUJRUUowYWlnQ0FHb2lBU0FBS0FLRUFVOEVmMEVBQlNBQkMwRUJkR29MSWdFdUFRQkJqUUpIQkVBUEN3c2dBQkMwQVJvTHNBd0JGMzhDUUNBQUlBQkJ3SzRDYWlnQ0FDSUNRZHdBYkdwQm5LOENhaUlXSUJZb0FnQkJBV28yQWdBZ0FDQUNRZHdBYkdwQjZLNENhaUlKSUFBZ0FrSGNBR3hxUWVTdUFtb2lBeWdDQUNJTU5nSUFJQU1nQUNBQ1Fkd0FiR3BCNEs0Q2FpSURLQUlBSWdvMkFnQWdBeUFBSUFKQjNBQnNha0hzcmdKcUloZ29BZ0FpQkNBQUlBSkIzQUJzYWtIY3JnSnFJZ01vQWdCcklnczJBZ0FnQXlBRU5nSUFJQUJCeUs0Q2FpQUNRZHdBYkdvaUR5Z0NBQ0FFYkNBQUlBSkIzQUJzYWtHZ3J3SnFJaGNvQWdCQkEzUnFJQXNnQUNBQ1Fkd0FiR3BCeks0Q2FpSVFLQUlBYkdvZ0NpQUFJQUpCM0FCc2FrSFFyZ0pxSWhFb0FnQnNhaUFNSUFBZ0FrSGNBR3hxUWRTdUFtb2lFaWdDQUd4cUlBQkJ4SzRDYWlJTktBSUFJQUFnQWtIY0FHeHFRZGl1QW1vaUV5Z0NBR3hxUVFOMlFmOEJjU0FCYXlFRFFRQWdBVUVZZENJT1FSVjFJZ0ZySVFnZ0FDQUNRZHdBYkdwQjhLNENhaUlVSUJRb0FnQWdEa0dBZ0lCL1NnUi9JQUVGSUFnTGFqWUNBRUVBSUFFZ0JHc2lDR3NoQnlBQUlBSkIzQUJzYWtIMHJnSnFJZzRnQ0VGL1NnUi9JQWdGSUFjTElBNG9BZ0JxTmdJQVFRQWdCQ0FCYWlJSWF5RUhJQUFnQWtIY0FHeHFRZml1QW1vaUJDQUlRWDlLQkg4Z0NBVWdCd3NnQkNnQ0FHbzJBZ0JCQUNBQklBdHJJZ2RySVFVZ0FDQUNRZHdBYkdwQi9LNENhaUlJSUFkQmYwb0VmeUFIQlNBRkN5QUlLQUlBYWpZQ0FFRUFJQXNnQVdvaUIyc2hCU0FBSUFKQjNBQnNha0dBcndKcUlnc2dCMEYvU2dSL0lBY0ZJQVVMSUFzb0FnQnFOZ0lBUVFBZ0FTQUtheUlGYXlFR0lBQWdBa0hjQUd4cVFZU3ZBbW9pQnlBRlFYOUtCSDhnQlFVZ0Jnc2dCeWdDQUdvMkFnQkJBQ0FLSUFGcUlnVnJJUVlnQUNBQ1Fkd0FiR3BCaUs4Q2FpSUtJQVZCZjBvRWZ5QUZCU0FHQ3lBS0tBSUFhallDQUVFQUlBRWdER3NpQldzaEJpQUFJQUpCM0FCc2FrR01yd0pxSWd3Z0JVRi9TZ1IvSUFVRklBWUxJQXdvQWdCcU5nSUFRUUFnQ1NnQ0FDQUJhaUlKYXlFR0lBQWdBa0hjQUd4cVFaQ3ZBbW9pQlNBSlFYOUtCSDhnQ1FVZ0Jnc2dCU2dDQUdvMkFnQkJBQ0FCSUEwb0FnQnJJZ1pySVJVZ0FDQUNRZHdBYkdwQmxLOENhaUlKSUFaQmYwb0VmeUFHQlNBVkN5QUpLQUlBYWpZQ0FFRUFJQTBvQWdBZ0FXb2lBV3NoRlNBQUlBSkIzQUJzYWtHWXJ3SnFJZ1lnQVVGL1NnUi9JQUVGSUJVTElBWW9BZ0JxTmdJQUlCZ2dBeUFYS0FJQWEwRVlkRUVZZFNJQU5nSUFJQTBnQURZQ0FDQVhJQU0yQWdBZ0ZpZ0NBRUVmY1EwQUlCUW9BZ0FoQWlBVVFRQTJBZ0FnRGlnQ0FDSUJJQUpKSWdCRkJFQWdBaUVCQ3lBT1FRQTJBZ0FnQkNnQ0FDSUNJQUZKSWcwRVFDQUNJUUVMSUEwRVFFRUNJUUFMSUFSQkFEWUNBQ0FJS0FJQUlnSWdBVWtpQkFSQUlBSWhBUXNnQkFSQVFRTWhBQXNnQ0VFQU5nSUFJQXNvQWdBaUFpQUJTU0lFQkVBZ0FpRUJDeUFFQkVCQkJDRUFDeUFMUVFBMkFnQWdCeWdDQUNJQ0lBRkpJZ1FFUUNBQ0lRRUxJQVFFUUVFRklRQUxJQWRCQURZQ0FDQUtLQUlBSWdJZ0FVa2lCQVJBSUFJaEFRc2dCQVJBUVFZaEFBc2dDa0VBTmdJQUlBd29BZ0FpQWlBQlNTSUVCRUFnQWlFQkN5QUVCRUJCQnlFQUN5QU1RUUEyQWdBZ0JTZ0NBQ0lDSUFGSklnUUVRQ0FDSVFFTElBUUVRRUVJSVFBTElBVkJBRFlDQUNBSktBSUFJZ0lnQVVraUJFVUVRQ0FCSVFJTElBUUVRRUVKSVFBTElBbEJBRFlDQUNBR0tBSUFJQUpKQkVCQkNpRUFDeUFHUVFBMkFnQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQkFXc09DZ0FCQWdNRUJRWUhDQWtLQ3lBUEtBSUFJZ0JCYjB3TkNpQVBJQUJCZjJvMkFnQU1DZ3NnRHlnQ0FDSUFRUkJPRFFrZ0R5QUFRUUZxTmdJQURBa0xJQkFvQWdBaUFFRnZUQTBJSUJBZ0FFRi9hallDQUF3SUN5QVFLQUlBSWdCQkVFNE5CeUFRSUFCQkFXbzJBZ0FNQndzZ0VTZ0NBQ0lBUVc5TURRWWdFU0FBUVg5cU5nSUFEQVlMSUJFb0FnQWlBRUVRVGcwRklCRWdBRUVCYWpZQ0FBd0ZDeUFTS0FJQUlnQkJiMHdOQkNBU0lBQkJmMm8yQWdBTUJBc2dFaWdDQUNJQVFSQk9EUU1nRWlBQVFRRnFOZ0lBREFNTElCTW9BZ0FpQUVGdlRBMENJQk1nQUVGL2FqWUNBQXdDQ3lBVEtBSUFJZ0JCRUU0TkFTQVRJQUJCQVdvMkFnQU1BUXNnQTBIL0FYRVBDeUFEUWY4QmNRdXRJQUlqZndGK0lBQkJ1SmdCYWlJWkxBQUFCRUFnQUNBQUtBSmtOZ0pnSUFCQnNKZ0JhaUlCSVFrZ0FTa0RBQ0VsQlNBQlJRUkFJQUJCaEFGcVFRQkJuSlVCRUZRYUlBQkJ4QUJxSWdkQ0FEY0NBQ0FIUWdBM0FnZ2dCMElBTndJUUlBZENBRGNDR0NBSFFRQTJBaUFnQUVHZ2xnRnFJQUJCek0wRGFpZ0NBQ0lIUVlDQWdBSkpCSDhnQndWQmdJQ0FBZ3NnQUVIUXpRTnFLQUlBY1RZQ0FBc2dBRUVBTmdJNElBQkJBRFlDQ0NBQVFRUnFJZ2xCQURZQ0FDQUFRY0NZQVdwQ0FEY0RBQ0FBUWVnQWFpSUVRZ0EzQXdBZ0JFSUFOd01JSUFSQ0FEY0RFQ0FFUVFBMkFoZ2dBRUh3QUdvaUJrRi9OZ0lBSUFGRkJFQWdBRUhBcmdKcVFRQTJBZ0FnQUVIRXJnSnFRUUEyQWdBZ0FFRzRyZ0pxUVFBMkFnQWdBRUc4cmdKcVFRRTJBZ0FnQUVISXJnSnFRUUJCOEFJUVZCb2dBRUdFcndGcVFRQkJ0UDhBRUZRYUlBQkJ6TXdEYWtFQU9nQUFJQUJCdE1rRGFrRUFRWlFERUZRYUlBQkJzTWtEYWtFQ05nSUFJQUJCeU13RGFrRUFOZ0lBQ3lBQUlBRVFnd0VnQkNnQ0FDSUhJQWtvQWdBaUEyc2lBa0VBU0FSQUR3c2dCaUFBUWZnQWFpSUZLQUlBSUFOcklBWW9BZ0JxTmdJQUlBTkJnSUFCU2dSQUlBSkJBRW9FUUNBQUtBSVFJZ2NnQnlBRGFpQUNFRjBhQ3lBSlFRQTJBZ0FnQkNBQ05nSUFJQUloQndzZ0IwR0FnQUpHQkVCQkFDRUNRWUNBQWlFSEJTQUFLQUlBSUFBb0FoQWdCMnBCZ0lBQ0lBZHJFRjRoQWlBRUtBSUFJZ2NnQW1vaEF5QUNRUUJLQkVBZ0JDQUROZ0lBSUFNaEJ3c0xJQUJCN0FCcUlnTWdCMEZpYWlJRU5nSUFJQVVnQ1NnQ0FDSUhOZ0lBSUFkQmYyb2dCaWdDQUNJSGFpRUZJQWRCZjBjRVFDQURJQVFnQlVnRWZ5QUVCU0FGQ3pZQ0FBc2dBa0YvUmdSQUR3c2dBVVVFUUNBQUVMUUJSUVJBRHdzTElBQkJzSmdCYWlJQktRTUFRbjk4SVNVZ0FTQWxOd01BSUFFaENRc0NRQ0FsUW45VkJFQWdBRUhRelFOcUlSQWdBRUhnQUdvaEJ5QUFRUVJxSVFvZ0FFSG9BR29oRXlBQVFmZ0FhaUVYSUFCQjhBQnFJUlVnQUVFUWFpRVVJQUJCN0FCcUlSZ2dBRUhrQUdvaEFTQUFRYml1QW1vaEdpQUFRUWhxSVFzZ0FFR0lBbW9oR3lBQVFhU1dBV29oRGlBQVFmUWZhaUVjSUFCQjFBQnFJUTBnQUVIY0FHb2hFU0FBUWRnQWFpRVNJQUJCOEI1cUlSMGdBRUhNMndCcUlSNGdBRUhJMmdCcUlSOGdBRUhNelFOcUlTQWdBRUdFQVdvaElTQUFRY0N1QW1vaEZpQUFRYnl1QW1vaElpQUFRYm1ZQVdvaEl5QUFRYnFZQVdvaEpBTkFBa0FnQnlBSEtBSUFJQkFvQWdBaUFuRWlCVFlDQUNBS0tBSUFJZ1FnRXlnQ0FDSURRV0pxU2dSQUlBTWdCR3NpQWtFQVNBMEVJQlVnRnlnQ0FDQUVheUFWS0FJQWFqWUNBQ0FFUVlDQUFVb0VRQ0FDUVFCS0JFQWdGQ2dDQUNJRElBTWdCR29nQWhCZEdnc2dDa0VBTmdJQUlCTWdBallDQUFVZ0F5RUNDeUFDUVlDQUFrWUVRRUVBSVFOQmdJQUNJUUlGSUFBb0FnQWdGQ2dDQUNBQ2FrR0FnQUlnQW1zUVhpRURJQk1vQWdBaUFpQURhaUVGSUFOQkFFb0VRQ0FUSUFVMkFnQWdCU0VDQ3dzZ0dDQUNRV0pxSWdRMkFnQWdGeUFLS0FJQUlnSTJBZ0FnQWtGL2FpQVZLQUlBSWdKcUlRVWdBa0YvUndSQUlCZ2dCQ0FGU0FSL0lBUUZJQVVMTmdJQUN5QURRWDlHRFFRZ0J5Z0NBQ0VGSUJBb0FnQWhBZ3NnQVNnQ0FDSUdJQVZHSUFZZ0JXc2dBbkZCalFKTGNrVUVRQ0FrUVFFNkFBQWdBQ2dDQUNFRUlBNG9BZ0FnQm1vaEF5QUZJQVpKQkVBZ0JDQURJQUpCQUNBR2EzRVFaU0FBS0FJQUlBNG9BZ0FnQnlnQ0FCQmxJQ05CQVRvQUFBVWdCQ0FESUFVZ0Jtc1FaUXNnQVNBSEtBSUFJZ1UyQWdBZ0dTd0FBQTBCQ3dKQUFrQWdHaWdDQUFSQUlBQWdGaWdDQUNJR1Fld2RiR3BCaUxBQmFpZ0NBQ0VDSUJRb0FnQWlBeUFLS0FJQUlnUkJBV3BxTFFBQVFRaDBJQU1nQkdvdEFBQkJFSFJ5SUFNZ0JFRUNhbW90QUFCeVFRZ2dDeWdDQUNJRGEzWkIvdjhEY1NJRklBQWdCa0hzSFd4cVFZaXZBV29nQWtFQ2RHb29BZ0JKQkg4Z0NpQURJQUFnQmtIc0hXeHFRWXl3QVdvZ0JVRVFJQUpyZGlJRGFpMEFBR29pQWtFRGRpQUVhallDQUNBTElBSkJCM0UyQWdBZ0FDQUdRZXdkYkdwQmpMZ0JhaUFEUVFGMGFnVURRQUpBSUFKQkFXb2lBa0VQVHdSQVFROGhBZ3dCQ3lBRklBQWdCa0hzSFd4cVFZaXZBV29nQWtFQ2RHb29BZ0JQRFFFTEN5QUtJQUlnQTJvaUEwRURkaUFFYWpZQ0FDQUxJQU5CQjNFMkFnQWdBQ0FHUWV3ZGJHcEJqTWdCYWlBRklBQWdCa0hzSFd4cUlBSkJBblJxUVlTdkFXb29BZ0JyUVJBZ0FtdDJJQUFnQmtIc0hXeHFRY2l2QVdvZ0FrRUNkR29vQWdCcUlnSWdBRUdFcndGcUlBWkI3QjFzYWlnQ0FFOEVmMEVBQlNBQ0MwRUJkR29MSWdJdUFRQWlBa0dBQWtZRVFDQUFFTFFCRFFJTUJ3VWdBQ0FDUWYvL0EzRVFnd1FoQlNBT0tBSUFJUU1nQnlBSEtBSUFJZ0pCQVdvMkFnQWdBeUFDYWlBRk9nQUFJQllnRmlnQ0FFRUJhaUlDSUNJb0FnQkdCSDlCQUFVZ0FnczJBZ0FnQ1NBSktRTUFRbjk4SWlVM0F3QUxCU0FVS0FJQUlnZ2dDaWdDQUNJTVFRRnFhaTBBQUVFSWRDQUlJQXhxTFFBQVFSQjBjaUFJSUF4QkFtcHFMUUFBY2tFSUlBc29BZ0FpQTJ0MlFmNy9BM0VpQmlBQVFZZ0JhaUFiS0FJQUlnSkJBblJxS0FJQVNRUi9JQW9nQXlBQVFZd0NhaUFHUVJBZ0FtdDJJZ1JxTFFBQWFpSUNRUU4ySUF4cUlnTTJBZ0FnQ3lBQ1FRZHhJZ0kyQWdBZ0FFR01DbW9nQkVFQmRHb0ZBMEFDUUNBQ1FRRnFJZ0pCRDA4RVFFRVBJUVFNQVFzZ0JpQUFRWWdCYWlBQ1FRSjBhaWdDQUU4TkFTQUNJUVFMQ3lBS0lBUWdBMm9pQWtFRGRpQU1haUlETmdJQUlBc2dBa0VIY1NJQ05nSUFJQUJCakJwcUlBWWdBQ0FFUVFKMGFpZ0NoQUZyUVJBZ0JHdDJJQUJCeUFGcUlBUkJBblJxS0FJQWFpSUVJQ0VvQWdCUEJIOUJBQVVnQkF0QkFYUnFDeUlFTGdFQUlnUkIvLzhEY1VHQUFrZ0VRQ0FPS0FJQUlRSWdCeUFGUVFGcU5nSUFJQUlnQldvZ0JEb0FBQ0FKSUFrcEF3QkNmM3dpSlRjREFBd0RDeUFFUWYvL0EzRWhCaUFFUWYvL0EzRkJqUUpLQkVBZ0JrSHlmV29pQkVIUk1Hb3RBQUJCQTJvaEJTQUVRZTB3YWkwQUFDRUVJQVpCNm4xcVFSUkpCRUFnQ0NBRFFRRnFhaTBBQUVFSWRDQUlJQU5xTFFBQVFSQjBjaUFJSUFOQkFtcHFMUUFBY2tFSUlBSnJka0gvL3dOeFFSQWdCR3QySUFWcUlRVWdDaUFDSUFScUlnSkJBM1lnQTJvaUJEWUNBQ0FMSUFKQkIzRWlBellDQUFVZ0F5RUVJQUloQXdzZ0NDQUVRUUZxYWkwQUFFRUlkQ0FJSUFScUxRQUFRUkIwY2lBSUlBUkJBbXBxTFFBQWNrRUlJQU5yZGtIKy93TnhJZ3dnQUVIMEhtb2dIQ2dDQUNJQ1FRSjBhaWdDQUVrRWZ5QUtJQU1nQUVINEgyb2dERUVRSUFKcmRpSUdhaTBBQUdvaUFrRURkaUFFYWlJRE5nSUFJQXNnQWtFSGNTSUNOZ0lBSUFCQitDZHFJQVpCQVhScUJRTkFBa0FnQWtFQmFpSUNRUTlQQkVCQkR5RUdEQUVMSUF3Z0FFSDBIbW9nQWtFQ2RHb29BZ0JQRFFFZ0FpRUdDd3NnQ2lBR0lBTnFJZ0pCQTNZZ0JHb2lBellDQUNBTElBSkJCM0VpQWpZQ0FDQUFRZmczYWlBTUlBQWdCa0VDZEdwQjhCNXFLQUlBYTBFUUlBWnJkaUFBUWJRZmFpQUdRUUowYWlnQ0FHb2lCQ0FkS0FJQVR3Ui9RUUFGSUFRTFFRRjBhZ3NpQkM4QkFDSU1RUUowUWN3WmFpZ0NBRUVCYWlFRUlBeEJpVEZxTFFBQUlRWWdERUY4YWtFc1NRUkFJQWdnQTBFQmFtb3RBQUJCQ0hRZ0NDQURhaTBBQUVFUWRISWdDQ0FEUVFKcWFpMEFBSEpCQ0NBQ2EzWkIvLzhEY1VFUUlBWnJkaUFFYWlFRUlBb2dBaUFHYWlJQ1FRTjJJQU5xTmdJQUlBc2dBa0VIY1RZQ0FBc2dCQ0lDUWY4L1N5RUdJQUpCLy84UFN3Ui9RUUlGUVFFTElRUWdEU0FOS0FJQUlnTkJBV28yQWdBZ0FFSEVBR29nQTBFRGNVRUNkR29nQWpZQ0FDQVJJQUkyQWdBZ0VpQUdCSDhnQkFWQkFBc2dCV29pQXpZQ0FDQUpJQWtwQXdBZ0E2MTlOd01BSUFBZ0F5QUNFSFlNQWdzQ1FBSkFBa0FnQkVHQUFtc09EZ0VDQWdJQ0FnSUNBZ0lDQWdJQUFnc2dBQkMwQVEwRERBZ0xJQklvQWdBaEJTQVJLQUlBSVFNZ0RTQU5LQUlBSWdKQkFXbzJBZ0FnQUVIRUFHb2dBa0VEY1VFQ2RHb2dBellDQUNBUklBTTJBZ0FnRWlBRk5nSUFJQWtnQ1NrREFDQUZyWDAzQXdBZ0FDQUZJQU1RZGd3Q0N5QUVRZi8vQTNGQmhRSk9CRUFnQmtIN2ZXb2lCVUhCTVdvdEFBQWhCQ0FGUWJreGFpMEFBRUVCYWlBSUlBTkJBV3BxTFFBQVFRaDBJQWdnQTJvdEFBQkJFSFJ5SUFnZ0EwRUNhbW90QUFCeVFRZ2dBbXQyUWYvL0EzRkJFQ0FFYTNacUlRVWdDaUFDSUFScUlnSkJBM1lnQTJvMkFnQWdDeUFDUVFkeE5nSUFJQTBnRFNnQ0FDSUNRUUZxTmdJQUlBQkJ4QUJxSUFKQkEzRkJBblJxSUFVMkFnQWdFU0FGTmdJQUlCSkJBallDQUNBSklBa3BBd0JDZm53M0F3QWdCeWdDQUNJR0lBVnJJZ1FnSUNnQ0FFSC9YMm9pQWtrZ0JpQUNTWEVFUUNBT0tBSUFJZ0lnQkdvaEF5QUhJQVpCQW1vMkFnQWdBaUFHYWlJQ0lBTXNBQUE2QUFBZ0FpQURMQUFCT2dBQkJTQU9LQUlBSWdJZ0Jtb2dBaUFFSUJBb0FnQnhhaXdBQURvQUFDQUhJQWNvQWdCQkFXb2dFQ2dDQUNJRmNTSUROZ0lBSUE0b0FnQWlBaUFEYWlBQ0lBUkJBV29nQlhGcUxBQUFPZ0FBSUFjZ0J5Z0NBRUVCYWlBUUtBSUFjVFlDQUFzTUFnc2dBRUhFQUdvZ0RTZ0NBQ0lNSUFaclFRTnhRUUowYWlnQ0FDRVBJQWdnQTBFQmFtb3RBQUJCQ0hRZ0NDQURhaTBBQUVFUWRISWdDQ0FEUVFKcWFpMEFBSEpCQ0NBQ2EzWkIvdjhEY1NJRUlBQkJ6Tm9BYWlBZUtBSUFJZ1ZCQW5ScUtBSUFTUVIvSUFvZ0FpQUFRZERiQUdvZ0JFRVFJQVZyZGlJRmFpMEFBR29pQWtFRGRpQURhaUlETmdJQUlBc2dBa0VIY1NJQ05nSUFJQUJCME9NQWFpQUZRUUYwYWdVRFFBSkFJQVZCQVdvaUJVRVBUd1JBUVE4aEJRd0JDeUFFSUFCQnpOb0FhaUFGUVFKMGFpZ0NBRThOQVFzTElBb2dCU0FDYWlJQ1FRTjJJQU5xSWdNMkFnQWdDeUFDUVFkeElnSTJBZ0FnQUVIUTh3QnFJQVFnQUNBRlFRSjBha0hJMmdCcUtBSUFhMEVRSUFWcmRpQUFRWXpiQUdvZ0JVRUNkR29vQWdCcUlnVWdIeWdDQUU4RWYwRUFCU0FGQzBFQmRHb0xJZ1V2QVFBaUJrSFJNR290QUFCQkFtb2hCU0FHUWUwd2FpMEFBQ0VFSUFaQmVHcEJGRWtFUUNBSUlBTkJBV3BxTFFBQVFRaDBJQWdnQTJvdEFBQkJFSFJ5SUFnZ0EwRUNhbW90QUFCeVFRZ2dBbXQyUWYvL0EzRkJFQ0FFYTNZZ0JXb2hCU0FLSUFJZ0JHb2lBa0VEZGlBRGFqWUNBQ0FMSUFKQkIzRTJBZ0FMSUFVaEFpQVBRWUFDU3dSQUlBOUIvejlMSVFVZ0QwSC8vdzlMQkg5QkF3VkJBZ3NoQXlBQ0lBVUVmeUFEQlVFQkMyb2hBZ3NnRFNBTVFRRnFOZ0lBSUFCQnhBQnFJQXhCQTNGQkFuUnFJQTgyQWdBZ0VTQVBOZ0lBSUJJZ0FqWUNBQ0FKSUFrcEF3QWdBcTE5TndNQUlBQWdBaUFQRUhZTUFRc01BUXNnQ1NrREFDRWxDeUFsUW45VkRRRU1Bd3NMRHdVZ0FFSGdBR29oQnlBQVFlUUFhaUVCQ3dzZ0FCQ0NCQ0FIS0FJQUlnUWdBU2dDQUNJR1J3UkFJQUJCdXBnQmFrRUJPZ0FBQ3lBQUtBSUFJUVVnQUVHa2xnRnFJZ0lvQWdBZ0Jtb2hBeUFFSUFaSkJFQWdCU0FESUFCQjBNMERhaWdDQUVFQUlBWnJjUkJsSUFBb0FnQWdBaWdDQUNBSEtBSUFFR1VnQUVHNW1BRnFRUUU2QUFBRklBVWdBeUFFSUFackVHVUxJQUVnQnlnQ0FEWUNBQXY1Q3dFS2Z3SkFBa0FnQUVIb3JnRnFRUUEyQWdBZ0FFRUVhaUlGRUZnaEFRSkFJQUJCOEs0QmFpSURLQUlBUVFKR0JFQWdCVUVCRUZVZ0FVSC8vd0ZOQkVBZ0EwRUFOZ0lBSUFGQkFYUWhBUXdDQ3d3REN3c2dBVUVJZGlFRUlBQkI1SzRCYWlFR0lBQkIySzRCYWlJSEtBSUFRU1ZKQkg5QkFDRUJBMEFnQVVFQ2RFSDhFbW9vQWdBaENDQUJRUUZxSVFKQmdINGdBVUVCUmlJS0JIOGdCaWdDQUVFRGFnVWdBVUVDZEVHNEUyb29BZ0FMSWdsMUlBZ2dCSE54QkVBZ0FpRUJEQUVMQ3lBRklBb0VmeUFHS0FJQVFRTnFCU0FCUVFKMFFiZ1RhaWdDQUFzaUFoQlZJQUVGUVFBaEFRTkFJQUZCQW5SQitCTnFLQUlBSVFnZ0FVRUJhaUVDUVlCK0lBRkJBMFlpQ2dSL0lBWW9BZ0JCQTJvRklBRkJBblJCdEJScUtBSUFDeUlKZFNBSUlBUnpjUVJBSUFJaEFRd0JDd3NnQlNBS0JIOGdCaWdDQUVFRGFnVWdBVUVDZEVHMEZHb29BZ0FMSWdJUVZTQUJDeUlDUVFoTkJFQWdBMEVBTmdJQUlBY2dCeWdDQUNBQ2FpSUJJQUZCQkhack5nSUFRWUFnSUFVUVdFSHcvd054SWdaTEJIOGdCVUVGRUZWQkJTRUJRUUFGUVFVaEFVRUFJUU1EUUNBQlFRRnFJUUVnQTBFQmFpSUVRUUowUWJBV2FpZ0NBQ0FHVFFSQUlBUWhBd3dCQ3dzZ0JTQUJFRlVnQTBFQ2RFR3dGbW9vQWdBTElRTWdBRUhLbkFGcUlBWWdBMnRCRUNBQmEzWWdBVUVDZEVIUUZtb29BZ0JxUWY4QmNTSUJRUUYwYWlJRkxnRUFJUU1nQUNBQlFRRjBha0hJbkFGcUlRUWdBUVJBSUFVZ0JDNEJBRHNCQUNBRUlBTTdBUUFMSUFCQjFBQnFJZ0VvQWdBaEJDQUJJQVJCQVdvMkFnQWdBRUhFQUdvZ0JFRUNkR29nQTBILy93TnhRUUZxSWdNMkFnQWdBU0FCS0FJQVFRTnhOZ0lBSUFBZ0FrRUNhaUlCTmdKWURBRUxJQUpCQ1VZRVFDQURJQU1vQWdCQkFXbzJBZ0FNQWdzZ0EwRUFOZ0lBSUFKQkRrWUVRRUdBd0FJZ0JSQllRZkQvQTNFaUJFc0VmeUFGUVFNUVZVRURJUUZCQUFWQkF5RUJRUUFoQWdOQUlBRkJBV29oQVNBQ1FRRnFJZ05CQW5SQjlCUnFLQUlBSUFSTkJFQWdBeUVDREFFTEN5QUZJQUVRVlNBQ1FRSjBRZlFVYWlnQ0FBc2hBaUFCUVFKMFFad1ZhaWdDQUVFRmFpQUVJQUpyUVJBZ0FXdDJhaUVCSUFVUVdFRUJka0dBZ0FKeUlRTWdCVUVQRUZVZ0FDQUJOZ0pZREFFTElBQkJ4QUJxUVFFZ0Ftc2dBRUhVQUdvaUNTZ0NBR3BCQTNGQkFuUnFLQUlBSVFkQmdJQUNJQVVRV0VIdy93TnhJZ2hMQkg4Z0JVRUNFRlZCQWlFQlFRQUZRUUloQVVFQUlRTURRQ0FCUVFGcUlRRWdBMEVCYWlJRVFRSjBRZEFWYWlnQ0FDQUlUUVJBSUFRaEF3d0JDd3NnQlNBQkVGVWdBMEVDZEVIUUZXb29BZ0FMSVFNZ0FrRUtSaUFJSUFOclFSQWdBV3QySUFGQkFuUkIvQlZxS0FJQWFpSUJRUUpxSWdKQmdRSkdjUVJBSUFZZ0JpZ0NBRUVCY3pZQ0FBOExJQUZCQTJvaEFTQUhRWUFDU3dSL0lBRUZJQUlMSUFjZ0FFR0Fyd0ZxS0FJQVQyb2hBU0FKSUFrb0FnQWlBa0VCYWpZQ0FDQUFRY1FBYWlBQ1FRSjBhaUFITmdJQUlBa2dDU2dDQUVFRGNUWUNBQ0FBSUFFMkFsZ2dBQ0FITmdKY0lBQkJzSmdCYWlJQ0lBSXBBd0FnQWExOU53TUFJQUZGQkVBUEN5QUFRYVNXQVdvaEJDQUFRZUFBYWlJREtBSUFJUUlnQUVIUXpRTnFJZ1VvQWdBaEFBTkFJQVFvQWdBaUJpQUNhaUFHSUFJZ0Iyc2dBSEZxTEFBQU9nQUFJQU1nQXlnQ0FFRUJhaUFGS0FJQUlnQnhJZ0kyQWdBZ0FVRi9haUlCRFFBTER3c2dBQ0FETmdKY0lBQkJzSmdCYWlJQ0lBSXBBd0FnQWExOU53TUFJQUZGQkVBUEN5QUFRYVNXQVdvaEJTQUFRZUFBYWlJRUtBSUFJUUlnQUVIUXpRTnFJZ1lvQWdBaEFBTkFJQVVvQWdBaUJ5QUNhaUFISUFJZ0Eyc2dBSEZxTEFBQU9nQUFJQVFnQkNnQ0FFRUJhaUFHS0FJQUlnQnhJZ0kyQWdBZ0FVRi9haUlCRFFBTER3c2dBQ2dDWENFRUlBQkJzSmdCYWlJQklBRXBBd0FnQUNnQ1dDSUJyWDAzQXdBZ0FVVUVRQThMSUFCQnBKWUJhaUVGSUFCQjRBQnFJZ01vQWdBaEFpQUFRZEROQTJvaUJpZ0NBQ0VBQTBBZ0JTZ0NBQ0lISUFKcUlBY2dBaUFFYXlBQWNXb3NBQUE2QUFBZ0F5QURLQUlBUVFGcUlBWW9BZ0FpQUhFaUFqWUNBQ0FCUVg5cUlnRU5BQXNMeGcwQ0RuOERmaUFCUlFSQUlBQkJoQUZxUVFCQm5KVUJFRlFhSUFCQnhBQnFJZ0pDQURjQ0FDQUNRZ0EzQWdnZ0FrSUFOd0lRSUFKQ0FEY0NHQ0FDUVFBMkFpQWdBRUdnbGdGcUlBQkJ6TTBEYWlnQ0FDSUNRWUNBZ0FKSkJIOGdBZ1ZCZ0lDQUFnc2dBRUhRelFOcUtBSUFjVFlDQUFzZ0FFRUFOZ0k0SUFCQkFEWUNDQ0FBUVFScUlneEJBRFlDQUNBQVFjQ1lBV3BDQURjREFDQUFRZWdBYWlJSFFnQTNBd0FnQjBJQU53TUlJQWRDQURjREVDQUhRUUEyQWhnZ0FFSHdBR29pQ1VGL05nSUFJQUVFUUNBQVFRRVFnd0VGSUFCQndLNENha0VBTmdJQUlBQkJ4SzRDYWtFQU5nSUFJQUJCdUs0Q2FrRUFOZ0lBSUFCQnZLNENha0VCTmdJQUlBQkJ5SzRDYWtFQVFmQUNFRlFhSUFCQmhLOEJha0VBUWJUL0FCQlVHaUFBUWN6TUEycEJBRG9BQUNBQVFiVEpBMnBCQUVHVUF4QlVHaUFBUWJESkEycEJBallDQUNBQVFjak1BMnBCQURZQ0FDQUFRUUFRZ3dFZ0FFSFVyZ0ZxSWdKQ0FEY0NBQ0FDUWdBM0FnZ2dBa0lBTndJUUlBQkIwSzRCYWtHQTZnQTJBZ0FnQUVHQXJ3RnFRWUhBQURZQ0FDQUFRZnl1QVdwQmdBRTJBZ0FnQUVINHJnRnFRWUFCTmdJQUN5QUFRZlN1QVdvaUNrRUFOZ0lBSUFCQnpLNEJhaUlPUVFBMkFnQWdBRUhzcmdGcUlndEJBRFlDQUNBQVFmQ3VBV3BCQURZQ0FDQUhRUUEyQWdBZ0RDZ0NBQ0lDUVFCTUJFQWdDU0FBUWZnQWFpSUZLQUlBSUFKcklBa29BZ0JxTmdJQUlBQW9BZ0FnQUNnQ0VFR0FnQUlRWGlFR0lBY29BZ0FpQWlBR2FpRURJQVpCQUVvRVFDQUhJQU0yQWdBZ0F5RUNDeUFBUWV3QWFpSURJQUpCWW1vaUJqWUNBQ0FGSUF3b0FnQWlBallDQUNBQ1FYOXFJQWtvQWdBaUFtb2hCU0FDUVg5SEJFQWdBeUFHSUFWSUJIOGdCZ1VnQlFzMkFnQUxDeUFBUWVBQWFpSUlJQUVFZnlBQUtBSmtCVUVBSVFFRFFDQUFRY3FnQVdvZ0FVRUJkR29nQVVFSWRFSC8vd054SWdJN0FRQWdBRUhLbUFGcUlBRkJBWFJxSUFJN0FRQWdBRUhLbkFGcUlBRkJBWFJxSUFFN0FRQWdBRUhLcEFGcUlBRkJBWFJxUVFBZ0FXdEJDSFE3QVFBZ0FVRUJhaUlCUVlBQ1J3MEFDeUFBUWNxb0FXcEJBRUdBQmhCVUdrRUFJQUJCeXFBQmFpQUFRY3FxQVdvUW53RkJBQXNpQVRZQ0FDQUFRYkNZQVdvaUR5a0RBQ0lTUW45OElSQWdEeUFRTndNQUlCSkNBRlVFUUNBQUVOMEJJQXBCQ0RZQ0FFRVJJUVFGSUJBaEVRc0RRQUpBSUFSQkVVWUVRQ0FQS1FNQUlSRUxJQkZDZjFjTkFDQUlJQWdvQWdBZ0FFSFF6UU5xSWdZb0FnQWlBbkVpQVRZQ0FDQU1LQUlBSWdRZ0J5Z0NBQ0lEUVdKcVNnUkFJQU1nQkdzaUFVRUFTQTBCSUFrZ0FFSDRBR29pQlNnQ0FDQUVheUFKS0FJQWFqWUNBQ0FFUVlDQUFVb0VRQ0FCUVFCS0JFQWdBQ2dDRUNJQ0lBSWdCR29nQVJCZEdnc2dERUVBTmdJQUlBY2dBVFlDQUFVZ0F5RUJDeUFCUVlDQUFrWUVRRUVBSVFKQmdJQUNJUUVGSUFBb0FnQWdBQ2dDRUNBQmFrR0FnQUlnQVdzUVhpRUNJQWNvQWdBaUFTQUNhaUVESUFKQkFFb0VRQ0FISUFNMkFnQWdBeUVCQ3dzZ0FFSHNBR29pQXlBQlFXSnFJZ1EyQWdBZ0JTQU1LQUlBSWdFMkFnQWdBVUYvYWlBSktBSUFJZ0ZxSVFVZ0FVRi9Sd1JBSUFNZ0JDQUZTQVIvSUFRRklBVUxOZ0lBQ3lBQ1FYOUdEUUVnQ0NnQ0FDRUJJQVlvQWdBaEFnc2dBRUhrQUdvaUJTZ0NBQ0lOSUFGR0lBMGdBV3NnQW5GQmpRSkxja1VFUUNBQVFicVlBV3BCQVRvQUFDQUFLQUlBSVFRZ0FFR2tsZ0ZxSWdNb0FnQWdEV29oQmlBQklBMUpCRUFnQkNBR0lBSkJBQ0FOYTNFUVpTQUFLQUlBSUFNb0FnQWdDQ2dDQUJCbElBQkJ1WmdCYWtFQk9nQUFCU0FFSUFZZ0FTQU5heEJsQ3lBRklBZ29BZ0EyQWdBTElBc29BZ0FFUUNBQUVOd0JRUkVoQkF3Q0N5QUtJQW9vQWdBaUFrRi9haUlCTmdJQUlBSkJBVWdFZnlBQUVOMEJJQXBCQnpZQ0FFRUhCU0FCQ3lFQ0lBNGdEaWdDQUNJRFFRRjBJZ0UyQWdBZ0EwR0FBWEVFUUNBQVFmeXVBV29vQWdBZ0FFSDRyZ0ZxS0FJQVN3UkFJQUFRcHdJRklBQVEzQUVMUVJFaEJBd0NDeUFLSUFKQmYybzJBZ0FnQWtFQlNBUkFJQUFRM1FFZ0NrRUhOZ0lBSUE0b0FnQWhBUXNnRGlBQlFRRjBOZ0lBSUFGQmdBRnhSUVJBSUFBUWhRUkJFU0VFREFJTElBQkIvSzRCYWlnQ0FDQUFRZml1QVdvb0FnQkxCRUFnQUJEY0FRVWdBQkNuQWd0QkVTRUVEQUVMQ3lBSUtBSUFJZ1lnQUVIa0FHb2lCU2dDQUNJTFJ3UkFJQUJCdXBnQmFrRUJPZ0FBQ3lBQUtBSUFJUU1nQUVHa2xnRnFJZ0VvQWdBZ0Myb2hBaUFHSUF0SkJFQWdBeUFDSUFCQjBNMERhaWdDQUVFQUlBdHJjUkJsSUFBb0FnQWdBU2dDQUNBSUtBSUFFR1VnQUVHNW1BRnFRUUU2QUFBRklBTWdBaUFHSUF0ckVHVUxJQVVnQ0NnQ0FEWUNBQXZ1Q2dJWWZ3RitJQUJCMUF4cUlna29BZ0FpQWl3QUFDRUxJQUlvQWdRaEFTQUNMUUFCSWdJaEJnSkFJQUpCL3dGeFFSOUlCRUFnQUVISURHb29BZ0FvQWd3aUFnUkFJQUpCQkdvaEF5QUNMZ0VBUVFGR0JFQWdBMEVCYWlJSExRQUFJUUlnQnlBQ1FmOEJjVUVnU0NBQ1FmOEJjV282QUFBZ0F5RUNEQU1MSUFJb0FnZ2lBaXdBQUNBTFJ3UkFBMEFnQWtFSWFpSUhMQUFBSUF0SEJFQWdCeUVDREFFTEN5QUNMUUFKSUFJdEFBRklCRUFnQnlFQ0JTQUhLUUlBSVJrZ0J5QUNLUUlBTndJQUlBSWdHVGNDQUFzTElBSkJBV29pQnkwQUFDSUVRZk1BU0FSQUlBY2dCRUgvQVhGQkFtbzZBQUFnQXlBREx3RUFRUUpxT3dFQUN3VkJBQ0VDQ3dWQkFDRUNDd3NDUUNBQVFlQU1haUlFS0FJQUJFQWdBRUdRbFFGcUlRNGdBRUhnbHdGcUlnTW9BZ0FoQnlBRElBZEJBV28yQWdBZ0J5QUxPZ0FBSUFNb0FnQWlCeUFBUWV5WEFXb29BZ0JKQkVBZ0FRUkFJQWNnQVVrRVFDQUJJUUlGSUFCQkFDQUNFS2dDSWdKRkRRUUxJQVFnQkNnQ0FFRi9haUlCTmdJQUlBRUVRQ0FBUWNnTWFpSURJUWtnQXlnQ0FDRURCU0FESUFNb0FnQWdBRUhRREdvb0FnQWdBRUhJREdvaUNTZ0NBQ0lEUjBFZmRFRWZkV28yQWdBZ0FpSUhJUUlMQlNBSktBSUFJQWMyQWdRZ0FFSElER29pQ1NnQ0FDSUNJUU1MSUFNdkFRQWlCQ0VOQWtBZ0FFSFFER29pRVNnQ0FDSUJJQU5IQkVBZ0FFRzZsUUZxSVJJZ0FFSEFsZ0ZxSVFvZ0FFSEVsZ0ZxSVE4Z0FFSGNER29oRXlBRVFmLy9BM0ZCQTBvaEZDQUdRUUYwSVJWQkFTQUdheUFETHdFRWFpQU5heUVXSUFFaEF3TkFBa0FnQXk0QkFDSUJRZi8vQTNFaENDQUJRUUZHQkVBZ0FFSElsZ0ZxSUJJdEFBQWlCa0VDZEdvaUJDZ0NBQ0lCQkVBZ0JDQUJLQUlBTmdJQUJTQUtJQW9vQWdBaUFTQUFRWlNWQVdvZ0Jtb2lCUzBBQUVFRWRHb2lCRFlDQUNBRUlBOG9BZ0JMQkVBZ0NpQUVJQVV0QUFCQkJIUnJOZ0lBSUE0Z0JoQ2dBU0VCQ3dzZ0FVVU5CeUFCSUFOQkJHb2lCaWtDQURjQ0FDQURJQUUyQWdnZ0FVRUJhaUlFTFFBQUlnVkJBWFJCL3dGeElRRWdCQ0FGUWY4QmNVRWVTQVIvSUFFRlFmZ0FJZ0VMT2dBQUlBWWdFeWdDQUNBVWFpQUJRZjhCY1dvaUFUc0JBQ0FEUVFScUlRWUZBa0FnQ0VFQmNVVUVRQ0FEUVFocUlnUW9BZ0FoQmlBQUlBaEJBWFlpQldwQnVaVUJhaXdBQUNJWElBQkJ1cFVCYWlBRmFpd0FBQ0lCUmdSQUlBWkZEUW9NQWdzZ0FFSElsZ0ZxSUFGQi93RnhJaEJCQW5ScUlnd29BZ0FpQVFSQUlBd2dBU2dDQURZQ0FBVWdDaUFLS0FJQUlnRWdBRUdVbFFGcUlCQnFJaGd0QUFCQkJIUnFJZ3cyQWdBZ0RDQVBLQUlBU3dSQUlBb2dEQ0FZTFFBQVFRUjBhellDQUNBT0lCQVFvQUVoQVFzTElBRkZEUU1nQVNBR0lBVkJCSFFRVXhvZ0JpQUFRY2lXQVdvZ0YwSC9BWEZCQW5ScUlnVW9BZ0EyQWdBZ0JTQUdOZ0lBSUFRZ0FUWUNBQXNMSUFoQkFuUWdEVTBnQ0VFRGRDQURRUVJxSWdZdkFRQWlBVTl4UVFGMElBaEJBWFFnRFVseUlBRnFJUUVnQmlBQk93RUFDeUFCUWYvL0EzRWlCVUVHYWlBVmJDSUVJQllnQldvaUJVRUdiRWtFUUNBRUlBVkxCSDlCQWdWQkFRc2dCQ0FGUVFKMFQyb2hCVUVESVFRRklBUWdCVUVKYkU4RWYwRUZCVUVFQ3lBRUlBVkJER3hQYWlBRUlBVkJEMnhQYWlJRUlRVUxJQVlnQkNBQmFqc0JBQ0FES0FJSUlnRWdDRUVEZEdvZ0J6WUNCQ0FCSUFoQkEzUnFJQXM2QUFBZ0FTQUlRUU4wYWlBRk9nQUJJQU1nQ0VFQmFqc0JBQ0FES0FJTUlnTWdDU2dDQUVjTkFRd0RDd3NnQkVFQU5nSUFEQVFMQ3lBSklBSTJBZ0FnRVNBQ05nSUFEd3NGSUFCQkFTQUNFS2dDSVFJZ0NTZ0NBQ0FDTmdJRUlBQkIwQXhxSUFJMkFnQWdBRUhJREdvZ0FqWUNBQ0FDQkVBUEN3c0xJQUFRM3dFZ0FFSHdGR3BCQURvQUFBdVlCZ0VQZnlNRUlRc2pCRUdBQ0dva0JDQUFMZ0VBSWdOQi8vOERjU0lNSUFGQjJBeHFJZzhvQWdBaUFtc2hCQ0FEUVlBQ1JnUi9RUUVoQ0NBQlFjSU1hZ1VnQVVFQ2FpQUJJQVJxUWU4T2FpMEFBRUVHZEdvZ0FDZ0NEQzhCQUNBTWF5QUVTa0VDZEdvZ0RFRUxiQ0FBTHdFRVMwRURkR29nQWlBRVNrRUVkR29nQVVIeUZHb3RBQUJCQW5ScUlnSXZBUUFpQXlBQ0xRQUNkaUVGSUFJZ0F5QUZhenNCQUNBRklBVkZhaUVJSUFJTElRa2dBVUdJbFFGcUloQWdDRFlDQUNBQlFmQVVhaUlOTEFBQUlRb2dBQ2dDQ0VGNGFpRUNJQXNpQXlFR0EwQWdBaUVGQTBBZ0FVSHdER29nQlVFSWFpSUNMUUFBYWl3QUFDQUtSZ1JBSUFJaEJRd0JDd3NnQnlBRkxRQUphaUVISUFaQkJHb2hCU0FHSUFJMkFnQWdCRUYvYWlJRUJFQWdCU0VHREFFTEN5QVFJQWdnQjJvaURqWUNBQ0FCUWZpVUFXb29BZ0FnQVVIMGxBRnFLQUlBYXlFRUlBRkIvSlFCYWlJQ0tBSUFJQTV1SVFVZ0FpQUZOZ0lBSUFRZ0JXNGlDQ0FPVGdSQUlBc2tCRUVBRHdzZ0FVR0FsUUZxSVFZZ0NDQUhTQVJBUVFBaEJBVWdCaUFITmdJQUlBRkJoSlVCYWlBT05nSUFJQXdnRHlnQ0FHc2hBaUFCUWZBTWFpQURLQUlBTFFBQWFpQUtPZ0FBSUFKQmYyb2lBZ1JBQTBBZ0FVSHdER29nQTBFRWFpSURLQUlBTFFBQWFpQU5MQUFBT2dBQUlBSkJmMm9pQWcwQUN3c2dDU0FRS0FJQUlBa3ZBUUJxT3dFQUlBOGdBQzhCQURZQ0FDQUxKQVJCQVE4TEEwQWdBMEVFYWlFQ0lBUWdBeWdDQUNJSFFRRnFJZ290QUFBaUJXb2lBeUFJVEFSQUlBTWhCQ0FDSVFNTUFRc0xJQUZCaEpVQmFpQUROZ0lBSUFZZ0JEWUNBQ0FKUVFKcUlnSXNBQUFpQmtIL0FYRkJCMGdFUUNBSlFRTnFJZ1FzQUFCQmYycEJHSFJCR0hVaEF5QUVJQU02QUFBZ0EwVUVRQ0FKSUFrdkFRQkJBWFE3QVFBZ0FpQUdRUUZxT2dBQUlBUkJBeUFHUWY4QmNYUTZBQUFMQ3lBQlFkUU1haUFITmdJQUlBb2dCVUVFYWpvQUFDQUFRUVJxSWdJZ0FpOEJBRUVFYWpzQkFDQUtMUUFBUWZ3QVNnUkFJQUFnQVJEZUFRc2dEU0FOTEFBQVFRRnFPZ0FBSUFGQjZBeHFJQUZCN0F4cUtBSUFOZ0lBSUFza0JFRUJDNmtEQVF4L0lBRkI4aFJxSUFGQjhCSnFJQUZCMUF4cUlnUW9BZ0F0QUFCcUxBQUFJZ0k2QUFBZ0FTQUFRUVJxSWdOQkFXb2lCaTBBQUNJSElnaEJCM1JxUWZRVGFpQUJRZkVVYWlJRkxRQUFJQUpCL3dGeGFpQUJJQUFvQWd3dkFRQnFRZThRYWkwQUFHb2dBVUh3RW1vZ0F5MEFBQ0lKYWkwQUFFRUJkR29nQVVIb0RHb2lDaWdDQUNJTFFScDJRU0J4YWtFQmRHb2hBQ0FCUWZpVUFXb29BZ0FnQVVIMGxBRnFLQUlBYXlFTUlBRkIvSlFCYWlJTktBSUFRUTUySVFJZ0RTQUNOZ0lBSUF3Z0FtNGdBQzhCQUNJQ1NRUkFJQVFnQXpZQ0FDQUdJQWRCQjNaQkFYTWdDR282QUFBZ0FVR0FsUUZxUVFBMkFnQWdBVUdFbFFGcUlBQXZBUUEyQWdBZ0FDQUFMd0VBSWdCQmdBRnFJQUJCSUdwQkIzWnJPd0VBSUFWQkFUb0FBQ0FLSUF0QkFXbzJBZ0FGSUFGQmdKVUJhaUFDTmdJQUlBQWdBQzhCQUNJRElBTkJJR3BCQjNack93RUFJQUZCaEpVQmFrR0FnQUUyQWdBZ0FVSGNER29nQUM4QkFFRUtka0hCTUdvdEFBQTJBZ0FnQVVIWURHcEJBVFlDQUNBQlFmQU1haUFKYWlBQlFmQVVhaXdBQURvQUFDQUZRUUE2QUFBZ0JFRUFOZ0lBQ3d2akJBSU5md0YrSUFGQmlKVUJhaUlNSUFCQkJHb2lCeThCQUNJQ05nSUFJQUFvQWdnaEF5QUJRZmlVQVdvb0FnQWdBVUgwbEFGcUtBSUFheUVGSUFGQi9KUUJhaUlHS0FJQUlBSnVJUVFnQmlBRU5nSUFJQVVnQkc0aUNpQUNUZ1JBUVFBUEN5QUJRWUNWQVdvaENDQUtJQU5CQVdvaUJTMEFBQ0lFU0FSQUlBRkJoSlVCYWlBRU5nSUFJQUZCOFJScUlBUkJBWFFnQWtzaUFqb0FBQ0FCUWVnTWFpSUdJQVlvQWdBZ0FtbzJBZ0FnQVVIVURHb2dBellDQUNBRklBUkJCR29pQXpvQUFDQUhJQWN2QVFCQkJHbzdBUUFnQTBIOEFFc0VRQ0FBSUFFUTNnRUxJQWhCQURZQ0FFRUJEd3NnQVVIVURHb2lDU2dDQUNJTlJRUkFRUUFQQ3lBQlFmRVVha0VBT2dBQUlBQXZBUUJCZjJvaEJnSkFBa0FEUUFKQUlBTkJDR29oQWlBRUlBTkJDV29pQ3kwQUFDSU9haUlGSUFwS0RRQWdCa0YvYWlJR1JRMENJQVVoQkNBQ0lRTU1BUXNMREFFTElBRkI4aFJxSUFGQjhCSnFJQTB0QUFCcUxBQUFPZ0FBSUFnZ0JUWUNBQ0FCUWZBTWFpQUNMUUFBYWlBQlFmQVVhaUlETEFBQU9nQUFJQUZCMkF4cUlBQXZBUUFpQURZQ0FDQUpRUUEyQWdBZ0FFRi9haUVBQTBBZ0FVSHdER29nQWtGNGFpSUNMUUFBYWlBRExBQUFPZ0FBSUFCQmYyb2lBQTBBQ3lBQlFZU1ZBV29nRENnQ0FEWUNBRUVCRHdzZ0FVR0VsUUZxSUFVMkFnQWdDQ0FFTmdJQUlBa2dBallDQUNBTElBNUJCR282QUFBZ0J5QUhMd0VBUVFScU93RUFJQXN0QUFBZ0F5MEFBVXdFUUVFQkR3c2dBaWtDQUNFUElBSWdBeWtDQURjQ0FDQURJQTgzQWdBZ0NTQUROZ0lBSUE5Q0NJaW5RZjhCY1VIOEFFd0VRRUVCRHdzZ0FDQUJFTjRCUVFFTE13QWdBRUlBTndJQUlBQkNBRGNDQ0NBQVFRQTJBaEFnQUVFQU5nSUVJQUJCQURZQ0NDQUFRUUEyQWhRZ0FFRUFOZ0pZQytnTEFRdC9JQUZCQkdvaUNDZ0NBQ0lEUWVML0FVb0VRQ0FCUWVnQWFpSUxLQUlBSUFOcklnbEJBRTRFUUNBQlFmQUFhaUlHSUFGQitBQnFJZ2NvQWdBZ0Eyc2dCaWdDQUdvMkFnQUNRQUpBSUFrRVFDQUJRUkJxSWdRb0FnQWlCU0FGSUFOcUlBa1FYUm9nQ0VFQU5nSUFJQXNnQ1RZQ0FDQUpRWUNBQWtjTkFVR0FnQUloQXdVZ0NFRUFOZ0lBSUF0QkFEWUNBQ0FCUVJCcUlRUU1BUXNNQVFzZ0FTZ0NBQ0FFS0FJQUlBbHFRWUNBQWlBSmF4QmVJUVVnQ3lnQ0FDSURJQVZxSVFRZ0JVRUFTZ1JBSUFzZ0JEWUNBQ0FFSVFNTEN5QUJRZXdBYWlJRklBTkJZbW9pQ3pZQ0FDQUhJQWdvQWdBaUF6WUNBQ0FEUVg5cUlBWW9BZ0FpQkdvaEJ5QUVRWDlIQkVBZ0JTQUxJQWRJQkg4Z0N3VWdCd3MyQWdBTEN3c2dBVUVRYWlJTUtBSUFJUVFnQ0NBRFFRRnFJZ1UyQWdBZ0JDQURhaTBBQUNJTlFTQnhRUUJISWdzRVFDQURRZUgvQVVvRVFDQUJRZWdBYWlJR0tBSUFJQVZySWdwQkFFZ0VRQ0FGSVFNRklBRkI4QUJxSWdrZ0FVSDRBR29pQnlnQ0FDQURRWDl6YWlBSktBSUFhallDQUFKQUFrQWdDZ1JBSUFRZ0JDQUZhaUFLRUYwYUlBaEJBRFlDQUNBR0lBbzJBZ0FnQ2tHQWdBSkdCRUJCZ0lBQ0lRTUZJQXdvQWdBaEJBd0NDd1VnQ0VFQU5nSUFJQVpCQURZQ0FBd0JDd3dCQ3lBQktBSUFJQVFnQ21wQmdJQUNJQXByRUY0aEJTQUdLQUlBSWdNZ0JXb2hCQ0FGUVFCS0JFQWdCaUFFTmdJQUlBUWhBd3NMSUFGQjdBQnFJZ1VnQTBGaWFpSUdOZ0lBSUFjZ0NDZ0NBQ0lETmdJQUlBTkJmMm9nQ1NnQ0FDSUVhaUVISUFSQmYwY0VRQ0FGSUFZZ0IwZ0VmeUFHQlNBSEN6WUNBQXNMQlNBRklRTUxJQXdvQWdBaEJDQUlJQU5CQVdvaUJUWUNBQ0FFSUFOcUxRQUFRUlIwUVlDQVFHc2hDaUFGSVFNRklBQkJrSlVCYWlnQ0FBUkFJQVVoQXdWQkFBOExDeUFOUWNBQWNRUkFJQU5CNHY4QlNnUkFJQUZCNkFCcUlnWW9BZ0FnQTJzaUJVRUFUZ1JBSUFGQjhBQnFJZ2tnQVVINEFHb2lCeWdDQUNBRGF5QUpLQUlBYWpZQ0FBSkFBa0FnQlFSQUlBUWdCQ0FEYWlBRkVGMGFJQWhCQURZQ0FDQUdJQVUyQWdBZ0JVR0FnQUpHQkVCQmdJQUNJUU1GSUF3b0FnQWhCQXdDQ3dVZ0NFRUFOZ0lBSUFaQkFEWUNBQXdCQ3d3QkN5QUJLQUlBSUFRZ0JXcEJnSUFDSUFWckVGNGhCU0FHS0FJQUlnTWdCV29oQkNBRlFRQktCRUFnQmlBRU5nSUFJQVFoQXdzTElBRkI3QUJxSWdVZ0EwRmlhaUlHTmdJQUlBY2dDQ2dDQUNJRE5nSUFJQU5CZjJvZ0NTZ0NBQ0lFYWlFSElBUkJmMGNFUUNBRklBWWdCMGdFZnlBR0JTQUhDellDQUFzTEN5QU1LQUlBSVFRZ0NDQURRUUZxTmdJQUlBSWdCQ0FEYWkwQUFEWUNBQXNnQUVIMGxBRnFJQUVRandRZ0N3UkFJQTFCSDNFaUEwRUJhaUVCSUFOQkEyeEJZMm9oQWlBQVFaQ1ZBV29pQlNnQ0FDRUVJQU5CRDBzRWZ5QUNCU0FCSWdJTFFRRkdCRUFnQkVVRVFFRUFEd3NnQlVFQU5nSUFJQUJCdkpZQmFpZ0NBQkJTUVFBUEN5QUVJQXBIQkVBZ0JBUkFJQVZCQURZQ0FDQUFRYnlXQVdvaUFTZ0NBQkJTQlNBQVFieVdBV29oQVFzZ0FTQUtRUXh1UVFSMFFTQnFJZ0VRYkNJRE5nSUFJQU1FUUNBQVFlaVhBV29nQXlBQmFrRndhallDQUNBRklBbzJBZ0FGUWF6MUFoQldDd3NnQUVId0ZHcEJBVG9BQUNBQVFlUU1haUFDTmdJQUlBQVEzd0VnQUVId0VHcEJBRG9BQUNBQVFmRVFha0VDT2dBQUlBQkI4aEJxSWdGQ2hJaVFvTUNBZ1lJRU53QUFJQUZCQkRvQUNDQUFRZnNRYWtFR1FmVUJFRlFhSUFCQjhBNXFRUUE2QUFBZ0FFSHhEbXBCQVRvQUFDQUFRZklPYWtFQ09nQUFRUU1oQkVFQklRSkJBU0VGUVFNaEF3TkFJQUJCOEE1cUlBTnFJQVE2QUFBZ0JVRUJhaUVCSUFKQmYyb2lBa1VpQndSQUlBRWhBZ3NnQkNBSGFpRUVJQWRGQkVBZ0JTRUJDeUFEUVFGcUlnTkJnQUpIQkVBZ0FTRUZEQUVMQ3lBQVFmQVNhaUlCUWdBM0FnQWdBVUlBTndJSUlBRkNBRGNDRUNBQlFnQTNBaGdnQVVJQU53SWdJQUZDQURjQ0tDQUJRZ0EzQWpBZ0FVSUFOd0k0SUFCQnNCTnFRUWhCd0FFUVZCb2dBRUhFREdwQkJ6b0FBQXNnQUVISURHb29BZ0JCQUVjTDBnVUJESDhqQkNFSkl3UkJFR29rQkNBQUtBS3dBU0lCSUFBb0FyUUJSd1JBSUFGQkFEb0FBQXNnQ1NJRklBVTJBZ2dnQlVFRWFpSUtJQVUyQWdBZ0JTSUJJZ01oQWdOQUlBQkJ1QUZxSUFSQkFuUnFJZ2NvQWdBaUJnUkFJQUJCQkdvZ0JHb2hDQ0FHSVFFRFFDQUhJQUVvQWdBaUF6WUNBQ0FCSUFVMkFnZ2dBU0FDTmdJRUlBSWdBVFlDQ0NBS0lBRTJBZ0FnQVVGL093RUFJQUVnQ0MwQUFEc0JBaUFEQkVBZ0FTRUNJQU1oQVF3QkJTQUJJZ0loQXdzTEN5QUVRUUZxSWdSQkprY05BQXNnQXlBRlJ3UkFJQU1oQkFOQUFrQWdCQ0FFUVFKcUlnY3VBUUFpQVVILy93TnhJZ0pCQkhScUlnTXVBUUJCZjBZRVFBTkFJQUlnQXk4QkFpSUlha0dBZ0FSUERRSWdBeWdDQ0NJR0lBTkJCR29pQWlnQ0FEWUNCQ0FDS0FJQUlBWTJBZ2dnQnlBQlFmLy9BM0VnQ0dvaUFrSC8vd054SWdFN0FRQWdCQ0FDUWYvL0EzRWlBa0VFZEdvaUF5NEJBRUYvUmcwQUN3c0xJQVFvQWdRaUJDQUZSdzBBQ3lBS0tBSUFJUUVMSUFFZ0JVWUVRQ0FKSkFRUEN5QUFRY3dDYWlFTEEwQWdBU2dDQ0NJRElBRkJCR29pQWlnQ0FEWUNCQ0FDS0FJQUlBTTJBZ2dnQVM4QkFpSUNJUVFnQWtILy93TnhRWUFCU2dSL0lBUkJmM01pQWtIL2ZVc0VmeUFDQlVIL2ZRdEJnQUZxSUFScUlnSkJnSDl4SVF3Z0FVR0FFR29nQWtFSGRrRUxkR29oQnlBRUlRTWdDeWdDQUNFQ0EwQWdBU0FDTmdJQUlBc2dBVFlDQUNBRFFZQi9haUVJSUFGQmdCQnFJUVlnQVNFQ0lBTkJnQUpLQkVBZ0NDRURJQVloQVF3QkN3c2dCRUdBZjJvZ0RHc2hCQ0FIQlNBQkN5RUNJQVFnQUVFRWFpQUFRU3BxSUFSQmYyb2lCbW90QUFBaUFXb3RBQUJIQkVBZ0FpQUFRUVJxSUFGQmYyb2lBV290QUFBaUEwRUVkR29pQkNBQVFiZ0JhaUFHSUFOclFRSjBhaUlES0FJQU5nSUFJQU1nQkRZQ0FBc2dBaUFBUWJnQmFpQUJRUUowYWlJQktBSUFOZ0lBSUFFZ0FqWUNBQ0FLS0FJQUlnRWdCVWNOQUFzZ0NTUUVDOTBDQVFSL0lBQkJ1QUZxUVFCQm1BRVFWQm9nQUNBQUtBS3NBU0lDTmdMUUFpQUFLQUlBSWdOQkNHMUJERzVCMUFCc0lnRkJERzVCQkhRaEJDQUFJQUlnQXlBQmF5SUJRUXh1UVFSMFFSQnFhaUlETmdMVUFpQUFJQU0yQXJBQklBQWdBaUFCYWpZQzNBSWdBQ0FESUFScU5nSzBBU0FBUVFFNkFBUWdBRUVDT2dBRklBQkJBem9BQmlBQVFRUTZBQWNnQUVFR09nQUlJQUJCQ0RvQUNTQUFRUW82QUFvZ0FFRU1PZ0FMUVE4aEEwRUlJUVFEUUNBQVFRUnFJQVJxSUFNNkFBQWdCRUVCYWlFQklBTkJBMm9oQWlBRVFRdElCRUFnQWlFRElBRWhCQXdCQ3dzZ0EwRUVhaUVDSUFGQkprZ0VRQU5BSUFCQkJHb2dBV29nQWpvQUFDQUJRUUZxSVFRZ0FrRUVhaUVDSUFGQkpVZ0VRQ0FFSVFFTUFRc0xDeUFBUVFBNkFLb0JRUUFoQWtFQUlRRURRQ0FBUVNwcUlBSnFJQUVnQWlBQVFRUnFJQUZxTFFBQVRtb2lBVG9BQUNBQ1FRRnFJZ0pCZ0FGSERRQUxDK2tLQVFwL0FrQWdBRUVZYWlJS0lBRTJBZ0FnQUVFRWFpSUxRUUEyQWdBZ0FFRUFOZ0lBSUFCQmZ6WUNDQ0FCUVFScUlnVW9BZ0FpQUVIaS93RktCRUFnQVVIb0FHb2lCQ2dDQUNBQWF5SUNRUUJPQkVBZ0FVSHdBR29pQ1NBQlFmZ0FhaUlJS0FJQUlBQnJJQWtvQWdCcU5nSUFBa0FDUUNBQ0JFQWdBVUVRYWlJREtBSUFJZ1lnQmlBQWFpQUNFRjBhSUFWQkFEWUNBQ0FFSUFJMkFnQWdBa0dBZ0FKSERRRkJnSUFDSVFBRklBVkJBRFlDQUNBRVFRQTJBZ0FnQVVFUWFpRUREQUVMREFFTElBRW9BZ0FnQXlnQ0FDQUNha0dBZ0FJZ0Ftc1FYaUVHSUFRb0FnQWlBQ0FHYWlFRElBWkJBRW9FUUNBRUlBTTJBZ0FnQXlFQUN3c2dBVUhzQUdvaUJpQUFRV0pxSWdRMkFnQWdDQ0FGS0FJQUlnQTJBZ0FnQUVGL2FpQUpLQUlBSWdOcUlRZ2dBMEYvUndSQUlBWWdCQ0FJU0FSL0lBUUZJQWdMTmdJQUN3c0xJQUVvQWhBaEFTQUZJQUJCQVdvMkFnQWdDeUFCSUFCcUxRQUFJZ2cyQWdBZ0NpZ0NBQ0lIUVFScUlnVW9BZ0FpQUVIaS93RktCRUFnQjBIb0FHb2lCQ2dDQUNBQWF5SUNRUUJPQkVBZ0IwSHdBR29pQ1NBSFFmZ0FhaUlHS0FJQUlBQnJJQWtvQWdCcU5nSUFBa0FDUUNBQ0JFQWdCMEVRYWlJQktBSUFJZ01nQXlBQWFpQUNFRjBhSUFWQkFEWUNBQ0FFSUFJMkFnQWdBa0dBZ0FKSERRRkJnSUFDSVFBRklBVkJBRFlDQUNBRVFRQTJBZ0FnQjBFUWFpRUJEQUVMREFFTElBY29BZ0FnQVNnQ0FDQUNha0dBZ0FJZ0Ftc1FYaUVESUFRb0FnQWlBQ0FEYWlFQklBTkJBRW9FUUNBRUlBRTJBZ0FnQVNFQUN3c2dCMEhzQUdvaUF5QUFRV0pxSWdRMkFnQWdCaUFGS0FJQUlnQTJBZ0FnQUVGL2FpQUpLQUlBSWdGcUlRWWdBVUYvUndSQUlBTWdCQ0FHU0FSL0lBUUZJQVlMTmdJQUN3c0xJQWNvQWhBaEFTQUZJQUJCQVdvMkFnQWdDeUFJUVFoMElBRWdBR290QUFCeUlnZzJBZ0FnQ2lnQ0FDSUhRUVJxSWdVb0FnQWlBRUhpL3dGS0JFQWdCMEhvQUdvaUJDZ0NBQ0FBYXlJQ1FRQk9CRUFnQjBId0FHb2lDU0FIUWZnQWFpSUdLQUlBSUFCcklBa29BZ0JxTmdJQUFrQUNRQ0FDQkVBZ0IwRVFhaUlCS0FJQUlnTWdBeUFBYWlBQ0VGMGFJQVZCQURZQ0FDQUVJQUkyQWdBZ0FrR0FnQUpIRFFGQmdJQUNJUUFGSUFWQkFEWUNBQ0FFUVFBMkFnQWdCMEVRYWlFQkRBRUxEQUVMSUFjb0FnQWdBU2dDQUNBQ2FrR0FnQUlnQW1zUVhpRURJQVFvQWdBaUFDQURhaUVCSUFOQkFFb0VRQ0FFSUFFMkFnQWdBU0VBQ3dzZ0IwSHNBR29pQXlBQVFXSnFJZ1EyQWdBZ0JpQUZLQUlBSWdBMkFnQWdBRUYvYWlBSktBSUFJZ0ZxSVFZZ0FVRi9Sd1JBSUFNZ0JDQUdTQVIvSUFRRklBWUxOZ0lBQ3dzTElBY29BaEFoQVNBRklBQkJBV28yQWdBZ0N5QUlRUWgwSUFFZ0FHb3RBQUJ5SWdBMkFnQWdBRUVJZENFSklBb29BZ0FpQWtFRWFpSUZLQUlBSWdCQjR2OEJUQTBBSUFKQjZBQnFJZ2dvQWdBZ0FHc2lDa0VBU0EwQUlBSkI4QUJxSWdRZ0FrSDRBR29pQmlnQ0FDQUFheUFFS0FJQWFqWUNBQUpBQWtBZ0NnUkFJQUpCRUdvaUFTZ0NBQ0lESUFNZ0FHb2dDaEJkR2lBRlFRQTJBZ0FnQ0NBS05nSUFJQXBCZ0lBQ1J3MEJRWUNBQWlFQUJTQUZRUUEyQWdBZ0NFRUFOZ0lBSUFKQkVHb2hBUXdCQ3d3QkN5QUNLQUlBSUFFb0FnQWdDbXBCZ0lBQ0lBcHJFRjRoQXlBSUtBSUFJZ0FnQTJvaEFTQURRUUJLQkVBZ0NDQUJOZ0lBSUFFaEFBc0xJQUpCN0FCcUlnTWdBRUZpYWlJSU5nSUFJQVlnQlNnQ0FDSUFOZ0lBSUFRb0FnQWlBVUYvUmcwQUlBTWdDQ0FBUVg5cUlBRnFJZ0ZJQkg4Z0NBVWdBUXMyQWdBZ0FpZ0NFQ0VCSUFVZ0FFRUJhallDQUNBTElBa2dBU0FBYWkwQUFISTJBZ0FQQ3lBQ0tBSVFJUUVnQlNBQVFRRnFOZ0lBSUFzZ0NTQUJJQUJxTFFBQWNqWUNBQXUvQVFFQmZ5QUFRZWd4YWl3QUFFVUVRRUVBRHdzQ1FBSkFBa0FDUUNBQ0RnSUFBUUlMSUFCQnNESnFJZ0lwQXdBZ0FWWUVRQ0FBUWFneWFpa0RBQ0FCVmdSQUlBQWdBRUh3TVdvcEF3QVFzQUlMQ3lBQ0lBRTNBd0FNQWdzZ0FFR3dNbW9pQWlBQ0tRTUFJQUY4TndNQURBRUxJQUJCdURKcUlnTkJBVG9BQUNBQ1FRSkhCRUJCQVE4TElBQW9BZ0FnQVVFQ0VKd0JJQUJCc0RKcUlBQW9BZ0FRMHdFM0F3QWdBMEVBT2dBQVFRRVBDeUFBUWJneWFrRUJPZ0FBUVFFTGF3QWdBQ0FCRU5FQk53Tm9JQUJCQURZQzBBRWdBRUVBTmdMVUFTQUFRUUU2QU5nQklBQkIzTUVBYWlBQUtBSUlRYWpFQW1vc0FBQTZBQUFnQUVFQU9nQmhJQUJCM2NFQWFrRUFPZ0FBSUFCQkFUb0EyUUVnQUVFQU9nRGFBU0FBUVFBNkFOc0JJQUFRd3dRTHZnRUNCSDhCZmtFQVFZQ0FFQkJYSWdSRklnVUVRRUdzOVFJUVZnc0NRQUpBQWtBRFFFRUFKQVZCR3lBQUlBUkJnSUFRRUFjaEFpTUZJUU5CQUNRRklBTkJBWEVOQVNBQ1FRRnFRUUpKRFFJZ0FhY2hBMEVBSkFWQkRpQUFJQVFnQVNBQ3JWVUVmeUFDQlNBRElnSUxFQTRqQlNFRFFRQWtCU0FEUVFGeERRRWdBcTBoQmlBQklBRkNmMVVFZmlBR0JVSUFDMzBoQVF3QUN3QUxFQmNoQUNBRkJFQWdBQkFlQ3lBRUVGSWdBQkFlREFFTElBVUVRQThMSUFRUVVnc0x5Z01CQkg4Q1FDTUVJUVlqQkVIQXdRQnFKQVFnQmtIb3dBQnFJUWdnQmtHY3dBQnFJUWNnQkNBRUlBVVErQUVnQmhEU0FVRUFKQVZCRUNBR0lBUVFCaUVKSXdVaEJVRUFKQVVDUUNBRlFRRnhSUVJBSUFsRkJFQWdCMEVBTmdKRUlBZEJFVFlDU0NBSElBSTJBZ0FnQnlBRU5nSUVJQWRCUUd0QkF6WUNBQ0FISUFNMkFnaEJBQ1FGSXdVaEFVRUFKQVVnQVVFQmNRMENJQWhCQURZQ1JDQUlRUkkyQWtnZ0NFRkFhMEVCTmdJQUlBZ2dBallDQUVFQUpBVWpCU0VCUVFBa0JTQUJRUUZ4RFFJZ0FDZ0NDRUdveXdScVFSYzJBZ0FnQmhCd0lBWWtCRUVBRHd0QkFFR0FnTUFBRUZjaUJFVWlBd1JBUVFBa0JVRVVRYXoxQWhBTUl3VWhBRUVBSkFVZ0FFRUJjUVJBRUJjaEFDQUdFSEFnQUJBZUN3c0NRQUpBQTBCQkFDUUZRUUlRQ3lNRklRQkJBQ1FGSUFCQkFYRU5Ba0VBSkFWQkJDQUdJQVJCZ0lEQUFCQUhJUUlqQlNFQVFRQWtCU0FBUVFGeERRSWdBa1VOQVVFQUpBVkJHaUFCSUFRZ0FoQUhHaU1GSVFCQkFDUUZJQUJCQVhGRkRRQU1BZ3NBQ3lBRERRTWdCQkJTREFNTEVCY2hBQ0FEQkVBZ0JoQndJQUFRSGdzZ0JCQlNJQVlRY0NBQUVCNExDeEFYSVFBZ0JoQndJQUFRSGtFQUR3c2dCaEJ3SUFZa0JFRUJDNDhEQVFaL0l3UWhCQ01FUWREQUFHb2tCQ0FFUVlCQWF5RURJQVJCek1BQWFpRUdBa0FDUUFKQUlBQkJDR29pQnlnQ0FDSUZRY2pMQkdvb0FnQkJ4UUJyRGhRQkFnSUNBZ0lDQWdJQ0FnQUNBZ0lDQWdJQ0FRSUxJQUpCQVRZQ0RDQUVKQVJCQVE4TElBVkJ5WWtEYWl3QUFBUkFJQVFrQkVFQkR3c2dCU0FDSUFCQjRNRUFhaUlBUVlBUUlBWWdBVUdBNkFGcUlnVXBBd0FnQVVIZzV3RnFJZ2hCQVJDN0FRUi9RUUVGSUFZc0FBQUVmMEVBQlVHczlRSWdBVUVZYWlJQklBQVFzd0lnQnlnQ0FFR295d1JxUVJBMkFnQUNmMEVBSUFBb0FnQkZEUUFhSUFCQnhBMFF4d0ZGQ3dSL1FRQUZJQU5CQURZQ1JDQURRZW9BTmdKSUlBTkJRR3RCQVRZQ0FDQURJQUUyQWdBZ0JDQUFRWUFRRUc4YUlBQkJBUkNTQXlBSEtBSUFJQUlnQUVHQUVDQUdJQVVwQXdBZ0NFRUJFTHNCQkg4Z0EwRUFOZ0pFSUFOQklUWUNTQ0FESUFFMkFnQWdBeUFFTmdJRUlBTkJRR3RCQXpZQ0FDQURJQUEyQWdoQkFRVkJyUFVDSUFFZ0FCQ3pBa0VBQ3dzTEN5RUFJQVFrQkNBQUR3c2dCQ1FFUVFFTHJnRUJCMzhqQkNFREl3UkI4TUFBYWlRRUlBTkJDR29oQkNBQVFRaHFJZ1lvQWdBaUJVSEppUU5xTEFBQUJFQWdBeUFDTmdJQUlBUkJ2TFVETmdJQUlBTWtCQThMSUFOQkdHb2hDQ0FEUVJCcUlRa2dBMEdnd0FCcUlRSWdBMEVnYWlFSEFrQUNRQUpBSUFCQjRNRUFhaUVFSUFWQnBJa0RhaXdBQUJvZ0FVSE1wd0ZxSWdVb0FnQWFEQUFMSUFrZ0JEWUNBQ0FJUWJ5MUF6WUNBQXNnQUVIZHdRQnFRUUU2QUFBTElBTWtCQXVmQWdFRWZ5TUVJUUVqQkVHQUJXb2tCQ0FCUVlBRWFpRUNJQUJCQ0dvaUF5Z0NBQ0lFUWFqRUFtb3NBQUJGQkVBZ0JFR3d5d1JxS0FJQUlnQkZCRUFnQVNRRVFRQVBDeUFCUVFBMkFnQUNRQUpBUVFRZ0JFR3N5d1JxS0FJQUlBRkJnQUVnQUVFUGNVSHFBR29SQXdCQmYwWUVRQ0FCUVFBMkFnQU1BUVVnQVNnQ0FFVU5BUXNNQVFzZ0FrRUFPZ0FBUVFJZ0F5Z0NBQ0lBUWF6TEJHb29BZ0FnQWtHQUFTQUFRYkRMQkdvb0FnQkJEM0ZCNmdCcUVRTUFRWDlHQkVBZ0FrRUFPZ0FBQ3lBQ1FRQWdBVUdBQVJEREFSb2dBa0dBQVJCYkN5QURLQUlBUWFqQUFtb2dBUkN1QWlBQlFZQUVFRnNnQXlnQ0FDSUFRYTNFQW1wQkFUb0FBQ0FBUWFqRUFtb3NBQUJGQkVBZ0FTUUVRUUFQQ3dzZ0FTUUVRUUVMOGlnQ0puOEJmZ0pBSXdRaEF5TUVRZENIQW1va0JDQUJRZmpuQVdvaUNTa0RBRUlBVXdSQUlBbENBRGNEQUFzZ0FVR0E2QUZxSWhFcEF3QkNBRk1FUUNBUlFnQTNBd0FMSUFCQkNHb2lCeWdDQUVISXl3UnFLQUlBSVEwZ0FrVUVRQ0FBTEFCaFJRUkFJQU1rQkVFQUR3c2dBU0FBUVJCcVFRQWdEUkMxQVVVRVFFR3M5UUpCQVJCa0lBTWtCRUVBRHdzTElBTkIyTUFBYWlFZUlBTkJ5TUFBYWlFUUlBTkJ3TUFBYWlFWklBTkJ1TUFBYWlFYUlBTkJzTUFBYWlFa0lBTWlCa0hvaGdKcUlRc2dCa0hNeGdGcUlRb2dCa0dBeGdGcUlSTWdCa0cweFFGcUlSUWdCa0hveEFGcUlSVWdCa0hBaHdKcUlRTWdCa0hvaEFGcUlRSWdCa0hveEFCcUlRd2dCa0hrd0FCcUlSWWdCa0c0aHdKcUlRNGdBVUd3cHdGcUlRVUNRQUpBQWtBQ1FBSkFJQUZCelBNQWFpZ0NBRUVDYXc1MkFBSUVBd1FFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFRUUxJQUJCM2NFQWFpSWJRUUE2QUFBZ0J5Z0NBQ0lFUWVTRUEyb29BZ0JGQkVBZ0FDZ0MxQUVnQkVHY3pBVnFLQUlBVHdSQUlBQXNBTmtCRFFZTEN5QURRUUE2QUFBZ0JDQUZJQU5CQlNBQ1FZQVFFUEFESVFRZ0J5Z0NBQ0lGUWVDRUEyb29BZ0JCQWtZRVFDQUZRYWlBQW1vZ0FrR0FFQkJ2R2lBSEtBSUFRYWlBQW1vUW13RkJBRFlDQUNBSEtBSUFRYWlBQW1vUXlnRUVRQ0FIS0FJQVFhaUFBbXBCQURZQ0FBc0xJQVJCQUVjaUFpQURMQUFBUlhFRVFDQUFRUUE2QU5rQkN5QUJFTzRCSUFGQjBLY0JhaUFNRUs4QkdpQUJRWlBwQVdvc0FBQUVRQ0FIS0FJQVFZekxBMm9vQWdBaUJFRUJSeUFETEFBQVJYRUVRQ0FNUVFBUTlnRWhBeUFIS0FJQVFZekxBMm9vQWdCQmYyb2dBMFlFZnlBTVFRRVE5Z0VhSUFJZ0JFRUFSM0VGUVFBTElRSUxCU0FCUVpIcEFXb3NBQUJGQkVBZ0FpQUhLQUlBUVl6TEEyb29BZ0JCQWtseElRSUxDeUFBUVJCcUlSSWdBQ0FCUWJub0FXb2lKU3dBQURvQVlTQUFRZUlBYWlJbVFRQTZBQUFnQVNBQlFaQzhBMm9wQXdBZ0NTa0RBSDFCQUNBQktBSUFLQUlRUVFOeFFiZ0NhaEVDQUFKQUFrQUNRQ0FBUWRnQmFpSURMQUFBQkVBZ0FnUkFJQUZCdU9nQmFpd0FBQVJBSUFaQkFEWUNSQ0FHUWNVQU5nSklJQVlnQVVFWWFqWUNBQ0FHUVVCclFRSTJBZ0FnQmlBTU5nSUVJQWNvQWdCQnFNc0Vha0VNTmdJQVFhejFBa0VHRUdRRklBTkJBRG9BQUVFQUlRTkJBU0VmREFNTEN5QURRUUE2QUFBRklBTkJBRG9BQUNBQ0JFQkJBQ0VEUVFFaEh3d0NDd3NnQVVHY3ZBTnFMQUFBQkVCQkFTRURCVUVCSVFCQkFDRUNEQUlMQ3dKL0lBY29BZ0JCeVlrRGFpd0FBQm9nRFVISkFFY2hKeUFEUVFCSElRSkJBUXNFUUNBQUlBRWdEQ0FBUWVEQkFHb2lCVUdBRUJDcEFpQUNCSDlCQUFVZ0JTZ0NBQVIvSUFGQnVPZ0JhaXdBQUVVRlFRQUxDeUlFUVFGeElRSUNRQUpBSUFjb0FnQWlDRUhiaEFOcUxBQUFEUUFnQ0VIY2hBTnFMQUFBRFFBTUFRc0NRQUpBQWtBZ0RVSEZBR3NPRkFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRc01BUXNNQVFzZ0JrR1F3QUJxSWdoQ0FEY0RBQ0FJUWdBM0F3Z2dDRUlBTndNUUlBUWdCeWdDQUVIYmhBTnFMQUFBUlhFaEFnc2dBVUc3NkFGcUlpQXNBQUFFUUNBQUVKWUVJUWdnQnlnQ0FDRUVJQWhGQkVBZ0JFR295d1JxUVJZMkFnQU1CQXNnQkVHb3hBSnFMQUFBUlFSQVFhejFBa0VCRUdRZ0J5Z0NBQ0lFUWFqTEJHcEJGallDQUVFQUlRSUxCU0FIS0FJQUlRUUxJQVJCcElzRWFpSUVLQUlBQkVBZ0JTQUVRWUFRRUc4YUN5QUJRY21uQVdvaUtDd0FBQ0lFUWY4QmNVRXlTaUVJSUFSQmMycEJHSFJCR0hWQi93RnhRUkJLSVFRZ0FVSEtwd0ZxSWlFc0FBQkJBRWNnQVVHWXZBTnFJaHdvQWdCQkEwWUVmeUFJQlNBRUMzRUVRRUdzOVFJZ0FVRVlhaUlBSUF3UXR3UWdCa0VBTmdKRUlBWkJJallDU0NBR1FVQnJRUUUyQWdBZ0JpQUFOZ0lBUWF6MUFrRUNFR1FnQnlnQ0FFR295d1JxUVE0MkFnQWdBU0FCUVpDOEEyb3BBd0JCQUNBQktBSUFLQUlRUVFOeFFiZ0NhaEVDQUNBQlFaeThBMm9zQUFCRklROE1Bd3NnRmlBSEtBSUFRYWpBQW1wQmhBUVFVeG9nQVVHODZBRnFLQUlBSVFnZ0FVSEI2QUZxSVFRZ0FVSEE2QUZxTEFBQVJRUkFRUUFoQkFzZ0FVR002UUZxS0FJQUlSZEJBQ1FGUVFFZ0VrRUFJQWdnRmlBRUlBRkIwZWdCYWlBWElBRkI2K2dCYWlJSUlBNFFFaU1GSVFSQkFDUUZBa0FnQkVFQmNVVUVRQUpBSUNBc0FBQUVRQ0FCUWVIb0FXb3NBQUJGRFFFZ0FVSGk2QUZxSUE1QkNCQnJSUTBCSUFGQnJMd0RhaXdBQUEwQklBcEJBRFlDUkNBS1FRWTJBa2dnQ2tGQWEwRUJOZ0lBSUFvZ0FVRVlhallDQUVFQUpBVWpCU0VDUVFBa0JTQUNRUUZ4RFFOQkFDUUZRUXBCclBVQ1FRc1FEU01GSVFKQkFDUUZJQUpCQVhFTkF5QUhLQUlBUWFqTEJHb2lBaWdDQUVFUFJnUkFRUUFoQWd3Q0N5QUNRUmcyQWdCQkFDRUNDd3RCQUNRRlFTSWdDaEFNSXdVaEJFRUFKQVVnQkVFQmNRUkFFQmNoQUFVZ0FVR2c2UUZxSWlJb0FnQWlCRUVBUnlFWEFrQUNRQUpBQWtBZ0JFRUZSaUFYUVFGemNnUkFRUUFrQlVFUklBRVFCU0VPSXdVaEJFRUFKQVVnQkVFQmNRMENJQUpCQVhGQkFFY2hCQ0FPUlFSQUlBUkZEUUpCQUNRRlFSZ2dBQ0FCSUFvUUJ5RUNJd1VoQkVFQUpBVWdCRUVCY1EwRElBSkJBWEVoQWd3Q0N5QUVSUVJBUVFFaEJBd0VDd0pBQWtBZ0RVSEZBR3NPREFBQkFRRUFBUUVCQVFFQkFBRUxRUUVoQkF3RUN5QUhLQUlBUWVDRUEyb29BZ0JCQVVZRVFFRUJJUVFNQkFzZ0FFSE1BV29pQkNBRUtBSUFRUUZxTmdJQVFRQWtCVUVNSUFBZ0FTQU1FQTRqQlNFRVFRQWtCU0FFUVFGeERRSkJBU0VFREFNRklBMUIwQUJISUFKQkFYRkJBRWR4UlEwQklBY29BZ0JCeVlrRGFpd0FBQTBCSUFaQkFEb0FBRUVBSkFWQkVDQUZFQVVoQkNNRklRNUJBQ1FGQWtBZ0RrRUJjVVVFUUNBRUlBWXNBQUFpQkVWeEJFQWdCeWdDQUNFRUlCRXBBd0FoS2tFQUpBVkJBU0FFUVFBZ0JVR0FFQ0FHSUNxbklDcENJSWluSUFGQjRPY0Jha0VBRUV3YUl3VWhCRUVBSkFVZ0JFRUJjUTBDSUFZc0FBQWhCQXNnQkVIL0FYRUVRRUVBSVFJTERBTUxDeEFYSVFBTERBTUxJQUpCQVhGRkJFQWdBVUdjdkFOcUxBQUFSUVJBUVFBaEJFRUJJUThNQXd0QkFDUUZRUVFnREVFQVFRQkJBUkFJSVFJakJTRURRUUFrQlNBRFFRRnhEUUVnQWdSQVFRRWhBMEVCSVFJRlFRQWhCRUVCSVFOQkFTRUNEQU1MQ3lBSEtBSUFRY21KQTJvc0FBQWlCQVJBSUJ0QkFUb0FBQXNnQTBFQmNTSWpRUUJISVE0Z0JDQWpjaUlwUWY4QmNVRUFSeUVkQWtBZ0RrVUVRQUpBSUExQjBBQkhJQjFCQVhOeEJFQkJBQ1FGUVJJZ0NoQUZJUVFqQlNFWVFRQWtCU0FZUVFGeERRTWdCRVVOQVNBTFFRQTJBa1FnQzBFNk5nSklJQXNnQVVFWWFpSUVOZ0lBSUF0QlFHdEJBallDQUNBTElBVTJBZ1JCQUNRRkl3VWhDMEVBSkFVZ0MwRUJjUTBEUVFBa0JVRU5RYXoxQWlBRUlBVVFEaU1GSVFSQkFDUUZJQVJCQVhFTkF3c0xJQUJCekFGcUlnUWdCQ2dDQUVFQmFqWUNBQXNnQUVIUUFXb2lHQ0FZS0FJQVFRRnFOZ0lBQWtBZ0p3UkFJQTRFUUNBa0lBdzJBZ0FNQWdzQ1FBSkFBa0FDUUNBSEtBSUFRY21KQTJvc0FBQUVmMEhVQUFVZ0RRdEJ4UUJyRGhRQ0F3TURBd01EQXdNREF3RURBd01BQXdNREFnTUxJQm9nRERZQ0FBd0VDeUFaSUF3MkFnQU1Bd3NnRUNBRk5nSUFDd3NMSUFjb0FnQWlCRUhNaEFOcUxBQUFSUVJBSUFjb0FnQWhCQXNnQUVHQUFXb2lDMElBTndNQUlBdENBRGNEQ0NBQlFaRG9BV29pQ3lnQ0FDRVFJQVJCb0lzRWFpZ0NBQ0VFUVFBa0JVRUVJQUJCdUFGcUloa2dFQ0FFRUE0akJTRUVRUUFrQlNBRVFRRnhEUUFnQ3lnQ0FDRUVJQWNvQWdCQm9Jc0VhaWdDQUNFUVFRQWtCVUVFSUFCQm9BRnFJQVFnRUJBT0l3VWhCRUVBSkFVZ0JFRUJjUTBBSUFBZ0NTa0RBRGNETUVFQUpBVkJBeUFTSUFFZ0NoQU9Jd1VoQkVFQUpBVWdCRUVCY1EwQUlBQWdLVG9BT1NBQUlDTTZBRG9nSFFSL0lBb2dCeWdDQUNJRVFaeUZBMm9zQUFCQkFYTTZBQk5CQUFVQ1FDQUJRYXk4QTJvc0FBQkZCRUFnQ1NrREFFSUxoaUFSS1FNQUlpcFhEUUVnS2tLQXd0Y3ZXUVJBUVFBa0JVRUZJQUVRVHEwakI2MUNJSWFFSVNvakJTRUVRUUFrQlNBRVFRRnhEUVFnS2lBSktRTUFWdzBDQzBFQUpBVWpCU0VFUVFBa0JTQUVRUUZ4RFFNTEN5QUtJQWNvQWdBaUJFR2NoUU5xTEFBQVFRRnpPZ0FUSUExQjBBQkhJQTVCQVhOeEN5RUpBa0FDUUNBWEJFQWdJaWdDQUNJUVFRUkdJUm9DUUFKQUFrQWdFRUVCY2tFRlJnUkFRUUFrQlVFRUlBQWdBU0FCUWFUcEFXb2dCa0dBRUJBUUl3VWhCRUVBSkFVQ1FDQUVRUUZ4UlFSQUlBWW9BZ0JGSUFsQkFYTnlEUU1nR2dSL1FRQWtCVUVaSUFVZ0JrR0FFQkFIQlVFQUpBVkJBaUFBSUFvZ0FVRVlhaUFGSUFaQmdCQVFDUXNoQkNNRklRVkJBQ1FGSUFWQkFYRU5BU0FFRFFOQkFDRUVEQVFMQ3dVQ1FDQVFRWDlxUVFOSkJFQWdDVVVOQTBFQUpBVkJCU0FFSUJJZ0FTQUZFQWdoQkNNRklRVkJBQ1FGSUFWQkFYRU5BU0FFQkVCQkFTRUZRUUVoQkF3R0JVRUFJUVFNQlFzQUJTQUdRUUEyQWtRZ0JrSEdBRFlDU0NBR0lBRkJHR28yQWdBZ0JrRkFhMEVDTmdJQUlBWWdCVFlDQkVFQUpBVWpCU0VFUVFBa0JTQUVRUUZ4RFFGQkFDRUVEQVFMQUFzTEVCY2hBQXdKQ3lBSklCd29BZ0JCQWtkeUJFQkJBU0VGUVFFaEJBVkJBU0VFREFFTERBRUxRUUFoQlFzZ0d5QUpJQVJ4UVFGeE9nQUFEQUVGSUFGQnVPZ0JhaXdBQUFSQVFRRWhCVUVCSVFRTUFnc2dJU3dBQUVVRVFDQVJLUU1BSVNwQkFDUUZRUUlnRWlBcXB5QXFRaUNJcHhCUEl3VWhCRUVBSkFVZ0JFRUJjUTBEUVFFaEJVRUJJUVFNQWdzZ0FFSElBV29pQkNnQ0FDRUZJQUZCbE9rQmFpZ0NBQ0VKSUFGQmtPa0JhaUlTTEFBQVFRQkhJUkJCQUNRRlFRVWdCU0FKSUJBUURpTUZJUVZCQUNRRklBVkJBWEVOQWlBRUtBSUFJZ1JCc0pnQmFpQVJLUU1BTndNQUlBUkJ5SmdCYWtFQU9nQUFJQndvQWdCQkEwY2dLQzBBQUNJRlFSQkljVVVFUUNBU0xBQUFRUUJISVFsQkFDUUZRUVlnQkNBRlFmOEJjU0FKRUE0akJTRUVRUUFrQlNBRVFRRnhEUU5CQVNFRlFRRWhCQXdDQ3lBWUtBSUFRUUZMQkg4Z0FVR2N2QU5xTEFBQVFRQkhCVUVBQ3lFRlFRQWtCVUVHSUFSQkR5QUZFQTRqQlNFRVFRQWtCU0FFUVFGeFJRUkFRUUVoQlVFQklRUU1BZ3NMREFFTFFRQWtCVUVWSUFFUURDTUZJUWxCQUNRRklBbEJBWEVOQUFKQUFrQWdKU3dBQUFSQVFRQWhDQXdCQlNBQlFlcm9BV29zQUFCRkJFQkJBQ0VJQzBFQUpBVkJGeUFaSUFzZ0NCQUhJUWdqQlNFSlFRQWtCU0FKUVFGeFJRMEJDd3dCQ3dKQUlBRkJrT2tCYWl3QUFBUkFJQ0VzQUFCRkRRRWdFU2tEQUVJQlV5QUlRUUZ6Y2cwQklBQkJBVG9BMndFRklBQkJBRG9BMndFTEN3Si9JQTRnQlVFQmMzSUVmMEVBQlNBSUJFQUNRQUpBSUExQnlRQnJEZ2dBQVFFQkFRRUJBQUVMUVFBTUF3c2dCeWdDQUVITWhBTnFMQUFBQkg5QjNCRUZRZVFSQ3lFRklBc29BZ0FFZjBHOHRRTUZRWUFTQ3lFSUlCNGdCVFlDQUNBZUlBZzJBZ1JCQUF3Q0N3SkFBa0FnSUN3QUFFVU5BQ0FCUWVIb0FXb3NBQUFFUUNBQlFheThBMm9zQUFCRkRRRUxJQUFzQU5zQkRRQWdFMEVBTmdKRUlCTkJCRFlDU0NBVElBRkJHR28yQWdBZ0UwRkFhMEVDTmdJQUlCTWdERFlDQkF3QkN5QVVRUUEyQWtRZ0ZFRUROZ0pJSUJRZ0FVRVlhallDQUNBVVFVQnJRUUkyQWdBZ0ZDQU1OZ0lFQzBFQUpBVWpCU0VGUVFBa0JTQUZRUUZ4RFFKQkFDUUZRUXBCclBVQ1FRTVFEU01GSVFWQkFDUUZJQVZCQVhFTkFnSkFBa0FnQnlnQ0FFR295d1JxSWdVb0FnQkJEMnNPQ2dBQkFRRUJBUUVCQVFBQkMwRUJEQUlMSUFWQkREWUNBRUVCQ3dzaEJTQWRCRUJCQUNFRVFRRWhEd3dGQ3dKQUFrQUNRQ0FOUWNVQWF3NFVBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQ3d3QkMwRUFJUVJCQVNFUERBVUxJQmNFUUNBaUtBSUFRUVZISUFSQkFYTnlCRUJCQUNFRVFRRWhEd3dHQ3dzZ0JRUkFJQWNvQWdCQm5JVURhaXdBQUVVRVFFRUFJUVJCQVNFUERBWUxRUUFrQlNNRklRUkJBQ1FGSUFSQkFYRU5BUXRCQUNRRkl3VWhCRUVBSkFVZ0JFRUJjUTBBUVFBa0JVRVRJQW9RQlJvakJTRUVRUUFrQlNBRVFRRnhEUUFDUUNBSEtBSUFRWkNGQTJvc0FBQUVRQ0FjS0FJQVFRTkhEUUVnQVVHbHFRSnFMQUFBUlEwQlFRQWtCVUVQSUFFZ0NrRVlhaEFOSXdVaEJFRUFKQVVnQkVFQmNRMENDd3RCQUNRRkl3VWhCRUVBSkFVZ0JFRUJjUTBBQWtBZ0J5Z0NBRUdraVFOcUxBQUFSUVJBSUFGQnpLY0JhaWdDQUNFRVFRQWtCVUVQSUFwQkdHb2lCU0FFRUFZaEJDTUZJUWhCQUNRRklBaEJBWEVOQWlBRURRRWdGVUVBTmdKRUlCVkJFRFlDU0NBVklBRkJHR28yQWdBZ0ZVRkFhMEVDTmdJQUlCVWdCVFlDQkVFQUpBVWpCU0VFUVFBa0JTQUVRUUZ4RFFJTEN5QWJRUUU2QUFCQkFDRUVRUUVoRHd3RUN4QVhJUUFNQkFzUUZ5RUFEQU1MRUJjaEFBd0NDeEFYSVFBTUFRc2dDaEJ3SUJZUVhDQVBSUVJBSUFRaER3d0hDeUFDUVFGeFFRQkhJUUlnQTBFQmNVVWhBeUFmUlFSQUlBTWhBQXdHQ3lBQVFkUUJhaUlBSUFBb0FnQkJBV28yQWdBZ0F5RUFEQVVMSUFvUWNBc2dGaEJjSUFBUUhnc0xFQmNoQUNBV0VGd2dBQkFlQ3d3QkN5QW1MQUFBQkg5QkFBVWdBa1VFUUNBQlFaeThBMm9zQUFBRVFDQUFCRUJCQUNFUERBUUxCU0FCSUFGQmtMd0RhaWtEQUVFQUlBRW9BZ0FvQWhCQkEzRkJ1QUpxRVFJQUN3dEJBUXNoRHdzZ0JpUUVJQThQQ3lBQVFkM0JBR29zQUFBRVFDQUhLQUlBSUFFZ0FFSGd3UUJxRUp3RUN3d0NDeUFBUWQzQkFHb3NBQUFFUUNBSEtBSUFJQUVnQUVIZ3dRQnFFSnNFQ3d3QkN5QUJRY3l0QW1vc0FBQkZEUUVnQVNBQVFSQnFRUUFnRFJDMUFRUkFJQUVnQVVHSXZBTnFLUU1BUVFBZ0FTZ0NBQ2dDRUVFRGNVRzRBbW9SQWdBZ0JpUUVRUUVQQlVHczlRSkJBUkJrREFJTEFBc2dBU0FCUVpDOEEyb3BBd0JCQUNBQktBSUFLQUlRUVFOeFFiZ0NhaEVDQUNBR0pBUkJBUThMSUFZa0JFRUFDNW9CQVFKL0lBQkNBRGNEQUNBQVFSQnFJZ01RdHdJZ0FDQUJOZ0lJSUFCQkFEWUMzQUVnQUVIZ3dRQnFRUUEyQWdBZ0FFRUFOZ0xNQVVFQUpBVkJCRUhZelFNUUJTRUJJd1VoQWtFQUpBVWdBa0VCY1FSQUVCY2hBaUFERUlRQklBSVFIZ3RCQUNRRlFRY2dBU0FERUEwakJTRUNRUUFrQlNBQ1FRRnhSUVJBSUFBZ0FUWUN5QUVQQ3hBWElRQWdBUkJTSUFNUWhBRWdBQkFlQzRJREFnZC9BWDRnQUVHUU1tb2hCa0dBZ0FRZ0FFR1VNbW9pQXlnQ0FDSUNhMEdBQWtrRVFDQUFLQUlRSWdVZ0JTQUNhaUFHS0FJQUlBSnJJZ0lRVXhvZ0EwRUFOZ0lBSUFZZ0FqWUNBQ0FBRU9JQkdpQURLQUlBSVFJTElBSkJCMm9nQmlnQ0FFc0VRRUVBRHdzZ0FTQUFRUkJxSWdjb0FnQWdBbXBCQnhEcEFTQURJQU1vQWdCQkIybzJBZ0FnQVJDbUFTRUlJQUZCQkJDNkFpSUNRWDFxSUFFUVlTSUpwMm9oQkNBSlFnQlJJQUpGSUFSQkFFaHljZ1JBSUFCQjZERnFRUUE2QUFCQkFBOExJQVlvQWdBZ0F5Z0NBQ0lDYXlFRkFrQWdCRUVBU2dSQUlBRWdCeWdDQUNBQ2FpQUZJQVJKQkg4Z0JRVWdCQXNpQWhEcEFTQURJQU1vQWdBZ0FtbzJBZ0FnQkNBQ2F5SUNRUUJLQkVBRFFBSkFJQU5CQURZQ0FDQUdRUUEyQWdBZ0FCRGlBVVVFUUVFQUlRQU1BUXNnQVNBSEtBSUFJQU1vQWdCcUlBVWdBa2tFZnlBRkJTQUNDeUlFRU9rQklBTWdBeWdDQUNBRWFqWUNBQ0FDSUFScklnSkJBRW9OQVF3RUN3dEJBQThMQ3dzZ0NDQUJFTGdDUmd0T0FRRi9Ba0FDUUFKQUlBSkJtTHdEYWlnQ0FFRUNhdzRDQUFFQ0N5TUVJUVFqQkVHQUVHb2tCQ0FDUWN5bkFXb29BZ0FhSUFRa0JFRUFEd3NnQUNBRElBSkJzS2NCYWhDZEJBOExRUUFMUndBZ0FFSEppUU5xTEFBQUJFQVBDeUFBUVpDRkEyb3NBQUJGQkVBUEN5QUJRWmk4QTJvb0FnQkJBa2NFUUE4TElBRkJrSzRDYWtITUVSQnpCRUFQQ3lBQklBSVFvUVFMT0FBZ0FFSEppUU5xTEFBQUJFQVBDeUFCUWVpdEFtb3VBUUJCZ1FKSEJFQVBDeUFBUVpDRkEyb3NBQUJGQkVBUEN5QUJJQUlRb2dRTHJRRUJBbjhqQkNFREl3UkJnQkJxSkFRZ0FrSDB3UUJxSWdRZ0EwR0FFQkJwR2dKQUFrQWdBa0h3d1FCcUtBSUFRWDV4UVFKSERRQWdBMEczTUVFRUVKQUNCRUFnQTBHOE1FRUVFSkFDQkVBZ0F5QURRWUFRRUlzRERBSUZRUUFoQUFzRlFRQWhBQXNNQVFzZ0FFR1RoUU5xTEFBQVJRUkFJQU1zQUFCQkwwWUVRRUVBSVFBTUFnc2dBa0VnYWlBRUVKOEVSUVJBUVFBaEFBd0NDd3NnQXlBQkVKNEVJUUFMSUFNa0JDQUFDNVlCQVFKL0l3UWhBaU1FUWRBUWFpUUVJQUVnQWtIUUFHb2lBMEdBRUJCcEdpQUFJQU1RdFFOQmYwY0VRQ0FDSkFSQkFROExRWWk4QXlnQ0FFRVJSZ1JBSUFKQkFEWUNSQ0FDUWRzQU5nSklJQUpCUUd0QkFUWUNBQ0FDSUFFMkFnQUZJQUpCQURZQ1JDQUNRUlEyQWtnZ0FrRUFOZ0lBSUFKQlFHdEJBallDQUNBQ0lBRTJBZ1JCclBVQ1FRRVFaQXNnQWlRRVFRQUxwd01CQkg4Z0FDZ0NBRUV2UmdSQVFRQVBDd0pBSUFBb0FnQWlBd1JBSUFBaEFrRUFJUUFEUUNBQ1FRUnFJUVFDUUNBRFFTOUdCRUFnQkNnQ0FDSURSUTBFSUFOQkwwY0VRQUpBSUFRb0FnQkJMa1lFUUNBQ1FRaHFJZ1VvQWdCQkwwWUVmMEVCQlNBRktBSUFSUXNoQXlBRUtBSUFRUzVHQkVBZ0JTZ0NBRUV1UmdSQUlBSkJER29pQWlnQ0FFRXZSd1JBSUFJb0FnQUVRQ0FBUVFGcUlRSWdBdzBJSUFJaEFBd0ZDd3NnQXcwR0RBTUxDeUFBUVFGcUlRSWdBMFVFUUNBQ0lRQUxCU0FBUVFGcUlRQUxDd3NMQ3lBRUtBSUFJZ01FUUNBRUlRSU1BUXNMQlVFQUlRQUxDeUFCS0FJQVFTOUdCRUJCQUE4RlFRQWhBeUFCSVFJTEEwQUNRQUpBQWtBQ1FBSkFJQUlvQWdBT0x3QUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUJBZ3NNQXdzZ0FrRUVhaUlCS0FJQVFTNUdCRUFnQWtFSWFpSUVLQUlBUVM5SEJFQWdCQ2dDQUEwREN5QURCRUFnQWtGOGFpZ0NBRUV2UncwREN5QUFRWDlxSVFBTERBRUxJQUpCQkdvaEFRc2dBMEVCYWlFRElBRWhBZ3dCQ3dzZ0FFRi9TZ3ZIQWdFRWZ3SkFJd1FoQWlNRVFkQVFhaVFFSUFFZ0FrSFFBR29pQlVHQUVCQnBHZ0pBSUFCQnFLa0NhaUlETEFBQUJFQWdBeEE5SWdRRVFDQUFRYWl0QW1vZ0JDZ0NDRFlDQUF3Q0N5QUFRYWFwQW1vc0FBQkZCRUFnQXhDVUFTRUJJQUpCQURZQ1JDQUNRZGNBTmdKSURBTUxDd3NDUUNBQVFhaXJBbW9pQXl3QUFBUkFJQU1RUENJRUJFQWdBRUdzclFKcUlBUW9BZ2cyQWdBTUFnc2dBRUducVFKcUxBQUFSUVJBSUFNUWxBRWhBU0FDUVFBMkFrUWdBa0hZQURZQ1NBd0RDd3NMSUFVZ0FFR29yUUpxS0FJQUlBQkJySzBDYWlnQ0FCRExBVVVFUUNBQ0pBUVBDeUFDUVFBMkFrUWdBa0haQURZQ1NDQUNJQUJCR0dvMkFnQWdBa0ZBYTBFQ05nSUFJQUlnQVRZQ0JFR3M5UUpCQ1JCa0lBSWtCQThMSUFJZ0FFRVlhallDQUNBQ1FVQnJRUUkyQWdBZ0FpQUJOZ0lFUWF6MUFrRUJFR1FnQWlRRUM1Z0NBUVYvQWtBakJDRUNJd1JCMENCcUpBUWdBU0FDUWRBUWFpSUdRWUFRRUdrYUlBQkJrTzRDYWlnQ0FDSUVFRzVCQVdvaEF5QUNRZEFBYWlJRklBUWdBMm9nQUVHVTdnSnFLQUlBSUFOcklnTVF4Z0VhSUFVZ0EycEJBRG9BQUNBRUVEMGlBMFVFUUNBRUVKUUJJUUVnQWtFQU5nSkVJQUpCMXdBMkFrZ01BUXNnQXlnQ0NDRUVJQVVRUENJRFJRUkFJQVVRbEFFaEFTQUNRUUEyQWtRZ0FrSFlBRFlDU0F3QkN5QUdJQVFnQXlnQ0NCRExBUVJBSUFKQkFEWUNSQ0FDUWRrQU5nSklJQUlnQUVFWWFqWUNBQ0FDUVVCclFRSTJBZ0FnQWlBQk5nSUVRYXoxQWtFSkVHUUxJQUlrQkE4TElBSWdBRUVZYWpZQ0FDQUNRVUJyUVFJMkFnQWdBaUFCTmdJRVFhejFBa0VCRUdRZ0FpUUVDNzhDQVFWL0FrQWpCQ0VDSXdSQjBCQnFKQVFnQVNBQ1FkQUFhaUlGUVlBUUVHa2FJQUJCckx3RGFpd0FBQVJBSUFKQkFEWUNSQ0FDUWRZQU5nSklEQUVMUVlpOEEwRUFOZ0lBSUFCQmpMVURhaUlERUQwaUJFVUVRQ0FERUpRQklRRWdBa0VBTmdKRUlBSkIxd0EyQWtnZ0FpQUFRUmhxTmdJQUlBSkJRR3RCQWpZQ0FDQUNJQUUyQWdSQnJQVUNRUUVRWkNBQ0pBUVBDeUFFS0FJSUlRWkJpTHdEUVFBMkFnQWdBRUdNdHdOcUlnTVFQQ0lFUlFSQUlBTVFsQUVoQVNBQ1FRQTJBa1FnQWtIWUFEWUNTQXdCQ3lBRklBWWdCQ2dDQ0JETEFRUkFJQUpCQURZQ1JDQUNRZGtBTmdKSUlBSWdBRUVZYWpZQ0FDQUNRVUJyUVFJMkFnQWdBaUFCTmdJRVFhejFBa0VKRUdRTElBSWtCQThMSUFJZ0FFRVlhallDQUNBQ1FVQnJRUUkyQWdBZ0FpQUJOZ0lFUWF6MUFrRURFR1FnQWlRRUN5VUJBWDhqQkNFREl3UkIwQ0JxSkFRZ0FTQUJJQUlRK0FFQ1FDQURKQVJCQUE4QUN3QUxpZ1FDQ0g4Q2ZpTUVJUVFqQkVFd2FpUUVJQVJCQ0dvaUEwRUFFTGdCUVFBa0JVRUhJQUFnQXhBR0lRSWpCU0VCUVFBa0JRSkFJQUZCQVhGRkJFQWdBZ1IvUVFBa0JVRURJQU1RVGhvakJTRUJRUUFrQlNBQlFRRnhEUUpCQUNRRlFRTWdBeEJPclNNSHJVSWdob1FoQ1NNRklRRkJBQ1FGSUFGQkFYRU5Ba0VBSkFWQkF5QURFRTZ0SXdldFFpQ0doQ0VLSXdVaEFVRUFKQVVnQVVFQmNRMENJQUJCbURKcUlRWWdBRUdnTW1vaUNDZ0NBQ0VCSUFCQm5ESnFJZ2NnQ3FjaUJUWUNBQ0FCSUFWSkJFQWdBRUdrTW1vb0FnQWlBa0VBUnlBQ0lBVkpjUVIvUVFBa0JTQUVJQUkyQWdCQkFrR3M5UUpCMkJzZ0JCQU9Jd1VoQVVFQUpBVWdBVUVCY1EwRVFRQWtCVUVVUWF6MUFoQU1Jd1VoQVVFQUpBVWdBVUVCY1EwRUlBZ29BZ0FoQWlBSEtBSUFCU0FCSVFJZ0JRc2hBU0FHS0FJQUlBRWdBa0VnYWlBQ1FRSjJhaUlDU3dSL0lBRUZJQUlpQVFzUVZ5SUhSUVJBUVFBa0JVRVVRYXoxQWhBTUl3VWhBa0VBSkFVZ0FrRUJjUTBFQ3lBR0lBYzJBZ0FnQ0NBQk5nSUFDeUFHS0FJQUlRRkJBQ1FGUVJJZ0F5QUJJQVVRQnhvakJTRUJRUUFrQlNBQlFRRnhEUUlnQUVHb01tb2dBRUh3TVdvcEF3QWdDWDAzQXdCQkFRVkJBQXNoQVNBREtBSUFJZ0JGQkVBZ0JDUUVJQUVQQ3lBQUVGSWdCQ1FFSUFFUEN3c1FGeUVCSUFNb0FnQWlBRVVFUUNBQkVCNExJQUFRVWlBQkVCNUJBQXNZQUNBQUtBSUFRUUpIQkVCQkFBOExJQUFvQWdSQmYzTUx0d3dCQW44Z0FFRUFJQUJyUVQ5eElBQnFJZ0kyQXZBQklBQWdBa0dBQVdvMkF2UUJJQUFnQWtHZ0FXbzJBdmdCSUFBZ0FrR29BV28yQXZ3QklBQWdBVVlpQXdSQUlBQkJBQ0FBUVlnQ2FpSUNhMEUvY1NBQ2FpSUNOZ0w0QXlBQUlBSkJnQUZxTmdMOEF5QUFJQUpCb0FGcU5nS0FCQ0FBSUFKQnFBRnFOZ0tFQkNBQVFRQWdBRUdRQkdvaUFtdEJQM0VnQW1vaUFqWUNnQVlnQUNBQ1FZQUJhallDaEFZZ0FDQUNRYUFCYWpZQ2lBWWdBQ0FDUWFnQmFqWUNqQVlnQUVHSUNHcEJBQ0FBUVpnR2FpSUNhMEUvY1NBQ2FpSUNOZ0lBSUFCQmpBaHFJQUpCZ0FGcU5nSUFJQUJCa0FocUlBSkJvQUZxTmdJQUlBQkJsQWhxSUFKQnFBRnFOZ0lBSUFCQmtBcHFRUUFnQUVHZ0NHb2lBbXRCUDNFZ0Ftb2lBallDQUNBQVFaUUthaUFDUVlBQmFqWUNBQ0FBUVpnS2FpQUNRYUFCYWpZQ0FDQUFRWndLYWlBQ1FhZ0JhallDQUNBQVFaZ01ha0VBSUFCQnFBcHFJZ0pyUVQ5eElBSnFJZ0kyQWdBZ0FFR2NER29nQWtHQUFXbzJBZ0FnQUVHZ0RHb2dBa0dnQVdvMkFnQWdBRUdrREdvZ0FrR29BV28yQWdBZ0FFR2dEbXBCQUNBQVFiQU1haUlDYTBFL2NTQUNhaUlDTmdJQUlBQkJwQTVxSUFKQmdBRnFOZ0lBSUFCQnFBNXFJQUpCb0FGcU5nSUFJQUJCckE1cUlBSkJxQUZxTmdJQUlBQkJxQkJxUVFBZ0FFRzREbW9pQW10QlAzRWdBbW9pQWpZQ0FDQUFRYXdRYWlBQ1FZQUJhallDQUNBQVFiQVFhaUFDUWFBQmFqWUNBQ0FBUWJRUWFpQUNRYWdCYWpZQ0FBVWdBaUFCS0FMd0FVR3dBUkJUR2lBQUlBRW9Bb0FDTmdLQUFpQUFJQUVzQUlRQ09nQ0VBaUFBUVFBZ0FFR0lBbW9pQW10QlAzRWdBbW9pQWpZQytBTWdBQ0FDUVlBQmFqWUMvQU1nQUNBQ1FhQUJhallDZ0FRZ0FDQUNRYWdCYWpZQ2hBUWdBaUFCS0FMNEEwR3dBUkJUR2lBQUlBRW9Bb2dFTmdLSUJDQUFJQUVzQUl3RU9nQ01CQ0FBUVFBZ0FFR1FCR29pQW10QlAzRWdBbW9pQWpZQ2dBWWdBQ0FDUVlBQmFqWUNoQVlnQUNBQ1FhQUJhallDaUFZZ0FDQUNRYWdCYWpZQ2pBWWdBaUFCS0FLQUJrR3dBUkJUR2lBQUlBRW9BcEFHTmdLUUJpQUFJQUVzQUpRR09nQ1VCaUFBUVlnSWFrRUFJQUJCbUFacUlnSnJRVDl4SUFKcUlnSTJBZ0FnQUVHTUNHb2dBa0dBQVdvMkFnQWdBRUdRQ0dvZ0FrR2dBV28yQWdBZ0FFR1VDR29nQWtHb0FXbzJBZ0FnQWlBQlFZZ0lhaWdDQUVHd0FSQlRHaUFBUVpnSWFpQUJRWmdJYWlnQ0FEWUNBQ0FBUVp3SWFpQUJRWndJYWl3QUFEb0FBQ0FBUVpBS2FrRUFJQUJCb0FocUlnSnJRVDl4SUFKcUlnSTJBZ0FnQUVHVUNtb2dBa0dBQVdvMkFnQWdBRUdZQ21vZ0FrR2dBV28yQWdBZ0FFR2NDbW9nQWtHb0FXbzJBZ0FnQWlBQlFaQUthaWdDQUVHd0FSQlRHaUFBUWFBS2FpQUJRYUFLYWlnQ0FEWUNBQ0FBUWFRS2FpQUJRYVFLYWl3QUFEb0FBQ0FBUVpnTWFrRUFJQUJCcUFwcUlnSnJRVDl4SUFKcUlnSTJBZ0FnQUVHY0RHb2dBa0dBQVdvMkFnQWdBRUdnREdvZ0FrR2dBV28yQWdBZ0FFR2tER29nQWtHb0FXbzJBZ0FnQWlBQlFaZ01haWdDQUVHd0FSQlRHaUFBUWFnTWFpQUJRYWdNYWlnQ0FEWUNBQ0FBUWF3TWFpQUJRYXdNYWl3QUFEb0FBQ0FBUWFBT2FrRUFJQUJCc0F4cUlnSnJRVDl4SUFKcUlnSTJBZ0FnQUVHa0Rtb2dBa0dBQVdvMkFnQWdBRUdvRG1vZ0FrR2dBV28yQWdBZ0FFR3NEbW9nQWtHb0FXbzJBZ0FnQWlBQlFhQU9haWdDQUVHd0FSQlRHaUFBUWJBT2FpQUJRYkFPYWlnQ0FEWUNBQ0FBUWJRT2FpQUJRYlFPYWl3QUFEb0FBQ0FBUWFnUWFrRUFJQUJCdUE1cUlnSnJRVDl4SUFKcUlnSTJBZ0FnQUVHc0VHb2dBa0dBQVdvMkFnQWdBRUd3RUdvZ0FrR2dBV28yQWdBZ0FFRzBFR29nQWtHb0FXbzJBZ0FnQWlBQlFhZ1FhaWdDQUVHd0FSQlRHaUFBUWJnUWFpQUJRYmdRYWlnQ0FEWUNBQ0FBUWJ3UWFpQUJRYndRYWl3QUFEb0FBQXNnQUVHd0VtcEJBQ0FBUWNBUWFpSUNhMEUvY1NBQ2FpSUNOZ0lBSUFCQnRCSnFJQUpCZ0FGcU5nSUFJQUJCdUJKcUlBSkJvQUZxTmdJQUlBQkJ2QkpxSUFKQnFBRnFOZ0lBSUFNRVFDQUFRY2dTYWlBQlFjZ1Nha0dFQkJCVEdnOExJQUlnQVVHd0Vtb29BZ0JCc0FFUVV4b2dBRUhBRW1vZ0FVSEFFbW9vQWdBMkFnQWdBRUhFRW1vZ0FVSEVFbW9zQUFBNkFBQWdBRUhJRW1vZ0FVSElFbXBCaEFRUVV4b0xFQUFnQUVFQU5nSUlJQUJCQURZQ0FBdFlBUUYvSUFBZ0FUWUNBQ0FCUVg5cVFRSkpCRUFnQUVFQU5nSUVEd3NnQVVFRFJ3UkFEd3NnQUVFRWFpSUNRWmN3S1FBQU53QUFJQUpCbnpBcEFBQTNBQWdnQWtHbk1Da0FBRGNBRUNBQ1FhOHdLUUFBTndBWUM4OFVBUTEvSXdRaEN5TUVRWUFDYWlRRUlBc2hDaUFBUWNnV2FpRU5BMEFDUUNBTktBSUFJZ01nQkVFR2RDSUhTd1JBSUFBZ0JFR0lBbXhxSVFVZ0F5QUhheUlEUWNBQVNRUi9JQU1GUWNBQUlnTUxCRUFnQUNBRVFZZ0NiR3BCOEFGcUlRd2dBQ0FFUVlnQ2JHcEIrQUZxSVE0Z0FFSElFbW9nQjJvaEJ5QUFJQVJCaUFKc2FrR0FBbW9pQWlnQ0FDRUlBMEFDUUNBTUtBSUFJQWhxSVFrZ0EwR0FBU0FJYXlJR1RRMEFJQWtnQnlBR0VGTWFJQUlnQWlnQ0FDQUdhallDQUNBT0tBSUFJZ2dvQWdBaENTQUlJQWxCUUdzMkFnQWdDRUVFYWlJSUlBZ29BZ0FnQ1VHL2YwdHFOZ0lBSUFVZ0RDZ0NBQkJ0SUF3b0FnQWlDRUZBYXlFSklBZ2dDU2tBQURjQUFDQUlJQWtwQUFnM0FBZ2dDQ0FKS1FBUU53QVFJQWdnQ1NrQUdEY0FHQ0FJSUFrcEFDQTNBQ0FnQ0NBSktRQW9Od0FvSUFnZ0NTa0FNRGNBTUNBSUlBa3BBRGczQURnZ0FpQUNLQUlBUVVCcUlnZzJBZ0FnQnlBR2FpRUhJQU1nQm1zaUF3MEJEQVFMQ3lBSklBY2dBeEJUR2lBQ0lBSW9BZ0FnQTJvMkFnQUxCU0FBSUFSQmlBSnNhaUVGQ3dzZ0JTQUtJQVJCQlhScUVPQUJJQVJCQVdvaUJFRUlSdzBBQ3lBQVFjQVFhaUVJSUFCQnNCSnFJUWNnQUVHNEVtb2hDVUVnSVFNZ0NpRUZJQUJCd0JKcUlnUW9BZ0FoQUFKQUFrQURRQ0FIS0FJQUlBQnFJUUlnQTBHQUFTQUFheUlHVFEwQklBSWdCU0FHRUZNYUlBUWdCQ2dDQUNBR2FqWUNBQ0FKS0FJQUlnQW9BZ0FoQWlBQUlBSkJRR3MyQWdBZ0FFRUVhaUlBSUFBb0FnQWdBa0cvZjB0cU5nSUFJQWdnQnlnQ0FCQnRJQWNvQWdBaUFFRkFheUVDSUFBZ0Fpa0FBRGNBQUNBQUlBSXBBQWczQUFnZ0FDQUNLUUFRTndBUUlBQWdBaWtBR0RjQUdDQUFJQUlwQUNBM0FDQWdBQ0FDS1FBb053QW9JQUFnQWlrQU1EY0FNQ0FBSUFJcEFEZzNBRGdnQkNBRUtBSUFRVUJxSWdBMkFnQWdCU0FHYWlFRklBTWdCbXNpQXcwQUN3d0JDeUFDSUFVZ0F4QlRHaUFFSUFRb0FnQWdBMm9pQURZQ0FBdEJJQ0VGSUFwQklHb2hBd0pBQWtBRFFDQUhLQUlBSUFCcUlRSWdCVUdBQVNBQWF5SUdUUTBCSUFJZ0F5QUdFRk1hSUFRZ0JDZ0NBQ0FHYWpZQ0FDQUpLQUlBSWdBb0FnQWhBaUFBSUFKQlFHczJBZ0FnQUVFRWFpSUFJQUFvQWdBZ0FrRy9mMHRxTmdJQUlBZ2dCeWdDQUJCdElBY29BZ0FpQUVGQWF5RUNJQUFnQWlrQUFEY0FBQ0FBSUFJcEFBZzNBQWdnQUNBQ0tRQVFOd0FRSUFBZ0Fpa0FHRGNBR0NBQUlBSXBBQ0EzQUNBZ0FDQUNLUUFvTndBb0lBQWdBaWtBTURjQU1DQUFJQUlwQURnM0FEZ2dCQ0FFS0FJQVFVQnFJZ0EyQWdBZ0F5QUdhaUVESUFVZ0Jtc2lCUTBBQ3d3QkN5QUNJQU1nQlJCVEdpQUVJQVFvQWdBZ0JXb2lBRFlDQUF0QklDRUZJQXBCUUdzaEF3SkFBa0FEUUNBSEtBSUFJQUJxSVFJZ0JVR0FBU0FBYXlJR1RRMEJJQUlnQXlBR0VGTWFJQVFnQkNnQ0FDQUdhallDQUNBSktBSUFJZ0FvQWdBaEFpQUFJQUpCUUdzMkFnQWdBRUVFYWlJQUlBQW9BZ0FnQWtHL2YwdHFOZ0lBSUFnZ0J5Z0NBQkJ0SUFjb0FnQWlBRUZBYXlFQ0lBQWdBaWtBQURjQUFDQUFJQUlwQUFnM0FBZ2dBQ0FDS1FBUU53QVFJQUFnQWlrQUdEY0FHQ0FBSUFJcEFDQTNBQ0FnQUNBQ0tRQW9Od0FvSUFBZ0Fpa0FNRGNBTUNBQUlBSXBBRGczQURnZ0JDQUVLQUlBUVVCcUlnQTJBZ0FnQXlBR2FpRURJQVVnQm1zaUJRMEFDd3dCQ3lBQ0lBTWdCUkJUR2lBRUlBUW9BZ0FnQldvaUFEWUNBQXRCSUNFRklBcEI0QUJxSVFNQ1FBSkFBMEFnQnlnQ0FDQUFhaUVDSUFWQmdBRWdBR3NpQmswTkFTQUNJQU1nQmhCVEdpQUVJQVFvQWdBZ0JtbzJBZ0FnQ1NnQ0FDSUFLQUlBSVFJZ0FDQUNRVUJyTmdJQUlBQkJCR29pQUNBQUtBSUFJQUpCdjM5TGFqWUNBQ0FJSUFjb0FnQVFiU0FIS0FJQUlnQkJRR3NoQWlBQUlBSXBBQUEzQUFBZ0FDQUNLUUFJTndBSUlBQWdBaWtBRURjQUVDQUFJQUlwQUJnM0FCZ2dBQ0FDS1FBZ053QWdJQUFnQWlrQUtEY0FLQ0FBSUFJcEFEQTNBREFnQUNBQ0tRQTROd0E0SUFRZ0JDZ0NBRUZBYWlJQU5nSUFJQU1nQm1vaEF5QUZJQVpySWdVTkFBc01BUXNnQWlBRElBVVFVeG9nQkNBRUtBSUFJQVZxSWdBMkFnQUxRU0FoQlNBS1FZQUJhaUVEQWtBQ1FBTkFJQWNvQWdBZ0FHb2hBaUFGUVlBQklBQnJJZ1pORFFFZ0FpQURJQVlRVXhvZ0JDQUVLQUlBSUFacU5nSUFJQWtvQWdBaUFDZ0NBQ0VDSUFBZ0FrRkFhellDQUNBQVFRUnFJZ0FnQUNnQ0FDQUNRYjkvUzJvMkFnQWdDQ0FIS0FJQUVHMGdCeWdDQUNJQVFVQnJJUUlnQUNBQ0tRQUFOd0FBSUFBZ0Fpa0FDRGNBQ0NBQUlBSXBBQkEzQUJBZ0FDQUNLUUFZTndBWUlBQWdBaWtBSURjQUlDQUFJQUlwQUNnM0FDZ2dBQ0FDS1FBd053QXdJQUFnQWlrQU9EY0FPQ0FFSUFRb0FnQkJRR29pQURZQ0FDQURJQVpxSVFNZ0JTQUdheUlGRFFBTERBRUxJQUlnQXlBRkVGTWFJQVFnQkNnQ0FDQUZhaUlBTmdJQUMwRWdJUVVnQ2tHZ0FXb2hBd0pBQWtBRFFDQUhLQUlBSUFCcUlRSWdCVUdBQVNBQWF5SUdUUTBCSUFJZ0F5QUdFRk1hSUFRZ0JDZ0NBQ0FHYWpZQ0FDQUpLQUlBSWdBb0FnQWhBaUFBSUFKQlFHczJBZ0FnQUVFRWFpSUFJQUFvQWdBZ0FrRy9mMHRxTmdJQUlBZ2dCeWdDQUJCdElBY29BZ0FpQUVGQWF5RUNJQUFnQWlrQUFEY0FBQ0FBSUFJcEFBZzNBQWdnQUNBQ0tRQVFOd0FRSUFBZ0Fpa0FHRGNBR0NBQUlBSXBBQ0EzQUNBZ0FDQUNLUUFvTndBb0lBQWdBaWtBTURjQU1DQUFJQUlwQURnM0FEZ2dCQ0FFS0FJQVFVQnFJZ0EyQWdBZ0F5QUdhaUVESUFVZ0Jtc2lCUTBBQ3d3QkN5QUNJQU1nQlJCVEdpQUVJQVFvQWdBZ0JXb2lBRFlDQUF0QklDRUZJQXBCd0FGcUlRTUNRQUpBQTBBZ0J5Z0NBQ0FBYWlFQ0lBVkJnQUVnQUdzaUJrME5BU0FDSUFNZ0JoQlRHaUFFSUFRb0FnQWdCbW8yQWdBZ0NTZ0NBQ0lBS0FJQUlRSWdBQ0FDUVVCck5nSUFJQUJCQkdvaUFDQUFLQUlBSUFKQnYzOUxhallDQUNBSUlBY29BZ0FRYlNBSEtBSUFJZ0JCUUdzaEFpQUFJQUlwQUFBM0FBQWdBQ0FDS1FBSU53QUlJQUFnQWlrQUVEY0FFQ0FBSUFJcEFCZzNBQmdnQUNBQ0tRQWdOd0FnSUFBZ0Fpa0FLRGNBS0NBQUlBSXBBREEzQURBZ0FDQUNLUUE0TndBNElBUWdCQ2dDQUVGQWFpSUFOZ0lBSUFNZ0Jtb2hBeUFGSUFacklnVU5BQXNNQVFzZ0FpQURJQVVRVXhvZ0JDQUVLQUlBSUFWcUlnQTJBZ0FMUVNBaEJTQUtRZUFCYWlFS0FrQUNRQU5BQWtBZ0J5Z0NBQ0FBYWlFRElBVkJnQUVnQUdzaUFrME5BQ0FESUFvZ0FoQlRHaUFFSUFRb0FnQWdBbW8yQWdBZ0NTZ0NBQ0lBS0FJQUlRTWdBQ0FEUVVCck5nSUFJQUJCQkdvaUFDQUFLQUlBSUFOQnYzOUxhallDQUNBSUlBY29BZ0FRYlNBSEtBSUFJZ0JCUUdzaEF5QUFJQU1wQUFBM0FBQWdBQ0FES1FBSU53QUlJQUFnQXlrQUVEY0FFQ0FBSUFNcEFCZzNBQmdnQUNBREtRQWdOd0FnSUFBZ0F5a0FLRGNBS0NBQUlBTXBBREEzQURBZ0FDQURLUUE0TndBNElBUWdCQ2dDQUVGQWFpSUFOZ0lBSUFVZ0Ftc2lCVVVOQWlBS0lBSnFJUW9NQVFzTERBRUxJQWdnQVJEZ0FTQUxKQVFQQ3lBRElBb2dCUkJUR2lBRUlBUW9BZ0FnQldvMkFnQWdDQ0FCRU9BQklBc2tCQXV3QWdJRWZ3TitJQUJCNkRGcUlnWXNBQUJGQkVCQkFBOExJQUJCcURKcUlRVWdBRUdjTW1vaEJ5QUFRYkF5YWlFRUEwQWdCU2tEQUNBSEtBSUFyWHdnQkNrREFGZ0VRQ0FBRUtRRURRRUxDeUFHTEFBQVJRUkFJQUJCdURKcUxBQUFSUVJBUVFBUEN5QUFLQUlBSUFRcEF3QkJBQkNjQVVFQUR3c2dCQ2tEQUNJSUlBVXBBd0FpQ1ZvRVFDQUlJQUt0SWdwOElBa2dCeWdDQUsxOFdBUkFJQUVnQUVHWU1tb29BZ0FnQ0NBSmZhZHFJQUlRVXhvZ0F5QUNOZ0lBSUFRZ0JDa0RBQ0FLZkRjREFDQUFRYmd5YWtFQk9nQUFRUUVQQ3dzZ0FFRzRNbW9pQlN3QUFBUkFJQUFvQWdBZ0NFRUFFSndCSUFWQkFEb0FBQXNnQUNnQ0FDQUJJQUlRMUFFaUFFRUFTQVIvSUFaQkFEb0FBRUVBQlNBRElBQTJBZ0FnQkNBRUtRTUFJQUNzZkRjREFFRUJDd3YyQmdFUGYwR0FCQ0FBUWNnV2FpSU9LQUlBSWdkcklRWWdCMFVnQmlBQ1MzSUVmeUFCSVFrZ0FnVWdBRUhJRW1vZ0Iyb2dBU0FHRUZNYUEwQWdBQ0FEUVlnQ2JHb2hEQ0FBSUFOQmlBSnNha0h3QVdvaENDQUFJQU5CaUFKc2FrSDRBV29oRFVIQUFDRUtJQUJCeUJKcUlBTkJCblJxSVFzZ0FDQURRWWdDYkdwQmdBSnFJZ2NvQWdBaEJBSkFBa0FEUUNBSUtBSUFJQVJxSVFVZ0NrR0FBU0FFYXlJSlRRMEJJQVVnQ3lBSkVGTWFJQWNnQnlnQ0FDQUphallDQUNBTktBSUFJZ1FvQWdBaEJTQUVJQVZCUUdzMkFnQWdCRUVFYWlJRUlBUW9BZ0FnQlVHL2YwdHFOZ0lBSUF3Z0NDZ0NBQkJ0SUFnb0FnQWlCRUZBYXlFRklBUWdCU2tBQURjQUFDQUVJQVVwQUFnM0FBZ2dCQ0FGS1FBUU53QVFJQVFnQlNrQUdEY0FHQ0FFSUFVcEFDQTNBQ0FnQkNBRktRQW9Od0FvSUFRZ0JTa0FNRGNBTUNBRUlBVXBBRGczQURnZ0J5QUhLQUlBUVVCcUlnUTJBZ0FnQ3lBSmFpRUxJQW9nQ1dzaUNnMEFDd3dCQ3lBRklBc2dDaEJUR2lBSElBY29BZ0FnQ21vMkFnQUxJQU5CQVdvaUEwRUlSdzBBQ3lBQklBWnFJUWxCQUNFSElBSWdCbXNMSWd0Qi93TkxJUTlCQUNFRUEwQWdBQ0FFUVlnQ2JHb2hFQ0FQQkVBZ0FDQUVRWWdDYkdwQjhBRnFJUTBnQUNBRVFZZ0NiR3BCK0FGcUlSRWdDU0FFUVFaMGFpRUNJQXNoQ2lBQUlBUkJpQUpzYWtHQUFtb2lDQ2dDQUNFREEwQkJ3QUFoQlNBQ0lRRUNRQUpBQTBBZ0RTZ0NBQ0FEYWlFR0lBVkJnQUVnQTJzaURFME5BU0FHSUFFZ0RCQlRHaUFJSUFnb0FnQWdER28yQWdBZ0VTZ0NBQ0lES0FJQUlRWWdBeUFHUVVCck5nSUFJQU5CQkdvaUF5QURLQUlBSUFaQnYzOUxhallDQUNBUUlBMG9BZ0FRYlNBTktBSUFJZ05CUUdzaEJpQURJQVlwQUFBM0FBQWdBeUFHS1FBSU53QUlJQU1nQmlrQUVEY0FFQ0FESUFZcEFCZzNBQmdnQXlBR0tRQWdOd0FnSUFNZ0Jpa0FLRGNBS0NBRElBWXBBREEzQURBZ0F5QUdLUUE0TndBNElBZ2dDQ2dDQUVGQWFpSUROZ0lBSUFFZ0RHb2hBU0FGSUF4cklnVU5BQ0FESVFFTERBRUxJQVlnQVNBRkVGTWFJQWdnQ0NnQ0FDQUZhaUlCTmdJQUN5QUNRWUFFYWlFQ0lBcEJnSHhxSWdwQi93TkxCRUFnQVNFRERBRUxDd3NnQkVFQmFpSUVRUWhKRFFBTElBdEIvd054SWdGRkJFQWdEaUFCSUFkcU5nSUFEd3NnQUVISUVtb2dCMm9nQ1NBTElBRnJhaUFCRUZNYUlBNGdBU0FIYWpZQ0FBdTVDZ0VEZnlBQVFjQVFha0VBUWZBQkVGUWFJQUJCd0JKcVFRQTJBZ0FnQUVIRUVtb2lBMEVBT2dBQUlBQkJ5QkpxUVFCQmhBUVFWQm9nQUVHMEVtb2lBaWdDQUNJQlFhd1JLUUlBTndJQUlBRkJ0QkVwQWdBM0FnZ2dBVUc4RVNrQ0FEY0NFQ0FCUWNRUktRSUFOd0lZSUFJb0FnQWlBU0FCS0FJQVFhQ0FvQkJ6TmdJQUlBRkJER29pQVNBQktBSUFRWUNBaElBQ2N6WUNBQ0FBUVFCQjhBRVFWQm9nQUVFQU5nS0FBaUFBUVFBNkFJUUNJQUJCOUFGcUlnSW9BZ0FpQVVHc0VTa0NBRGNDQUNBQlFiUVJLUUlBTndJSUlBRkJ2QkVwQWdBM0FoQWdBVUhFRVNrQ0FEY0NHQ0FDS0FJQUlnRWdBU2dDQUVHZ2dLQVFjellDQUNBQlFReHFJZ0VnQVNnQ0FFR0FnSUNBQW5NMkFnQWdBRUdJQW1wQkFFSHdBUkJVR2lBQVFRQTJBb2dFSUFCQkFEb0FqQVFnQUVIOEEyb2lBaWdDQUNJQlFhd1JLUUlBTndJQUlBRkJ0QkVwQWdBM0FnZ2dBVUc4RVNrQ0FEY0NFQ0FCUWNRUktRSUFOd0lZSUFJb0FnQWlBU0FCS0FJQVFhQ0FvQkJ6TmdJQUlBRkJDR29pQWlBQ0tBSUFRUUZ6TmdJQUlBRkJER29pQVNBQktBSUFRWUNBZ0lBQ2N6WUNBQ0FBUVpBRWFrRUFRZkFCRUZRYUlBQkJBRFlDa0FZZ0FFRUFPZ0NVQmlBQVFZUUdhaUlDS0FJQUlnRkJyQkVwQWdBM0FnQWdBVUcwRVNrQ0FEY0NDQ0FCUWJ3UktRSUFOd0lRSUFGQnhCRXBBZ0EzQWhnZ0FpZ0NBQ0lCSUFFb0FnQkJvSUNnRUhNMkFnQWdBVUVJYWlJQ0lBSW9BZ0JCQW5NMkFnQWdBVUVNYWlJQklBRW9BZ0JCZ0lDQWdBSnpOZ0lBSUFCQm1BWnFRUUJCOEFFUVZCb2dBRUdZQ0dwQkFEWUNBQ0FBUVp3SWFrRUFPZ0FBSUFCQmpBaHFJZ0lvQWdBaUFVR3NFU2tDQURjQ0FDQUJRYlFSS1FJQU53SUlJQUZCdkJFcEFnQTNBaEFnQVVIRUVTa0NBRGNDR0NBQ0tBSUFJZ0VnQVNnQ0FFR2dnS0FRY3pZQ0FDQUJRUWhxSWdJZ0FpZ0NBRUVEY3pZQ0FDQUJRUXhxSWdFZ0FTZ0NBRUdBZ0lDQUFuTTJBZ0FnQUVHZ0NHcEJBRUh3QVJCVUdpQUFRYUFLYWtFQU5nSUFJQUJCcEFwcVFRQTZBQUFnQUVHVUNtb2lBaWdDQUNJQlFhd1JLUUlBTndJQUlBRkJ0QkVwQWdBM0FnZ2dBVUc4RVNrQ0FEY0NFQ0FCUWNRUktRSUFOd0lZSUFJb0FnQWlBU0FCS0FJQVFhQ0FvQkJ6TmdJQUlBRkJDR29pQWlBQ0tBSUFRUVJ6TmdJQUlBRkJER29pQVNBQktBSUFRWUNBZ0lBQ2N6WUNBQ0FBUWFnS2FrRUFRZkFCRUZRYUlBQkJxQXhxUVFBMkFnQWdBRUdzREdwQkFEb0FBQ0FBUVp3TWFpSUNLQUlBSWdGQnJCRXBBZ0EzQWdBZ0FVRzBFU2tDQURjQ0NDQUJRYndSS1FJQU53SVFJQUZCeEJFcEFnQTNBaGdnQWlnQ0FDSUJJQUVvQWdCQm9JQ2dFSE0yQWdBZ0FVRUlhaUlDSUFJb0FnQkJCWE0yQWdBZ0FVRU1haUlCSUFFb0FnQkJnSUNBZ0FKek5nSUFJQUJCc0F4cVFRQkI4QUVRVkJvZ0FFR3dEbXBCQURZQ0FDQUFRYlFPYWtFQU9nQUFJQUJCcEE1cUlnSW9BZ0FpQVVHc0VTa0NBRGNDQUNBQlFiUVJLUUlBTndJSUlBRkJ2QkVwQWdBM0FoQWdBVUhFRVNrQ0FEY0NHQ0FDS0FJQUlnRWdBU2dDQUVHZ2dLQVFjellDQUNBQlFRaHFJZ0lnQWlnQ0FFRUdjellDQUNBQlFReHFJZ0VnQVNnQ0FFR0FnSUNBQW5NMkFnQWdBRUc0RG1wQkFFSHdBUkJVR2lBQVFiZ1Fha0VBTmdJQUlBQkJyQkJxSWdJb0FnQWlBVUdzRVNrQ0FEY0NBQ0FCUWJRUktRSUFOd0lJSUFGQnZCRXBBZ0EzQWhBZ0FVSEVFU2tDQURjQ0dDQUNLQUlBSWdFZ0FTZ0NBRUdnZ0tBUWN6WUNBQ0FCUVFocUlnSWdBaWdDQUVFSGN6WUNBQ0FCUVF4cUlnRWdBU2dDQUVHQWdJQ0FBbk0yQWdBZ0EwRUJPZ0FBSUFCQnZCQnFRUUU2QUFBTFJ3QWdBRUdCeHBTNkJqWUNBQ0FBUVluWHR2NStOZ0lFSUFCQi9ybnJ4WGsyQWdnZ0FFSDJxTW1CQVRZQ0RDQUFRZkREeTU1OE5nSVFJQUJCQURZQ0dDQUFRUUEyQWhRTDNCY0JhbjhnQWtVRVFBOExJQUJCQ0dvaUxpd0FBQ0VWSUFCQkNXb2lMeXdBQUNFV0lBQkJDbW9pTUN3QUFDRVhJQUJCQzJvaU1Td0FBQ0VZSUFCQkRHb2lNaXdBQUNFWklBQkJEV29pTXl3QUFDRWFJQUJCRG1vaU5Dd0FBQ0ViSUFCQkQyb2lOU3dBQUNFY0lBQkJFR29pTml3QUFDRWRJQUJCRVdvaU55d0FBQ0VlSUFCQkVtb2lPQ3dBQUNFZklBQkJFMm9pT1N3QUFDRWdJQUJCRkdvaU9pd0FBQ0VoSUFCQkZXb2lPeXdBQUNFaUlBQkJGbW9pUEN3QUFDRWpJQUJCRjJvaVBTd0FBQ0VrSUFKQkJIWWlKUVJBSUFCQkJHb2hQaUFBUVNocUlUOGdBRUVwYWlGQUlBQkJLbW9oUVNBQVFTdHFJVUlnQUVFc2FpRkRJQUJCTFdvaFJDQUFRUzVxSVVVZ0FFRXZhaUZHSUFCQk1Hb2hSeUFBUVRGcUlVZ2dBRUV5YWlGSklBQkJNMm9oU2lBQVFUUnFJVXNnQUVFMWFpRk1JQUJCTm1vaFRTQUFRVGRxSVU0Z0FFRVlhaUZQSUFCQkdXb2hVQ0FBUVJwcUlWRWdBRUViYWlGU0lBQkJIR29oVXlBQVFSMXFJVlFnQUVFZWFpRlZJQUJCSDJvaFZpQUFRU0JxSVZjZ0FFRWhhaUZZSUFCQkltb2hXU0FBUVNOcUlWb2dBRUVrYWlGYklBQkJKV29oWENBQVFTWnFJVjBnQUVFbmFpRmVBMEFnQUNBK0tBSUFJZ0pCQkhScUxBQWJJQUZCQTJvaVh5d0FBSE1oRFNBQUlBSkJCSFJxTEFBZUlBRkJCbW9pWUN3QUFITWhEaUFBSUFKQkJIUnFMQUFoSUFGQkNXb2lZU3dBQUhNaER5QUFJQUpCQkhScUxBQWtJQUZCREdvaVlpd0FBSE1oRUNBQUlBSkJCSFJxTEFBYUlBRkJBbW9pWXl3QUFITWhFU0FBSUFKQkJIUnFMQUFkSUFGQkJXb2laQ3dBQUhNaEVpQUFJQUpCQkhScUxBQWdJQUZCQ0dvaVpTd0FBSE1oQ1NBQUlBSkJCSFJxTEFBaklBRkJDMm9pWml3QUFITWhDaUFBSUFKQkJIUnFMQUFtSUFGQkRtb2laeXdBQUhNaEN5QUFJQUpCQkhScUxBQVpJQUZCQVdvaWFDd0FBSE1oRENBQUlBSkJCSFJxTEFBY0lBRkJCR29pYVN3QUFITWhFeUFBSUFKQkJIUnFMQUFmSUFGQkIyb2lhaXdBQUhNaEJ5QUFJQUpCQkhScUxBQWlJQUZCQ21vaWF5d0FBSE1oQlNBQUlBSkJCSFJxTEFBbElBRkJEV29pYkN3QUFITWhCaUFBUVJocUlBSkJCSFJxTEFBQUlBRXNBQUJ6SVJRZ0FVRVBhaUp0TEFBQUlRZ0RRQ0FHUWY4QmNTSUVRUUowUWR6UUEyb3NBQUFnRkVIL0FYRWlCa0VDZEVIYzJBTnFMQUFBY3lBRlFmOEJjU0lGUVFKMFFkeklBMm9zQUFCeklBZEIvd0Z4SWdkQkFuUkIzTUFEYWl3QUFITWhGQ0FFUVFKMFFkM1FBMm9zQUFBZ0JrRUNkRUhkMkFOcUxBQUFjeUFGUVFKMFFkM0lBMm9zQUFCeklBZEJBblJCM2NBRGFpd0FBSE1oSmlBRVFRSjBRZDdRQTJvc0FBQWdCa0VDZEVIZTJBTnFMQUFBY3lBRlFRSjBRZDdJQTJvc0FBQnpJQWRCQW5SQjNzQURhaXdBQUhNaEp5QUVRUUowUWQvUUEyb3NBQUFnQmtFQ2RFSGYyQU5xTEFBQWN5QUZRUUowUWQvSUEyb3NBQUJ6SUFkQkFuUkIzOEFEYWl3QUFITWhLQ0FNUWY4QmNTSUVRUUowUWR6UUEyb3NBQUFnRTBIL0FYRWlCa0VDZEVIYzJBTnFMQUFBY3lBTFFmOEJjU0lGUVFKMFFkeklBMm9zQUFCeklBcEIvd0Z4SWdkQkFuUkIzTUFEYWl3QUFITWhFeUFFUVFKMFFkM1FBMm9zQUFBZ0JrRUNkRUhkMkFOcUxBQUFjeUFGUVFKMFFkM0lBMm9zQUFCeklBZEJBblJCM2NBRGFpd0FBSE1oQ2lBRVFRSjBRZDdRQTJvc0FBQWdCa0VDZEVIZTJBTnFMQUFBY3lBRlFRSjBRZDdJQTJvc0FBQnpJQWRCQW5SQjNzQURhaXdBQUhNaEN5QUVRUUowUWQvUUEyb3NBQUFnQmtFQ2RFSGYyQU5xTEFBQWN5QUZRUUowUWQvSUEyb3NBQUJ6SUFkQkFuUkIzOEFEYWl3QUFITWhCeUFTUWY4QmNTSUVRUUowUWR6UUEyb3NBQUFnQ1VIL0FYRWlCa0VDZEVIYzJBTnFMQUFBY3lBUlFmOEJjU0lGUVFKMFFkeklBMm9zQUFCeklBQWdBa0VFZEdvc0FDY2dDSE5CL3dGeElnaEJBblJCM01BRGFpd0FBSE1oQ1NBRVFRSjBRZDNRQTJvc0FBQWdCa0VDZEVIZDJBTnFMQUFBY3lBRlFRSjBRZDNJQTJvc0FBQnpJQWhCQW5SQjNjQURhaXdBQUhNaERDQUVRUUowUWQ3UUEyb3NBQUFnQmtFQ2RFSGUyQU5xTEFBQWN5QUZRUUowUWQ3SUEyb3NBQUJ6SUFoQkFuUkIzc0FEYWl3QUFITWhLU0FFUVFKMFFkL1FBMm9zQUFBZ0JrRUNkRUhmMkFOcUxBQUFjeUFGUVFKMFFkL0lBMm9zQUFCeklBaEJBblJCMzhBRGFpd0FBSE1oS2lBUFFmOEJjU0lFUVFKMFFkelFBMm9zQUFBZ0VFSC9BWEVpQ0VFQ2RFSGMyQU5xTEFBQWN5QU9RZjhCY1NJR1FRSjBRZHpJQTJvc0FBQnpJQTFCL3dGeElnVkJBblJCM01BRGFpd0FBSE1oS3lBRVFRSjBRZDNRQTJvc0FBQWdDRUVDZEVIZDJBTnFMQUFBY3lBR1FRSjBRZDNJQTJvc0FBQnpJQVZCQW5SQjNjQURhaXdBQUhNaExDQUVRUUowUWQ3UUEyb3NBQUFnQ0VFQ2RFSGUyQU5xTEFBQWN5QUdRUUowUWQ3SUEyb3NBQUJ6SUFWQkFuUkIzc0FEYWl3QUFITWhMU0FFUVFKMFFkL1FBMm9zQUFBZ0NFRUNkRUhmMkFOcUxBQUFjeUFHUVFKMFFkL0lBMm9zQUFCeklBVkJBblJCMzhBRGFpd0FBSE1oQ0NBQ1FYOXFJUVFnQWtFQ1NnUkFJQUFnQkVFRWRHb3NBQnNnS0hNaERTQUFJQVJCQkhScUxBQWVJQXR6SVE0Z0FDQUVRUVIwYWl3QUlTQU1jeUVQSUFBZ0JFRUVkR29zQUNRZ0szTWhFQ0FBSUFSQkJIUnFMQUFhSUNkeklSRWdBQ0FFUVFSMGFpd0FIU0FLY3lFU0lBQWdCRUVFZEdvc0FDQWdDWE1oQ1NBQUlBUkJCSFJxTEFBaklDcHpJUW9nQUNBRVFRUjBhaXdBSmlBdGN5RUxJQUFnQkVFRWRHb3NBQmtnSm5NaERDQUFJQVJCQkhScUxBQWNJQk56SVJNZ0FDQUVRUVIwYWl3QUh5QUhjeUVISUFBZ0JFRUVkR29zQUNJZ0tYTWhCU0FBSUFSQkJIUnFMQUFsSUN4eklRWWdBRUVZYWlBRVFRUjBhaXdBQUNBVWN5RVVJQVFoQWd3QkN3c2dUeXdBQUNBL0xBQUFJQlJ6UWY4QmNVSGN2Z05xTEFBQWN5RUNJRkFzQUFBZ1RDd0FBQ0FzYzBIL0FYRkIzTDREYWl3QUFITWhCQ0JSTEFBQUlFa3NBQUFnS1hOQi93RnhRZHkrQTJvc0FBQnpJUVlnVWl3QUFDQkdMQUFBSUFkelFmOEJjVUhjdmdOcUxBQUFjeUVGSUZNc0FBQWdReXdBQUNBVGMwSC9BWEZCM0w0RGFpd0FBSE1oQnlCVUxBQUFJRUFzQUFBZ0puTkIvd0Z4UWR5K0Eyb3NBQUJ6SVEwZ1ZTd0FBQ0JOTEFBQUlDMXpRZjhCY1VIY3ZnTnFMQUFBY3lFT0lGWXNBQUFnU2l3QUFDQXFjMEgvQVhGQjNMNERhaXdBQUhNaER5QlhMQUFBSUVjc0FBQWdDWE5CL3dGeFFkeStBMm9zQUFCeklSQWdXQ3dBQUNCRUxBQUFJQXB6UWY4QmNVSGN2Z05xTEFBQWN5RVJJRmtzQUFBZ1FTd0FBQ0FuYzBIL0FYRkIzTDREYWl3QUFITWhFaUJhTEFBQUlFNHNBQUFnQ0hOQi93RnhRZHkrQTJvc0FBQnpJUWdnV3l3QUFDQkxMQUFBSUN0elFmOEJjVUhjdmdOcUxBQUFjeUVKSUZ3c0FBQWdTQ3dBQUNBTWMwSC9BWEZCM0w0RGFpd0FBSE1oQ2lCZExBQUFJRVVzQUFBZ0MzTkIvd0Z4UWR5K0Eyb3NBQUJ6SVFzZ1hpd0FBQ0JDTEFBQUlDaHpRZjhCY1VIY3ZnTnFMQUFBY3lFTUlBQXNBQUFFUUNBQ0lCVnpJUUlnRWlBZmN5RVNJQWdnSUhNaENDQUpJQ0Z6SVFrZ0JDQVdjeUVFSUFvZ0luTWhDaUFMSUNOeklRc2dEQ0FrY3lFTUlBWWdGM01oQmlBRklCaHpJUVVnQnlBWmN5RUhJQTBnR25NaERTQU9JQnR6SVE0Z0R5QWNjeUVQSUJBZ0hYTWhFQ0FSSUI1eklSRUxJQUVzQUFBaEZTQm9MQUFBSVJZZ1l5d0FBQ0VYSUY4c0FBQWhHQ0JwTEFBQUlSa2daQ3dBQUNFYUlHQXNBQUFoR3lCcUxBQUFJUndnWlN3QUFDRWRJR0VzQUFBaEhpQnJMQUFBSVI4Z1ppd0FBQ0VnSUdJc0FBQWhJU0JzTEFBQUlTSWdaeXdBQUNFaklHMHNBQUFoSkNBRElBSTZBQUFnQXlBRU9nQUJJQU1nQmpvQUFpQURJQVU2QUFNZ0F5QUhPZ0FFSUFNZ0RUb0FCU0FESUE0NkFBWWdBeUFQT2dBSElBTWdFRG9BQ0NBRElCRTZBQWtnQXlBU09nQUtJQU1nQ0RvQUN5QURJQWs2QUF3Z0F5QUtPZ0FOSUFNZ0N6b0FEaUFESUF3NkFBOGdBVUVRYWlFQklBTkJFR29oQXlBbFFYOXFJaVVOQUFzTElDNGdGVG9BQUNBdklCWTZBQUFnTUNBWE9nQUFJREVnR0RvQUFDQXlJQms2QUFBZ015QWFPZ0FBSURRZ0d6b0FBQ0ExSUJ3NkFBQWdOaUFkT2dBQUlEY2dIam9BQUNBNElCODZBQUFnT1NBZ09nQUFJRG9nSVRvQUFDQTdJQ0k2QUFBZ1BDQWpPZ0FBSUQwZ0pEb0FBQXZLQ2dFamZ5TUVJUUVqQkVFUWFpUUVJQUJCQkdvaUZDZ0NBRUVCVEFSQUlBRWtCQThMSUFFaUFrRUVhaUVWSUFKQkNHb2hGaUFDUVF4cUlSY2dBa0VCYWlFWUlBSkJCV29oR1NBQ1FRbHFJUm9nQWtFTmFpRWJJQUpCQW1vaEhDQUNRUVpxSVIwZ0FrRUthaUVlSUFKQkRtb2hIeUFDUVFOcUlTQWdBa0VIYWlFaElBSkJDMm9oSWlBQ1FROXFJU05CQVNFQkEwQWdBQ0FCUVFSMGFpMEFIQ0VESUFBZ0FVRUVkR290QUIwaEJDQUFJQUZCQkhScUxRQWVJUVVnQUNBQlFRUjBhaTBBSHlFR0lBQWdBVUVFZEdvdEFDQWhCeUFBSUFGQkJIUnFMUUFoSVFnZ0FDQUJRUVIwYWkwQUlpRUpJQUFnQVVFRWRHb3RBQ01oQ2lBQUlBRkJCSFJxTFFBa0lRc2dBQ0FCUVFSMGFpMEFKU0VNSUFBZ0FVRUVkR290QUNZaERTQUFJQUZCQkhScUxRQW5JUTRnQWlBQUlBRkJCSFJxTFFBWklnOUJBblJCM1BBRGFpd0FBQ0FBUVJocUlBRkJCSFJxSWhNdEFBQWlFRUVDZEVIYytBTnFMQUFBY3lBQUlBRkJCSFJxTFFBYUloRkJBblJCM09nRGFpd0FBSE1nQUNBQlFRUjBhaTBBR3lJU1FRSjBRZHpnQTJvc0FBQnpPZ0FBSUJVZ0JFRUNkRUhjOEFOcUxBQUFJQU5CQW5SQjNQZ0RhaXdBQUhNZ0JVRUNkRUhjNkFOcUxBQUFjeUFHUVFKMFFkemdBMm9zQUFCek9nQUFJQllnQ0VFQ2RFSGM4QU5xTEFBQUlBZEJBblJCM1BnRGFpd0FBSE1nQ1VFQ2RFSGM2QU5xTEFBQWN5QUtRUUowUWR6Z0Eyb3NBQUJ6T2dBQUlCY2dERUVDZEVIYzhBTnFMQUFBSUF0QkFuUkIzUGdEYWl3QUFITWdEVUVDZEVIYzZBTnFMQUFBY3lBT1FRSjBRZHpnQTJvc0FBQnpPZ0FBSUJnZ0QwRUNkRUhkOEFOcUxBQUFJQkJCQW5SQjNmZ0RhaXdBQUhNZ0VVRUNkRUhkNkFOcUxBQUFjeUFTUVFKMFFkM2dBMm9zQUFCek9nQUFJQmtnQkVFQ2RFSGQ4QU5xTEFBQUlBTkJBblJCM2ZnRGFpd0FBSE1nQlVFQ2RFSGQ2QU5xTEFBQWN5QUdRUUowUWQzZ0Eyb3NBQUJ6T2dBQUlCb2dDRUVDZEVIZDhBTnFMQUFBSUFkQkFuUkIzZmdEYWl3QUFITWdDVUVDZEVIZDZBTnFMQUFBY3lBS1FRSjBRZDNnQTJvc0FBQnpPZ0FBSUJzZ0RFRUNkRUhkOEFOcUxBQUFJQXRCQW5SQjNmZ0RhaXdBQUhNZ0RVRUNkRUhkNkFOcUxBQUFjeUFPUVFKMFFkM2dBMm9zQUFCek9nQUFJQndnRDBFQ2RFSGU4QU5xTEFBQUlCQkJBblJCM3ZnRGFpd0FBSE1nRVVFQ2RFSGU2QU5xTEFBQWN5QVNRUUowUWQ3Z0Eyb3NBQUJ6T2dBQUlCMGdCRUVDZEVIZThBTnFMQUFBSUFOQkFuUkIzdmdEYWl3QUFITWdCVUVDZEVIZTZBTnFMQUFBY3lBR1FRSjBRZDdnQTJvc0FBQnpPZ0FBSUI0Z0NFRUNkRUhlOEFOcUxBQUFJQWRCQW5SQjN2Z0RhaXdBQUhNZ0NVRUNkRUhlNkFOcUxBQUFjeUFLUVFKMFFkN2dBMm9zQUFCek9nQUFJQjhnREVFQ2RFSGU4QU5xTEFBQUlBdEJBblJCM3ZnRGFpd0FBSE1nRFVFQ2RFSGU2QU5xTEFBQWN5QU9RUUowUWQ3Z0Eyb3NBQUJ6T2dBQUlDQWdEMEVDZEVIZjhBTnFMQUFBSUJCQkFuUkIzL2dEYWl3QUFITWdFVUVDZEVIZjZBTnFMQUFBY3lBU1FRSjBRZC9nQTJvc0FBQnpPZ0FBSUNFZ0JFRUNkRUhmOEFOcUxBQUFJQU5CQW5SQjMvZ0RhaXdBQUhNZ0JVRUNkRUhmNkFOcUxBQUFjeUFHUVFKMFFkL2dBMm9zQUFCek9nQUFJQ0lnQ0VFQ2RFSGY4QU5xTEFBQUlBZEJBblJCMy9nRGFpd0FBSE1nQ1VFQ2RFSGY2QU5xTEFBQWN5QUtRUUowUWQvZ0Eyb3NBQUJ6T2dBQUlDTWdERUVDZEVIZjhBTnFMQUFBSUF0QkFuUkIzL2dEYWl3QUFITWdEVUVDZEVIZjZBTnFMQUFBY3lBT1FRSjBRZC9nQTJvc0FBQnpPZ0FBSUJNZ0Fpa0FBRGNBQUNBVElBSXBBQWczQUFnZ0FVRUJhaUlCSUJRb0FnQklEUUFMSUFJa0JBdmVDZ0VoZnlNRUlRSWpCRUVnYWlRRUlBQkJCR29pRGlnQ0FDSUVRWHBxSVFzZ0FpQUJLUUFBTndBQUlBSWdBU2tBQ0RjQUNDQUNJQUVwQUJBM0FCQWdBaUFCS1FBWU53QVlJQVJCQmtvaUJRUkFRUUFoQVFOQUlBb2dDMGdnQVVFRVNIRUVRQ0FLSVFNZ0FTRUdRUUFoQ1FOQUlBQkJHR29nQjBFRWRHb2dBU0FKYWtFQ2RHb2dBaUFLSUFscVFRSjBhaWdBQURZQUFDQUdRUUZxSVFnZ0NVRUJhaUVKSUFOQkFXb2lBeUFMU0NBR1FRTkljUVJBSUFnaEJnd0JCU0FJSVFFZ0F5RUtDd3NMSUFjZ0FVRUVSaUlEYWlFR0lBTUVRRUVBSVFFTElBb2dDMDRnQmlBT0tBSUFJZ05LY2dSQUlBRWhDaUFHSVFFZ0F5RUdCU0FHSVFjTUFRc0xCVUVBSVFFZ0JDRUdDeUFCSUFaS0JFQWdBaVFFRHdzZ0FpQUVRWGxxSWdOQkFuUnFRUUZxSVJZZ0FpQURRUUowYWtFQ2FpRVhJQUpCQVdvaER5QUNJQU5CQW5ScVFRTnFJUmdnQWtFQ2FpRVFJQUlnQTBFQ2RHb2hHU0FDUVFOcUlSRWdDMEVJUmlFYUlBUkJCMG9oR3lBQ0lBdEJBbTBpREVGL2FpSURRUUowYWlFY0lBSWdERUVDZEdvaEVpQUNJQU5CQW5ScVFRRnFJUjBnQWlBTVFRSjBha0VCYWlFVElBSWdBMEVDZEdwQkFtb2hIaUFDSUF4QkFuUnFRUUpxSVJRZ0FpQURRUUowYWtFRGFpRWZJQUlnREVFQ2RHcEJBMm9oRlNBRVFSUklJU0FnREVFQmFpRWhJQVZCQVhNaElnTkFJQUlnQWl3QUFDQVdMUUFBUWI2OEEyb3NBQUJ6SWdNNkFBQWdEeUFQTEFBQUlCY3RBQUJCdnJ3RGFpd0FBSE1pQ0RvQUFDQVFJQkFzQUFBZ0dDMEFBRUcrdkFOcUxBQUFjeUlKT2dBQUlCRWdFU3dBQUNBWkxRQUFRYjY4QTJvc0FBQnpJZ2M2QUFBZ0FpQURJQTFCdnI0RGFpd0FBSE1pQkRvQUFDQWFCRUJCQVNFRklBZ2hBeUFKSVFnZ0J5RUpJQVFoQndOQUlBSWdCVUVDZEdvaUJDd0FBQ0FIY3lFSElBUWdCem9BQUNBQ0lBVkJBblJxUVFGcUlnUXNBQUFnQTNNaEF5QUVJQU02QUFBZ0FpQUZRUUowYWtFQ2FpSUVMQUFBSUFoeklRZ2dCQ0FJT2dBQUlBSWdCVUVDZEdwQkEyb2lCQ3dBQUNBSmN5RUpJQVFnQ1RvQUFDQUZRUUZxSWdVZ0RFZ05BQXNnRWlBU0xBQUFJQnd0QUFCQnZyd0RhaXdBQUhNaUNEb0FBQ0FUSUJNc0FBQWdIUzBBQUVHK3ZBTnFMQUFBY3lJSk9nQUFJQlFnRkN3QUFDQWVMUUFBUWI2OEEyb3NBQUJ6SWdjNkFBQWdGU0FWTEFBQUlCOHRBQUJCdnJ3RGFpd0FBSE1pQkRvQUFDQWdCRUFnSVNFREEwQWdBaUFEUVFKMGFpSUZMQUFBSUFoeklRZ2dCU0FJT2dBQUlBSWdBMEVDZEdwQkFXb2lCU3dBQUNBSmN5RUpJQVVnQ1RvQUFDQUNJQU5CQW5ScVFRSnFJZ1VzQUFBZ0IzTWhCeUFGSUFjNkFBQWdBaUFEUVFKMGFrRURhaUlGTEFBQUlBUnpJUVFnQlNBRU9nQUFJQU5CQVdvaUEwRUlSdzBBQ3dzRklCc0VRRUVCSVFVZ0JDRURBMEFnQWlBRlFRSjBhaUlFTEFBQUlBTnpJUU1nQkNBRE9nQUFJQUlnQlVFQ2RHcEJBV29pQkN3QUFDQUljeUVJSUFRZ0NEb0FBQ0FDSUFWQkFuUnFRUUpxSWdRc0FBQWdDWE1oQ1NBRUlBazZBQUFnQWlBRlFRSjBha0VEYWlJRUxBQUFJQWR6SVFjZ0JDQUhPZ0FBSUFWQkFXb2lCU0FMUncwQUN3c0xJQUVnQmtvZ0luSkZCRUFnQVNFRElBb2hBVUVBSVFvRFFDQUtJQXRJSUFGQkJFaHhCRUFnQVNFR0lBb2hDRUVBSVFjRFFDQUFRUmhxSUFOQkJIUnFJQUVnQjJwQkFuUnFJQUlnQ2lBSGFrRUNkR29vQUFBMkFBQWdCa0VCYWlFSklBZEJBV29oQnlBSVFRRnFJZ2dnQzBnZ0JrRURTSEVFUUNBSklRWU1BUVVnQ1NFQklBZ2hDZ3NMQ3lBRElBRkJCRVlpQm1vaEF5QUdCSDlCQUFVZ0FRc2hCaUFLSUF0T0lBTWdEaWdDQUNJSVNuSUVRQ0FESVFFZ0JpRUtJQWdoQmdVZ0JpRUJEQUVMQ3dzZ0RVRUJhaUVOSUFFZ0Jrd05BQXNnQWlRRUM3VUpBUVYvSXdRaEF5TUVRWUFHYWlRRUlBTkJnQUpxSVFSQkFTRUFBMEFnQkNBQ2FpQUFRZjhCY1NJQk9nQUFJQVFnQWtIL0FXcHFJQUU2QUFBZ0FrRUJhaUVCSUFNZ0FHb2dBam9BQUNBQVFRRjBJQUJ6SUFCQmdBRnhCSDlCbXdJRlFRQUxjeUlBUVFGSEJFQWdBU0VDREFFTEMwRyt2Z05CQVRvQUFFRy92Z05CQWpvQUFFSEF2Z05CQkRvQUFFSEJ2Z05CQ0RvQUFFSEN2Z05CRURvQUFFSER2Z05CSURvQUFFSEV2Z05Cd0FBNkFBQkJ4YjREUVlCL09nQUFRY2ErQTBFYk9nQUFRY2UrQTBFMk9nQUFRY2krQTBIc0FEb0FBRUhKdmdOQldEb0FBRUhLdmdOQnEzODZBQUJCeTc0RFFjMEFPZ0FBUWN5K0EwR2Fmem9BQUVITnZnTkJMem9BQUVIT3ZnTkIzZ0E2QUFCQno3NERRYngvT2dBQVFkQytBMEhqQURvQUFFSFJ2Z05CUmpvQUFFSFN2Z05CbDM4NkFBQkIwNzREUVRVNkFBQkIxTDREUWVvQU9nQUFRZFcrQTBGVU9nQUFRZGErQTBHemZ6b0FBRUhYdmdOQi9RQTZBQUJCMkw0RFFYbzZBQUJCMmI0RFFXODZBQUJCMnI0RFFVVTZBQUJCMjc0RFFaRi9PZ0FBUVFBaEFBTkFJQUJCdnJ3RGFpQUFRZjhCY1FSL0lBUWdBeUFBYWl3QUFFRi9jMEgvQVhGcUxRQUFCVUVBQ3lJQ1FlTUFjeUFDUVFGMElBSkJBblJ6SUFKQkEzUnpJQUpCQkhSeklnSnpJQUpCQ0haek9nQUFJQUJCM0w0RGFpQUFRUUYwSUFCQkEzUnpJQUJCQm5SeklnSkJCWE1nQWtFSWRuTWlBa0gvQVhFRWZ5QUVJQU1nQWtIL0FYRnFMQUFBUVg5elFmOEJjV290QUFBRlFRQUxJZ0pCL3dGeElnRTZBQUFnQUVFQ2RFSGV3QU5xSUFGQi93RnhRUUJISWdVRWZ5QUVJQU1nQW1vdEFBQkI2QUJxYWkwQUFBVkJBQXNpQVVIL0FYRWlBVG9BQUNBQVFRSjBRZDNJQTJvZ0FUb0FBQ0FBUVFKMFFkelFBMm9nQVRvQUFDQUFRUUowUWQvWUEyb2dBVG9BQUNBQ1FRSjBRZDdnQTJvZ0FUb0FBQ0FDUVFKMFFkM29BMm9nQVRvQUFDQUNRUUowUWR6d0Eyb2dBVG9BQUNBQ1FRSjBRZC80QTJvZ0FUb0FBQ0FBUVFKMFFkekFBMm9nQlFSL0lBUWdBeUFDYWkwQUFFSEhBV3BxTFFBQUJVRUFDeUlCUWY4QmNTSUJPZ0FBSUFCQkFuUkIzOGdEYWlBQk9nQUFJQUJCQW5SQjN0QURhaUFCT2dBQUlBQkJBblJCM2RnRGFpQUJPZ0FBSUFKQkFuUkIzT0FEYWlBQk9nQUFJQUpCQW5SQjMrZ0RhaUFCT2dBQUlBSkJBblJCM3ZBRGFpQUJPZ0FBSUFKQkFuUkIzZmdEYWlBQk9nQUFJQUJCQW5SQjNjQURhaUFGQkg4Z0JDQURJQUpxTFFBQVFlNEJhbW90QUFBRlFRQUxJZ0ZCL3dGeElnRTZBQUFnQUVFQ2RFSGN5QU5xSUFFNkFBQWdBRUVDZEVIZjBBTnFJQUU2QUFBZ0FFRUNkRUhlMkFOcUlBRTZBQUFnQWtFQ2RFSGQ0QU5xSUFFNkFBQWdBa0VDZEVIYzZBTnFJQUU2QUFBZ0FrRUNkRUhmOEFOcUlBRTZBQUFnQWtFQ2RFSGUrQU5xSUFFNkFBQWdBRUVDZEVIZndBTnFJQVVFZnlBRUlBTWdBbW90QUFCQjN3RnFhaTBBQUFWQkFBc2lBVUgvQVhFaUFUb0FBQ0FBUVFKMFFkN0lBMm9nQVRvQUFDQUFRUUowUWQzUUEyb2dBVG9BQUNBQVFRSjBRZHpZQTJvZ0FUb0FBQ0FDUVFKMFFkL2dBMm9nQVRvQUFDQUNRUUowUWQ3b0Eyb2dBVG9BQUNBQ1FRSjBRZDN3QTJvZ0FUb0FBQ0FDUVFKMFFkejRBMm9nQVRvQUFDQUFRUUZxSWdCQmdBSkhEUUFMSUFNa0JBc1pBRUcrdkFNc0FBQkZCRUJCQUJDeEJBc2dBRUVCT2dBQUM1UUJBUU4vSUFBc0FJQUVSUVJBSUFGQkFEWUNBQThMSUFFZ0FDQUNRWUFCU1FSL0lBSUZRWUFCQzBFQ2RCQlRHaU1FSVFBakJFRVFhaVFFUVJRZ0FCQWxJUU1nQUNRRUlBTWhBQ0FDUVFKMElnTUVRQ0FBUWNzQWFpRUVRUUFoQUFOQUlBRWdBR29pQlNBRUlBQnFJQVV0QUFCek9nQUFJQUJCQVdvaUFDQURSdzBBQ3dzZ0FTQUNRWDlxUVFKMGFrRUFOZ0lBQy9rSEFRVi9Jd1FoQmlNRVFSQnFKQVFnQUVFQU5nSUVJQUJCQURZQ0FDQUFLQUlNSUFFZ0FrR0FnQUpKQkg4Z0FnVkJnSUFDQ3hCVEdpQUNRUUZMQkVCQkFTRUZBMEFnQVNBRmFpd0FBQ0FFY3lFRUlBVkJBV29pQlNBQ1J3MEFDd3NnQmtFSWFpRUhJQUJCQ0JCVklBTkJGR29pQlVFQU5nSUFBa0FnQkVIL0FYRWdBUzBBQUVZRVFBSi9RWDhnQVNBQ0VKa0JJZ0JCZ3ZIbmozOUlCSDhnQUVIQTdkbkVmRWdFUUNBQVFZRzFvSmw4YXcwRUlBSkJPVWNOQkVFQkRBSUxJQUJCdDhUT25uNUlCSDhnQUVIQTdkbkVmR3NOQkNBQ1FmZ0FSdzBFUVFJRklBQkJ0OFRPbm41ckRRUWdBa0dWQVVjTkJFRUVDd1VnQUVIK3NlaWJCRWdFUUNBQVFZTHg1NDkvYXcwRUlBSkJIVWNOQkVFRERBSUxJQUJCK0s2aWxRVklCSDhnQUVIK3NlaWJCR3NOQkNBQ1FkZ0JSdzBFUVFVRklBQkIrSzZpbFFWckRRUWdBa0UxUncwRVFRQUxDd3NpQUVFTWJFSHNEbW9vQWdBaENDQURRUVJxSWdJb0FnQkJBV29oQUNBQ0lBQTJBZ0FnQUNBRFFRaHFJZ1FvQWdBaUFVc0VRQ0FES0FJTUlnZEJBRWNnQUNBSFMzRUVRQ0FHSUFjMkFnQkJyUFVDUWRnYklBWVFZRUdzOVFJUVZpQUVLQUlBSVFFZ0FpZ0NBQ0VBQ3lBREtBSUFJQUFnQVVFZ2FpQUJRUUoyYWlJQlN3Ui9JQUFpQVFVZ0FRdEJLR3dRVnlJQVJRUkFRYXoxQWhCV0N5QURJQUEyQWdBZ0JDQUJOZ0lBQlNBREtBSUFJUUFMSUFVZ0JTZ0NBQ0lCUVFGcU5nSUFJQUFnQVVFb2JHcEJLRFlDQUNBQUlBRkJLR3hxUVF4cUlnSWdDRFlDQUNBQUlBRkJLR3hxSUFJMkFoUWdBQ0FCUVNoc2FpQUFJQUZCS0d4cVFSeHFOZ0lrSUFBZ0FVRW9iR3BCQXpZQ0dDQUFJQUZCS0d4cVFRTTJBZ2dnQmlRRUR3c0xJQU5CQkdvaUFpZ0NBRUVCYWlFQUlBSWdBRFlDQUNBQUlBTkJDR29pQkNnQ0FDSUJTd1JBSUFNb0Fnd2lDRUVBUnlBQUlBaExjUVJBSUFjZ0NEWUNBRUdzOVFKQjJCc2dCeEJnUWF6MUFoQldJQVFvQWdBaEFTQUNLQUlBSVFBTElBTW9BZ0FnQUNBQlFTQnFJQUZCQW5acUlnRkxCSDhnQUFVZ0FTSUFDMEVvYkJCWElnSkZCRUJCclBVQ0VGWUxJQU1nQWpZQ0FDQUVJQUEyQWdBRklBTW9BZ0FoQWdzZ0JTQUZLQUlBSWdOQkFXbzJBZ0FnQWlBRFFTaHNha0VXTmdJQUlBSWdBMEVvYkdvZ0FpQURRU2hzYWtFTWFqWUNGQ0FDSUFOQktHeHFJQUlnQTBFb2JHcEJIR28yQWlRZ0FpQURRU2hzYWtFRE5nSVlJQUlnQTBFb2JHcEJBellDQ0NBRFFYOUtCRUJCQUNFQUJTQUdKQVFQQ3dOQUlBSWdBRUVvYkdwQkZHb2lBU2dDQUVVRVFDQUJJQUlnQUVFb2JHcEJER28yQWdBTElBSWdBRUVvYkdwQkpHb2lBU2dDQUVVRVFDQUJJQUlnQUVFb2JHcEJIR28yQWdBTElBQkJBV29oQVNBQUlBTklCRUFnQVNFQURBRUxDeUFHSkFRTC9SWUJGMzhDUUFKQUFrQUNRQUpBQWtBZ0FVRUJhdzRHQUFBQkF3UUNCUXNnQUNnQ0xDRUdJQUFvQWlRaUJFSC8vdzVMSUFSQkJFaHlCRUFQQ3lBRVFRUk1CRUFQQ3lBRVFYeHFJUVVnQUVFUWFpSUhLQUlBSVFBZ0FVRUNSZ1IvUWVrQkJVSG9BUXNoQ0VFQUlRRURRQ0FBUVFGcUlRUWdBVUVCYWlFQ0lBQXNBQUFpQ1VGb1JpQUlJQWxCL3dGeFJuSUVmeUFDSUFacUlRSWdCeWdDQUNJSklBUk5JQWxCZ0lBUWFpQUVTM0VpQXdSL0lBQXRBQUpCQ0hRZ0JDMEFBSElnQUMwQUEwRVFkSElnQUMwQUJFRVlkSElGSUFRb0FnQUxJZ2xCQUVnRVFDQUpJQUpxUVg5S0JFQWdDVUdBZ0lBSWFpRUNJQU1FUUNBRUlBSTZBQUFnQUNBQ1FRaDJPZ0FDSUFBZ0FrRVFkam9BQXlBQUlBSkJHSFk2QUFRRklBUWdBallDQUFzTEJTQUpRWUNBZ0FoSUJFQWdDU0FDYXlFQ0lBTUVRQ0FFSUFJNkFBQWdBQ0FDUVFoMk9nQUNJQUFnQWtFUWRqb0FBeUFBSUFKQkdIWTZBQVFGSUFRZ0FqWUNBQXNMQ3lBQlFRVnFJUUVnQUVFRmFnVWdBaUVCSUFRTElRQWdBU0FGU0EwQUN3OExJQUFvQWlRaUFVSC8vdzVMSUFGQkZVaHlCRUFQQ3lBQlFSVk1CRUFQQ3lBQlFXdHFJUU1nQUNnQ0VDRUJJQUFvQWl4QkJIWWhBQU5BSUFFc0FBQkJIM0VpQWtFUFNnUkFJQUpCY0dvaUNVSG5MbW90QUFBaEFrSFA1d0FnQ1haQkFYRUVRQ0FDUVFGeEJFQWdBU3dBQlVFOGNVRVVSZ1JBSUFGQkEyb2lCaTBBQUVFSWRDQUJRUUpxSWdVdEFBQWlCM0lnQVVFRWFpSUlMUUFBSWdwQkVIUnlJQUJCQW5ScklndEIvUC8vQVhFaENTQUZJQWtnQjBFRGNYSTZBQUFnQmlBTFFRaDJPZ0FBSUFnZ0NVRVFkaUFLUWNBQmNYSTZBQUFMQ3lBQ1FRSnhCRUFnQVN3QUNrSDRBSEZCS0VZRVFDQUJRUWhxSWdZdEFBQkJDSFFnQVVFSGFpSUZMUUFBSWdkeUlBRkJDV29pQ0MwQUFDSUtRUkIwY2lBQVFRTjBheUlMUWZqLy93TnhJUWtnQlNBSklBZEJCM0Z5T2dBQUlBWWdDMEVJZGpvQUFDQUlJQWxCRUhZZ0NrR0FBWEZ5T2dBQUN3c2dBa0VFY1FSQUlBRXNBQTlCOEFGeFFkQUFSZ1JBSUFGQkRXb2lDUzBBQUVFSWRDQUJRUXhxSWdZdEFBQWlCWElnQVVFT2FpSUhMUUFBUVJCMGNpQUFRUVIwYXlFQ0lBWWdBa0h3QVhFZ0JVRVBjWEk2QUFBZ0NTQUNRUWgyT2dBQUlBY2dBa0VRZGpvQUFBc0xDd3NnQVVFUWFpRUJJQUJCQVdvaEFDQUVRUkJxSWdRZ0EwZ05BQXNQQ3lBQUtBSVVJUVlnQUVFUWFpSUhLQUlBSWdGQm9JQVBhaUFBS0FJa0lnTTZBQUFnQVVHaGdBOXFJQU5CQ0hZNkFBQWdBVUdpZ0E5cUlBTkJFSFk2QUFBZ0FVR2pnQTlxSUFOQkdIWTZBQUFnQTBHQXdBZEpJQVpCQUVweEJFQkJBQ0VBQlE4TElBTkJBWFFoQlFOQUlBSWdBMm9pQVNBRlNBUkFRUUFoQ1FOQUlBQkJBV29oQkNBSlFmOEJjU0FIS0FJQUlnZ2dBR290QUFCcklRa2dDQ0FCYWlBSk9nQUFJQUVnQm1vaUFTQUZTQVJBSUFRaEFBd0JCU0FFSVFBTEN3c2dBa0VCYWlJQ0lBWkhEUUFMRHdzZ0FDZ0NGRUY5YWlFS0lBQW9BaGdoQ1NBQUtBSVFJZ0ZCb0lBUGFpQUFLQUlrSWdjNkFBQWdBVUdoZ0E5cUlBZEJDSFk2QUFBZ0FVR2lnQTlxSUFkQkVIWTZBQUFnQVVHamdBOXFJQWRCR0hZNkFBQWdCMEgvdndkTElBb2dDWEpCQUVoeUJFQVBDeUFCSUFkcUlRZ2dCMEVBU2dSQVFRQWhBQU5BSUFJZ0Ntc2lCRUVDU2dSQVFRQWdBQ0FJSUFScUlnUXRBQUFpQzJvZ0JFRjlhaTBBQUNJRWF5SUZJQUJySWdOcklRNUJBQ0FGSUF0cklnWnJJUTlCQUNBRklBUnJJZ1ZySVF3Z0EwRi9TZ1IvSUFNRklBNGlBd3NnQmtGL1NnUi9JQVlGSUE4aUJndEtJQU1nQlVGL1NnUi9JQVVGSUF3aUJRdEtjaUVESUFZZ0JVd0VRQ0FMSVFRTElBTUVRQ0FFSVFBTEN5QUJRUUZxSVFRZ0FDQUJMUUFBYXlJQlFmOEJjU0VBSUFnZ0Ftb2dBVG9BQUNBQ1FRTnFJZ0lnQjBnRVFDQUVJUUVNQVFzTElBZEJBVW9FUUVFQUlRQkJBU0VDSUFRaEFRTkFJQUlnQ21zaUJFRUNTZ1JBUVFBZ0FDQUlJQVJxSWdRdEFBQWlDMm9nQkVGOWFpMEFBQ0lFYXlJRklBQnJJZ05ySVE1QkFDQUZJQXRySWdacklROUJBQ0FGSUFScklnVnJJUXdnQTBGL1NnUi9JQU1GSUE0aUF3c2dCa0YvU2dSL0lBWUZJQThpQmd0S0lBTWdCVUYvU2dSL0lBVUZJQXdpQlF0S2NpRURJQVlnQlV3RVFDQUxJUVFMSUFNRVFDQUVJUUFMQ3lBQlFRRnFJUVFnQUNBQkxRQUFheUlCUWY4QmNTRUFJQWdnQW1vZ0FUb0FBQ0FDUVFOcUlnSWdCMGdFUUNBRUlRRU1BUXNMSUFkQkFrb0VRRUVBSVFCQkFpRUNJQVFoQVFOQUlBSWdDbXNpQkVFQ1NnUkFRUUFnQUNBSUlBUnFJZ1F0QUFBaUMyb2dCRUY5YWkwQUFDSUVheUlGSUFCcklnTnJJUTVCQUNBRklBdHJJZ1pySVE5QkFDQUZJQVJySWdWcklRd2dBMEYvU2dSL0lBTUZJQTRpQXdzZ0JrRi9TZ1IvSUFZRklBOGlCZ3RLSUFNZ0JVRi9TZ1IvSUFVRklBd2lCUXRLY2lFRElBWWdCVXdFUUNBTElRUUxJQU1FUUNBRUlRQUxDeUFCUVFGcUlRUWdBQ0FCTFFBQWF5SUJRZjhCY1NFQUlBZ2dBbW9nQVRvQUFDQUNRUU5xSWdJZ0IwZ0VRQ0FFSVFFTUFRc0xDd3NMSUFrZ0IwRithaUlCU0FSQUlBa2hBQVVQQ3dOQUlBZ2dBR29pQkNBRUxRQUFJQWdnQUVFQmFtb3RBQUFpQkdvNkFBQWdDQ0FBUVFKcWFpSUNJQUl0QUFBZ0JHbzZBQUFnQUVFRGFpSUFJQUZJRFFBTER3c2dBQ2dDRkNFVElBQW9BaEFpQWtHZ2dBOXFJQUFvQWlRaUVEb0FBQ0FDUWFHQUQyb2dFRUVJZGpvQUFDQUNRYUtBRDJvZ0VFRVFkam9BQUNBQ1FhT0FEMm9nRUVFWWRqb0FBQ0FRUVlEQUIwa2dFMEVBU25GRkJFQVBDeUFDSUJCcUlSZ0RRQ0FPSUJCSUJFQkJBQ0VVSUE0aEQwRUFJUUJCQUNFQlFRQWhCRUVBSVJKQkFDRURRUUFoQ1VFQUlSRWdBaUVNUVFBaEMwRUFJUXBCQUNFSVFRQWhCMEVBSVFWQkFDRUdRUUFoRmdOQUlBeEJBV29oRnlBWUlBOXFJQVFnQ1d3Z0VVRURkR29nQVNBSklBTnJJaFZzYWlBQUlCSnNha0VEZGtIL0FYRWdEQ3dBQUNJRFFmOEJjV3NpRERvQUFDQU1JQkZyUVJoMFFSaDFJUkZCQUNBRFFRTjBJZ0pySVEwZ0EwRi9TZ1IvSUFJRklBMExJQXRxSVF0QkFDQUNJQWxySWdOcklRMGdBMEYvU2dSL0lBTUZJQTBMSUFwcUlRcEJBQ0FDSUFscUlnTnJJUTBnQ0NBRFFYOUtCSDhnQXdVZ0RRdHFJUWhCQUNBQ0lCVnJJZ05ySVEwZ0J5QURRWDlLQkg4Z0F3VWdEUXRxSVFkQkFDQUNJQlZxSWdOcklRMGdCU0FEUVg5S0JIOGdBd1VnRFF0cUlRVkJBQ0FDSUJKcklnTnJJUTBnQmlBRFFYOUtCSDhnQXdVZ0RRdHFJUVpCQUNBQ0lCSnFJZ0pySVFNZ0ZpQUNRWDlLQkg4Z0FnVWdBd3RxSVFNQ1FDQVVRUjl4UlFSQUlBTWdCaUFGSUFjZ0NDQUtJQXRKSWdJRWZ5QUtCU0FMSWdvTFNTSURCSDhnQ0FVZ0NpSUlDMGtpQ2dSL0lBY0ZJQWdpQnd0SklnZ0VmeUFGQlNBSElnVUxTU0lIQkg4Z0JnVWdCUXRKSVFZZ0F3UkFRUUloQWdzZ0NnUkFRUU1oQWdzZ0NBUkFRUVFoQWdzZ0J3UkFRUVVoQWdzQ1FBSkFBa0FDUUFKQUFrQUNRQ0FHQkg5QkJnVWdBZ3RCQjNGQkFXc09CZ0FCQWdNRUJRWUxJQVFnQkVGdlNrRWZkRUVmZFdvaEJFRUFJUU5CQUNFR1FRQWhCVUVBSVFkQkFDRUlRUUFoQ2tFQUlRc01Cd3NnQkNBRVFSQklhaUVFUVFBaEEwRUFJUVpCQUNFRlFRQWhCMEVBSVFoQkFDRUtRUUFoQ3d3R0N5QUJJQUZCYjBwQkgzUkJIM1ZxSVFGQkFDRURRUUFoQmtFQUlRVkJBQ0VIUVFBaENFRUFJUXBCQUNFTERBVUxJQUVnQVVFUVNHb2hBVUVBSVFOQkFDRUdRUUFoQlVFQUlRZEJBQ0VJUVFBaENrRUFJUXNNQkFzZ0FDQUFRVzlLUVI5MFFSOTFhaUVBUVFBaEEwRUFJUVpCQUNFRlFRQWhCMEVBSVFoQkFDRUtRUUFoQ3d3REN5QUFJQUJCRUVocUlRQkJBQ0VEUVFBaEJrRUFJUVZCQUNFSFFRQWhDRUVBSVFwQkFDRUxEQUlMUVFBaEEwRUFJUVpCQUNFRlFRQWhCMEVBSVFoQkFDRUtRUUFoQ3dzTElCUkJBV29oRkNBUElCTnFJZzhnRUVnRVFDQUpJUUlnRlNFU0lCRWhDU0FNSVJFZ0Z5RU1JQU1oRmlBQ0lRTU1BUVVnRnlFQ0N3c0xJQTVCQVdvaURpQVRSdzBBQ3dzTEVBQWdBRUVCRU9RQklBQkJBRFlDRUF0ZkFDTUVJUUFqQkVIUUFHb2tCQ0FBUVFBMkFrUWdBRUVmTmdKSUlBQWdBVFlDQUNBQVFVQnJRUUkyQWdBZ0FDQUNOZ0lFUWF6MUFpZ0NBRUVDU1FSQVFhejFBa0VDTmdJQUMwR3c5UUpCc1BVQ0tBSUFRUUZxTmdJQUlBQWtCQXRUQVFGL0l3UWhBaU1FUWRBQWFpUUVJQUpCQURZQ1JDQUNRUWcyQWtnZ0FrRUFOZ0lBSUFKQlFHdEJBallDQUNBQ0lBRTJBZ1FnQUVFR05nSUFJQUJCQkdvaUFDQUFLQUlBUVFGcU5nSUFJQUlrQkFzdkFDQUFRUVUyQWdBZ0FFRUVhaUlBSUFBb0FnQkJBV28yQWdCQkJCQVVJZ0JCQlRZQ0FDQUFRWUFJUVFBUUd3czZBQ0FBS0FJQVFRSkpCRUFnQUVFQ05nSUFDeUFBUVFScUlnQWdBQ2dDQUVFQmFqWUNBRUVFRUJRaUFFRUNOZ0lBSUFCQmdBaEJBQkFiQzVVQkFDQUFRUUJCd01zRUVGUWFJQUJCZ0lDQUVEWUNEQ0FBUWJpRUEycEJBRFlDQUNBQVFieUVBMnBCQXpZQ0FDQUFRYkNFQTJwQkFEWUNBQ0FBUVl5RkEycEJBRFlDQUNBQVFaVExBMnBCQkRZQ0FDQUFRYmlKQTJwQy8vLy8vL2YvLy8vL0FEY0RBQ0FBUWNDSkEycEMvLy8vLy9mLy8vLy9BRGNEQUNBQVFjQ0VBMnBCQWpZQ0FDQUFRWkNBQVdwQkFUWUNBQXNYQUNBQVFRRTZBQXdnQUNBQk5nSVVJQUFnQWpZQ0VBdWRBUUVFZnlBQVFRaHFJUVFnQVFSQUlBUW9BZ0FpQXdSQUEwQWdBeWdDRUNFRklBTW9BZ0FpQmdSQUlBWVFVZ3NnQXhCU0lBVUVRQ0FGSVFNTUFRc0xDd3NnQUNBQk5nSUFJQUFnQWtFQmNUb0FCQ0FFUVFBMkFnQWdBRUVBTmdJTUlBQkJFR29pQVNnQ0FBUkFJQUJCQURZQ0ZDQUFRZWd4YWtFQU9nQUFEd3NnQVVHQWdBUVFYellDQUNBQVFRQTJBaFFnQUVIb01XcEJBRG9BQUFzU0FDQUFRUUU2QUxVQklBQW9Ba1FReUFJTFRRQWdBUVJBSUFBZ0FFRkFheWdDQUVFQklBSWdBeUFFSUFVZ0JpQUhJQWdRdVFGQkFYRTZBTFFCQlNBQUlBQW9Ba1JCQUNBQ0lBTWdCQ0FGSUFZZ0J5QUlFTGtCUVFGeE9nQzFBUXNMRmdBZ0FTQUFLQUljTmdJQUlBSWdBQ2dDR0RZQ0FBc2hBQ0FCQkVBZ0FDQUJOZ0lzQ3lBQ0JFQWdBQ0FDTmdJd0N5QUFRWDgyQWtnTHdRRUJBWDhnQUVFQU9nQUFJQUJCQURvQURDQUFRZ0EzQXlBZ0FFRUJPZ0FvSUFCQkFEb0FLU0FBUVFBNkFDb2dBRUVBT2dCUUlBQkJBRG9BVVNBQVFRQTZBRklnQUVFQU5nSXNJQUJCQURZQ01DQUFRUUEyQWhnZ0FFRUFOZ0kwSUFCQkFEb0F0QUVnQUVFQU9nQzFBU0FBUWVBQWFpSUJRZ0EzQXdBZ0FVSUFOd01JSUFGQ0FEY0RFQ0FCUWdBM0F4Z2dBRUYvTmdKSUlBQkJBRFlDT0NBQVFRQTJBandnQUVFQU5nSk1JQUJCZ0FGcUlnQkNBRGNEQUNBQVFnQTNBd2dMTkFFQmZ5TUVJUUVqQkVFUWFpUUVJQUVRU3hvZ0FDQUJLQUlBckVLQXJlSUVma0tBZ1BxcDdidnN6Z0Y4TndNQUlBRWtCQXVQQVFFRWZ5QUFRUmhxSWdJUXZRSWdBRUdZTW1vaUFVSUFOd0lBSUFGQ0FEY0NDQ0FBUVJCcUlnRkJBRFlDQUNBQVFRQTJBZ0FnQUVFQU9nQUVJQUJCQURZQ0NDQUFRUUEyQWd4QkFDUUZRUWRCZ0lBRUVBVWhBeU1GSVFSQkFDUUZJQVJCQVhFRVFCQVhJUUFnQWhDT0FTQUFFQjRGSUFFZ0F6WUNBQ0FBUVFBMkFoUWdBRUhvTVdwQkFEb0FBQXNMaHdFQkFYOGpCQ0VDSXdSQk1Hb2tCQ0FDSUFGQkFYUkJQbkUyQWdBZ0FpQUJRUVYyUVQ5eE5nSUVJQUlnQVVFTGRrRWZjVFlDQ0NBQ0lBRkJFSFpCSDNFMkFnd2dBaUFCUVJWMlFROXhRWDlxTmdJUUlBSWdBVUVaZGtIUUFHbzJBaFFnQWtGL05nSWdJQUFnQWhCR3JFS0FyZUlFZmtLQWdQcXA3YnZzemdGOE53TUFJQUlrQkF0NEFRRi9Jd1FoQVNNRVFSQnFKQVFnQVNBQUtRTUFRb0NBaHRhU3hKT3hmbnhDZ0szaUJJQStBZ0FnQVJCRklnQW9BZ3hCRUhRZ0FDZ0NGRUVaZEVHQWdJQ0FCbXB5SUFBb0FoQkJGWFJCZ0lDQUFXcHlJQUFvQWdoQkMzUnlJQUFvQWdSQkJYUnlJQUFvQWdCQkFYWnlJUUFnQVNRRUlBQUxmd0VCZnlNRUlRSWpCRUV3YWlRRUlBSWdBU2dDRkRZQ0FDQUNJQUVvQWhBMkFnUWdBaUFCS0FJTU5nSUlJQUlnQVNnQ0NEWUNEQ0FDSUFFb0FnUkJmMm8yQWhBZ0FpQUJLQUlBUVpSeGFqWUNGQ0FDUVg4MkFpQWdBQ0FDRUVhc1FvQ3Q0Z1IrUW9DQStxbnR1K3pPQVh3Z0FTZ0NHSzE4TndNQUlBSWtCQXVaQVFFQ2Z5TUVJUU1qQkVFUWFpUUVJQU1nQUNrREFFS0FnSWJXa3NTVHNYNThRb0N0NGdTQVBnSUFJQUVnQXhCRklnSW9BaFJCN0E1cU5nSUFJQUVnQWlnQ0VFRUJhallDQkNBQklBSW9BZ3cyQWdnZ0FTQUNLQUlJTmdJTUlBRWdBaWdDQkRZQ0VDQUJJQUlvQWdBMkFoUWdBU0FBS1FNQVFvQ3Q0Z1NDUGdJWUlBRWdBaWdDR0RZQ0hDQUJJQUlvQWh3MkFpQWdBeVFFQ3gwQUlBQWdBYXhDZ0szaUJINUNnSUQ2cWUyNzdNNEJmRGNEQUNBQUMrb0VBUWwvSUFWQkFFY2lCaUFEUVFGTGNVVUVRRUVBSVFFZ0JVRi9haUVDSUFRZ0JnUi9RUUFGSUFJTFFRSjBha0VBTmdJQUR3c2dBRUVFYWlFS0lBSXRBQUJCQ0hRaERFRUJJUVlnQUVFSWFpSU5LQUlBSVFBQ1FBTkFJQUFFZnlBS0xBQUFJUXNnQUFVZ0NpQUNJQVpxTEFBQUlnQTZBQUFnRFVFSU5nSUFJQVpCQVdvaEJpQUFJUXRCQ0FzaERnSkFBa0FDUUFKQUFrQUNRQ0FMUWY4QmNVRUdkZzRFQUFFQ0F3UUxJQVFnQjBFQ2RHb2dBaUFHYWkwQUFEWUNBQ0FHUVFGcUlRWWdCMEVCYWlFQURBUUxJQVFnQjBFQ2RHb2dEQ0FDSUFacUxRQUFjallDQUNBR1FRRnFJUVlnQjBFQmFpRUFEQU1MSUFRZ0IwRUNkR29nQWlBR1FRRnFhaTBBQUVFSWRDQUNJQVpxTFFBQWNqWUNBQ0FHUVFKcUlRWWdCMEVCYWlFQURBSUxJQVpCQVdvaENDQUNJQVpxTFFBQUlnQkJnQUZ4QkVBZ0JrRUNhaUVHSUFjZ0JVOEVRQ0FISVFBTUF3c2dBaUFJYWkwQUFDRUpJQUJCL3dCeFFRSnFJUWdnQnlFQUEwQWdCQ0FBUVFKMGFpQUJJQUJxTFFBQUlBbHFRZjhCY1NBTWNqWUNBQ0FJUVg5cUlRY2dBRUVCYWlJQUlBVkpJQWhCQVVweEJFQWdCeUVJREFFTEN3VWdCeUFGVHdSQUlBZ2hCaUFISVFBTUF3c2dBRUVDYWlFSklBY2hBQU5BSUFRZ0FFRUNkR29nQVNBQWFpd0FBRFlDQUNBSlFYOXFJUVlnQUVFQmFpSUFJQVZKSUFsQkFVcHhCRUFnQmlFSkRBRUZJQWdoQmdzTEN3d0JDd3dDQ3lBS0lBdEIvd0Z4UVFKME9nQUFJQTBnRGtGK2FpSUlOZ0lBSUFBZ0JVa2lCeUFHSUFOSmNRUkFJQUFoQnlBSUlRQU1BUVVnQUNFQklBY2hBQXNMSUFWQmYyb2hBaUFFSUFBRWZ5QUJCU0FDQzBFQ2RHcEJBRFlDQUFzTEhnQWdBRUVBT2dBRUlBQkJBRFlDQ0NBQVFRQTJBZ3dnQUVFQU5nSVFDMFVCQW44Z0FFRVVhaUlDS0FJQVFRTkpCRUJCQUE4TElBQkJHR29oQTBGL0lBQW9BZ0JCQW1vZ0FRUi9JQU1GSUFJTEtBSUFRWDVxRUprQlFmLy9BM0ZCLy84RGN3dElBUU4vSUFCQkdHb2lBaWdDQUNJQlFRRnFJZ01nQUNnQ0ZFOEVRRUVBRHdzZ0FDZ0NBQ0lBSUFOcUxRQUFRUWgwSUFBZ0FXb3RBQUJ5SVFBZ0FpQUJRUUpxTmdJQUlBQUx3UVFCQ244akJDRURJd1JCRUdva0JDQURRUWhxSVFVZ0FFRWNhaUlMS0FJQVJRUkFJQUZGQkVBZ0F5UUVRUUFQQ3lBQVFRUnFJZ1lvQWdBZ0FXb2hBaUFHSUFJMkFnQWdBaUFBUVFocUlnY29BZ0FpQkVzRVFDQUFLQUlNSWdoQkFFY2dBaUFJUzNFRVFDQUZJQWcyQWdCQnJQVUNRZGdiSUFVUVlFR3M5UUlRVmlBSEtBSUFJUVFnQmlnQ0FDRUNDeUFBS0FJQUlBSWdCRUVnYWlBRVFRSjJhaUlFU3dSL0lBSWlCQVVnQkFzUVZ5SUNSUVJBUWF6MUFoQldDeUFBSUFJMkFnQWdCeUFFTmdJQUJTQUFLQUlBSVFJTElBQW9BaEFpQkNBQ0lBQkJGR29pQUNnQ0FHb2dBU0FFS0FJQUtBSU1RUjl4UWNvQWFoRUJBQ0VCSUFBZ0FDZ0NBQ0FCYWpZQ0FDQURKQVFnQVE4TElBTWhCQ0FBUVFScUlnWW9BZ0FpQlNBQVFSUnFJZ2NvQWdBaUFtc2lBeUFCU1FSL0lBWkJBQ0FCSUFOcklnSnJRUTl4SUFKcUlnZ2dCV29pQWpZQ0FDQUNJQUJCQ0dvaUNTZ0NBQ0lEU3dSQUlBQW9BZ3dpQ2tFQVJ5QUNJQXBMY1FSQUlBUWdDallDQUVHczlRSkIyQnNnQkJCZ1FhejFBaEJXSUFrb0FnQWhBeUFHS0FJQUlRSUxJQUFvQWdBZ0FpQURRU0JxSUFOQkFuWnFJZ05MQkg4Z0FnVWdBeUlDQ3hCWElnTkZCRUJCclBVQ0VGWUxJQUFnQXpZQ0FDQUpJQUkyQWdBRklBQW9BZ0FoQXdzZ0FDRUNJQUFvQWhBaUFDQURJQVZxSUFnZ0FDZ0NBQ2dDREVFZmNVSEtBR29SQVFBaEFDQUxLQUlBSUFJb0FnQWdCV29nQ0JEcUFTQUhLQUlBSUFBRWZ5QUJCVUVBQzJvRklBSWdBU0lBYWdzaEFTQUhJQUUyQWdBZ0JDUUVJQUFMRVFBZ0FDQUJJQUlnQTBFQVFRQVF1UUlMUXdFQmZ5QUNSUVJBSUFBUEN3TkFJQUVnQTJvdEFBQWdBRUgvL3dOeGFpSUFRUTkyUVFGeElBQkJBWFJ5UWYvL0EzRWhBQ0FEUVFGcUlnTWdBa2NOQUFzZ0FBdkZCQUVEZjBIQTlRSW9BZ0FFUUVFQUlRQUZRUUFoQUFOQUlBQkJBWFlpQWtHZ2h1THRmbk1oQVNBQVFRRnhCSDhnQVFVZ0FpSUJDMEVCZGlJRFFhQ0c0dTErY3lFQ0lBRkJBWEVFZnlBQ0JTQURJZ0lMUVFGMklnTkJvSWJpN1g1eklRRWdBa0VCY1FSL0lBRUZJQU1pQVF0QkFYWWlBMEdnaHVMdGZuTWhBaUFCUVFGeEJIOGdBZ1VnQXlJQ0MwRUJkaUlEUWFDRzR1MStjeUVCSUFKQkFYRUVmeUFCQlNBRElnRUxRUUYySWdOQm9JYmk3WDV6SVFJZ0FVRUJjUVIvSUFJRklBTWlBZ3RCQVhZaUEwR2dodUx0Zm5NaEFTQUNRUUZ4Qkg4Z0FRVWdBeUlCQzBFQmRpSUNRYUNHNHUxK2N5RURJQUJCQW5SQnZQVUNhaUFCUVFGeEJIOGdBd1VnQWdzMkFnQWdBRUVCYWlJQVFZQUNSdzBBUVFBaEFBc0xBMEFnQUVFQ2RFRzgvUUpxSUFCQkFuUkJ2UFVDYWlnQ0FDSUJRZjhCY1VFQ2RFRzg5UUpxS0FJQUlBRkJDSFp6SWdFMkFnQWdBRUVDZEVHOGhRTnFJQUZCL3dGeFFRSjBRYnoxQW1vb0FnQWdBVUVJZG5NaUFUWUNBQ0FBUVFKMFFieU5BMm9nQVVIL0FYRkJBblJCdlBVQ2FpZ0NBQ0FCUVFoMmN5SUJOZ0lBSUFCQkFuUkJ2SlVEYWlBQlFmOEJjVUVDZEVHODlRSnFLQUlBSUFGQkNIWnpJZ0UyQWdBZ0FFRUNkRUc4blFOcUlBRkIvd0Z4UVFKMFFiejFBbW9vQWdBZ0FVRUlkbk1pQVRZQ0FDQUFRUUowUWJ5bEEyb2dBVUgvQVhGQkFuUkJ2UFVDYWlnQ0FDQUJRUWgyY3lJQk5nSUFJQUJCQW5SQnZLMERhaUFCUWY4QmNVRUNkRUc4OVFKcUtBSUFJQUZCQ0haek5nSUFJQUJCQVdvaUFFR0FBa2NOQUFzTENRQkJ2YndERU5FRUN4c0JBWDhqQkNFQkl3UWdBR29rQkNNRVFROXFRWEJ4SkFRZ0FRc0xtbU5lQUVHQUNBdmxCVGdUQUFCVUZnQUFuQklBQUY0V0FBQ1FCQUFBQUFBQUFIUVNBQUNZR2dBQUhCTUFBSW9hQUFBQUFBQUFHQVFBQUJ3VEFBQjdHZ0FBQVFBQUFCZ0VBQUIwRWdBQVZob0FBRlFUQUFBWEdnQUFBQUFBQUFFQUFBQ0lCQUFBQUFBQUFIUVNBQUFNR2dBQVZCTUFBS2NaQUFBQUFBQUFBUUFBQUlnRUFBQUFBQUFBZEJJQUFKY1pBQUIwRWdBQTVoa0FBSFFTQUFDeEdnQUFWQk1BQUZzZkFBQUFBQUFBQVFBQUFJZ0VBQUFBQUFBQWRCSUFBRWdmQUFCMEVnQUFLUjhBQUhRU0FBQUtId0FBZEJJQUFPc2VBQUIwRWdBQXpCNEFBSFFTQUFDdEhnQUFkQklBQUk0ZUFBQjBFZ0FBYng0QUFIUVNBQUJRSGdBQWRCSUFBREVlQUFCMEVnQUFFaDRBQUhRU0FBRHpIUUFBZEJJQUFOUWRBQUIwRWdBQUlUZ0FBSndTQUFDQk9BQUFNQVVBQUFBQUFBQ2NFZ0FBTGpnQUFFQUZBQUFBQUFBQWRCSUFBRTg0QUFDY0VnQUFYRGdBQUNBRkFBQUFBQUFBbkJJQUFLUTVBQUFZQlFBQUFBQUFBSndTQUFDeE9RQUFHQVVBQUFBQUFBQ2NFZ0FBd1RrQUFHZ0ZBQUFBQUFBQW5CSUFBUFk1QUFBd0JRQUFBQUFBQUp3U0FBRFNPUUFBaUFVQUFBQUFBQUNjRWdBQUdEb0FBREFGQUFBQUFBQUFBQk1BQUVBNkFBQUFFd0FBUWpvQUFBQVRBQUJGT2dBQUFCTUFBRWM2QUFBQUV3QUFTVG9BQUFBVEFBQkxPZ0FBQUJNQUFFMDZBQUFBRXdBQVR6b0FBQUFUQUFCUk9nQUFBQk1BQUZNNkFBQUFFd0FBVlRvQUFBQVRBQUJYT2dBQUFCTUFBRms2QUFBQUV3QUFXem9BQUp3U0FBQmRPZ0FBTUFVQUFBQUFBQUNjRWdBQWZqb0FBQ0FGQUFBQUFBQUFXQUFBQUFBQUFBQlVBQUFBQUFBQUFGRUFBQUJQQUFBQUFBQUFBQzRBQUFBQUFBQUFjd0FBQUdZQUFBQjRBQUFBQUFBQUFDOEFBQUFBQUFBQUxnQUFBSElBQUFCaEFBQUFjZ0FBQUFBQUFBQmxBQUFBZUFBQUFHVUFBQUFBQUFBQWNnQUFBR0VBQUFCeUFBQUFBQUFBQURBQUFBQXdBQUFBQUFBQUFEOEFBQUFxQUFBQVBBQUFBRDRBQUFCOEFBQUFJZ0FBQUFBQUFBQS9BQUFBS2dCQjhBMExoUVVJQkFBQUFRQUFBQUlBQUFBQkFBQUFBZ0FBQUFFQUFBQUJBQUFBUXdBQUFFMEFBQUJVQUFBQUFBQUFBRHNBQUFBbEFBQUFkUUFBQUFBQUFBQlNBQUFBVWdBQUFBQUFBQUQvLy8vL1h3QUFBRjhBQUFCeUFBQUFZUUFBQUhJQUFBQmZBQUFBQUFBQUFDb0FBQUEvQUFBQUFBQUFBRFVBQUFDSGFGZXRBUUFBQURrQUFBQis1ZGM4QWdBQUFIZ0FBQUEvaVdrM0F3QUFBQjBBQUFCOUJ3WU9CZ0FBQUpVQUFBRElYU3djQkFBQUFOZ0FBQUFCNTRXOEJRQUFBSmd2aWtLUlJEZHh6L3ZBdGFYYnRlbGJ3bFk1OFJIeFdhU0NQNUxWWGh5cm1Lb0gyQUZiZ3hLK2hURWt3MzBNVlhSZHZuTCtzZDZBcHdiY20zVHhtOEhCYVp2a2hrZSs3OGFkd1EvTW9Rd2tieXpwTGFxRWRFcmNxYkJjMm9qNWRsSlJQcGh0eGpHb3lDY0RzTWQvV2IvekMrREdSNUduMVZGanlnWm5LU2tVaFFxM0p6Z2hHeTc4YlN4TkV3MDRVMVJ6Q21XN0NtcDJMc25DZ1lVc2NwS2g2TCtpUzJZYXFIQ0xTOEtqVVd6SEdlaVMwU1FHbWRhRk5RNzBjS0JxRUJiQnBCa0liRGNlVEhkSUo3VzhzRFN6REJ3NVNxcllUay9LbkZ2emJ5NW83b0tQZEc5anBYZ1VlTWlFQ0FMSGpQci92cERyYkZDazk2UDV2dko0Y2NabjVnbHFoYTVudTNMemJqdzY5VStsZjFJT1VZeG9CWnVyMllNZkdjM2dXMVVBQUFCUEFBQUFWd0FBQUFBQUFBQWdBQUFBQUFBQUFBZ0FBQUFJQUFBQUNBQUFBQWdBQUFBSUFBQUFJQUFBQUFBQUFBQWdBQUFBSUFBQUFEOEFBQUFBQUFBQUpRQUFBSE1BQUFBbEFBQUFjd0FBQUNBQUFBQUFBQUFBQ0FBQUFBZ0FBQUFJQUFBQUNBQUFBQWdBQUFBZ0FBQUFJQUFBQUNBQUFBQWdBQUFBSUFBQUFBQUFBQUFnQUFBQUpRQUFBSE1BQUFBQUFBQUFJQUFBQUNBQUFBQWdBQUFBSUFBQUFDQUFRWUFUQzNHZ0FBQUEwQUFBQU9BQUFBRHdBQUFBK0FBQUFQd0FBQUQrQUFBQS93QUFBTUFBQUFDQUFBQUFrQUFBQUpnQUFBQ2NBQUFBc0FBQUFBRUFBQUFEQUFBQUJBQUFBQVFBQUFBRkFBQUFCZ0FBQUFjQUFBQUlBQUFBQ0FBQUFBUUFBQUFFQUFBQUJRQUFBQVlBQUFBR0FBQUFCQUJCL0JNTGNVQUFBQUJnQUFBQW9BQUFBTkFBQUFEZ0FBQUE4QUFBQVBnQUFBRDhBQUFBd0FBQUFJQUFBQUNRQUFBQW1BQUFBSndBQUFDd0FBQUFBZ0FBQUFNQUFBQURBQUFBQXdBQUFBUUFBQUFFQUFBQUJRQUFBQVlBQUFBR0FBQUFCQUFBQUFRQUFBQUZBQUFBQmdBQUFBWUFBQUFFQUVIMUZBc2xvQUFBQU1BQUFBRFFBQUFBNEFBQUFPb0FBQUR1QUFBQThBQUFBUElBQUVEeUFBRC8vd0JCckJVTFRnVUFBQUFIQUFBQUNRQUFBQTBBQUFBU0FBQUFGZ0FBQUJvQUFBQWlBQUFBSkFBQUFBQ0FBQUFBb0FBQUFNQUFBQURRQUFBQTRBQUFBT29BQUFEdUFBQUE4QUFBQVBJQUFBRHlBQUQvL3dCQmlCWUxSZ0lBQUFBREFBQUFCUUFBQUFjQUFBQUxBQUFBRUFBQUFCUUFBQUFZQUFBQUlBQUFBQ0FBQUFBQUVBQUFBQ1FBQUFDQUFBQUF3QUFBQVBvQUFQLy9BQUQvL3dBQS8vOEFRZWdXQ3hFQ0FBQUFCd0FBQURVQUFBQjFBQUFBNlFCQmhSY0xIU0FBQUFEQUFBQUE0QUFBQVBBQUFBRHlBQUFBOGdBQTRQY0FBUC8vQUVHOEZ3cytCQUFBQUN3QUFBQThBQUFBVEFBQUFGQUFBQUJRQUFBQWZ3QUFBQUNBQUFBQXdBQUFBT0FBQUFEeUFBQUE4Z0FBQVBJQUFBRHlBQUFBOGdBQS8vOEFRWkFZQ3pZSUFBQUFFQUFBQUJnQUFBQWhBQUFBSVFBQUFDRUFBQUFoQUFBQUlRQUFBQUQvQUFELy93QUEvLzhBQVAvL0FBRC8vd0FBLy84QVFld1lDd0gvQUVIOUdBc1pDQUFBQUNRQUFBRHVBQUNBL2dBQS8vOEFBUC8vQUFELy93QkJ0QmtMRFFJQUFBQVFBQUFBMmdBQUFQc0FRZEFaQzVzRUFRQUFBQUlBQUFBREFBQUFCQUFBQUFZQUFBQUlBQUFBREFBQUFCQUFBQUFZQUFBQUlBQUFBREFBQUFCQUFBQUFZQUFBQUlBQUFBREFBQUFBQUFFQUFJQUJBQUFBQWdBQUFBTUFBQUFFQUFBQUJnQUFBQWdBQUFBTUFBQUFFQUFBQUJnQUFBQWdBQUFBTUFBQUFFQUFBQUJnQUFBQWdBQUFBTUFBQUFBQUFRQUFnQUVBQUFBQ0FBQUFBd0FBQUFRQUFBQUZBQUFBQmdBQUFBY0FBQUFJQUFBQUNRQUFBQW9BQUFBTEFBQUFEQUFBQUEwQUFBQU9BQUFBRHdBRUFBQUFBZ0FBQUFJQUFBQUNBQUFBQWdBQUFBSUFBQUFDQUFBQUFnQUFBQUlBQUFBQ0FBQUFBZ0FBQUFJQUFBQUNBQUFBQWdBQUFBSUFBQUFDQUFBQURnQUFBQUFBQUFBTUFBQUFUUUFBQUdFQUFBQjRBQUFBYVFBQUFHMEFBQUIxQUFBQWJRQUFBQ0FBQUFCaEFBQUFiQUFBQUd3QUFBQnZBQUFBZHdBQUFHVUFBQUJrQUFBQUlBQUFBR0VBQUFCeUFBQUFjZ0FBQUdFQUFBQjVBQUFBSUFBQUFITUFBQUJwQUFBQWVnQUFBR1VBQUFBZ0FBQUFLQUFBQUNVQUFBQjFBQUFBS1FBQUFDQUFBQUJwQUFBQWN3QUFBQ0FBQUFCbEFBQUFlQUFBQUdNQUFBQmxBQUFBWlFBQUFHUUFBQUJsQUFBQVpBQUFBQUFBQUFBcUFBQUFBQUFBQUNBRUFBQmdCQUFBSUFRQUFHZ0VBQUJvQkFBQXlBVUFBSUFFQUFBZ0JBQUFRQVFBQUNBRUFBRElCUUFBQUFBQUFKQUVBQUFEQUFBQUJBQUFBQU1BQUFBRUFBQUFBZ0FBQUFJQUFBRDREZ0FBRkFBQUFFTXVWVlJHTFRnQVFmZ2RDeGJlRWdTVkFBQUFBUC8vLy8vLy8vLy8vLy8vLzl3T0FFR2tIZ3ZSQVFJQUFNQURBQURBQkFBQXdBVUFBTUFHQUFEQUJ3QUF3QWdBQU1BSkFBREFDZ0FBd0FzQUFNQU1BQURBRFFBQXdBNEFBTUFQQUFEQUVBQUF3QkVBQU1BU0FBREFFd0FBd0JRQUFNQVZBQURBRmdBQXdCY0FBTUFZQUFEQUdRQUF3Qm9BQU1BYkFBREFIQUFBd0IwQUFNQWVBQURBSHdBQXdBQUFBTE1CQUFEREFnQUF3d01BQU1NRUFBRERCUUFBd3dZQUFNTUhBQUREQ0FBQXd3a0FBTU1LQUFEREN3QUF3d3dBQU1NTkFBRFREZ0FBd3c4QUFNTUFBQXk3QVFBTXd3SUFETU1EQUF6REJBQU0wL1FQQUFBSkFFR0FJQXNCQVFCQmxDQUxFZ1VBQUFBQUFBQUFCZ0FBQUNRQkFRQUFCQUJCd0NBTEJQLy8vLzhBUWZBZ0N3VjBFQUFBQlFCQmdDRUxBUUVBUVpnaEN3c0hBQUFBQmdBQUFDd0ZBUUJCc0NFTEFRSUFRYjhoQ3dYLy8vLy8vd0JCckNNTEF2RGRBRUdJSkFzQkNBQkJyeVFMQmYvLy8vLy9BRUhnSkF1TkRDVUFBQUFBQUFBQUFRQUFBQUFBQUFBZ0JRQUFCUUFBQUFZQUFBQUhBQUFBQ0FBQUFBa0FBQUFCQUFBQUFRQUFBQUVBQUFBQUFBQUFTQVVBQUFVQUFBQUpBQUFBQndBQUFBZ0FBQUFKQUFBQUFnQUFBQUlBQUFBQ0FBQUFBQUFBQUZnRkFBQUtBQUFBQ3dBQUFBSUFBQUFBQUFBQWFBVUFBQXdBQUFBTkFBQUFBd0FBQUFBQUFBQjRCUUFBREFBQUFBNEFBQUFEQUFBQUFBQUFBS2dGQUFBRkFBQUFEd0FBQUFjQUFBQUlBQUFBQ2dBQUFBQUFBQUNZQlFBQUJRQUFBQkFBQUFBSEFBQUFDQUFBQUFzQUFBQUFBQUFBS0FZQUFBVUFBQUFSQUFBQUJ3QUFBQWdBQUFBTUFBQUFBQUFBQURnR0FBQUZBQUFBRWdBQUFBY0FBQUFJQUFBQUNRQUFBQU1BQUFBREFBQUFBd0FBQUVrQU1RRlRBSDhCTUFGcEFIZ0Ivd0NCQVZNQ2dnR0RBWVFCaFFHR0FWUUNod0dJQVlrQlZnS0tBVmNDaXdHTUFZNEIzUUdQQVZrQ2tBRmJBcEVCa2dHVEFXQUNsQUZqQXBZQmFRS1hBV2dDbUFHWkFad0Jid0tkQVhJQ253RjFBcVlCZ0FLbkFhZ0JxUUdEQXF3QnJRR3VBWWdDcndHd0FiRUJpZ0t5QVlzQ3R3R1NBcmdCdVFHOEFiMEJ4QUhHQWNRQnhRSEZBY1lCeHdISkFjY0J5QUhJQWNrQnlnSE1BY29CeXdITEFjd0I4UUh6QWZFQjhnSHlBZk1COUFIMUFmWUJsUUgzQWI4QklBS2VBWVlEckFPSUE2MERpUU91QTRvRHJ3T01BOHdEamdQTkE0OER6Z09aQTBVRG1RTytINk1Ed2dQM0EvZ0QrZ1A3QTJBZW14NmVIdDhBV1I5Ukgxc2ZVeDlkSDFVZlh4OVhIN3dmc3gvTUg4TWY3Qi9sSC93Zjh4ODZBbVVzT3dJOEFqMENtZ0UrQW1Zc1FRSkNBa01DZ0FGRUFva0NSUUtNQXZRRHVBUDVBL0lEL1FON0EvNERmQVAvQTMwRHdBVFBCQ1loeVFNcUlXc0FLeUhsQURJaFRpR0RJWVFoWUN4aExHSXNhd0pqTEgwZFpDeDlBbTBzVVFKdUxIRUNieXhRQW5Bc1VnSnlMSE1zZFN4MkxINHNQd0ovTEVBQzhpenpMSDJuZVIyTHA0eW5qYWRsQXFxblpnTEhFQ2N0elJBdExYWURkd09jQTdVQWtnUFFBNWdEMFFPbUE5VURvQVBXQTVvRDhBT2hBL0VEbFFQMUE4OEQxd01BQUFBQVFRQWdHc0FBSUI4QUFRRXZNZ0VCQlRrQkFROUtBUUV0ZVFFQkJYQURBUU9SQXlBUm93TWdDUUFFVUJBUUJDQWdZQVFCSVlvRUFUWEJCQUVOMEFRQlB4UUZBUk14QlRBbW9BRUJCYk1CQVFQTkFRRVAzZ0VCRWZnQkFTY2lBZ0VSMkFNQkZ3QWVBWldnSGdGZkNCLzRDQmdmK0FZb0gvZ0lPQi80Q0VnZitBWm9IL2dJaUIvNENKZ2YrQWlvSC9nSXVCLzRBcm9mdGdMSUg2b0UyQi80QXRvZm5BTG9IL2dDNmgrUUF2Z2ZnQUw2SDRJQ1JnSUJDUkFGQVFOZ0lSQVFBQ3d3TDJjc0FRV0FMQUZqNnl3QkEwQ21BUzJBcGdFWElxY0JEVEtuQVQxNXB3RURmcWNCQ1pDbkFRT2dwd0VKSWY4Z0dnQUFBQUE0VWtGU1gwVllTVlFBTjBGeVkyaHBkbVVBMXhPVkkwbkZ3TTM1SEJCM01OMENLdWdCc2VrT1dOc1ozOFAwV2xmdm1Zbi94NU5HWEVMMkRkZ29QaDNaNWxZR1J4aXJ4R1Z4Mm50ZFc2T3l5a01zNjJ2NlMrb3hwMzNUVTNLZGtDREJqeVNlZlBlN1dkYU5MM25rUFlMVndxNzdZVzQyNVhNNW1GNXA4OVEzMGZVL0M2VElINXhSc09NVlRHT0x2SDhSK0RQUGVMM1NDT0lwU0xmTGg2V21QR0lIZWlhYnFrV3MvTzRuaGp1QTdCdndVSU1EVmM2UlQ1cU9uOXpKaFVwQUZJSGd1WXBucmJZckl2NVN4cGZudERvS2RocG1EREtFRnIrSWI2S3pMUVNVYktFNFRuN3kzZyt2a2hjaDhiVytUZUVBTHFtNlJGL3RRVFhRL2FnSkVtUTBkTGlnWUcwbEhtcU1hSllGekhWd1ZBUUVCZ1lBQUFjSEJBUUFBQVFFQUFBQUFRSURCQVVHQndnSkNnc01EUTRQRGdvRUNBa1BEUVlCREFBQ0N3Y0ZBd3NJREFBRkFnOE5DZzREQmdjQkNRUUhDUU1CRFF3TERnSUdCUW9FQUE4SUNRQUZCd0lFQ2c4T0FRc01CZ2dERFFJTUJnb0FDd2dEQkEwSEJROE9BUWtNQlFFUERnMEVDZ0FIQmdNSkFnZ0xEUXNIRGd3QkF3a0ZBQThFQ0FZQ0NnWVBEZ2tMQXdBSURBSU5Cd0VFQ2dVS0FnZ0VCd1lCQlE4TENRNEREQTBBM1E2SkYzYVRQMFBIMERLd2lwRitKWFFmaXFtaExCTGh5c2lBRlFEeXlrOWNQejljQUM4L1B5OEFHUTRKQndVRkJBUUVBd01EQWdJQ0FnQUJBZ01FQlFZSENBb01EaEFVR0J3Z0tEQTRRRkJnY0lDZ3dPQUFRZlV3QzZVU0FRRUJBUUlDQWdJREF3TURCQVFFQkFVRkJRVUFBQUFBQVFFQ0FnTURCQVFGQlFZR0J3Y0lDQWtKQ2dvTEN3d01EUTBPRGc4UEVCQVFFQkFRRUJBUUVCQVFFQkFBQkFnUUlFQ0F3QUlDQXdRRkJnWUdhV2tBZGdCU1lYSkJjbU5vYVhabEFIWnBBRzl3Wlc0QWFXbHBhV2xwQUdkbGRFWnBiR1ZJWldGa1pYSUFhV2xwQUhKbFlXUkdhV3hsQUdscGFXa0FVM1JoZEdVQWFRQmxjbkpEYjJSbEFIWnBhV2tBWlhKeVZIbHdaUUJCY21OSVpXRmtaWElBYzNSaGRHVUFZMjl0YldWdWRBQm1iR0ZuY3dCQmNtTkdhV3hsU0dWaFpHVnlBRzVoYldVQWNHRmphMU5wZW1VQVpHbHBBSFpwYVdRQWRXNXdVMmw2WlFCb2IzTjBUMU1BWTNKakFIUnBiV1VBZFc1d1ZtVnlBRzFsZEdodlpBQm1hV3hsUVhSMGNnQXhNMEZ5WTBacGJHVklaV0ZrWlhJQVRsTjBNMTlmTWpFeVltRnphV05mYzNSeWFXNW5TWGRPVTE4eE1XTm9ZWEpmZEhKaGFYUnpTWGRGUlU1VFh6bGhiR3h2WTJGMGIzSkpkMFZGUlVVQVRsTjBNMTlmTWpJeFgxOWlZWE5wWTE5emRISnBibWRmWTI5dGJXOXVTVXhpTVVWRlJRQTVRWEpqU0dWaFpHVnlBRTVUZEROZlh6SXhNbUpoYzJsalgzTjBjbWx1WjBsalRsTmZNVEZqYUdGeVgzUnlZV2wwYzBsalJVVk9VMTg1WVd4c2IyTmhkRzl5U1dORlJVVkZBRFZUZEdGMFpRQkZVbEpmVUZKUFEwVlRVd0JGVWxKZlVrVkJSQUJGVWxKZlQxQkZUZ0JRU3pFd1VtRnlRWEpqYUdsMlpRQlFNVEJTWVhKQmNtTm9hWFpsQURFd1VtRnlRWEpqYUdsMlpRQlRSVlFBUlU1RUFFTlZVZ0EwUm1sc1pRQjJiMmxrQUdKdmIyd0FZMmhoY2dCemFXZHVaV1FnWTJoaGNnQjFibk5wWjI1bFpDQmphR0Z5QUhOb2IzSjBBSFZ1YzJsbmJtVmtJSE5vYjNKMEFHbHVkQUIxYm5OcFoyNWxaQ0JwYm5RQWJHOXVad0IxYm5OcFoyNWxaQ0JzYjI1bkFHWnNiMkYwQUdSdmRXSnNaUUJ6ZEdRNk9uTjBjbWx1WndCemRHUTZPbUpoYzJsalgzTjBjbWx1Wnp4MWJuTnBaMjVsWkNCamFHRnlQZ0J6ZEdRNk9uZHpkSEpwYm1jQVpXMXpZM0pwY0hSbGJqbzZkbUZzQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR05vWVhJK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhOcFoyNWxaQ0JqYUdGeVBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWJuTnBaMjVsWkNCamFHRnlQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHphRzl5ZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4ZFc1emFXZHVaV1FnYzJodmNuUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BHbHVkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkVzV6YVdkdVpXUWdhVzUwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhzYjI1blBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWJuTnBaMjVsWkNCc2IyNW5QZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHBiblE0WDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWcGJuUTRYM1ErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR2x1ZERFMlgzUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnBiblF4Tmw5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4cGJuUXpNbDkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYVc1ME16SmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhabXh2WVhRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdSdmRXSnNaVDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhiRzl1WnlCa2IzVmliR1UrQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1dWRlJRQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbGtSVVVBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKWmtWRkFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXMUZSUUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxzUlVVQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmFrVkZBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTV2xGUlFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsMFJVVUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpjMFZGQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1doRlJRQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbGhSVVVBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKWTBWRkFFNHhNR1Z0YzJOeWFYQjBaVzR6ZG1Gc1JRQk9VM1F6WDE4eU1USmlZWE5wWTE5emRISnBibWRKYUU1VFh6RXhZMmhoY2w5MGNtRnBkSE5KYUVWRlRsTmZPV0ZzYkc5allYUnZja2xvUlVWRlJRQVNFUk1VRlJZWEdCa2FHeHdkSGg4Z0lSRWlJeVFSSlNZbktDa3FLeXdSTFM0dkVCQXdFQkFRRUJBUUVERXlNeEEwTlJBUUVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVRZUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFM0VSRVJFVGdST1RvN1BEMCtFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVSRVJFUkVUOFFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUlFFRVJRa05FUlVaSFNFa1FFQkJLUzB4TlRoQVFFRTlRRUJBUUVGRVFFQkFRRUJBUUVCQVJFUkZTVXhBUUVCQVFFQkFRRUJBUUVSRVJFVlFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVJFVlVRRUJBUVZoQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQlhFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQllXVnBiRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVGd1FFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQkJ1c01BQ3lELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vd0JCNHNNQUN6YisvLzhIL3YvL0J3QUFBQUFBQkNBRS8vOS8vLy8vZi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9EL3dNQUgxQUFRYUxFQUF1a0FTQUFBQUFBQU44OFFOZi8vL3YvLy8vLy8vLy8vLysvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzhEL1AvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy84QS92Ly8vMzhDL3YvLy8vOEFBQUFBQVArL3RnRC8vLzhIQndBQUFQOEgvLy8vLy8vLy8vNy93Ly8vLy8vLy8vLy8vLy8vLys4Zi91SC9ud0FBLy8vLy8vLy9BT0QvLy8vLy8vLy8vLy8vLy84REFQLy8vLy8vQnpBRS8vLy8vUDhmQUFELy8vOEJBRUhPeFFBTDVBSDlId0FBQUFBQUFQQUQvMy8vLy8vLy8vLy83Ly9mNGYvUC8vNys3cC81Ly8vOXhlT2ZXWUN3ei84REFPNkgrZi8vL1czRGh4a0NYc0QvUHdEdXYvdi8vLzN0NDc4YkFRRFAvd0FBN3AvNS8vLzk3ZU9mR2NDd3ovOENBT3pIUGRZWXgvL0R4eDJCQU1EL0FBRHUzLzMvLy8zdjQ5OGRZQVBQL3dBQTdOLzkvLy85NytQZkhXQkF6LzhHQU96Zi9mLy8vLy9uMzEyQUFNLy9BUHpzLzMvOC8vLzdMMytBWC84QUFBd0Evdi8vLy85Ly93Yy9JUDhEQUFBQUFKWWw4UDZ1N1A4N1h5RC84d0FBQUFBQkFBQUEvd01BQVAvKy8vLy9ILzcvQS8vLy92Ly8veDhBUWJySEFBdVZBdi8vLy8vLy8zLzUvd1AvLytmQi8vOS9RUDh6Ly8vLy83OGcvLy8vLy8vMy8vLy8vLy8vLy8vL1BYODkvLy8vLy84OS8vLy8vejEvUGY5Ly8vLy8vLy8vL3ozLy8vLy8vLy8vLzRjQUFBQUEvLzhBQVAvLy8vLy8vLy8vLy84ZkFQNy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy81Ly8vLzcvL3dmLy8vLy8vLy8vLy8vSEFRRC8zdzhBLy84UEFQLy9Ed0QvM3cwQS8vLy8vLy8vei8vL0FZQVEvd01BQUFBQS93UC8vLy8vLy8vLy8vLy8vd0QvLy8vLy93Zi8vLy8vLy8vLy96OEEvLy8vSC84UC93SEEvLy8vL3o4ZkFQLy8vLy8vRC8vLy93UC9Bd0FBQUFELy8vOFAvLy8vLy8vLy8zLysveDhBL3dQL0E0QUFRZHJKQUFzdy8vLy8vLy8vNy8vdkQvOERBQUFBQVAvLy8vLy84Ly8vLy8vLy83Ly9Bd0QvLy8vLy8vOC9BUC9qLy8vLy8vOC9BRUdYeWdBTEc5NXZBUC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy93QkJ1c29BQ3lELy96OC8vLy8vL3o4Ly82ci8vLzgvLy8vLy8vLy8zMS9jSDg4UC94L2NId0JCNk1vQUN3WUNnQUFBL3g4QVFmcktBQXNTaFB3dlBsQzkvL1BnUXdBQS8vLy8vLzhCQUVHd3l3QUxVTUQvLy8vLy8vOERBQUQvLy8vLy8zLy8vLy8vLzMvLy8vLy8vLy8vLy8vLy8vLy8vLy8vSDNnTUFQLy8vLysvSVAvLy8vLy8vLytBQUFELy8zOEFmMzkvZjM5L2YzLy8vLy8vQUFBQUFBQ0FBRUdhekFBTFYrQUFBQUQrQXo0Zi92Ly8vLy8vLy8vLy8zL2cvdi8vLy8vLy8vLy8vLy8zNFAvLy8vOC8vdi8vLy8vLy8vLy8vLzkvQUFELy8vOEhBQUFBQUFBQS8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vUHdCQitzd0FDekwvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9Id0FBQUFBQUFQLy8vLy8vLy8vLy8vLy8vLy8vLy8vL0h3QkJ0TTBBQ3p6Ly8vLy8vei8vSC8vLy93OEFBUC8vLy8vL2YvQ1AvLy8vZ1AvLy8vLy8vLy8vLy84QUFBQUFnUC84Ly8vLy8vLy8vLy8vLy8vL2VROEEvd2NBUWZuTkFBdG4vN3YzLy8vL0FBQUEvLy8vLy8vL0R3RC8vLy8vLy8vLy93OEEvd01BQVB3SS8vLy8vLzhILy8vLy93Y0EvLy8vSC8vLy8vLy8vL2YvQUlEL0F3QUFBQUQvLy8vLy8vOS9BUDgvL3dQLy8zOEUvLy8vLy8vLy8zOEZBQUE0Ly84OEFINStmZ0IvZndCQjhzNEFDNGdCLy8vLy8vOEgvd1AvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL3c4QS8vOS8rUC8vLy8vL0QvLy8vLy8vLy8vLy8vLy8vLzgvLy8vLy8vLy8vLy8vLy8vLy93TUFBQUFBZndENDRQLzlmMS9iLy8vLy8vLy8vLy8vLy8vLy93TUFBQUQ0Ly8vLy8vLy8vLy8vLy8vL1B3QUEvLy8vLy8vLy8vLzgvLy8vLy8vL0FBQUFBQUQvRHdCQmlOQUFDMUxmLy8vLy8vLy8vLy8vLy8vLy8vLy8veDhBQVA4RC92Ly9CLzcvL3dmQS8vLy8vLy8vLy8vLy8zLzgvUHdjQUFBQUFQL3YvLzkvLy8rMy96Ly9Qd0FBQUFELy8vLy8vLy8vLy8vLy8vLy8vLzhIQUVIaTBBQUxCLy8vLy8vLy94OEFRWXJSQUF0Ry8vLy9ILy8vLy8vLy93RUFBQUFBQVAvLy8zOEFBUC8vL3djQUFBQUFBQUQvLy84Ly8vLy8vdy8vUGdBQUFBQUEvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vei8vQXdCQjJ0RUFDd3MvL2YvLy8vKy9rZi8vUHdCQit0RUFDd2ovL3o4QS8vLy9Bd0JCaXRJQUN3ai8vLy8vLy8vL3dBQkJtdElBQ3hCdjhPLysvLzhQQUFBQUFBRC8vLzhmQUVHNjBnQUxELy8vLy8vLy96OEEvLzgvQVAvL0J3QkIydElBQ3dyLy8vLy8vLy8vLy84QkFFSDYwZ0FMS1AvLy8vLy8vLy8vUHdBQUFNRC9BQUQ4Ly8vLy8vLy9BUUFBLy8vL0FmOEQvLy8vLy8vL3gvOEFRYXJUQUFzTS8vLy8vLy8vLy84ZUFQOERBRUhLMHdBTEh2Ly8vLy8vL3o4QS93TUFBQUFBQUFELy8vLy8vLy8vLy8vLy8vLy9md0JCK3RNQUN3My8vLy8vLy8vLy8vLy8vLzhIQUVHYTFBQUxCdi8vLy8vL2Z3QkJ1dFFBQ3dqLy8vLy8vLy8vQVFCQjJ0UUFDeFQvLy8vLy8vLy8veDhBLy8vLy8vOS9BQUQ0L3dCQit0UUFDd0VEQUVHYTFRQUxtQUgvLy8vLy8vLy8vLy8vMy8vLy8vLy8vLy8vMzJUZS8rdnYvLy8vLy8vLy83L24zOS8vLy85N1gvejkvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy84Ly8vLy8vZi8vOS8vLy8vZi8vOS8vLy8vZi8vOS8vLy8vZi8vLy8vMy8vLy85Ly8vM3ovLy8vLy8vLysvLy8vK1cvdmNLaE9xV3FwYjM5MTcvKy84UDd2di9Ed0JCdXRZQUMrc1BWQ0VpR1EwQkFnTVJTeHdNRUFRTEhSSWVKMmh1YjNCeFlpQUZCZzhURkJVYUNCWUhLQ1FYR0FrS0Roc2ZKU09EZ24wbUtpczhQVDQvUTBkS1RWaFpXbHRjWFY1ZllHRmpaR1ZtWjJscWEyeHljM1I1ZW50OEFFbHNiR1ZuWVd3Z1lubDBaU0J6WlhGMVpXNWpaUUJFYjIxaGFXNGdaWEp5YjNJQVVtVnpkV3gwSUc1dmRDQnlaWEJ5WlhObGJuUmhZbXhsQUU1dmRDQmhJSFIwZVFCUVpYSnRhWE56YVc5dUlHUmxibWxsWkFCUGNHVnlZWFJwYjI0Z2JtOTBJSEJsY20xcGRIUmxaQUJPYnlCemRXTm9JR1pwYkdVZ2IzSWdaR2x5WldOMGIzSjVBRTV2SUhOMVkyZ2djSEp2WTJWemN3QkdhV3hsSUdWNGFYTjBjd0JXWVd4MVpTQjBiMjhnYkdGeVoyVWdabTl5SUdSaGRHRWdkSGx3WlFCT2J5QnpjR0ZqWlNCc1pXWjBJRzl1SUdSbGRtbGpaUUJQZFhRZ2IyWWdiV1Z0YjNKNUFGSmxjMjkxY21ObElHSjFjM2tBU1c1MFpYSnlkWEIwWldRZ2MzbHpkR1Z0SUdOaGJHd0FVbVZ6YjNWeVkyVWdkR1Z0Y0c5eVlYSnBiSGtnZFc1aGRtRnBiR0ZpYkdVQVNXNTJZV3hwWkNCelpXVnJBRU55YjNOekxXUmxkbWxqWlNCc2FXNXJBRkpsWVdRdGIyNXNlU0JtYVd4bElITjVjM1JsYlFCRWFYSmxZM1J2Y25rZ2JtOTBJR1Z0Y0hSNUFFTnZibTVsWTNScGIyNGdjbVZ6WlhRZ1lua2djR1ZsY2dCUGNHVnlZWFJwYjI0Z2RHbHRaV1FnYjNWMEFFTnZibTVsWTNScGIyNGdjbVZtZFhObFpBQkliM04wSUdseklHUnZkMjRBU0c5emRDQnBjeUIxYm5KbFlXTm9ZV0pzWlFCQlpHUnlaWE56SUdsdUlIVnpaUUJDY205clpXNGdjR2x3WlFCSkwwOGdaWEp5YjNJQVRtOGdjM1ZqYUNCa1pYWnBZMlVnYjNJZ1lXUmtjbVZ6Y3dCQ2JHOWpheUJrWlhacFkyVWdjbVZ4ZFdseVpXUUFUbThnYzNWamFDQmtaWFpwWTJVQVRtOTBJR0VnWkdseVpXTjBiM0o1QUVseklHRWdaR2x5WldOMGIzSjVBRlJsZUhRZ1ptbHNaU0JpZFhONUFFVjRaV01nWm05eWJXRjBJR1Z5Y205eUFFbHVkbUZzYVdRZ1lYSm5kVzFsYm5RQVFYSm5kVzFsYm5RZ2JHbHpkQ0IwYjI4Z2JHOXVad0JUZVcxaWIyeHBZeUJzYVc1cklHeHZiM0FBUm1sc1pXNWhiV1VnZEc5dklHeHZibWNBVkc5dklHMWhibmtnYjNCbGJpQm1hV3hsY3lCcGJpQnplWE4wWlcwQVRtOGdabWxzWlNCa1pYTmpjbWx3ZEc5eWN5QmhkbUZwYkdGaWJHVUFRbUZrSUdacGJHVWdaR1Z6WTNKcGNIUnZjZ0JPYnlCamFHbHNaQ0J3Y205alpYTnpBRUpoWkNCaFpHUnlaWE56QUVacGJHVWdkRzl2SUd4aGNtZGxBRlJ2YnlCdFlXNTVJR3hwYm10ekFFNXZJR3h2WTJ0eklHRjJZV2xzWVdKc1pRQlNaWE52ZFhKalpTQmtaV0ZrYkc5amF5QjNiM1ZzWkNCdlkyTjFjZ0JUZEdGMFpTQnViM1FnY21WamIzWmxjbUZpYkdVQVVISmxkbWx2ZFhNZ2IzZHVaWElnWkdsbFpBQlBjR1Z5WVhScGIyNGdZMkZ1WTJWc1pXUUFSblZ1WTNScGIyNGdibTkwSUdsdGNHeGxiV1Z1ZEdWa0FFNXZJRzFsYzNOaFoyVWdiMllnWkdWemFYSmxaQ0IwZVhCbEFFbGtaVzUwYVdacFpYSWdjbVZ0YjNabFpBQkVaWFpwWTJVZ2JtOTBJR0VnYzNSeVpXRnRBRTV2SUdSaGRHRWdZWFpoYVd4aFlteGxBRVJsZG1salpTQjBhVzFsYjNWMEFFOTFkQ0J2WmlCemRISmxZVzF6SUhKbGMyOTFjbU5sY3dCTWFXNXJJR2hoY3lCaVpXVnVJSE5sZG1WeVpXUUFVSEp2ZEc5amIyd2daWEp5YjNJQVFtRmtJRzFsYzNOaFoyVUFSbWxzWlNCa1pYTmpjbWx3ZEc5eUlHbHVJR0poWkNCemRHRjBaUUJPYjNRZ1lTQnpiMk5yWlhRQVJHVnpkR2x1WVhScGIyNGdZV1JrY21WemN5QnlaWEYxYVhKbFpBQk5aWE56WVdkbElIUnZieUJzWVhKblpRQlFjbTkwYjJOdmJDQjNjbTl1WnlCMGVYQmxJR1p2Y2lCemIyTnJaWFFBVUhKdmRHOWpiMndnYm05MElHRjJZV2xzWVdKc1pRQlFjbTkwYjJOdmJDQnViM1FnYzNWd2NHOXlkR1ZrQUZOdlkydGxkQ0IwZVhCbElHNXZkQ0J6ZFhCd2IzSjBaV1FBVG05MElITjFjSEJ2Y25SbFpBQlFjbTkwYjJOdmJDQm1ZVzFwYkhrZ2JtOTBJSE4xY0hCdmNuUmxaQUJCWkdSeVpYTnpJR1poYldsc2VTQnViM1FnYzNWd2NHOXlkR1ZrSUdKNUlIQnliM1J2WTI5c0FFRmtaSEpsYzNNZ2JtOTBJR0YyWVdsc1lXSnNaUUJPWlhSM2IzSnJJR2x6SUdSdmQyNEFUbVYwZDI5eWF5QjFibkpsWVdOb1lXSnNaUUJEYjI1dVpXTjBhVzl1SUhKbGMyVjBJR0o1SUc1bGRIZHZjbXNBUTI5dWJtVmpkR2x2YmlCaFltOXlkR1ZrQUU1dklHSjFabVpsY2lCemNHRmpaU0JoZG1GcGJHRmliR1VBVTI5amEyVjBJR2x6SUdOdmJtNWxZM1JsWkFCVGIyTnJaWFFnYm05MElHTnZibTVsWTNSbFpBQkRZVzV1YjNRZ2MyVnVaQ0JoWm5SbGNpQnpiMk5yWlhRZ2MyaDFkR1J2ZDI0QVQzQmxjbUYwYVc5dUlHRnNjbVZoWkhrZ2FXNGdjSEp2WjNKbGMzTUFUM0JsY21GMGFXOXVJR2x1SUhCeWIyZHlaWE56QUZOMFlXeGxJR1pwYkdVZ2FHRnVaR3hsQUZKbGJXOTBaU0JKTDA4Z1pYSnliM0lBVVhWdmRHRWdaWGhqWldWa1pXUUFUbThnYldWa2FYVnRJR1p2ZFc1a0FGZHliMjVuSUcxbFpHbDFiU0IwZVhCbEFFNXZJR1Z5Y205eUlHbHVabTl5YldGMGFXOXVBQUJNUTE5QlRFd0FURU5mUTFSWlVFVUFBQUFBVEVOZlRsVk5SVkpKUXdBQVRFTmZWRWxOUlFBQUFBQUFURU5mUTA5TVRFRlVSUUFBVEVOZlRVOU9SVlJCVWxrQVRFTmZUVVZUVTBGSFJWTUFURUZPUndCRExsVlVSaTA0QUZCUFUwbFlBRTFWVTB4ZlRFOURVRUZVU0FBUkFBb0FFUkVSQUFBQUFBVUFBQUFBQUFBSkFBQUFBQXNBUWEzbUFBc2hFUUFQQ2hFUkVRTUtCd0FCRXdrTEN3QUFDUVlMQUFBTEFBWVJBQUFBRVJFUkFFSGU1Z0FMQVFzQVFlZm1BQXNZRVFBS0NoRVJFUUFLQUFBQ0FBa0xBQUFBQ1FBTEFBQUxBRUdZNXdBTEFRd0FRYVRuQUFzVkRBQUFBQUFNQUFBQUFBa01BQUFBQUFBTUFBQU1BRUhTNXdBTEFRNEFRZDduQUFzVkRRQUFBQVFOQUFBQUFBa09BQUFBQUFBT0FBQU9BRUdNNkFBTEFSQUFRWmpvQUFzZUR3QUFBQUFQQUFBQUFBa1FBQUFBQUFBUUFBQVFBQUFTQUFBQUVoSVNBRUhQNkFBTERoSUFBQUFTRWhJQUFBQUFBQUFKQUVHQTZRQUxBUXNBUVl6cEFBc1ZDZ0FBQUFBS0FBQUFBQWtMQUFBQUFBQUxBQUFMQUVHNjZRQUxBUXdBUWNicEFBdGREQUFBQUFBTUFBQUFBQWtNQUFBQUFBQU1BQUFNQUFBdEt5QWdJREJZTUhnQUxUQllLekJZSURCWUxUQjRLekI0SURCNEFHbHVaZ0JKVGtZQWJtRnVBRTVCVGdBd01USXpORFUyTnpnNVFVSkRSRVZHTGdCRExsVlVSaTA0QUVHczZnQUxHa01BRVFBS0FCRVJFUUFBQUFBRkFBQUFBQUFBQ1FBQUFBQUxBRUhPNmdBTEdoRUFEd29SRVJFRENnY0FBUk1KQ3dzQUFBa0dDd0FBQ3dBR0FFSC82Z0FMQVFzQVFZcnJBQXNXQ2dvQUFBQUFDZ0FBQWdBSkN3QUFBQWtBQ3dBQUN3QkJ1ZXNBQ3dFTUFFSEY2d0FMRlF3QUFBQUFEQUFBQUFBSkRBQUFBQUFBREFBQURBQkI4K3NBQ3dFT0FFSC82d0FMRlEwQUFBQUVEUUFBQUFBSkRnQUFBQUFBRGdBQURnQkJyZXdBQ3dFUUFFRzU3QUFMSGc4QUFBQUFEd0FBQUFBSkVBQUFBQUFBRUFBQUVBQUFFZ0FBQUJJU0VnQkI4T3dBQ3c0U0FBQUFFaElTQUFBQUFBQUFDUUJCb2UwQUN3RUxBRUd0N1FBTEZRb0FBQUFBQ2dBQUFBQUpDd0FBQUFBQUN3QUFDd0JCMiswQUN3RU1BRUhuN1FBTHZBY01BQUFBQUF3QUFBQUFDUXdBQUFBQUFBd0FBQXdBQUNVcWN3QW9iblZzYkNrQUl3QXJBQzBBSUFBd0FFd0FBR3BNVEV3QWFnQUFBQUFBYW1vQUFBQUFhZ0FBYWlVbEpYTWxjeVZ6SlhNbGN5b3VLaVZqSldNQVltRnphV05mYzNSeWFXNW5BR0ZzYkc5allYUnZjanhVUGpvNllXeHNiMk5oZEdVb2MybDZaVjkwSUc0cElDZHVKeUJsZUdObFpXUnpJRzFoZUdsdGRXMGdjM1Z3Y0c5eWRHVmtJSE5wZW1VQWRHVnliV2x1WVhScGJtY2dkMmwwYUNBbGN5QmxlR05sY0hScGIyNGdiMllnZEhsd1pTQWxjem9nSlhNQWRHVnliV2x1WVhScGJtY2dkMmwwYUNBbGN5QmxlR05sY0hScGIyNGdiMllnZEhsd1pTQWxjd0IwWlhKdGFXNWhkR2x1WnlCM2FYUm9JQ1Z6SUdadmNtVnBaMjRnWlhoalpYQjBhVzl1QUhSbGNtMXBibUYwYVc1bkFIVnVZMkYxWjJoMEFGTjBPV1Y0WTJWd2RHbHZiZ0JPTVRCZlgyTjRlR0ZpYVhZeE1UWmZYM05vYVcxZmRIbHdaVjlwYm1adlJRQlRkRGwwZVhCbFgybHVabThBVGpFd1gxOWplSGhoWW1sMk1USXdYMTl6YVY5amJHRnpjMTkwZVhCbFgybHVabTlGQUU0eE1GOWZZM2g0WVdKcGRqRXhOMTlmWTJ4aGMzTmZkSGx3WlY5cGJtWnZSUUJ3ZEdoeVpXRmtYMjl1WTJVZ1ptRnBiSFZ5WlNCcGJpQmZYMk40WVY5blpYUmZaMnh2WW1Gc2MxOW1ZWE4wS0NrQVkyRnVibTkwSUdOeVpXRjBaU0J3ZEdoeVpXRmtJR3RsZVNCbWIzSWdYMTlqZUdGZloyVjBYMmRzYjJKaGJITW9LUUJqWVc1dWIzUWdlbVZ5YnlCdmRYUWdkR2h5WldGa0lIWmhiSFZsSUdadmNpQmZYMk40WVY5blpYUmZaMnh2WW1Gc2N5Z3BBSFJsY20xcGJtRjBaVjlvWVc1a2JHVnlJSFZ1Wlhod1pXTjBaV1JzZVNCeVpYUjFjbTVsWkFCMFpYSnRhVzVoZEdWZmFHRnVaR3hsY2lCMWJtVjRjR1ZqZEdWa2JIa2dkR2h5WlhjZ1lXNGdaWGhqWlhCMGFXOXVBSE4wWkRvNlltRmtYMkZzYkc5akFGTjBPV0poWkY5aGJHeHZZd0JUZERFeGJHOW5hV05mWlhKeWIzSUFVM1F4TW14bGJtZDBhRjlsY25KdmNnQk9NVEJmWDJONGVHRmlhWFl4TVRsZlgzQnZhVzUwWlhKZmRIbHdaVjlwYm1adlJRQk9NVEJmWDJONGVHRmlhWFl4TVRkZlgzQmlZWE5sWDNSNWNHVmZhVzVtYjBVQVRqRXdYMTlqZUhoaFltbDJNVEl6WDE5bWRXNWtZVzFsYm5SaGJGOTBlWEJsWDJsdVptOUZBSFlBUkc0QVlnQmpBR2dBWVFCekFIUUFhUUJxQUd3QWJRQm1BR1FBVGpFd1gxOWplSGhoWW1sMk1URTJYMTlsYm5WdFgzUjVjR1ZmYVc1bWIwVUFUakV3WDE5amVIaGhZbWwyTVRJeFgxOTJiV2xmWTJ4aGMzTmZkSGx3WlY5cGJtWnZSUT09IiksZy5vblJ1bnRpbWVJbml0aWFsaXplZD0oKT0+cG9zdE1lc3NhZ2Uoe3R5cGU6IldBU01fTE9BREVEIn0pO2Vsc2UgaWYoImZldGNoIj09QS5kYXRhLnR5cGUpRShBLmRhdGEpLnRoZW4oKEI9PntDKEEsQil9KSwoQj0+e2NvbnN0IEk9e3R5cGU6IkVSUk9SIixyZXNvdXJjZUlkOkEuZGF0YS5yZXNvdXJjZUlkLHVybDpBLmRhdGEudXJsfTtzZWxmLnBvc3RNZXNzYWdlKEkpfSkpO2Vsc2UgaWYoInVucGFjayI9PUEuZGF0YS50eXBlKXtjb25zdHtidWZmZXI6Qn09QS5kYXRhO2lmKCFJKXRocm93IG5ldyBFcnJvcigidW5wYWNrQnJpZGdlIG5vdCBkZXRlY3RlZCIpO2lmKCFnKXRocm93IG5ldyBFcnJvcigidW5wYWNrIG5vdCBkZXRlY3RlZCIpO2NvbnN0IFE9SS5jcmVhdGVFeHRyYWN0b3JGcm9tRGF0YShCKS5leHRyYWN0QWxsKCk7QyhBLFEpfX19KCk7Cgo=",null,!1);const QU=e.hardwareConcurrency-1;class lU extends k{constructor(){super(),this.baseUrl="",this.__totalWork=0,this.__doneWork=0,this.plugins={},this.systemUrls={};const U="https://storage.googleapis.com/visualive-tmp/zea-engine-resources";this.systemUrls["ZeaEngine/Vive.vla"]=U+"/Vive.vla",this.systemUrls["ZeaEngine/Oculus.vla"]=U+"/Oculus.vla",this.commonResources={}}registerPlugin(U){U.init(this),this.plugins[U.getType()]=U}loadFile(U,F){const e=this.plugins[U];if(!e)throw new Error(`There's no plugin registered for the type of file "${U}". Did you add the plugins script? See: https://docs.zea.live/zea-engine/#/adding-default-plugins`);this.incrementWorkload();const t=e.loadFile(F);return t.then((()=>{this.incrementWorkDone(),this.emit("loaded",{url:F})}),(()=>{this.incrementWorkDone()})),t}getCommonResource(U){return this.commonResources[U]}setCommonResource(U,F){this.commonResources[U]=F}incrementWorkload(U=1){this.__totalWork+=U;const F=this.__doneWork/this.__totalWork*100;this.emit("progressIncremented",{percent:F})}incrementWorkDone(U=1){this.__doneWork+=U;const F=this.__doneWork/this.__totalWork*100;if(this.emit("progressIncremented",{percent:F}),this.__doneWork>this.__totalWork)throw new Error("Mismatch between work loaded and work done.")}}const nU=new lU,aU=new class{constructor(){this.__callbacks={},this.__workers=[],this.__nextWorker=0}init(U){this.resourceLoader=U}getType(){return"archive"}__getWorker(){return this.__nextWorker=(this.__nextWorker+1)%QU,null==this.__workers[this.__nextWorker]&&(this.__workers[this.__nextWorker]=(()=>new Promise(((U,F)=>{const e=new tU;e.postMessage({type:"init"}),e.onmessage=t=>{if("WASM_LOADED"===t.data.type)U(e);else if("FINISHED"===t.data.type)this.__onFinishedReceiveFileData(t.data);else if("ERROR"===t.data.type){const U=t.data;F(new Error(`Unable to load Resource: ${U.resourceId}`))}}})))()),this.__workers[this.__nextWorker]}__terminateWorkers(){for(const U of this.__workers)U.terminate();this.__workers=[]}loadFile(U){this.resourceLoader.incrementWorkload(1);return new Promise(((F,e)=>{U in this.__callbacks||(this.__callbacks[U]=[]),this.__callbacks[U].push(F),fetch(U).then((F=>(this.resourceLoader.incrementWorkDone(1),function(U){return!!U.ok&&U}(F)?F.arrayBuffer():(e(new Error(`loadArchive: ${F.status} - ${F.statusText} : ${U}`)),null)))).then((e=>{const t=U;t in this.__callbacks||(this.__callbacks[t]=[]),this.__callbacks[t].push(F),this.__getWorker().then((U=>{U.postMessage({type:"unpack",resourceId:t,buffer:e})}))}))}))}__onFinishedReceiveFileData(U){const F=U.resourceId,e=this.__callbacks[F];if(e){for(const F of e)F(U.entries);delete this.__callbacks[F]}}shutDownWorkers(){this.__workers.forEach((U=>{U.then((U=>{U.terminate()}))}))}};nU.registerPlugin(aU);const dU=new class{init(U){this.resourceLoader=U}getType(){return"json"}loadFile(U){this.resourceLoader.incrementWorkload(1);return new Promise(((F,e)=>{fetch(U).then((t=>{this.resourceLoader.incrementWorkDone(1),!function(U){return!!U.ok&&U}(t)?e(`loadJSON: ${t.status} - ${t.statusText} : ${U}`):F(t.json())}))}))}};nU.registerPlugin(dU);const iU=new class{init(U){this.resourceLoader=U}getType(){return"text"}loadFile(U){this.resourceLoader.incrementWorkload(1);return new Promise(((F,e)=>{fetch(U).then((t=>{this.resourceLoader.incrementWorkDone(1),!function(U){return!!U.ok&&U}(t)?e(`loadText: ${t.status} - ${t.statusText} : ${U}`):F(t.text())}))}))}};nU.registerPlugin(iU);const sU=new class{init(U){this.resourceLoader=U}getType(){return"binary"}loadFile(U){this.resourceLoader.incrementWorkload(1);return new Promise(((F,e)=>{fetch(U).then((t=>{this.resourceLoader.incrementWorkDone(1),!function(U){return!!U.ok&&U}(t)?e(`loadBinary: ${t.status} - ${t.statusText} : ${U}`):F(t.arrayBuffer())}))}))}};nU.registerPlugin(sU);class RU{constructor(U=""){if(this.branch="",U){const F=U.split("-"),e=F[0].split(".");this.major=parseInt(e[0]),this.minor=parseInt(e[1]),this.patch=parseInt(e[2]),2==F.length&&(this.branch=F[1])}else this.major=0,this.minor=0,this.patch=0}compare(U){const F=[this.major,this.minor,this.patch];for(let e=0;e<3;e++)if(F[e]!==U[e])return F[e]-U[e];return 0}}class BU{constructor(U,F=0,e=!0){this.__data=U,this.__byteOffset=F,this.__dataView=new DataView(this.__data),this.__isMobileDevice=e,this.utf8decoder=new TextDecoder}get isMobileDevice(){return this.__isMobileDevice}get data(){return this.__data}get byteLength(){return this.__dataView.byteLength}get remainingByteLength(){return this.__dataView.byteLength-this.__byteOffset}pos(){return this.__byteOffset}seek(U){this.__byteOffset=U}advance(U){this.__byteOffset+=U}loadUInt8(){const U=this.__dataView.getUint8(this.__byteOffset);return this.__byteOffset+=1,U}loadUInt16(){const U=this.__dataView.getUint16(this.__byteOffset,!0);return this.__byteOffset+=2,U}loadUInt32(){const U=this.__dataView.getUint32(this.__byteOffset,!0);return this.__byteOffset+=4,U}loadSInt32(){const U=this.__dataView.getInt32(this.__byteOffset,!0);return this.__byteOffset+=4,U}loadFloat16(){const U=this.loadUInt16();return J.decode16BitFloat(U)}loadUFloat16(){const U=this.loadFloat16();return U<0?2048-U:U}loadFloat16From2xUInt8(){throw Error("loadFloat16From2xUInt8 not implemented!")}loadUInt32From2xUFloat16(){return this.loadUFloat16()+4096*this.loadUFloat16()}loadSInt32From2xFloat16(){return this.loadFloat16()+2048*this.loadFloat16()}loadFloat32(){const U=this.__dataView.getFloat32(this.__byteOffset,!0);return this.__byteOffset+=4,U}loadUInt8Array(U,F=!1){null==U&&(U=this.loadUInt32());const e=new Uint8Array(this.__data,this.__byteOffset,U);return this.__byteOffset+=U,e}loadUInt16Array(U,F=!1){if(null==U&&(U=this.loadUInt32()),0==U)return new Uint16Array;let e;if(this.readPad(2),this.__isMobileDevice){e=new Uint16Array(U);for(let F=0;F<U;F++)e[F]=this.__dataView.getUint16(this.__byteOffset,!0),this.__byteOffset+=2}else e=new Uint16Array(this.__data,this.__byteOffset,U),this.__byteOffset+=2*U;return e}loadUInt32Array(U,F=!1){if(null==U&&(U=this.loadUInt32()),0==U)return new Uint32Array;let e;if(this.readPad(4),this.__isMobileDevice){e=new Uint32Array(U);for(let F=0;F<U;F++)e[F]=this.__dataView.getUint32(this.__byteOffset,!0),this.__byteOffset+=4}else e=new Uint32Array(this.__data,this.__byteOffset,U),this.__byteOffset+=4*U;return e}loadFloat32Array(U,F=!1){if(null==U&&(U=this.loadUInt32()),0==U)return new Float32Array;let e;if(this.readPad(4),this.__isMobileDevice){e=new Float32Array(U);for(let F=0;F<U;F++)e[F]=this.__dataView.getFloat32(this.__byteOffset,!0),this.__byteOffset+=4}else e=new Float32Array(this.__data,this.__byteOffset,U),this.__byteOffset+=4*U;return e}loadStr(){const U=this.loadUInt32(),F=new Uint8Array(this.__data,this.__byteOffset,U);return this.__byteOffset+=U,this.utf8decoder.decode(F)}loadStrArray(){const U=this.loadUInt32(),F=[];for(let e=0;e<U;e++)F[e]=this.loadStr();return F}loadSInt32Vec2(){const U=this.loadSInt32(),F=this.loadSInt32();return new d(U,F)}loadUInt32Vec2(){const U=this.loadUInt32(),F=this.loadUInt32();return new d(U,F)}loadFloat16Vec2(){const U=this.loadFloat16(),F=this.loadFloat16();return new d(U,F)}loadFloat32Vec2(){const U=this.loadFloat32(),F=this.loadFloat32();return new d(U,F)}loadFloat16Vec3(){const U=this.loadFloat16(),F=this.loadFloat16(),e=this.loadFloat16();return new i(U,F,e)}loadFloat32Vec3(){const U=this.loadFloat32(),F=this.loadFloat32(),e=this.loadFloat32();return new i(U,F,e)}loadFloat16Quat(){const U=this.loadFloat16(),F=this.loadFloat16(),e=this.loadFloat16(),t=this.loadFloat16();return new o(U,F,e,t)}loadFloat32Quat(){const U=this.loadFloat32(),F=this.loadFloat32(),e=this.loadFloat32(),t=this.loadFloat32();return new o(U,F,e,t)}loadRGBFloat32Color(){const U=this.loadFloat32(),F=this.loadFloat32(),e=this.loadFloat32();return new B(U,F,e)}loadRGBAFloat32Color(){const U=this.loadFloat32(),F=this.loadFloat32(),e=this.loadFloat32(),t=this.loadFloat32();return new B(U,F,e,t)}loadRGBUInt8Color(){const U=this.loadUInt8(),F=this.loadUInt8(),e=this.loadUInt8();return new B(U/255,F/255,e/255)}loadRGBAUInt8Color(){const U=this.loadUInt8(),F=this.loadUInt8(),e=this.loadUInt8(),t=this.loadUInt8();return new B(U/255,F/255,e/255,t/255)}loadBox2(){return new m(this.loadFloat32Vec2(),this.loadFloat32Vec2())}loadBox3(){return new W(this.loadFloat32Vec3(),this.loadFloat32Vec3())}readPad(U){const F=this.__byteOffset%U;0!=F&&(this.__byteOffset+=U-F)}}var VU;U.OperatorOutputMode=void 0,(VU=U.OperatorOutputMode||(U.OperatorOutputMode={}))[VU.OP_WRITE=0]="OP_WRITE",VU[VU.OP_READ_WRITE=1]="OP_READ_WRITE";class rU extends k{constructor(U="",F,e){super(),this.dirty=!1,this.boundInputs=[],this.boundOutputs=[],this.cleaning=!1,this.dirtyOpIndex=0,this.firstOP_WRITE=0,this.name=U,this.__value=F,this.dataType=e}getName(){return this.name}setName(U){if(U===this.name)return;const F=this.name;this.name=U,this.emit("nameChanged",{newName:this.name,prevName:F})}getOwner(){return this.ownerItem}setOwner(U){this.ownerItem=U}getPath(){return this.ownerItem&&this.ownerItem instanceof A?[...this.ownerItem.getPath(),this.name]:[this.name]}getDataType(){return this.dataType}bindOperatorInput(U){this.boundInputs.push(U)}unbindOperatorInput(U){const F=this.boundInputs.indexOf(U);this.boundInputs.splice(F,1)}bindOperatorOutput(U,F=-1){-1==F&&(F=this.boundOutputs.length),this.boundOutputs.splice(F,0,U);for(let U=F;U<this.boundOutputs.length;U++)this.boundOutputs[U].setParamBindIndex(U);return this.__findFirstOP_WRITE(),this.dirtyOpIndex=this.boundOutputs.length,this.setDirty(F),F}unbindOperatorOutput(U){const F=U.getParamBindIndex();this.boundOutputs.splice(F,1);for(let U=F;U<this.boundOutputs.length;U++)this.boundOutputs[U].setParamBindIndex(U);return this.__findFirstOP_WRITE(),this.dirtyOpIndex=this.boundOutputs.length,this.setDirty(Math.max(0,F-1)),F}__findFirstOP_WRITE(){if(this.firstOP_WRITE=this.boundOutputs.length,this.boundOutputs.length>0)for(this.firstOP_WRITE--;this.firstOP_WRITE>0&&this.boundOutputs[this.firstOP_WRITE].getMode()!=U.OperatorOutputMode.OP_WRITE;this.firstOP_WRITE--);}setDirty(U){if(U<this.dirtyOpIndex){let F=this.firstOP_WRITE;if(F<=U){for(this.dirtyOpIndex=F,F++;F<this.boundOutputs.length;F++)F!=U&&this.boundOutputs[F].getOperator().setDirty();for(let U=0;U<this.boundInputs.length;U++)this.boundInputs[U].setDirty();return this.emit("valueChanged"),!0}}return!1}isDirty(){return this.dirtyOpIndex<this.boundOutputs.length}getDirtyBindingIndex(){return this.dirtyOpIndex}setCleanFromOp(F,e){if(e!=this.dirtyOpIndex)if(e<this.dirtyOpIndex)console.log("Parameter is cleaned when it was already clean to that point in the stack:",this.getPath());else if(this.boundOutputs[e].getMode()!=U.OperatorOutputMode.OP_WRITE){const U=this.getClassName(),F=this.boundOutputs[e].getOperator(),t=F.getClassName();throw new Error(`Parameter: ${U} with name: ${this.getName()} is not cleaning all outputs during evaluation of op: ${t} with name: ${F.getName()}`)}this.__value=F,this.dirtyOpIndex=e+1}getValueFromOp(U){return this.dirtyOpIndex<U&&this._clean(U),this.__value}_clean(U){if(this.cleaning)throw new Error(`Cycle detected when cleaning: ${this.getPath()}. Operators need to be rebound to fix errors`);for(this.cleaning=!0;this.dirtyOpIndex<U;){const U=this.dirtyOpIndex;if(this.boundOutputs[this.dirtyOpIndex].getOperator().evaluate(),U==this.dirtyOpIndex){const U=this.boundOutputs[this.dirtyOpIndex].getOperator(),F=U.getClassName();console.warn(`Operator: ${F} with name: ${U.getName()} is not cleaning its outputs during evaluation`),this.dirtyOpIndex++}}this.cleaning=!1}getValue(){return this.dirtyOpIndex<this.boundOutputs.length&&this._clean(this.boundOutputs.length),this.__value}setValue(U){if(null==U)throw"undefined was passed into the set value for param:"+this.getName();if(this.boundOutputs.length>0)for(let F=this.boundOutputs.length-1;F>=0;F--){const e=this.boundOutputs[F];if(U=e.backPropagateValue(U),0==e.getMode())return}if("object"==typeof U||this.__value!=U){this.__value=U;for(let U=0;U<this.boundInputs.length;U++)this.boundInputs[U].paramValueChanged();this.emit("valueChanged")}}get value(){return this.getValue()}set value(U){this.setValue(U)}loadValue(U){this.__value=U}readBinary(U,F){console.warn(`TODO: Parameter: ${this.constructor.name} with name: ${this.name} does not implement readBinary`)}destroy(){console.warn("nothing destroyed. This method was not overwritten in subclass")}}class hU extends rU{constructor(U="",F=0,e,t){super(U,F,"Number"),this.range=e,this.step=t}getRange(){return this.range}setRange(U){this.range=U}getStep(){return this.step}setStep(U){this.step=U}toJSON(U){const F={value:this.__value};return this.range&&(F.range=this.range),this.step&&(F.step=this.step),F}fromJSON(U,F){this.__value=U.value,U.range&&(this.range=U.range),U.step&&(this.step=U.step)}readBinary(U,F){this.__value=U.loadFloat32()}clone(){return new hU(this.name,this.__value,this.range,this.step)}}n.register("NumberParameter",hU),n.register("Property_SInt32",class extends hU{readBinary(U,F){this.__value=U.loadSInt32()}}),n.register("Property_UInt32",class extends hU{readBinary(U,F){this.__value=U.loadUInt32()}}),n.register("Property_Float32",class extends hU{readBinary(U,F){this.__value=U.loadFloat32()}});class oU extends hU{constructor(U,F,e=[]){super(U,F,[0,e.length],1),this.choices=e}getChoices(){return this.choices}setValue(U){"string"==typeof U?super.setValue(this.choices.indexOf(U)):super.setValue(U)}}n.register("MultiChoiceParameter",oU);class JU extends rU{constructor(U="",F){super(U,null!=F&&F,"Boolean")}readBinary(U,F){this.__value=0!=U.loadUInt8()}toJSON(U){return{value:this.__value}}fromJSON(U,F){this.__value=U.value,this.emit("valueChanged",{mode:0})}clone(){return new JU(this.name,this.__value)}}n.register("BooleanParameter",JU),n.register("Property_Boolean",JU);class ZU extends rU{constructor(U="",F,e){super(U,F||new d,"Vec2"),this.range=e}getRange(){return this.range}setRange(U){this.range=U,this.emit("rangeChanged",{range:U})}readBinary(U,F){var e;null===(e=this.__value)||void 0===e||e.readBinary(U)}toJSON(U){var F;return{name:this.name,value:null===(F=this.__value)||void 0===F?void 0:F.toJSON()}}fromJSON(U,F){const e=new d;e.fromJSON(U.value),this.__value=e,U.name&&(this.name=U.name)}clone(){var U;const F=new ZU(this.name,null===(U=this.__value)||void 0===U?void 0:U.clone());return this.range&&F.setRange(this.range),F}}n.register("Vec2Parameter",ZU),n.register("Property_Vec2_32f",ZU);class cU extends rU{constructor(U="",F,e){super(U,F||new i,"Vec3"),this.range=e}readBinary(U,F){var e;null===(e=this.__value)||void 0===e||e.readBinary(U)}toJSON(U){var F;return{name:this.name,value:null===(F=this.__value)||void 0===F?void 0:F.toJSON()}}fromJSON(U,F){const e=new i;e.fromJSON(U.value),this.__value=e,U.name&&(this.name=U.name)}clone(){var U;return new cU(this.name,null===(U=this.__value)||void 0===U?void 0:U.clone())}}n.register("Vec3Parameter",cU),n.register("Property_Vec3_32f",cU);class mU extends rU{constructor(U="",F){super(U,F||new s,"Vec4")}readBinary(U,F){var e;null===(e=this.__value)||void 0===e||e.readBinary(U)}toJSON(U){var F;return{name:this.name,value:null===(F=this.__value)||void 0===F?void 0:F.toJSON()}}fromJSON(U,F){const e=new s;e.fromJSON(U.value),this.__value=e,U.name&&(this.name=U.name)}clone(){var U;return new mU(this.name,null===(U=this.__value)||void 0===U?void 0:U.clone())}}n.register("Vec4Parameter",mU),n.register("Property_Vec4_32f",mU);class SU extends rU{constructor(U="",F){super(U,F||new B,"Color")}readBinary(U,F){const e=U.loadRGBAFloat32Color();e.applyGamma(2.2),this.__value=e}toJSON(U){var F;return{value:null===(F=this.__value)||void 0===F?void 0:F.toJSON()}}fromJSON(U,F){var e;null===(e=this.__value)||void 0===e||e.fromJSON(U.value)}clone(){var U;return new SU(this.name,null===(U=this.__value)||void 0===U?void 0:U.clone())}}n.register("ColorParameter",SU),n.register("Property_Color_32f",SU);class WU extends rU{constructor(U="",F){super(U,F||new o,"Quat")}readBinary(U,F){var e;null===(e=this.__value)||void 0===e||e.readBinary(U)}toJSON(U){var F;return{value:null===(F=this.__value)||void 0===F?void 0:F.toJSON()}}fromJSON(U,F){const e=new o;e.fromJSON(U.value),this.__value=e}clone(){var U;return new WU(this.name,null===(U=this.__value)||void 0===U?void 0:U.clone())}}n.register("QuatParameter",WU),n.register("Property_Quat_32f",WU);class EU extends rU{constructor(U="",F){super(U,F||new r,"Mat3")}readBinary(U,F){var e;null===(e=this.__value)||void 0===e||e.readBinary(U)}toJSON(U){var F;return{value:null===(F=this.__value)||void 0===F?void 0:F.toJSON()}}fromJSON(U,F){const e=new r;e.fromJSON(U.value),this.__value=e}clone(){var U;return new EU(this.name,null===(U=this.__value)||void 0===U?void 0:U.clone())}}n.register("Mat3Parameter",EU),n.register("Property_Mat3_32f",EU);class pU extends rU{constructor(U="",F){super(U,F||new h,"Mat4")}readBinary(U,F){var e;null===(e=this.__value)||void 0===e||e.readBinary(U)}toJSON(U){var F;return{value:null===(F=this.__value)||void 0===F?void 0:F.toJSON()}}fromJSON(U,F){const e=new h;e.fromJSON(U.value),this.__value=e}clone(){var U;return new pU(this.name,null===(U=this.__value)||void 0===U?void 0:U.clone())}}n.register("Mat4Parameter",pU),n.register("Property_Mat4_32f",pU);class uU extends rU{constructor(U="",F){super(U,F||new c,"Xfo")}readBinary(U,F){this.__value.readBinary(U)}toJSON(U){return{name:this.name,value:this.__value.toJSON()}}fromJSON(U,F){const e=new c;e.fromJSON(U.value),this.__value=e,U.name&&(this.name=U.name)}clone(){return new uU(this.name,this.__value.clone())}}n.register("XfoParameter",uU),n.register("Property_Xfo_32f",uU);class NU extends rU{constructor(U="",F){super(U,F,"BaseImage")}toJSON(U){const F={name:this.name};return this.__value&&(F.imageType=this.__value.getClassName(),F.value=this.__value.toJSON()),F}fromJSON(U,F){var e;U.imageType&&(this.__value=n.constructClass(U.imageType),U.value&&(null===(e=this.__value)||void 0===e||e.fromJSON(U.value,F)))}clone(){return new NU(this.name,this.__value)}}n.register("ImageParameter",NU);class kU extends rU{constructor(U="",F=""){super(U,F,"String"),this.multiLine=!1}setMultiLine(U){this.multiLine=U}getMultiLine(){return this.multiLine}readBinary(U,F){this.__value=U.loadStr()}toJSON(U){return{value:this.__value}}fromJSON(U,F){this.__value=U.value?U.value:"",this.emit("valueChanged",{mode:0})}clone(){return new kU(this.name,this.__value)}}n.register("StringParameter",kU),n.register("Property_String",kU);class bU extends rU{constructor(U="",F=[]){super(U,F,"String[]")}readBinary(U,F){this.__value=U.loadStrArray()}toJSON(U){return{value:this.__value}}fromJSON(U,F){this.__value=U.value,this.emit("valueChanged",{mode:0})}clone(){return new bU(this.name,this.__value)}}n.register("StringListParameter",bU),n.register("Property_StringList",bU);class CU extends rU{constructor(U="",F){super(U,[],F)}filter(U){return!0}getCount(){var U;return(null===(U=this.__value)||void 0===U?void 0:U.length)||0}getElement(U){if(this.__value)return this.__value[U]}setElement(U,F){this.__value||(this.__value=[]),this.__value[U]=F,this.emit("valueChanged")}addElement(U){if((U||0==U)&&this.filter(U))return this.__value||(this.__value=[]),this.__value.push(U),this.emit("elementAdded",{elem:U,index:this.__value.length-1}),this.emit("valueChanged"),U}removeElement(U){this.__value||(this.__value=[]);const F=this.__value[U];this.__value.splice(U,1),this.emit("elementRemoved",{elem:F,index:U}),this.emit("valueChanged")}insertElement(U,F){this.__value&&this.filter(F)&&(this.__value.splice(U,0,F),this.emit("elementAdded",{elem:F,index:U}),this.emit("valueChanged"))}toJSON(U){const F=[];if(this.__value)for(const e of this.__value)"string"==typeof this.dataType?F.push(e):F.push(e.toJSON(U));return{value:F}}fromJSON(U,F){if(null!=U.items){this.__value=[];for(let e=0;e<U.items.length;e++){let t;if("string"==typeof this.dataType)t=U.items[e];else{if(!this.dataType)throw"No DataType";t=n.constructClass(this.dataType),t.fromJSON(U.items[e],F)}this.__value.push(t),this.emit("elementAdded",{elem:t,index:this.__value.length-1})}this.emit("valueChanged",{mode:0})}else console.warn("Invalid Parameter JSON")}clone(){const U=this.__value?this.__value.slice(0):[];if(!this.dataType)throw"This parameter does not have a DataType";const F=new CU(this.name,this.dataType);return F.setValue(U),F}destroy(){if(this.__value)for(let U=0;U<this.__value.length;U++)this.__value[U]instanceof rU&&this.__value[U].destroy(),this.removeElement(U)}}class TU extends rU{constructor(U){super(U,{},"Struct"),this.members=[]}addMember(U){return this.__value&&(this.__value[U.getName()]=U.value),U.on("valueChanged",(()=>{this.__value&&(this.__value[U.getName()]=U.value)})),this.members.push(U),this.emit("valueChanged"),U}getParameter(U){for(const F of this.members)if(F.getName()==U)return F}getMember(U){return this.getParameter(U)}getMemberNames(){const U=[];for(let F=0;F<this.members.length;F++){const e=this.members[F];null!=e&&(U[F]=e.getName())}return U}toJSON(U){const F={},e=[];for(const F of this.members)e.push(F.toJSON(U));return F.members=e,F.name=this.name,F}fromJSON(U,F){if(null!=U.members){for(let e=0;e<U.members.length;e++)U.members[e]&&this.members[e].fromJSON(U.members[e],F);this.name=U.name}else console.warn("Invalid Parameter JSON")}clone(){return new TU(this.name)}destroy(){for(const U of this.members)U.destroy()}}n.register("StructParameter",TU);class GU extends k{constructor(F,e=U.OperatorOutputMode.OP_WRITE){super(),this._op=null,this.__name=F,this._mode=e,this._param=void 0,this._paramBindIndex=-1,this.detached=!1}getName(){return this.__name}setOperator(U){this._op=U}getOperator(){return this._op}getMode(){return this._mode}isConnected(){return null!=this._param}getParam(){return this._param}setParam(U,F=-1){this._param&&this._param.unbindOperatorOutput(this),this._param=U,this._param&&(this._paramBindIndex=this._param.bindOperatorOutput(this,F)),this.emit("paramSet",{param:this._param})}getParamBindIndex(){return this._paramBindIndex}setParamBindIndex(U){this._paramBindIndex=U}setDirty(){this._param&&this._param.setDirty(this._paramBindIndex)}getValue(){if(this._param)return this._param.getValueFromOp(this._paramBindIndex);throw new Error("Cannot call getValue on OperatorOutput that is not connected:",this.__name)}backPropagateValue(U){return this._op&&(U=this._op.backPropagateValue(U)),U}setClean(U){this._param&&this._param.setCleanFromOp(U,this._paramBindIndex)}toJSON(U){const F=this._param?this._param.getPath():"";return{name:this.__name,paramPath:U&&U.makeRelative?U.makeRelative(F):F,paramBindIndex:this._paramBindIndex}}fromJSON(U,F){U.paramPath&&(null==F||F.resolvePath(U.paramPath,(F=>{this.setParam(F,U.paramBindIndex)}),(F=>{console.warn("OperatorOutput: '"+this.getName()+"'. Unable to connect to:"+U.paramPath)})))}detach(){this.detached=!0,this._paramBindIndex=this._param?this._param.unbindOperatorOutput(this):-1}reattach(){this.detached=!1,this._param&&(this._paramBindIndex=this._param.bindOperatorOutput(this,this._paramBindIndex))}rebind(){this._param&&(this._param.unbindOperatorOutput(this),this._paramBindIndex=this._param.bindOperatorOutput(this))}}class XU extends GU{}class gU extends GU{}class yU extends GU{}class IU extends A{constructor(U=""){super(U),this.__inputs=new Map,this.__outputs=new Map}setDirty(){this.__outputs.forEach((U=>U.setDirty()))}parameterValueChanged(U){super.parameterValueChanged(U),this.setDirty()}addInput(U){return U.setOperator(this),this.__inputs.set(U.getName(),U),this.setDirty(),U}removeInput(U){"string"==typeof U&&(U=this.getInput(U)),U.getParam()&&U.setParam(void 0),this.__inputs.delete(U.getName())}getNumInputs(){return this.__inputs.size}getInputByIndex(U){return Array.from(this.__inputs.values())[U]}getInput(U){const F=this.__inputs.get(U);if(!F)throw`Couldn't find an Input with the name of '${U}'`;return F}addOutput(U){return U.setOperator(this),this.__outputs.set(U.getName(),U),this.setDirty(),U}removeOutput(U){if("string"==typeof U&&(U=this.getOutput(U)),!(U instanceof GU))throw new Error("removeOutput only accepts string or OperatorInput");U.getParam()&&U.setParam(),this.__outputs.delete(U.getName())}getNumOutputs(){return this.__outputs.size}getOutputByIndex(U){return Array.from(this.__outputs.values())[U]}getOutput(U){const F=this.__outputs.get(U);if(!F)throw new Error(`Couldn't find an Output with the name of '${U}'`);return F}evaluate(){throw new Error("Not yet implemented")}backPropagateValue(U){return U}toJSON(U){const F=super.toJSON(U);F.type=this.getClassName();const e=[];this.__inputs.forEach((F=>{e.push(F.toJSON(U))})),F.inputs=e;const t=[];return this.__outputs.forEach((F=>{t.push(F.toJSON(U))})),F.outputs=t,F}fromJSON(U,F){super.fromJSON(U,F),U.inputs&&U.inputs.forEach(((U,e)=>{let t;U.name?(t=this.getInput(U.name),t||(t=this.addInput(U.name))):t=this.getInputByIndex(e),t.fromJSON(U,F)})),U.outputs&&U.outputs.forEach(((U,e)=>{let t;U.name?(t=this.getOutput(U.name),t||(t=this.addOutput(U.name))):t=this.getOutputByIndex(e),t.fromJSON(U,F)}))}detach(){this.__inputs.forEach((U=>U.detach())),this.__outputs.forEach((U=>U.detach()))}reattach(){this.__inputs.forEach((U=>U.reattach())),this.__outputs.forEach((U=>U.reattach()))}rebind(){this.__outputs.forEach((U=>U.rebind()))}}class xU extends k{constructor(U){super(),this.detached=!1,this.name=U}getName(){return this.name}setOperator(U){this._op=U}getOperator(){return this._op}isConnected(){return null!=this.param}getParam(){return this.param}paramValueChanged(){this._op&&this._op.setDirty()}setParam(U){this.param&&this.param.unbindOperatorInput(this),this.param=U,this.param&&this.param.bindOperatorInput(this),this.emit("paramSet",{param:this.param})}getValue(){if(this.param)return this.param.value;throw new Error("Unable to getValue")}setValue(U){this.param&&this.param.setValue(U)}setDirty(){this._op&&this._op.setDirty()}toJSON(U){const F=this.param?this.param.getPath():[],e=U&&U.makeRelative?U.makeRelative(F):F;return{name:this.name,paramPath:e}}fromJSON(U,F){U.paramPath&&(null==F||F.resolvePath(U.paramPath,(U=>{this.setParam(U)}),(()=>{console.warn("OperatorInput: '"+this.getName()+"'. Unable to connect to:"+U.paramPath)})))}detach(){this.param&&this.param.unbindOperatorInput(this)}reattach(){this.detached=!1,this.param&&this.param.bindOperatorInput(this)}}class fU extends xU{}class MU extends IU{constructor(U,F){super("CalcGlobalXfoOperator"),this.parentGlobal=new fU("ParentGlobal"),this.localXfo=new fU("LocalXfo"),this.globalXfo=new gU("GlobalXfo"),this.localXfo.setParam(F),this.globalXfo.setParam(U),this.addInput(this.parentGlobal),this.addInput(this.localXfo),this.addOutput(this.globalXfo)}backPropagateValue(U){if(this.parentGlobal.isConnected()){const F=this.parentGlobal.getValue();this.localXfo.setValue(F.inverse().multiply(U))}else this.localXfo.setValue(U)}evaluate(){const U=this.localXfo.getValue();if(this.parentGlobal.isConnected()){const F=this.parentGlobal.getValue();this.globalXfo.setClean(F.multiply(U))}else this.globalXfo.setClean(U)}}n.register("CalcGlobalXfoOperator",MU);class vU extends rU{constructor(U="",F){super(U,new W,"Box3"),this.treeItem=F,this.dirty=!0}setParameterAsDirty(){this.dirty=!0}setDirty(U){const F=super.setDirty(U);return F&&(this.dirty=!0),F}getValue(){return this.dirty&&(this.__value=this.treeItem._cleanBoundingBox(this.__value)),this.__value}toJSON(U){var F;return{value:null===(F=this.__value)||void 0===F?void 0:F.toJSON()}}fromJSON(U,F){var e;null===(e=this.__value)||void 0===e||e.fromJSON(U.value)}readBinary(U,F){throw new Error("Method not implemented.")}clone(){var U;const F=new vU(this.name,this.treeItem);return F.value=null===(U=this.__value)||void 0===U?void 0:U.clone(),F}}class DU extends A{constructor(U){super(U),this.disableBoundingBox=!1,this.__childItems=[],this.__childItemsEventHandlers=[],this.__childItemsMapping={},this.globalXfoParam=new uU("GlobalXfo",new c),this.localXfoParam=new uU("LocalXfo",new c),this.boundingBoxParam=new vU("BoundingBox",this),this.visibleParam=new JU("Visible",!0),this.__highlightMapping={},this.__highlights=[],this.__visible=!0,this.__visibleCounter=1,this.addParameter(this.visibleParam),this.addParameter(this.localXfoParam),this.addParameter(this.globalXfoParam),this.addParameter(this.boundingBoxParam),this.globalXfoOp=new MU(this.globalXfoParam,this.localXfoParam),this.globalXfoParam.on("valueChanged",(U=>{this.setBoundingBoxDirty(),this.emit("globalXfoChanged",U)})),this.visibleParam.on("valueChanged",(()=>{this.__visibleCounter+=this.visibleParam.value?1:-1,this.updateVisibility()}))}setOwner(U){if(this.__ownerItem){const U=this.__ownerItem;if(U&&U instanceof DU){U.isVisible()||this.__visibleCounter++;const F=U.getChildIndex(this);F>=0&&U.unbindChild(F,this)}}if(super.setOwner(U),this.__ownerItem){const U=this.__ownerItem;U&&(U.isVisible()||this.__visibleCounter--,this.globalXfoOp.getInput("ParentGlobal").setParam(U.globalXfoParam))}else this.globalXfoOp.getInput("ParentGlobal").setParam(void 0);this.updateVisibility()}updatePath(){super.updatePath();for(const U of this.__childItems)U&&U.updatePath()}getParentItem(){return this.getOwner()}setParentItem(U){this.setOwner(U)}isVisible(){return this.__visibleCounter>0}setVisible(U){this.visibleParam.value=U}propagateVisibility(U){this.__visibleCounter+=U,this.updateVisibility()}updateVisibility(){const U=this.__visibleCounter>0;if(U!=this.__visible){this.__visible=U;for(const U of this.__childItems)U.propagateVisibility(this.__visible?1:-1);this.emit("visibilityChanged",{visible:U});const F=this.__ownerItem;return F&&F instanceof DU&&F.setBoundingBoxDirty(),!0}return!1}addHighlight(U,F,e=!1){if(U in this.__highlightMapping)if(this.__highlights[this.__highlights.length-1]!=U){const e=this.__highlights.indexOf(U);this.__highlights.splice(e,1),this.__highlights.push(U),this.emit("highlightChanged",{name:U,color:F})}else this.__highlightMapping[U].isEqual(F)||(this.__highlightMapping[U]=F,this.emit("highlightChanged",{name:U,color:F}));else this.__highlights.push(U),this.__highlightMapping[U]=F,this.emit("highlightChanged",{name:U,color:F});e&&this.__childItems.forEach((t=>{t.addHighlight(U,F,e)}))}removeHighlight(U,F=!1){if(U in this.__highlightMapping){if(this.__highlights[this.__highlights.length-1]==U)if(this.__highlights.pop(),delete this.__highlightMapping[U],this.__highlights.length>0){const U=this.__highlights[this.__highlights.length-1],F=this.__highlightMapping[U];this.emit("highlightChanged",{name:U,color:F})}else this.emit("highlightChanged");else{const F=this.__highlights.indexOf(U);this.__highlights.splice(F,1),delete this.__highlightMapping[U],this.emit("highlightChanged")}F&&this.__childItems.forEach((e=>{e.removeHighlight(U,F)}))}}getHighlight(){if(!(this.__highlights.length>0))throw Error("highlight length > 0");return this.__highlightMapping[this.__highlights[this.__highlights.length-1]]}isHighlighted(){return this.__highlights.length>0}_cleanBoundingBox(U){return U.reset(),this.__childItems.forEach((F=>{if(F.isVisible()){const e=F.boundingBoxParam.value;e&&U.addBox3(e)}})),U}childBBoxChanged(){this.setBoundingBoxDirty()}setBoundingBoxDirty(){this.boundingBoxParam&&this.boundingBoxParam.setDirty(-1);const U=this.__ownerItem;U&&U instanceof DU&&U.setBoundingBoxDirty()}getChildren(){return this.__childItems}getNumChildren(){return this.__childItems.length}generateUniqueName(U){if(!(U in this.__childItemsMapping))return U;let F=1;U.length>4&&!Number.isNaN(parseInt(U.substring(U.length-4)))?F=parseInt(U.substr(U.length-4)):U.length>3&&!Number.isNaN(parseInt(U.substring(U.length-3)))?F=parseInt(U.substr(U.length-3)):U.length>2&&!Number.isNaN(parseInt(U.substring(U.length-2)))&&(F=parseInt(U.substr(U.length-2)));const e=[];for(const U of this.__childItems)U&&e.push(U.getName());let t=U;for(;;){let Q=""+F;for(;Q.length<2;)Q="0"+Q;if(t=U+Q,!e.includes(t))break;F++}return t}updateChildNameMapping(U){for(let F=U;F<this.__childItems.length;F++)this.__childItemsMapping[this.__childItems[F].getName()]=F}childNameChanged(U){const F=this.__childItemsMapping[U.oldName];delete this.__childItemsMapping[U.oldName],this.__childItemsMapping[U.newName]=F}insertChild(U,F,e=!1,t=!0){if(U.getName()in this.__childItemsMapping){if(!t)throw new Error("Item '"+U.getName()+"' is already a child of :"+this.getPath());U.setName(this.generateUniqueName(U.getName()))}if(!(U instanceof DU))throw new Error("Object is is not a tree item :"+U);const Q={};if(Q.nameChanged=U.on("nameChanged",(U=>{this.childNameChanged(U)})),e){const F=this.globalXfoParam.value,e=U.globalXfoParam.value,t=F.inverse().multiply(e);U.localXfoParam.value=t}return this.setBoundingBoxDirty(),this.__highlights.forEach((F=>{const e=this.__highlightMapping[F];U.addHighlight(F,e,!0)})),this.__childItems.splice(F,0,U),this.__childItemsEventHandlers.splice(F,0,Q),this.__childItemsMapping[U.getName()]=F,this.updateChildNameMapping(F),U.setOwner(this),this.emit("childAdded",{childItem:U,index:F}),U}addChild(U,F=!0,e=!0){const t=this.__childItems.length;return this.insertChild(U,t,F,e),U}getChild(U){return this.__childItems[U]}getChildByName(U){const F=this.__childItemsMapping[U];return null!=F?this.__childItems[F]:null}getChildNames(){const U=[];for(let F=0;F<this.__childItems.length;F++){const e=this.__childItems[F];null!=e&&(U[F]=e.getName())}return U}unbindChild(U,F){const e=this.__childItemsEventHandlers[U];for(const U in e)F.removeListenerById(U,e[U]);this.__childItems.splice(U,1),this.__childItemsEventHandlers.splice(U,1),delete this.__childItemsMapping[F.getName()],this.updateChildNameMapping(U),this.setBoundingBoxDirty(),this.emit("childRemoved",{childItem:F,index:U})}removeChild(U){const F=this.__childItems[U];F&&(this.unbindChild(U,F),F.setOwner(void 0))}removeChildByName(U){const F=this.__childItemsMapping[U];if(null!=F)return this.removeChild(F)}removeChildByHandle(U){const F=this.__childItems.indexOf(U);if(-1==F)throw new Error("Error in removeChildByHandle. Child not found:"+U.getName());this.removeChild(F)}removeAllChildren(){let U=this.__childItems.length;for(;U--;)this.removeChild(U);this.setBoundingBoxDirty()}getChildIndex(U){return this.__childItems.indexOf(U)}resolvePath(U,F=0,e=!1){if("string"==typeof U&&(U=U.split("/")),0==F)if("."==U[0]||U[0]==this.__name)F++;else if(".."==U[0]){if(this.__ownerItem)return this.__ownerItem.resolvePath(U,F+1);if(e)throw Error("this.__ownerItem is undefined");console.warn("this.__ownerItem is undefined")}if(F==U.length)return this;const t=U[F],Q=this.getChildByName(t);if(null==Q){const e=this.getParameter(U[F]);if(e)return e;throw new Error(`Unable to resolve path : [${U.toString()}] after: ${this.getName()} \nNo child or parameter called : "${U[F]}"`)}return Q.resolvePath(U,F+1)}traverse(U,F=!0){const e=(U,F)=>{const e=U.getChildren();for(const U of e)U&&U instanceof DU&&t(U,F+1)},t=(F,t)=>{0!=U(F,t)&&F instanceof DU&&e(F,t)};F?t(this,1):e(this,0)}onPointerDown(U){this.emit("pointerDown",U);const F=this.__ownerItem;U.propagating&&F&&F.onPointerDown(U)}onPointerUp(U){this.emit("pointerUp",U);const F=this.__ownerItem;U.propagating&&F&&F.onPointerUp(U)}onPointerMove(U){this.emit("pointerMove",U);const F=this.__ownerItem;U.propagating&&F&&F.onPointerMove(U)}onPointerEnter(U){this.emit("pointerEnter",U);const F=this.__ownerItem;U.propagating&&F&&F.onPointerEnter(U)}onPointerLeave(U){this.emit("pointerLeave",U);const F=this.__ownerItem;U.propagating&&F&&F.onPointerLeave(U)}onWheel(U){this.emit("mouseWheel",U);const F=this.__ownerItem;U.propagating&&F&&F.onWheel(U)}onTouchCancel(U){this.emit("touchCancel",U);const F=this.__ownerItem;U.propagating&&F&&F.onTouchCancel(U)}toJSON(U){let F=super.toJSON(U);const e={};for(const F of this.__childItems)if(F){const t=F.toJSON(U);t&&(e[F.getName()]=t)}return Object.keys(e).length>0&&(F?F.children=e:F={name:this.__name,children:e}),F}fromJSON(U,F,e){if(super.fromJSON(U,F),F&&!Number.isNaN(F.numTreeItems)&&F.numTreeItems++,null!=U.children){const e=U.children;if(Array.isArray(e))for(const U of e){let e=this.getChildByName(U.name);e?e.fromJSON(U,F):U.type&&(e=n.constructClass(U.type),e&&(e.fromJSON(U,F),this.addChild(e,!1,!1)))}else for(const U in e){const t=e[U];let Q=this.getChildByName(U);Q?Q.fromJSON(t,F):t.type&&(Q=n.constructClass(t.type),Q&&(Q.fromJSON(t,F),this.addChild(Q,!1,!1)))}}}readBinary(U,F){super.readBinary(U,F),F.numTreeItems++;const e=U.loadUInt8();this.setVisible(0!=(2&e));if(4&e){const F=new c;if(F.tr=U.loadFloat32Vec3(),F.ori=U.loadFloat32Quat(),32&e)F.sc=U.loadFloat32Vec3();else{const e=U.loadFloat32();F.sc.set(e,e,e)}this.localXfoParam.value=F}8&e&&this.boundingBoxParam.loadValue(new W(U.loadFloat32Vec3(),U.loadFloat32Vec3()));const t=U.loadUInt32();if(t>0){const e=U.loadUInt32Array(t);for(let Q=0;Q<t;Q++)try{U.seek(e[Q]);let t=U.loadStr();const l=n.constructClass(t);if(!l){const F=U.loadStr();console.warn("Unable to construct child:"+F+" of type:"+t);continue}U.seek(e[Q]),l.readBinary(U,F),this.addChild(l,!1,!0)}catch(U){console.warn("Error loading tree item: ",U)}}}clone(U){const F=new DU("");return F.copyFrom(this,U),F}copyFrom(U,F){super.copyFrom(U,F),U.getChildren().forEach((U=>{U&&this.addChild(U.clone(),!1,!1)}))}}n.register("TreeItem",DU);class LU extends rU{constructor(U="",F){super(U,void 0,"TreeItem"),this.listenerIDs={},this.owner=new DU(""),this.filterFn=F}emitTreeItemGlobalXfoChanged(U){this.emit("treeItemGlobalXfoChanged",U)}setOwner(U){this.owner=U}getOwner(){return this.owner}setFilterFn(U){this.filterFn=U}getFilterFn(){return this.filterFn}setValue(U){this.filterFn&&!this.filterFn(U)||this.__value!==U&&(this.__value&&this.__value.removeListenerById("globalXfoChanged",this.listenerIDs.globalXfoChanged),this.__value=U,this.__value&&(this.listenerIDs.globalXfoChanged=this.__value.on("globalXfoChanged",(U=>{this.emitTreeItemGlobalXfoChanged(U)}))),this.emit("valueChanged"))}toJSON(U){var F;return{value:U.makeRelative(null===(F=this.__value)||void 0===F?void 0:F.getPath())}}fromJSON(U,F){null!=U.value?F.resolvePath(U.value,(U=>{this.setValue(U)}),(()=>{console.warn("Unable to resolve tree item parameter value:"+U.paramPath)})):console.warn("Invalid Parameter JSON")}clone(U){const F=new LU(this.name,this.filterFn);return this.__value&&F.setValue(this.__value.clone(U)),F}}n.register("TreeItemParameter",LU);class YU extends N{constructor(U,F){super(),this.index=F,this.item=U}}class _U extends rU{constructor(U="",F){super(U,new Set,"TreeItem"),this.filterFn=F}setFilterFn(U){this.filterFn=U}getFilterFn(){return this.filterFn}getItem(U){return Array.from(this.__value)[U]}addItem(U,F=!0){if(this.filterFn&&!this.filterFn(U))return void console.warn("ItemSet __filterFn rejecting item:",U.getPath());this.__value.add(U);const e=Array.from(this.__value).indexOf(U);return this.emit("itemAdded",new YU(U,e)),F&&this.emit("valueChanged"),e}addItems(U,F=!0){U.forEach((U=>this.addItem(U,!1))),F&&this.emit("valueChanged")}removeItem(U,F=!0){const e=Array.from(this.__value)[U];return this.__value.delete(e),this.emit("itemRemoved",new YU(e,U)),F&&this.emit("valueChanged"),e}setItems(U,F=!0){const e=Array.from(this.__value);for(let F=e.length-1;F>=0;F--){const t=e[F];U.has(t)||this.removeItem(F,!1)}for(const F of U)this.__value.has(F)||this.addItem(F,!1);F&&this.emit("valueChanged")}clearItems(U=!0){this.__value.clear(),U&&this.emit("valueChanged")}getNumItems(){return this.__value.size}toJSON(U){this.__value||(this.__value=new Set);const F=[];if(U)for(const U of this.__value)F.push(U.getPath());return{value:F}}fromJSON(U,F){if(F)for(const e in U.value){const U=F.resolvePath(e);this.__value.add(U)}}clone(){return new _U(this.name,this.filterFn)}}class wU extends rU{constructor(U="",F){super(U,F,"Geometry"),this.listenerIDs={},F&&this.setValue(F)}emitBoundingBoxDirtied(U){this.emit("boundingBoxChanged",U)}setValue(U){this.__value!==U&&(this.__value&&this.__value.removeListenerById("boundingBoxChanged",this.listenerIDs.boundingBoxChanged),this.__value=U,this.__value&&(this.listenerIDs.boundingBoxChanged=this.__value.on("boundingBoxChanged",(U=>{this.emitBoundingBoxDirtied(U)}))),this.emit("valueChanged"))}loadValue(U){this.__value&&this.__value.removeListenerById("boundingBoxChanged",this.listenerIDs.boundingBoxChanged),this.__value=U,this.__value&&(this.listenerIDs.boundingBoxChanged=this.__value.on("boundingBoxChanged",(U=>{this.emitBoundingBoxDirtied(U)})))}toJSON(U){var F;return{name:this.name,value:null===(F=this.__value)||void 0===F?void 0:F.toJSON(U)}}fromJSON(U,F){U.name&&(this.name=U.name);const e=n.constructClass(U.value.type);e.fromJSON(U.value,F),this.__value=e}clone(){return new wU(this.name,this.__value)}}n.register("GeometryParameter",wU);class zU extends rU{constructor(U=""){super(U,"","FilePath")}getFilename(){if(!this.__value)throw"No file value";return this.__value.lastIndexOf("/")>-1?this.__value.substring(this.__value.lastIndexOf("/")+1):""}getExt(){const U=this.getFilename(),F=U.lastIndexOf(".");if(-1!=F)return U.substring(F).toLowerCase()}getStem(){const U=this.getFilename();if(U){const F=U.split(".");return 2==F.length?F[0]:U}return null}setValue(U){if(!U)throw new Error("Invalid value for setValue.");U!=this.__value&&(this.__value=U,this.emit("valueChanged"))}toJSON(U){return{value:this.__value}}fromJSON(U,F){U.value&&(this.__value=U.value)}clone(){const U=new zU(this.name);return this.__value&&U.setValue(this.__value),U}}n.register("FilePathParameter",zU);class KU extends A{constructor(U){super(U),this.width=0,this.height=0,this.format="RGB",this.type="UNSIGNED_BYTE",this.mipMapped=!0,this.wrapS="REPEAT",this.wrapT="REPEAT",this.minFilter="LINEAR",this.magFilter="LINEAR",this.loaded=!1,this.width=0,this.height=0,this.format="RGB",this.type="UNSIGNED_BYTE",this.wrapS="CLAMP_TO_EDGE",this.wrapT="CLAMP_TO_EDGE",this.minFilter="LINEAR",this.magFilter="LINEAR",this.on("parameterValueChanged",(()=>{this.emit("updated")}))}isLoaded(){return this.loaded}getParams(){return{type:this.type,format:this.format,width:this.width,height:this.height,wrapS:this.wrapS,wrapT:this.wrapT,minFilter:this.minFilter,magFilter:this.magFilter,mipMapped:this.mipMapped}}}class HU extends hU{constructor(U="",F,e){super(U,F,e)}toJSON(U){return super.toJSON(U)}getImage(){return this.image}setImage(U){const F=()=>{this.emit("textureDisconnected")};U?(null!=this.image&&this.image!==U&&F(),this.image=U,this.emit("textureConnected"),this.emit("valueChanged",{mode:0})):null!=this.image&&(F(),this.image=void 0,this.emit("textureDisconnected"))}setValue(U){U instanceof KU?this.setImage(U):super.setValue(U)}readBinary(U,F){super.readBinary(U,F);const e=U.loadStr();""!=e&&(console.log("Load Texture"),this.setImage(F.materialLibrary.getImage(e)))}clone(){return new HU(this.name,this.__value,this.range)}}n.register("MaterialFloatParam",HU);class PU extends SU{constructor(U,F){super(U,F),this.listenerIDs={}}getImage(){return this.image}imageUpdated(){this.emit("valueChanged")}setImage(U){const F=()=>{this.image&&(this.image.removeListenerById("loaded",this.listenerIDs.loaded),this.image.removeListenerById("updated",this.listenerIDs.updated),this.image=void 0),this.emit("textureDisconnected")};U?(null!=this.image&&this.image!==U&&F(),this.image=U,this.listenerIDs.updated=this.image.on("updated",(()=>{this.imageUpdated()})),this.emit("textureConnected"),this.emit("valueChanged")):null!=this.image&&(F(),this.image=void 0,this.emit("textureDisconnected"))}setValue(U){U instanceof KU?this.setImage(U):super.setValue(U)}readBinary(U,F){super.readBinary(U,F);const e=U.loadStr();""!=e&&this.setImage(F.materialLibrary.getImage(e))}clone(){var U;return new PU(this.name,null===(U=this.__value)||void 0===U?void 0:U.clone())}}n.register("MaterialColorParam",PU);class OU extends N{constructor(U){super(),this.shaderName=U}}class jU extends N{constructor(U){super(),this.isTransparent=U}}class AU extends N{constructor(U,F){super(),this.isTextured=U,this.param=F}}class qU extends A{constructor(U,F){super(U),this.__isTransparent=!1,this.__isTextured=!1,this.__shaderName="",F&&this.setShaderName(F)}getShaderName(){return this.__shaderName}setShaderName(U){if(this.__shaderName==U)return;this.__shaderName=U;const F=n.getClassDefinition(U).getMaterialTemplate();if(!F)throw new Error("Error setting Shader. Material template not registered found:"+U);const e={};let t=F.getNumParameters();for(;t--;){const U=F.getParameterByIndex(t);this.getParameter(U.getName())||this.addParameter(U.clone()),e[U.getName()]=!0}for(const U of this.params)e[U.getName()]||this.removeParameter(U.getName());this.__shaderName=U,this.__checkTransparency({});const Q=new OU(U);this.emit("shaderNameChanged",Q)}removeAllTextures(){for(const U of this.params)U instanceof PU?U.getImage()&&U.setImage(null):U instanceof HU&&U.getImage()&&U.setImage(null)}getParamTextures(){const U={};for(const F of this.params)F instanceof PU?F.getImage()&&(U[F.getName()]=F.getImage()):F instanceof HU&&F.getImage()&&(U[F.getName()]=F.getImage());return U}isTransparent(){return this.__isTransparent}__checkTransparency(U){let F=!1;try{this.getShaderClass().isTransparent()&&(F=!0)}catch(U){}if(!F){const U=this.getParameter("Opacity");if(U&&(U.value<.99||U instanceof HU&&U.getImage()))F=!0;else{const U=this.getParameter("BaseColor");if(U){if(U instanceof PU){const e=U.getImage();e&&"RGBA"==e.format&&(F=!0)}if(!F&&U.value){U.value.a<1&&(F=!0)}}}}if(F!=this.__isTransparent){this.__isTransparent=F;const U=new jU(F);this.emit("transparencyChanged",U)}}isTextured(){return this.__isTextured}__checkTextures(U){const F=U||{};let e=!1;for(const U of this.params)if(U instanceof PU){if(U.getImage()){e=!0;break}}else if(U instanceof HU&&U.getImage()){e=!0;break}if(e!=this.__isTextured){this.__isTextured=e;let U=new AU(e,F);this.emit("texturedChanged",U)}}parameterValueChanged(U){this.__checkTransparency(U),this.__checkTextures(U),super.parameterValueChanged(U)}getShaderClass(){return n.getClassDefinition(this.getShaderName())}toJSON(U){const F=super.toJSON(U);return F.shader=this.__shaderName,F}fromJSON(U,F={}){U.shader?(this.setShaderName(U.shader),super.fromJSON(U,F)):console.warn("Invalid Material JSON")}readBinary(U,F){let e=U.loadStr();if("StandardMaterial"==e&&(e="StandardSurfaceShader"),"TransparentMaterial"==e&&(e="StandardSurfaceShader"),this.setShaderName(e),F.versions["zea-engine"].compare([0,0,3])<0)throw`Loading zcad files of version ${F.versions["zea-engine"]} is not longer support`;super.readBinary(U,F),this.__checkTransparency(),this.__checkTextures()}clone(U){const F=new qU("clone","");return F.copyFrom(this,U),F}copyFrom(U,F){this.setShaderName(U.getShaderName()),super.copyFrom(U,F)}}n.register("Material",qU);class $U extends rU{constructor(U="",F){super(U,F,"Material"),this.listenerIDs={},F&&this.setValue(F)}valueParameterValueChanged(U){this.emit("valueParameterValueChanged",U)}setValue(U){this.__value!==U&&(this.__value&&this.__value.removeListenerById("parameterValueChanged",this.listenerIDs.parameterValueChanged),this.__value=U,this.__value&&(this.listenerIDs.parameterValueChanged=this.__value.on("parameterValueChanged",(U=>{this.valueParameterValueChanged(U)}))),this.emit("valueChanged"))}loadValue(U){this.__value&&this.__value.removeListenerById("parameterValueChanged",this.listenerIDs.parameterValueChanged),this.__value=U,this.__value&&(this.listenerIDs.parameterValueChanged=this.__value.on("parameterValueChanged",(U=>{this.valueParameterValueChanged(U)})))}toJSON(U){let F={};return F.name=this.name,this.__value&&(F={value:U&&U.onlyPath?this.__value.getPath():this.__value.toJSON(U)}),F}fromJSON(U,F){if(null!=U.value)if(U.value instanceof Array||U.value instanceof String){if(F&&F.assetItem){const e=F.assetItem.getMaterialLibrary().getMaterial(U.value instanceof Array?U.value[1]:U.value);e&&this.loadValue(e)}}else{const e=new qU;U.value&&e.fromJSON(U.value,F),this.loadValue(e)}else console.warn("Invalid Parameter JSON")}clone(){return new $U(this.name,this.__value)}}function UF(U,F){return!U.some(((U,e)=>Math.abs(F[e]-U)>.001))}n.register("MaterialParameter",$U);class FF extends u{constructor(U,F){super(),this.data=new Float32Array(0),this.dataTypeName=U,this.stride=F,this.initRange(0),this.splits={},this.splitValues=[]}setMesh(U){this.mesh=U}asArray(){return this.data}getDataTypeName(){return this.dataTypeName}getCount(){return this.data.length/this.stride}setCount(U){const F=this.data.length,e=U*this.stride;if(e>F){const U=new Float32Array(e);U.set(this.data,0),this.data=U,this.initRange(F)}else e<F&&(this.data=this.data.slice(0,e));this.splits={},this.splitValues=[]}initRange(U){for(let F=U;F<this.data.length;F++)this.data[F]=Number.NaN}get numElements(){return this.stride}getFloat32Value(U){return this.data[U]}setFloat32Value(U,F){this.data[U]=F}getSplits(){return this.splits}getFaceVertexValueRef_array(U,F){const e=this.mesh.getFaceVertexIndex(U,F);return e in this.splits&&U in this.splits[e]?this.splitValues[this.splits[e][U]]:this.data.subarray(e*this.stride,(e+1)*this.stride)}setFaceVertexValue_array(U,F,e){const t=this.mesh.getFaceVertexIndex(U,F);this.setFaceVertexValue_ByVertexIndex(U,t,e)}setFaceVertexValue_ByVertexIndex(U,F,e){const t=this.data.subarray(F*this.stride,(F+1)*this.stride);if(function(U){for(let F=0;F<U.length;F++)if(!Number.isNaN(U[F]))return!0;return!1}(t))if(UF(t,e));else{if(F in this.splits){const t=this.splits[F];for(const F in t){const Q=t[F];if(UF(this.splitValues[Q],e))return void(t[U]=Q)}if(U in this.splits[F])return void(this.splitValues[this.splits[F][U]]=e)}else this.splits[F]={};this.splits[F][U]=this.splitValues.length,this.splitValues.push(e)}else t.set(e)}setSplitVertexValue_array(U,F,e){if(U in this.splits||(this.splits[U]={}),F in this.splits[U]){if(UF(this.splitValues[this.splits[U][F]],e))return;console.warn("Face Vertex Already Split with different value")}this.splits[U][F]=this.splitValues.length,this.splitValues.push(e)}setSplitVertexValues(U,F,e){U in this.splits||(this.splits[U]={});const t=this.splitValues.length;this.splitValues.push(e);for(const e of F)this.splits[U][e]=t}generateSplitValues(U,F){if(0==F)return this.data;const e=this.getCount(),t=new Float32Array((e+F)*this.stride);t.set(this.data);for(const F in U){const Q=U[F];for(const U in Q){const l=e+Q[U];if(F in this.splits&&U in this.splits[F]){const e=this.splits[F][U];this.splitValues[e].forEach(((U,F)=>{t[l*this.stride+F]=U}))}else{const U=parseInt(F);for(let F=0;F<this.stride;F++)t[l*this.stride+F]=this.data[U*this.stride+F]}}}return t}toJSON(U){return{data:this.data,dataType:this.dataTypeName,length:this.data.length/this.stride}}fromJSON(U){const F=U.data.map((U=>J.isNumeric(U)?U:Number.POSITIVE_INFINITY));this.data=Float32Array.from(F)}loadSplitValues(U){const F=U.loadUInt32Array();if(0==F.length)return;let e=0,t=0;for(;;){const U=F[e++],Q=F[e++],l={};for(let U=0;U<Q;U++){const U=F[e++],Q=F[e++];l[U]=Q,Q>=t&&(t=Q+1)}if(this.splits[U]=l,e>=F.length)break}const Q=this.stride,l=U.loadFloat32Array(t*Q);this.splitValues=[];for(let U=0;U<t;U++){const F=l.slice(U*Q,U*Q+Q);this.splitValues.push(F)}}toString(){return JSON.stringify(this.toJSON(),null,2)}genBuffer(){return{values:this.data,count:this.getCount(),dataType:this.dataTypeName,normalized:this.normalized}}}class eF extends FF{constructor(){super("Vec3",3),this.normalized=!1}getValueRef(U){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const F=U*this.stride,e=this.data.subarray(F,F+this.stride);return new i(e)}getValue(U){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const F=U*this.stride,e=this.data.slice(F,F+this.stride);return new i(e)}setValue(U,F){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const e=U*this.stride;this.data.set(F.asArray(),e)}getFaceVertexValueRef(U,F){const e=this.getFaceVertexValueRef_array(U,F);return new i(e)}setFaceVertexValue(U,F,e){this.setFaceVertexValue_array(U,F,e.asArray())}setSplitVertexValue(U,F,e){this.setSplitVertexValue_array(U,F,e.asArray())}}n.register("Vec3Attribute",eF);class tF extends FF{constructor(){super("Vec2",2),this.normalized=!1}getValueRef(U){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const F=U*this.stride,e=this.data.subarray(F,F+this.stride);return new d(e)}getValue(U){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const F=U*this.stride,e=this.data.slice(F,F+this.stride);return new d(e)}setValue(U,F){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const e=U*this.stride;this.data.set(F.asArray(),e)}getFaceVertexValueRef(U,F){const e=this.getFaceVertexValueRef_array(U,F);return new d(e)}setFaceVertexValue(U,F,e){this.setFaceVertexValue_array(U,F,e.asArray())}setSplitVertexValue(U,F,e){this.setSplitVertexValue_array(U,F,e.asArray())}}n.register("Vec2Attribute",tF);class QF extends K{constructor(){super(),this.__boundingBox=new W,this.__boundingBoxDirty=!0,this.__metaData=new Map,this.__name="",this.__numVertices=0,this.__vertexAttributes=new Map,this.debugColor=new B(1,0,0,1),this.name="",this.addVertexAttribute("positions",new eF)}clear(){this.setNumVertices(0)}setDebugName(U){this.name=U}addVertexAttribute(U,F){F.setCount(this.__numVertices),this.__vertexAttributes.set(U,F)}hasVertexAttribute(U){return this.__vertexAttributes.has(U)}getVertexAttribute(U){return this.__vertexAttributes.get(U)}getVertexAttributes(){const U={};for(const[F,e]of this.__vertexAttributes.entries())U[F]=e;return U}get positions(){return this.__vertexAttributes.get("positions")}numVertices(){return this.__numVertices}getNumVertices(){return this.__numVertices}setNumVertices(U){this.__numVertices=U,this.__vertexAttributes.forEach((U=>U.setCount(this.__numVertices))),this.setBoundingBoxDirty()}getBoundingBox(){return this.__boundingBoxDirty&&this.updateBoundingBox(),this.__boundingBox}setBoundingBoxDirty(){this.__boundingBoxDirty=!0,this.emit("boundingBoxChanged")}updateBoundingBox(){const U=this.positions,F=new W;if(U){const e=U.getCount();for(let t=0;t<e;t++)F.addPoint(U.getValueRef(t))}this.__boundingBox=F,this.__boundingBoxDirty=!1}getMetadata(U){return this.__metaData.get(U)}hasMetadata(U){return this.__metaData.has(U)}setMetadata(U,F){this.__metaData.set(U,F)}deleteMetadata(U){this.__metaData.delete(U)}genBuffers(U){const F={};for(const[U,e]of this.__vertexAttributes)F[U]=e.genBuffer();return{numVertices:this.numVertices(),attrBuffers:F}}loadBaseGeomBinary(U){this.name=U.loadStr();const F=U.loadUInt8();this.debugColor=U.loadRGBFloat32Color();const e=U.loadUInt32();this.__boundingBox.set(U.loadFloat32Vec3(),U.loadFloat32Vec3()),this.setNumVertices(e);const t=this.positions;let Q,l;2&F&&(Q=this.getVertexAttribute("normals"),Q||(Q=new eF,this.addVertexAttribute("normals",Q))),4&F&&(l=this.getVertexAttribute("texCoords"),l||(l=new tF,this.addVertexAttribute("texCoords",l)));const n=(U,F,e,Q)=>{for(let l=U[0];l<U[1];l++){const U=new i(Q[3*l+0]/255,Q[3*l+1]/255,Q[3*l+2]/255);U.multiplyInPlace(e),U.addInPlace(F),t&&t.setValue(l,U)}},a=(U,F,e,t)=>{e.isNull()&&e.set(1,1,1);for(let l=U[0];l<U[1];l++){const U=new i(t[3*l+0]/255,t[3*l+1]/255,t[3*l+2]/255);U.multiplyInPlace(e),U.addInPlace(F),U.normalizeInPlace(),Q.setValue(l,U)}},s=(U,F,e,t)=>{for(let Q=U[0];Q<U[1];Q++){const U=new d(t[2*Q+0]/255,t[2*Q+1]/255);U.multiplyInPlace(e),U.addInPlace(F),l.setValue(Q,U)}},R=U.loadUInt32();if(1==R){{const F=this.__boundingBox,t=U.loadUInt8Array(3*e);n([0,e],F.p0,F.diagonal(),t)}if(Q){const F=new W(U.loadFloat32Vec3(),U.loadFloat32Vec3()),t=U.loadUInt8Array(3*e);a([0,e],F.p0,F.diagonal(),t),Q.loadSplitValues(U)}if(l){const F=new m(U.loadFloat32Vec2(),U.loadFloat32Vec2()),t=U.loadUInt8Array(2*e);s([0,e],F.p0,F.diagonal(),t),l.loadSplitValues(U)}}else{const F=[];let t=0;for(let e=0;e<R;e++){const e=U.loadUInt32(),n={range:[t,t+e],bbox:new W(U.loadFloat32Vec3(),U.loadFloat32Vec3()),normalsRange:new W,texCoordsRange:new m};Q&&n.normalsRange.set(U.loadFloat32Vec3(),U.loadFloat32Vec3()),l&&n.texCoordsRange.set(U.loadFloat32Vec2(),U.loadFloat32Vec2()),F.push(n),t+=e}const d=U.loadUInt8Array(3*e);let i=null,B=null;Q&&(i=U.loadUInt8Array(3*e)),l&&(B=U.loadUInt8Array(2*e));for(let U=0;U<R;U++){{const e=F[U].bbox;n(F[U].range,e.p0,e.diagonal(),d)}if(Q){const e=F[U].normalsRange;a(F[U].range,e.p0,e.diagonal(),i)}if(l){const e=F[U].texCoordsRange;s(F[U].range,e.p0,e.diagonal(),B)}}Q&&Q.loadSplitValues(U),l&&l.loadSplitValues(U)}}toJSON(U){const F=super.toJSON(U);U&&U.skipTopology||(F.numVertices=this.__numVertices||0);const e={};for(const[F,t]of this.__vertexAttributes.entries())U&&"skipAttributes"in U&&U.skipAttributes.includes(F)||(e[F]=t.toJSON(U));return F.vertexAttributes=e,F}fromJSON(U,F){this.clear(),super.fromJSON(U,F),this.setNumVertices(U.numVertices);for(const F in U.vertexAttributes){let e=this.__vertexAttributes.get(F);const t=U.vertexAttributes[F];e?e.fromJSON(t):console.warn("attr undefined, cannot execute fromJSON()")}this.emit("geomDataTopologyChanged")}toString(){return JSON.stringify(this.toJSON(),null,2)}}class lF extends FF{constructor(){super("Vec4",4),this.normalized=!1}getValueRef(U){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const F=U*this.stride,e=this.data.subarray(F,F+this.stride);return new s(e)}getValue(U){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const F=U*this.stride,e=this.data.slice(F,F+this.stride);return new s(e)}setValue(U,F){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const e=U*this.stride;this.data.set(F.asArray(),e)}getFaceVertexValueRef(U,F){const e=this.getFaceVertexValueRef_array(U,F);return new s(e)}setFaceVertexValue(U,F,e){this.setFaceVertexValue_array(U,F,e.asArray())}setSplitVertexValue(U,F,e){this.setSplitVertexValue_array(U,F,e.asArray())}}n.register("Vec4Attribute",lF);class nF extends FF{constructor(){super("Color",4),this.normalized=!1}getValueRef(U){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const F=U*this.stride,e=this.data.subarray(F,F+this.stride);return new B(e)}getValue(U){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const F=U*this.stride,e=this.data.slice(F,F+this.stride);return new B(e)}setValue(U,F){if(U>=this.data.length/this.stride)throw new Error("Invalid vertex index:"+U+". Num Vertices:"+this.data.length/3);const e=U*this.stride;this.data.set(F.asArray(),e)}getFaceVertexValueRef(U,F){const e=this.getFaceVertexValueRef_array(U,F);return new B(e)}setFaceVertexValue(U,F,e){this.setFaceVertexValue_array(U,F,e.asArray())}setSplitVertexValue(U,F,e){this.setSplitVertexValue_array(U,F,e.asArray())}}n.register("ColorAttribute",nF);class aF extends QF{constructor(){super()}clear(){this.setNumVertices(0),this.emit("geomDataTopologyChanged")}loadBin(U){this.name=U.loadStr();const F=U.loadUInt32();this.__boundingBox.set(U.loadFloat32Vec3(),U.loadFloat32Vec3()),this.setNumVertices(F);const e=this.getVertexAttribute("positions");if(!e)throw Error("positions is undefined");if(F<256){const t=this.__boundingBox.toMat4(),Q=U.loadUInt8Array(3*F);for(let U=0;U<F;U++){const F=new i(Q[3*U+0]/255,Q[3*U+1]/255,Q[3*U+2]/255);e.setValue(U,t.transformVec3(F))}}else{const t=U.loadUInt32(),Q=[];for(let F=0;F<t;F++){const F=U.loadUInt32Vec2(),e=U.loadFloat32Vec3(),t=U.loadFloat32Vec3();Q.push({range:F,bbox:new W(e,t)})}const l=U.loadUInt8Array(3*F);for(let U=0;U<t;U++){const F=Q[U].bbox.toMat4();for(let t=Q[U].range.x;t<Q[U].range.y;t++){const U=new i(l[3*t+0]/255,l[3*t+1]/255,l[3*t+2]/255);e.setValue(t,F.transformVec3(U))}}}}readBinary(U,F){super.loadBaseGeomBinary(U),this.emit("geomDataChanged")}}n.register("Points",aF);class dF extends QF{constructor(){super(),this.__indices=new Uint32Array}clear(){this.setNumSegments(0),this.setNumVertices(0),this.emit("geomDataTopologyChanged")}getIndices(){return this.__indices}getNumSegments(){return this.__indices.length/2}setNumSegments(U){if(U>this.getNumSegments()){const F=new Uint32Array(2*U);F.set(this.__indices),this.__indices=F}else this.__indices=this.__indices.slice(0,2*U)}setSegmentVertexIndices(U,F,e){if(U>=this.__indices.length/2)throw new Error("Invalid line index:"+U+". Num Segments:"+this.__indices.length/2);this.__indices[2*U+0]=F,this.__indices[2*U+1]=e}getSegmentVertexIndex(U,F){return U<this.getNumSegments()?this.__indices[2*U+F]:-1}genBuffers(U){const F=super.genBuffers();let e;return e=F.numVertices<Math.pow(2,8)?new Uint8Array(this.__indices):F.numVertices<Math.pow(2,16)?new Uint16Array(this.__indices):this.__indices,F.indices=e,F}readBinary(U,F){super.loadBaseGeomBinary(U),this.setNumSegments(U.loadUInt32());const e=U.loadUInt8();1==e?this.__indices=U.loadUInt8Array():2==e?this.__indices=U.loadUInt16Array():4==e&&(this.__indices=U.loadUInt32Array()),this.emit("geomDataChanged")}toJSON(U){const F=super.toJSON(U);return U&&U.skipTopology||(F.indices=Array.from(this.__indices)),F}fromJSON(U,F){super.fromJSON(U,F),U.indices&&(this.__indices=Uint32Array.from(U.indices))}}n.register("Lines",dF);class iF extends QF{constructor(){super(),this.edgeFaces=[],this.faceEdges=[[]],this.faceCounts=[],this.__faceVertexIndices=new Uint32Array,this.__logTopologyWarnings=!1,this.__edgeAttributes=new Map,this.__faceAttributes=new Map,this.numEdges=0,this.edgeVerts=[],this.vertexEdges=[],this.edgeAngles=new Float32Array,this.edgeVecs=[]}init(){}clear(){super.clear(),this.edgeVerts=[],this.vertexEdges=[],this.numEdges=0,this.edgeAngles=new Float32Array,this.emit("geomDataTopologyChanged")}addVertexAttribute(U,F){super.addVertexAttribute(U,F),F.setMesh(this)}getFaceCounts(){return this.faceCounts}getNumFaces(){return 0==this.faceCounts.length?0:this.faceCounts.reduce(((U,F)=>U+F))}setFaceCounts(U){let F=0,e=3;for(const t of U)F+=t*e,e++;if(0==this.getNumFaces())this.__faceVertexIndices=new Uint32Array(F);else{const t=new Uint32Array(F);let Q=0,l=0;F=0,e=3,U.forEach(((U,F)=>{const n=Q+Math.min(U,this.faceCounts[F])*e;t.set(this.__faceVertexIndices.slice(Q,n),l),Q+=this.faceCounts[F]*e,l+=U*e,e++})),this.__faceVertexIndices=t}this.faceCounts=U}getFaceVertexCount(U){let F=0,e=0;return this.faceCounts.some(((t,Q)=>(F+=t,F>U&&(e=Q+3,!0)))),e}getFaceVertexOffset(U){let F=0,e=0;return this.faceCounts.some(((t,Q)=>F+t>U?(e+=(U-F)*(Q+3),!0):(F+=t,e+=t*(Q+3),!1))),e}setFaceVertexIndices(U,F){const e=this.getFaceVertexCount(U);if(F.length!=e)throw new Error(`Invalid indices for face:${U} vertexIndices:${F}. Expected ${e} indices`);const t=this.getFaceVertexOffset(U);this.__faceVertexIndices.set(F,t)}addFace(U){const F=[...this.faceCounts];if(F.length<=U.length-3){for(let e=F.length;e<U.length-3;e++)F[e]=0;F[U.length-3]=1}else F[U.length-3]++;this.setFaceCounts(F);let e=0,t=0;return this.faceCounts.some(((F,Q)=>Q+3==U.length?(e+=F-1,t+=(F-1)*(Q+3),!0):(e+=F,t+=F*(Q+3),!1))),this.__faceVertexIndices.set(U,t),e}getFaceVertexIndices(U){const F=[],e=this.getFaceVertexOffset(U),t=this.getFaceVertexCount(U);for(let U=0;U<t;U++)F.push(this.__faceVertexIndices[e+U]);return F}getFaceVertexIndex(U,F){const e=this.getFaceVertexOffset(U);return this.__faceVertexIndices[e+F]}addFaceAttribute(U,F){return F.setCount(this.getNumFaces()),this.__faceAttributes.set(U,F),F}hasFaceAttribute(U){return this.__faceAttributes.has(U)}getFaceAttribute(U){return this.__faceAttributes.get(U)}addEdgeAttribute(U,F){F.setCount(this.numEdges),this.__edgeAttributes.set(U,F)}hasEdgeAttribute(U){return this.__edgeAttributes.has(U)}getEdgeAttribute(U){return this.__edgeAttributes.get(U)}genTopologyInfo(){let U={};this.vertexEdges=[],this.edgeFaces=[],this.edgeVerts=[],this.faceEdges=[],this.numEdges=0;const F=this.positions,e=(e,t)=>{let Q=e,l=t;if(l<Q){const U=Q;Q=l,l=U}const n=Q+">"+l;if(n in U)return U[n];const a=F.getValueRef(Q),d=F.getValueRef(l).subtract(a),i={edgeIndex:this.edgeFaces.length/2,edgeVec:d};return U[n]=i,this.edgeFaces.push(-1),this.edgeFaces.push(-1),this.edgeVerts.push(Q),this.edgeVerts.push(l),this.numEdges++,i},t=(U,F,t)=>{const Q=e(U,F).edgeIndex;if(F<U){const U=2*Q+0;this.__logTopologyWarnings&&-1!=this.edgeFaces[U]&&console.warn("Edge poly 0 already set. Mesh is non-manifold."),this.edgeFaces[U]=t}else{const U=2*Q+1;this.__logTopologyWarnings&&-1!=this.edgeFaces[U]&&console.warn("Edge poly 1 already set. Mesh is non-manifold."),this.edgeFaces[U]=t}t in this.faceEdges||(this.faceEdges[t]=[]),this.faceEdges[t].push(Q),null==this.vertexEdges[U]&&(this.vertexEdges[U]=new Set),null==this.vertexEdges[F]&&(this.vertexEdges[F]=new Set),this.vertexEdges[U].add(Q),this.vertexEdges[F].add(Q)},Q=this.getNumFaces();for(let U=0;U<Q;U++){const F=this.getFaceVertexIndices(U);for(let e=0;e<F.length;e++){t(F[e],F[(e+1)%F.length],U)}}}computeFaceNormals(){const U=this.positions,F=new eF;this.addFaceAttribute("normals",F);const e=this.getNumFaces();for(let t=0;t<e;t++){const e=this.getFaceVertexIndices(t),Q=U.getValueRef(e[0]);let l=U.getValueRef(e[1]);const n=new i;for(let F=2;F<e.length;F++){const t=U.getValueRef(e[F]),a=l.subtract(Q),d=t.subtract(Q);n.addInPlace(a.cross(d).normalize()),l=t}n.lengthSquared()<Number.EPSILON||F.setValue(t,n.normalize())}}calculateEdgeAngles(){0==this.vertexEdges.length&&this.genTopologyInfo(),this.computeFaceNormals();const U=this.positions,F=this.getFaceAttribute("normals");this.edgeVecs=[],this.edgeAngles=new Float32Array(this.numEdges);for(let e=0;e<this.edgeFaces.length;e+=2){const t=this.edgeVerts[e],Q=this.edgeVerts[e+1],l=U.getValueRef(Q).subtract(U.getValueRef(t));l.normalizeInPlace(),this.edgeVecs.push(l);const n=this.edgeFaces[e],a=this.edgeFaces[e+1];if(-1==n||-1==a){this.edgeAngles[e/2]=2*Math.PI;continue}const d=F.getValueRef(n),i=F.getValueRef(a);this.edgeAngles[e/2]=d.angleTo(i)}}computeVertexNormals(U=1){this.calculateEdgeAngles();const F=this.getFaceAttribute("normals"),e=new eF;this.addVertexAttribute("normals",e);const t=(U,F)=>{e.setValue(U,F)},Q=(U,F)=>{let e,t;const Q=this.faceEdges[U];for(const U of Q)(this.edgeVerts[2*U]==F||this.edgeVerts[2*U+1]==F)&&(e?t=this.edgeVecs[U]:e=this.edgeVecs[U]);return[e,t]};for(let n=0;n<this.vertexEdges.length;n++){if(null==this.vertexEdges[n])continue;const a=this.vertexEdges[n],d=[],s=U=>{let F=!1;for(const e of d)if(F=e.includes(U),F)break;F||d.push([U])};for(const F of a){const e=this.edgeFaces[2*F],t=this.edgeFaces[2*F+1];if(-1!=e&&-1!=t&&this.edgeAngles[F]<U){let U=-1,F=-1;for(let Q=0;Q<d.length;Q++)-1==U&&d[Q].includes(e)&&(U=Q),-1==F&&d[Q].includes(t)&&(F=Q);-1==U&&-1==F?d.push([e,t]):-1!=U&&-1!=F?U!=F&&(d[U]=d[U].concat(d[F]),d.splice(F,1)):(-1==U&&d[F].push(e),-1==F&&d[U].push(t))}else-1!=e&&s(e),-1!=t&&s(t)}d.sort(((U,F)=>U.length<F.length?1:U.length>F.length?-1:0));let R=!0;for(const U of d){const a=new i;for(const e of U){const U=Q(e,n);let t;U[0]&&U[1]?(t=U[0].angleTo(U[1]),a.addInPlace((l=e,F.getValueRef(l)).scale(t))):console.warn("variable weight is undefined because faceEdges[0] or faceEdges[1] is undefined")}a.normalizeInPlace(),R?(t(n,a),R=!1):e.setSplitVertexValues(n,U,a.asArray())}}var l;return e}computeHardEdgesIndices(U=1){0==this.edgeVerts.length&&this.calculateEdgeAngles();const F=[],e=U=>{F.push(this.edgeVerts[U]),F.push(this.edgeVerts[U+1])};for(let F=0;F<this.edgeAngles.length;F++)this.edgeAngles[F]>U&&e(2*F);return Uint32Array.from(F)}genBuffers(U){const F={};let e=0;for(const[,U]of this.__vertexAttributes){const t=U.getSplits();for(const U in t){U in F||(F[U]={});const Q=t[U];for(const t in Q){const Q=parseInt(t);Q in F[U]||(F[U][Q]=e,e++)}}}const t=this.positions.getCount(),Q=t+e;let l;U&&0==U.includeIndices||(l=this.generateTriangulatedIndices(Q,t,F));const n={};for(const[U,t]of this.__vertexAttributes){let Q;Q=0==e?t.asArray():t.generateSplitValues(F,e);const l=t.stride,a=Q.length/l;n[U]={values:Q,count:a,dimension:l,normalized:"normals"==U,dataType:t.getDataTypeName()}}return{numVertices:this.numVertices(),numRenderVerts:Q,indices:l,attrBuffers:n}}computeNumTriangles(){let U=3,F=0;for(const e of this.faceCounts)F+=e*(U-2),U++;return F}generateTriangulatedIndices(U,F,e){const t=this.computeNumTriangles();let Q;Q=U<Math.pow(2,8)?new Uint8Array(3*t):U<Math.pow(2,16)?new Uint16Array(3*t):new Uint32Array(3*t);let l=0;const n=function(U,t){U in e&&t in e[U]&&(U=F+e[U][t]),Q[l]=U,l++},a=this.getNumFaces();for(let U=0;U<a;U++){const F=this.getFaceVertexIndices(U);for(let e=0;e<F.length;e++)e>=3&&(n(F[0],U),n(F[e-1],U)),n(F[e],U)}return Q}readBinary(U,F){super.loadBaseGeomBinary(U),this.setFaceCounts(Array.from(U.loadUInt32Array()));const e=this.getNumFaces(),t=U.loadUInt8Array(e),Q=U.loadSInt32Vec2(),l=U.loadUInt8();let n;if(1==l)n=U.loadUInt8Array();else if(2==l)n=U.loadUInt16Array();else{if(4!=l)throw Error("faceVertexIndexDeltas undefined");n=U.loadUInt32Array()}let a=3,d=0;const i=this.faceCounts.map(((U,F)=>{const e=d;return d+=U*a,a++,e}));let s=0,R=0;const B=[];for(let U=0;U<e;U++){const F=t[U],e=i[F],l=F+3;B[U]=e;for(let F=0;F<l;F++){const t=e+F,l=n[s+F]+Q.x;if(0==U)this.__faceVertexIndices[t]=l;else{let e=B[U-1];e+=F<R?F:R-1,this.__faceVertexIndices[t]=this.__faceVertexIndices[e]+l}}s+=l,i[F]+=l,R=l}this.hasVertexAttribute("normals")||this.computeVertexNormals(),this.emit("geomDataChanged")}toJSON(U){const F=super.toJSON(U);return U&&U.skipTopology||(F.faceCounts=Array.from(this.faceCounts),F.faceVertexIndices=Array.from(this.__faceVertexIndices)),F}fromJSON(U,F){super.fromJSON(U,F),U.faceCounts&&(this.faceCounts=U.faceCounts),U.faceVertexIndices&&(this.__faceVertexIndices=Uint32Array.from(U.faceVertexIndices))}}n.register("Mesh",iF);class sF extends k{constructor(U){super(),this.name=U.name,this.__buffers=U.geomBuffers,this.__buffers.attrBuffers,this.boundingBox=new W,this.boundingBox.p0.__data=U.bbox.p0.__data,this.boundingBox.p1.__data=U.bbox.p1.__data,this.__metaData=new Map}getNumVertices(){return this.__buffers.numVertices}getBoundingBox(){return this.boundingBox}genBuffers(){return this.__buffers}getMetadata(U){return this.__metaData.get(U)}hasMetadata(U){return this.__metaData.has(U)}setMetadata(U,F){this.__metaData.set(U,F)}deleteMetadata(U){this.__metaData.delete(U)}}class RF extends sF{constructor(U){super(U)}}class BF extends sF{constructor(U){super(U)}getNumLineSegments(){return this.__buffers.indices.length/2}}class VF extends sF{constructor(U){super(U)}getNumTriangles(){return this.__buffers.indices.length/3}}class rF extends aF{constructor(){super(),this.dirtyTopology=!0,this.dirtyVertices=!0,this.topologyParams=[]}parameterValueChanged(U){this.setBoundingBoxDirty(),this.topologyParams.includes(U.param.getName())?(this.dirtyTopology=!0,this.emit("geomDataTopologyChanged")):(this.dirtyVertices=!0,this.setBoundingBoxDirty(),this.emit("geomDataChanged")),super.parameterValueChanged(U)}update(){this.dirtyTopology?(this.rebuild(),this.dirtyTopology=!1,this.dirtyVertices=!1,this.rebuild()):this.dirtyVertices&&(this.dirtyVertices=!1,this.resize(),this.dirtyVertices=!1)}getBoundingBox(){return this.update(),super.getBoundingBox()}getNumVertices(){return this.update(),super.getNumVertices()}genBuffers(U){return this.update(),super.genBuffers(U)}toJSON(U){U||(U={}),U.skipTopology=!0,U.skipAttributes=["positions","normals","texCoords"];const F=super.toJSON(U);return U.skipTopology=!1,U.skipAttributes=[],F}}class hF extends dF{constructor(){super(),this.dirtyTopology=!0,this.dirtyVertices=!0,this.topologyParams=[]}parameterValueChanged(U){this.setBoundingBoxDirty(),this.topologyParams.includes(U.param.getName())?(this.dirtyTopology=!0,this.emit("geomDataTopologyChanged")):(this.dirtyVertices=!0,this.setBoundingBoxDirty(),this.emit("geomDataChanged")),super.parameterValueChanged(U)}update(){this.dirtyTopology?(this.rebuild(),this.dirtyTopology=!1,this.dirtyVertices=!1,this.rebuild()):this.dirtyVertices&&(this.resize(),this.dirtyVertices=!1,this.resize())}getBoundingBox(){return this.update(),super.getBoundingBox()}getNumVertices(){return this.update(),super.getNumVertices()}genBuffers(U){return this.update(),super.genBuffers()}toJSON(U){U||(U={}),U.skipTopology=!0,U.skipAttributes=["positions","normals","texCoords"];const F=super.toJSON(U);return U.skipTopology=!1,U.skipAttributes=[],F}fromJSON(U,F){super.fromJSON(U,F)}}class oF extends iF{constructor(){super(),this.dirtyTopology=!0,this.dirtyVertices=!0,this.topologyParams=[]}parameterValueChanged(U){this.setBoundingBoxDirty(),this.topologyParams.includes(U.param.getName())?(this.dirtyTopology=!0,this.emit("geomDataTopologyChanged")):(this.dirtyVertices=!0,this.setBoundingBoxDirty(),this.emit("geomDataChanged")),super.parameterValueChanged(U)}update(){this.dirtyTopology?(this.vertexEdges=[],this.dirtyTopology=!1,this.dirtyVertices=!1,this.rebuild()):this.dirtyVertices&&(this.dirtyVertices=!1,this.resize())}getBoundingBox(){return this.update(),super.getBoundingBox()}getNumVertices(){return this.update(),super.getNumVertices()}computeVertexNormals(U=1){return this.update(),super.computeVertexNormals(U)}computeHardEdgesIndices(U=1){return this.update(),super.computeHardEdgesIndices(U)}genBuffers(U){return this.update(),super.genBuffers(U)}toJSON(U){U||(U={}),U.skipTopology=!0,U.skipAttributes=["positions","normals","texCoords"];const F=super.toJSON(U);return U.skipTopology=!1,U.skipAttributes=[],F}}class JF extends rF{constructor(U=1,F=1,e=1,t=1,Q=!1){if(super(),this.topologyParams=[],isNaN(U)||isNaN(F)||isNaN(e)||isNaN(t))throw new Error("Invalid geom args");this.sizeXParam=this.addParameter(new hU("X",U)),this.sizeYParam=this.addParameter(new hU("Y",F)),this.divisionsXParam=this.addParameter(new hU("XDivisions",e)),this.divisionsYParam=this.addParameter(new hU("YDivisions",t)),Q&&this.addVertexAttribute("texCoords",new tF),this.topologyParams.push("XDivisions"),this.topologyParams.push("YDivisions")}rebuild(){const U=this.divisionsXParam.value,F=this.divisionsYParam.value;this.setNumVertices(U*F);const e=this.getVertexAttribute("texCoords");if(e)for(let t=0;t<F;t++){const Q=t/(F-1);for(let F=0;F<U;F++){const l=F/(U-1);e.getValueRef(t*U+F).set(l,Q)}}this.resize()}resize(){const U=this.divisionsXParam.value,F=this.divisionsYParam.value,e=this.sizeXParam.value,t=this.sizeYParam.value,Q=this.getVertexAttribute("positions");if(Q)for(let l=0;l<F;l++){const n=(l/(F-1)-.5)*t;for(let F=0;F<U;F++){const t=(F/(U-1)-.5)*e;Q.getValueRef(l*U+F).set(t,n,0)}}}}n.register("PointGrid",JF);class ZF extends hF{constructor(U=1,F=1){if(super(),isNaN(U)||isNaN(F))throw new Error("Invalid geom args");this.sizeXParam=this.addParameter(new hU("X",U)),this.sizeXParam.on("valueChanged",this.resize.bind(this)),this.sizeYParam=this.addParameter(new hU("Y",F)),this.sizeYParam.on("valueChanged",this.resize.bind(this)),this.rebuild()}rebuild(){this.setNumVertices(4),this.setNumSegments(4),this.setSegmentVertexIndices(0,0,1),this.setSegmentVertexIndices(1,1,2),this.setSegmentVertexIndices(2,2,3),this.setSegmentVertexIndices(3,3,0),this.resize(!1)}resize(){const U=this.sizeXParam.value,F=this.sizeYParam.value,e=this.getVertexAttribute("positions");e&&(e.getValueRef(0).set(-.5*U,-.5*F,0),e.getValueRef(1).set(.5*U,-.5*F,0),e.getValueRef(2).set(.5*U,.5*F,0),e.getValueRef(3).set(-.5*U,.5*F,0))}}n.register("Rect",ZF);class cF extends hF{constructor(U=1,F=32,e=2*Math.PI){if(super(),this.topologyParams=[],isNaN(U)||isNaN(F))throw new Error("Invalid geom args");this.radiusParam=this.addParameter(new hU("Radius",U)),this.angleParam=this.addParameter(new hU("Angle",e)),this.sidesParam=this.addParameter(new hU("Sides",F>=3?F:3,[3,200],1)),this.topologyParams.push("Sides")}rebuild(){const U=this.sidesParam.value;this.setNumVertices(U);const F=this.angleParam.value<2*Math.PI;F?this.setNumSegments(U-1):this.setNumSegments(U);for(let e=0;e<(F?U-1:U);e++)this.setSegmentVertexIndices(e,e,(e+1)%U);this.resize()}resize(){const U=this.radiusParam.value,F=this.sidesParam.value,e=this.angleParam.value/F,t=this.getVertexAttribute("positions");if(t)for(let Q=0;Q<F;Q++)t.getValueRef(Q).set(Math.cos(e*Q)*U,Math.sin(e*Q)*U,0)}}n.register("Circle",cF);class mF extends hF{constructor(U=1){if(super(),isNaN(U))throw new Error("Invalid geom args");this.sizeParam=this.addParameter(new hU("Size",U))}rebuild(){this.setNumVertices(6),this.setNumSegments(3),this.setSegmentVertexIndices(0,0,1),this.setSegmentVertexIndices(1,2,3),this.setSegmentVertexIndices(2,4,5),this.resize()}resize(){const U=this.sizeParam.value,F=this.getVertexAttribute("positions");F&&(F.getValueRef(0).set(-.5*U,0,0),F.getValueRef(1).set(.5*U,0,0),F.getValueRef(2).set(0,.5*U,0),F.getValueRef(3).set(0,-.5*U,0),F.getValueRef(4).set(0,0,.5*U),F.getValueRef(5).set(0,0,-.5*U))}}n.register("Cross",mF);class SF extends hF{constructor(U=1,F=1,e=1,t=!1){super(),this.sizeXParam=this.addParameter(new hU("X",U)),this.sizeYParam=this.addParameter(new hU("Y",F)),this.sizeZParam=this.addParameter(new hU("Z",e)),this.baseZAtZeroParam=this.addParameter(new JU("BaseZAtZero",t))}rebuild(){this.setNumVertices(8),this.setNumSegments(12),this.setSegmentVertexIndices(0,0,1),this.setSegmentVertexIndices(1,1,2),this.setSegmentVertexIndices(2,2,3),this.setSegmentVertexIndices(3,3,0),this.setSegmentVertexIndices(4,4,5),this.setSegmentVertexIndices(5,5,6),this.setSegmentVertexIndices(6,6,7),this.setSegmentVertexIndices(7,7,4),this.setSegmentVertexIndices(8,0,4),this.setSegmentVertexIndices(9,1,5),this.setSegmentVertexIndices(10,2,6),this.setSegmentVertexIndices(11,3,7),this.resize()}resize(){const U=this.sizeXParam.value,F=this.sizeYParam.value,e=this.sizeZParam.value,t=this.baseZAtZeroParam.value,Q=this.getVertexAttribute("positions");if(Q){let l=.5;t&&(l=1),Q.getValueRef(0).set(.5*U,-.5*F,l*e),Q.getValueRef(1).set(.5*U,.5*F,l*e),Q.getValueRef(2).set(-.5*U,.5*F,l*e),Q.getValueRef(3).set(-.5*U,-.5*F,l*e),l=-.5,t&&(l=0),Q.getValueRef(4).set(.5*U,-.5*F,l*e),Q.getValueRef(5).set(.5*U,.5*F,l*e),Q.getValueRef(6).set(-.5*U,.5*F,l*e),Q.getValueRef(7).set(-.5*U,-.5*F,l*e)}}}n.register("LinesCuboid",SF);class WF extends hF{constructor(U=1,F=1,e=10,t=10,Q=!1){if(super(),this.topologyParams=[],isNaN(U)||isNaN(F)||isNaN(e)||isNaN(t))throw new Error("Invalid geom args");this.xParam=this.addParameter(new hU("X",U)),this.yParam=this.addParameter(new hU("Y",F)),this.xDivisionsParam=this.addParameter(new hU("XDivisions",e)),this.yDivisionsParam=this.addParameter(new hU("YDivisions",t)),this.skipCenterLinesParam=this.addParameter(new JU("SkipCenterLines",Q)),this.topologyParams.push("XDivisions"),this.topologyParams.push("YDivisions"),this.topologyParams.push("SkipCenterLines")}rebuild(){const U=this.xDivisionsParam.value,F=this.yDivisionsParam.value,e=this.skipCenterLinesParam.value&&U%2==0&&F%2==0;this.setNumVertices(2*(U+F+2-(e?1:0))),this.setNumSegments(U+F+2-(e?1:0));let t=0;for(let F=0;F<=U;F++){if(e&&F==U/2)continue;const Q=2*t,l=2*t+1;this.setSegmentVertexIndices(t,Q,l),t++}for(let Q=0;Q<=F;Q++){if(e&&Q==U/2)continue;const F=2*t,l=2*t+1;this.setSegmentVertexIndices(t,F,l),t++}this.resize()}resize(){const U=this.getVertexAttribute("positions"),F=this.xDivisionsParam.value,e=this.yDivisionsParam.value,t=this.xParam.value,Q=this.yParam.value,l=this.skipCenterLinesParam.value&&F%2==0&&e%2==0;let n=0;for(let e=0;e<=F;e++){if(l&&e==F/2)continue;const a=2*n,d=2*n+1,i=(e/F-.5)*t;U&&(U.getValueRef(a).set(i,-.5*Q,0),U.getValueRef(d).set(i,.5*Q,0)),n++}for(let a=0;a<=e;a++){if(l&&a==F/2)continue;const d=2*n,i=2*n+1,s=(a/e-.5)*Q;U&&(U.getValueRef(d).set(-.5*t,s,0),U.getValueRef(i).set(.5*t,s,0)),n++}}}n.register("Grid",WF);class EF extends oF{constructor(U=.5,F=1,e=32,t=!0,Q=!0,l=!0){if(super(),this.topologyParams=[],isNaN(U)||isNaN(F)||isNaN(e))throw new Error("Invalid geom args");this.radiusParam=this.addParameter(new hU("Radius",U)),this.heightParam=this.addParameter(new hU("Height",F)),this.detailParam=this.addParameter(new hU("Detail",e>=3?e:3,[3,200],1)),this.capParam=this.addParameter(new JU("Cap",t)),Q&&this.addVertexAttribute("normals",new eF),l&&this.addVertexAttribute("texCoords",new tF),this.topologyParams.push("Detail"),this.topologyParams.push("Cap")}rebuild(){const U=this.detailParam.value,F=this.radiusParam.value,e=this.heightParam.value,t=this.capParam.value;let Q=U+1;t&&(Q+=1),this.setNumVertices(Q);const l=U,n=U+1,a=this.getVertexAttribute("positions");if(a){a.getValueRef(l).set(0,0,e);for(let e=0;e<U;e++){const t=-e/U*2*Math.PI;a.getValueRef(e).set(F*Math.cos(t),F*Math.sin(t),0)}t&&a.getValueRef(n).set(0,0,0)}this.setFaceCounts([U+(t?U:0)]);for(let F=0;F<U;F++){const e=(F+1)%U;this.setFaceVertexIndices(F,[e,F,l])}if(t)for(let F=0;F<U;F++){const e=(F+1)%U;this.setFaceVertexIndices(U+F,[F,e,n])}const i=this.getVertexAttribute("texCoords");if(i){let F=0;for(let e=0;e<U;e++)"setFaceVertexValue"in i&&(i.setFaceVertexValue(F,0,new d((e+1)/U,0)),i.setFaceVertexValue(F,1,new d(e/U,0)),i.setFaceVertexValue(F,2,new d((e+.5)/U,1)));if(t)for(let e=0;e<U;e++)i.setFaceVertexValue(F,0,new d(e/U,0)),i.setFaceVertexValue(F,1,new d((e+1)/U,0)),i.setFaceVertexValue(F,2,new d((e+.5)/U,1)),F++}this.resize()}resize(){const U=this.detailParam.value,F=this.radiusParam.value,e=this.heightParam.value,t=U,Q=U+1,l=this.getVertexAttribute("positions");if(l){l.getValueRef(t).set(0,0,e);for(let e=0;e<U;e++){const t=-e/U*2*Math.PI;l.getValueRef(e).set(F*Math.cos(t),F*Math.sin(t),0)}this.capParam.value&&l.getValueRef(Q).set(0,0,0)}this.dirtyTopology=!1,this.dirtyVertices=!1;this.getVertexAttribute("normals")&&this.computeVertexNormals()}}n.register("Cone",EF);class pF extends oF{constructor(U=1,F=1,e=1,t=!1){if(super(),isNaN(U)||isNaN(F)||isNaN(e))throw new Error("Invalid geom args");this.sizeXParam=this.addParameter(new hU("X",U)),this.sizeYParam=this.addParameter(new hU("Y",F)),this.sizeZParam=this.addParameter(new hU("Z",e)),this.baseZAtZeroParam=this.addParameter(new JU("BaseZAtZero",t)),this.setFaceCounts([0,6]),this.setFaceVertexIndices(0,[0,1,2,3]),this.setFaceVertexIndices(1,[7,6,5,4]),this.setFaceVertexIndices(2,[1,0,4,5]),this.setFaceVertexIndices(3,[3,2,6,7]),this.setFaceVertexIndices(4,[0,3,7,4]),this.setFaceVertexIndices(5,[2,1,5,6]),this.setNumVertices(8),this.addVertexAttribute("normals",new eF)}rebuild(){const U=this.getVertexAttribute("normals");if(U)for(let F=0;F<6;F++){let e;switch(F){case 0:e=new i(0,0,1);break;case 1:e=new i(0,0,-1);break;case 2:e=new i(1,0,0);break;case 3:e=new i(-1,0,0);break;case 4:e=new i(0,-1,0);break;default:e=new i(0,1,0)}U.setFaceVertexValue(F,0,e),U.setFaceVertexValue(F,1,e),U.setFaceVertexValue(F,2,e),U.setFaceVertexValue(F,3,e)}this.resize()}resize(){const U=this.sizeXParam.value,F=this.sizeYParam.value,e=this.sizeZParam.value,t=this.baseZAtZeroParam.value;let Q=.5;const l=this.getVertexAttribute("positions");t&&(Q=1),l&&(l.getValueRef(0).set(.5*U,-.5*F,Q*e),l.getValueRef(1).set(.5*U,.5*F,Q*e),l.getValueRef(2).set(-.5*U,.5*F,Q*e),l.getValueRef(3).set(-.5*U,-.5*F,Q*e),Q=-.5,t&&(Q=0),l.getValueRef(4).set(.5*U,-.5*F,Q*e),l.getValueRef(5).set(.5*U,.5*F,Q*e),l.getValueRef(6).set(-.5*U,.5*F,Q*e),l.getValueRef(7).set(-.5*U,-.5*F,Q*e))}}n.register("Cuboid",pF);class uF extends oF{constructor(U=.5,F=1,e=32,t=2,Q=!0,l=!1){if(super(),this.topologyParams=[],isNaN(U)||isNaN(F)||isNaN(e)||isNaN(t))throw new Error("Invalid geom args");this.radiusParam=this.addParameter(new hU("Radius",U)),this.heightParam=this.addParameter(new hU("Height",F)),this.sidesParam=this.addParameter(new hU("Sides",e>=3?e:3,[3,200],1)),this.loopsParam=this.addParameter(new hU("Loops",t>=2?t:2,[1,200],1)),this.capsParam=this.addParameter(new JU("Caps",Q)),this.baseZAtZeroParam=this.addParameter(new JU("BaseZAtZero",l)),this.addVertexAttribute("texCoords",new tF),this.addVertexAttribute("normals",new eF),this.topologyParams.push("Sides"),this.topologyParams.push("Loops"),this.topologyParams.push("Caps")}rebuild(){const U=this.sidesParam.value,F=this.loopsParam.value,e=this.capsParam.value;let t=U*F;e&&(t+=2),this.setNumVertices(t),e?this.setFaceCounts([2*U,U]):this.setFaceCounts([0,U]);let Q=0;if(e){for(let F=0;F<U;F++){const e=t-1,l=F,n=(F+1)%U;this.setFaceVertexIndices(Q++,[e,l,n])}for(let e=0;e<U;e++){const l=U*(F-1)+e,n=t-2,a=U*(F-1)+(e+1)%U;this.setFaceVertexIndices(Q++,[l,n,a])}}for(let e=0;e<F-1;e++)for(let F=0;F<U;F++){const t=U*e+(F+1)%U,l=U*e+F,n=U*(e+1)+F,a=U*(e+1)+(F+1)%U;this.setFaceVertexIndices(Q++,[t,l,n,a])}const l=this.getVertexAttribute("normals");if(l){if(Q=0,e){const F=new i(0,0,-1);for(let e=0;e<U;e++)l.setFaceVertexValue(Q,0,F),l.setFaceVertexValue(Q,1,F),l.setFaceVertexValue(Q,2,F),Q++;F.set(0,0,1);for(let e=0;e<U;e++)l.setFaceVertexValue(Q,0,F),l.setFaceVertexValue(Q,1,F),l.setFaceVertexValue(Q,2,F),Q++}for(let e=0;e<F-1;e++)for(let F=0;F<U;F++){let e=F/U*2*Math.PI;const t=new i(Math.sin(e),Math.cos(e),0);l.setFaceVertexValue(Q,0,t),l.setFaceVertexValue(Q,1,t),e=(F+1)/U*2*Math.PI;const n=new i(Math.sin(e),Math.cos(e),0);l.setFaceVertexValue(Q,2,n),l.setFaceVertexValue(Q,3,n),Q++}}const n=this.getVertexAttribute("texCoords");if(n){if(Q=0,e){for(let F=0;F<U;F++)n.setFaceVertexValue(Q,0,new d(F/U,0)),n.setFaceVertexValue(Q,1,new d((F+1)/U,0)),n.setFaceVertexValue(Q,2,new d((F+.5)/U,1)),Q++;for(let F=0;F<U;F++)n.setFaceVertexValue(Q,0,new d(F/U,0)),n.setFaceVertexValue(Q,1,new d((F+1)/U,0)),n.setFaceVertexValue(Q,2,new d((F+.5)/U,1)),Q++}for(let F=0;F<U;F++)n.setFaceVertexValue(Q,0,new d((F+1)/U,0)),n.setFaceVertexValue(Q,2,new d((F+1)/U,1)),n.setFaceVertexValue(Q,1,new d(F/U,0)),n.setFaceVertexValue(Q,3,new d(F/U,1)),Q++}this.resize()}resize(){const U=this.sidesParam.value,F=this.loopsParam.value,e=this.radiusParam.value,t=this.heightParam.value,Q=this.capsParam.value,l=this.baseZAtZeroParam.value;let n=U*F;Q&&(n+=2);let a=0,d=.5;l&&(d=0);const i=this.getVertexAttribute("positions");if(i){for(let Q=0;Q<F;Q++){const l=Q/(F-1)*t-t*d;for(let F=0;F<U;F++){const t=F/U*2*Math.PI;i.getValueRef(a).set(Math.sin(t)*e,Math.cos(t)*e,l),a++}}Q&&(i.getValueRef(n-1).set(0,0,t*(l?0:-.5)),i.getValueRef(n-2).set(0,0,t*(l?1:.5)))}this.dirtyTopology=!1,this.dirtyVertices=!1,this.computeVertexNormals()}}n.register("Cylinder",uF);class NF extends oF{constructor(U=.5,F=32){if(super(),this.topologyParams=[],isNaN(U)||isNaN(F))throw new Error("Invalid geom args");this.radiusParam=this.addParameter(new hU("Radius",U)),this.sidesParam=this.addParameter(new hU("Sides",F>=3?F:3,[3,200],1)),this.addVertexAttribute("texCoords",new tF),this.addVertexAttribute("normals",new eF),this.topologyParams.push("Sides")}rebuild(){const U=this.sidesParam.value;this.setNumVertices(U+1),this.setFaceCounts([U]);const F=this.getVertexAttribute("positions");F&&F.getValueRef(0).set(0,0,0);for(let F=0;F<U;F++){const e=F%U+1,t=(F+1)%U+1;this.setFaceVertexIndices(F,[0,e,t])}const e=this.getVertexAttribute("normals");if(e){const F=new i(0,0,1);e.setValue(0,F);for(let t=0;t<U;t++)e.setValue(t+1,F)}const t=this.getVertexAttribute("texCoords");if(t){t.getValueRef(0).set(.5,.5);for(let F=0;F<U;F++){const e=F/U*2*Math.PI;t.getValueRef(F+1).set(.5*Math.sin(e)+.5,.5*Math.cos(e)+.5)}}this.resize()}resize(){const U=this.sidesParam.value,F=this.radiusParam.value,e=this.getVertexAttribute("positions");if(e)for(let t=0;t<U;t++){const Q=t/U*2*Math.PI;e.getValueRef(t+1).set(Math.sin(Q)*F,Math.cos(Q)*F,0)}}}n.register("Disc",NF);class kF extends oF{constructor(U=1,F=1,e=1,t=1,Q=!0,l=!0){if(super(),this.topologyParams=[],isNaN(U)||isNaN(F)||isNaN(e)||isNaN(t))throw new Error("Invalid geom args");this.sizeXParam=this.addParameter(new hU("SizeX",U)),this.sizeYParam=this.addParameter(new hU("SizeY",F)),this.detailXParam=this.addParameter(new hU("DetailX",e)),this.detailYParam=this.addParameter(new hU("DetailY",t)),Q&&this.addVertexAttribute("normals",new eF),l&&this.addVertexAttribute("texCoords",new tF),this.topologyParams.push("DetailX"),this.topologyParams.push("DetailY")}rebuild(){const U=this.detailXParam.value,F=this.detailYParam.value;this.setNumVertices((U+1)*(F+1)),this.setFaceCounts([0,U*F]);let e=0;for(let t=0;t<F;t++)for(let F=0;F<U;F++){const Q=(U+1)*(t+1)+F,l=(U+1)*t+F,n=(U+1)*t+(F+1),a=(U+1)*(t+1)+(F+1);this.setFaceVertexIndices(e,[Q,l,n,a]),e+=1}let t=0;const Q=this.getVertexAttribute("normals");if(Q)for(let e=0;e<=F;e++)for(let F=0;F<=U;F++)Q.getValueRef(t).set(0,0,1),t++;t=0;const l=this.getVertexAttribute("texCoords");if(l)for(let e=0;e<=F;e++){const Q=e/F;for(let F=0;F<=U;F++){const e=F/U;l.getValueRef(t).set(e,Q),t++}}this.resize()}resize(){const U=this.sizeXParam.value,F=this.sizeYParam.value,e=this.detailXParam.value,t=this.detailYParam.value,Q=this.getVertexAttribute("positions");if(!Q)return;let l=0;for(let n=0;n<=t;n++){const a=(n/t-.5)*F;for(let F=0;F<=e;F++){const t=(F/e-.5)*U;Q.getValueRef(l).set(t,a,0),l++}}}}n.register("Plane",kF);class bF extends oF{constructor(U=1,F=12,e=12,t=!0,Q=!0){if(super(),this.radiusParam=new hU("Radius",1),this.sidesParam=new hU("Sides",12,[3,200],1),this.loopsParam=new hU("Loops",6,[3,200],1),isNaN(U)||isNaN(F)||isNaN(e))throw new Error("Invalid geom args");this.addParameter(this.radiusParam),this.addParameter(this.sidesParam),this.addParameter(this.loopsParam),this.radiusParam.value=U,this.sidesParam.value=F,this.loopsParam.value=e,t&&this.addVertexAttribute("normals",new eF),Q&&this.addVertexAttribute("texCoords",new tF),this.topologyParams.push("Sides"),this.topologyParams.push("Loops")}rebuild(){const U=this.radiusParam.value,F=this.sidesParam.value,e=this.loopsParam.value,t=2+F*e,Q=2*F,l=F*e;this.setNumVertices(t),this.setFaceCounts([Q,l]);const n=this.getVertexAttribute("positions"),a=this.getVertexAttribute("normals"),s=new i(0,0,1);let R=0;if(!n)return;n.getValueRef(R).set(0,0,U),a&&a.getValueRef(R).set(0,0,1),R++;for(let t=0;t<e;t++){const Q=(t+1)/(e+1)*Math.PI;for(let e=0;e<F;e++){const t=-e/F*2*Math.PI;s.set(Math.sin(Q)*Math.cos(t),Math.sin(Q)*Math.sin(t),Math.cos(Q)),n.getValueRef(R).setFromOther(s.scale(U)),a&&a.getValueRef(R).setFromOther(s),R++}}n.getValueRef(R).set(0,0,-U),a&&a.getValueRef(R).set(0,0,-1),R++;const B=this.getVertexAttribute("texCoords");let V=0;for(let U=0;U<F;U++){const t=0,Q=(U+1)%F+1,l=U+1;if(this.setFaceVertexIndices(V,[t,Q,l]),B){const t=new d(.5,0),Q=new d((U+1)/(F-1),1/(e+1)),l=new d(U/(F-1),1/(e+1));B.setFaceVertexValue(V,0,t),B.setFaceVertexValue(V,1,Q),B.setFaceVertexValue(V,2,l)}V++}for(let U=0;U<F;U++){const Q=t-1,l=F*(e-1)+(U+1)%F+1,n=F*(e-1)+U+1;if(this.setFaceVertexIndices(V,[Q,n,l]),B){const t=new d(.5,1),Q=new d((U+1)/(F-1),1-1/(e+1)),l=new d(U/(F-1),1-1/(e+1));B.setFaceVertexValue(V,0,t),B.setFaceVertexValue(V,1,Q),B.setFaceVertexValue(V,2,l)}V++}for(let U=0;U<e-1;U++)for(let t=0;t<F;t++){const Q=F*U+t+1,l=F*U+(t+1)%F+1,n=F*(U+1)+(t+1)%F+1,a=F*(U+1)+t+1;this.setFaceVertexIndices(V,[Q,l,n,a]),B&&(B.setFaceVertexValue(V,0,new d(t/F,(U+1)/e)),B.setFaceVertexValue(V,1,new d((t+1)/F,(U+1)/e)),B.setFaceVertexValue(V,2,new d((t+1)/F,(U+2)/e)),B.setFaceVertexValue(V,3,new d(t/F,(U+2)/e))),V++}}resize(){const U=this.radiusParam.value,F=this.sidesParam.value,e=this.loopsParam.value;if(!F||!e)return void console.warn("resize() failed");const t=this.getVertexAttribute("positions"),Q=this.getVertexAttribute("normals");let l=0;const n=new i(0,0,1);t.getValueRef(l).set(0,0,U),Q&&Q.getValueRef(l).set(0,0,1),l++;for(let a=0;a<e;a++){const d=(a+1)/(e+1)*Math.PI;for(let e=0;e<F;e++){const a=-e/F*2*Math.PI;n.set(Math.sin(d)*Math.cos(a),Math.sin(d)*Math.sin(a),Math.cos(d)),t.getValueRef(l).setFromOther(n.scale(U)),Q&&Q.getValueRef(l).setFromOther(n),l++}}t.getValueRef(l).set(0,0,-U),Q&&Q.getValueRef(l).set(0,0,-1),l++}}n.register("Sphere",bF);class CF extends oF{constructor(U=.5,F=3,e=32,t=2*Math.PI){if(super(),isNaN(U)||isNaN(F)||isNaN(e))throw new Error("Invalid geom args");this.innerRadiusParam=this.addParameter(new hU("InnerRadius",U)),this.outerRadiusParam=this.addParameter(new hU("OuterRadius",F)),this.detailParam=this.addParameter(new hU("Detail",e>=3?e:3,[3,200],1)),this.arcAngleParam=this.addParameter(new hU("ArcAngle",t)),this.addVertexAttribute("texCoords",new tF),this.addVertexAttribute("normals",new eF),this.topologyParams.push("Detail"),this.topologyParams.push("ArcAngle")}rebuild(){const U=this.arcAngleParam.value<2*Math.PI,F=this.detailParam.value,e=F,t=2*F+(U?1:0),Q=e*t;this.setNumVertices(Q),this.setFaceCounts([0,e*t]);const l=this.getVertexAttribute("texCoords");if(l){let F=0;for(let Q=0;Q<(U?t-1:t);Q++)for(let U=0;U<e;U++){const n=(Q+1)%t,a=(U+1)%e,i=e*Q+U,s=e*Q+a,R=e*n+a,B=e*n+U;this.setFaceVertexIndices(F,[i,s,R,B]),l.setFaceVertexValue(F,0,new d(Q/t,U/t)),l.setFaceVertexValue(F,1,new d(Q/t,(U+1)/t)),l.setFaceVertexValue(F,2,new d((Q+1)/t,(U+1)/t)),l.setFaceVertexValue(F,3,new d((Q+1)/t,U/t)),F++}}this.resize()}resize(){const U=this.innerRadiusParam.value,F=this.outerRadiusParam.value,e=this.arcAngleParam.value,t=this.detailParam.value,Q=e<2*Math.PI,l=t,n=2*t+(Q?1:0),a=this.getVertexAttribute("positions"),d=this.getVertexAttribute("normals");if(!a||!d)return;let i=0;for(let t=0;t<n;t++){const s=-t/(Q?n-1:n)*e,R=Math.cos(s),B=Math.sin(s);for(let e=0;e<l;e++){const t=e/l*2*Math.PI,Q=Math.sin(t),n=Math.cos(t),s=F+n*U;a.getValueRef(i).set(R*s,B*s,U*Q),d.getValueRef(i).set(R*n,B*n,Q),i++}}}}n.register("Torus",CF);class TF extends KU{constructor(U){super(U),this.__data=new Uint8Array(4),null==U&&(U=this.constructor.name),this.__name=U,this.format="RGBA",this.type="UNSIGNED_BYTE",this.__loaded=!1,this.width=1,this.height=1}isLoaded(){return this.__loaded}isStream(){return!1}setData(U,F,e){this.__data!=e&&(this.width=U,this.height=F,this.__data=e,this.__loaded?this.emit("updated"):(this.__loaded=!0,this.emit("loaded")))}getParams(){const U=super.getParams();return U.data=this.__data,U}}n.register("DataImage2D",TF),n.register("DataImage",TF);const GF={};class XF extends KU{constructor(U,F="",e={}){super(U),this.__data=null,this.type="UNSIGNED_BYTE",this.crossOrigin="anonymous",this.loaded=!1,F&&""!=F&&this.load(F)}setCrossOrigin(U){this.crossOrigin=U}getDOMElement(){return this.__data}load(U,F="RGB"){return new Promise(((e,t)=>{if(!F){const e=U.lastIndexOf(".");if(-1!=e){".png"==U.substring(e).toLowerCase()&&(F="RGBA")}}this.format=F,this.loaded=!1;const Q=()=>{this.url=U,this.width=this.__data.width,this.height=this.__data.height,this.loaded=!0,this.emit("loaded"),e()};U in GF?(this.__data=GF[U],this.__data.complete?Q():(this.__data.addEventListener("load",Q),this.__data.addEventListener("error",t))):(this.__data=new Image,this.__data.crossOrigin=this.crossOrigin,this.__data.src=U,this.__data.addEventListener("load",Q),this.__data.addEventListener("error",t),GF[U]=this.__data)}))}setImageURL(U,F="RGB"){this.load(U,F)}getParams(){const U=super.getParams();return this.loaded&&(U.data=this.__data),U}toJSON(U){return{}}fromJSON(U,F){}readBinary(U,F){this.setName(U.loadStr());const e=U.loadStr();if("string"==typeof e&&""!=e){const U=F.url.substring(0,F.url.lastIndexOf("/"));this.load(U+"/"+e)}}}n.register("FileImage2D",XF),n.register("FileImage",XF);class gF extends XF{constructor(U,F,e){super(U,F,e)}}n.register("LDRImage",gF);class yF extends KU{constructor(U,F={}){let e;super(U),this.__data={},null!=U&&U.includes(".")&&(e=U,this.setName(U.substring(U.lastIndexOf("/")+1,U.lastIndexOf(".")))),this.__exposure=1,this.__ambientLightFactor=0,this.__hdrTint=new B(1,1,1,1),this.__stream="stream"in F&&F.stream,this.type="FLOAT",e&&this.load(e)}__decodeData(U){return new Promise(((F,e)=>{const t=U.ldr,Q=U.cdm,l=new Blob([t.buffer]),n=new Image;n.onload=()=>{this.width=n.width,this.height=n.height,this.__data={ldr:n,cdm:Q},this.loaded?this.emit("updated"):(this.loaded=!0,this.emit("loaded")),F()},n.src=URL.createObjectURL(l)}))}load(U){return this.loaded=!1,new Promise(((F,e)=>{const t=U.lastIndexOf("/")>-1?U.substring(U.lastIndexOf("/")+1):"",Q=t.substring(0,t.lastIndexOf("."));""==this.getName()&&this.setName(Q),this.type="FLOAT",nU.loadFile("archive",U).then((U=>{if(!U.ldr||!U.cdm)for(const F in U)F.endsWith(".jpg")?(U.ldr=U[F],delete U[F]):F.endsWith(".bin")&&(U.cdm=U[F],delete U[F]);this.__decodeData(U).then((()=>{F()}))}),(U=>{this.emit("error",U),e(U)}))}))}isStream(){return!1}getParams(){const U=super.getParams();return this.loaded&&(U.data=this.__data,U.exposure=this.__exposure),U}setHDRTint(U){this.__hdrTint=U}getHDRTint(){return this.__hdrTint}toJSON(U){return{}}fromJSON(U,F){return{}}readBinary(U,F){this.setName(U.loadStr());let e=U.loadStr();"string"==typeof e&&""!=e&&this.load(e)}}n.register("VLHImage",yF);class IF extends XF{constructor(U,F,e){super(U,F,e),this.videoElem=new HTMLVideoElement,this.muteParam=new JU("Mute",!1),this.loopParam=new JU("Loop",!0),this.spatializeAudioParam=new JU("SpatializeAudio",!0),this.refDistanceParam=new hU("refDistance",2),this.maxDistanceParam=new hU("maxDistance",1e4),this.rolloffFactorParam=new hU("rolloffFactor",1),this.coneInnerAngleParam=new hU("coneInnerAngle",360),this.coneOuterAngleParam=new hU("coneOuterAngle",0),this.coneOuterGainParam=new hU("coneOuterGain",1),this.gainParam=new hU("Gain",2),this.format="RGB",this.type="UNSIGNED_BYTE",this.addParameter(this.muteParam),this.addParameter(this.loopParam),this.addParameter(this.spatializeAudioParam),this.addParameter(this.refDistanceParam),this.addParameter(this.maxDistanceParam),this.addParameter(this.rolloffFactorParam),this.addParameter(this.coneInnerAngleParam),this.addParameter(this.coneOuterAngleParam),this.addParameter(this.coneOuterGainParam),this.addParameter(this.gainParam).setRange([0,5])}getAudioSource(){return this.videoElem}load(U,F="RGB"){return new Promise(((F,e)=>{nU.incrementWorkload(1),this.videoElem.style.display="none",this.videoElem.preload="auto",this.videoElem.crossOrigin="anonymous",document.body.appendChild(this.videoElem),this.videoElem.addEventListener("loadedmetadata",(()=>{this.videoElem.muted=this.muteParam.value,this.muteParam.on("valueChanged",(()=>{this.videoElem.muted=this.muteParam.value})),this.videoElem.loop=this.loopParam.value,this.loopParam.on("valueChanged",(()=>{this.videoElem.loop=this.loopParam.value})),this.width=this.videoElem.videoHeight,this.height=this.videoElem.videoWidth,this.loaded=!0,nU.incrementWorkDone(1),this.emit("loaded"),F(t);let U=0;const e=()=>{if(this.videoElem.paused||this.videoElem.ended)return;const F=Math.floor(29.97*this.videoElem.currentTime);U!=F&&(this.emit("updated"),U=F),setTimeout(e,20)};e()}),!1),this.videoElem.src=U;const t=this.videoElem.play();void 0!==t&&t.then((U=>{console.log("Autoplay started!")})).catch((()=>{console.log("Autoplay was prevented.")}))}))}getParams(){const U=super.getParams();return this.loaded&&(U.data=this.videoElem),U}}function xF(U){this.data=U,this.pos=0}function fF(U){this.stream=new xF(U),this.output={}}n.register("LDRVideo",IF),xF.prototype.readByte=function(){return this.data[this.pos++]},xF.prototype.peekByte=function(){return this.data[this.pos]},xF.prototype.readBytes=function(U){for(var F=new Array(U),e=0;e<U;e++)F[e]=this.readByte();return F},xF.prototype.peekBytes=function(U){for(var F=new Array(U),e=0;e<U;e++)F[e]=this.data[this.pos+e];return F},xF.prototype.readString=function(U){for(var F="",e=0;e<U;e++)F+=String.fromCharCode(this.readByte());return F},xF.prototype.readBitArray=function(){for(var U=[],F=this.readByte(),e=7;e>=0;e--)U.push(!!(F&1<<e));return U},xF.prototype.readUnsigned=function(U){var F=this.readBytes(2);return U?(F[1]<<8)+F[0]:(F[0]<<8)+F[1]},fF.prototype.parse=function(U){return this.parseParts(this.output,U),this.output},fF.prototype.parseParts=function(U,F){for(var e=0;e<F.length;e++){var t=F[e];this.parsePart(U,t)}},fF.prototype.parsePart=function(U,F){var e,t=F.label;if(!F.requires||F.requires(this.stream,this.output,U))if(F.loop){for(var Q=[];F.loop(this.stream);){var l={};this.parseParts(l,F.parts),Q.push(l)}U[t]=Q}else F.parts?(e={},this.parseParts(e,F.parts),U[t]=e):F.parser?(e=F.parser(this.stream,this.output,U),F.skip||(U[t]=e)):F.bits&&(U[t]=this.parseBits(F.bits))},fF.prototype.parseBits=function(U){var F={},e=this.stream.readBitArray();for(var t in U){var Q=U[t];Q.length?F[t]=e.slice(Q.index,Q.index+Q.length).reduce((function(U,F){return 2*U+F}),0):F[t]=e[Q.index]}return F};var MF=function(){return function(U){return U.readByte()}},vF=function(U){return function(F){return F.readBytes(U)}},DF=function(U){return function(F){return F.readString(U)}},LF=function(U){return function(F){return F.readUnsigned(U)}},YF=function(U,F){return function(e,t,Q){for(var l=F(e,t,Q),n=new Array(l),a=0;a<l;a++)n[a]=e.readBytes(U);return n}},_F={label:"blocks",parser:function(U){for(var F=[],e=U.readByte();0!==e;e=U.readByte())F=F.concat(U.readBytes(e));return F}},wF={label:"gce",requires:function(U){var F=U.peekBytes(2);return 33===F[0]&&249===F[1]},parts:[{label:"codes",parser:vF(2),skip:!0},{label:"byteSize",parser:MF()},{label:"extras",bits:{future:{index:0,length:3},disposal:{index:3,length:3},userInput:{index:6},transparentColorGiven:{index:7}}},{label:"delay",parser:LF(!0)},{label:"transparentColorIndex",parser:MF()},{label:"terminator",parser:MF(),skip:!0}]},zF={label:"image",requires:function(U){return 44===U.peekByte()},parts:[{label:"code",parser:MF(),skip:!0},{label:"descriptor",parts:[{label:"left",parser:LF(!0)},{label:"top",parser:LF(!0)},{label:"width",parser:LF(!0)},{label:"height",parser:LF(!0)},{label:"lct",bits:{exists:{index:0},interlaced:{index:1},sort:{index:2},future:{index:3,length:2},size:{index:5,length:3}}}]},{label:"lct",requires:function(U,F,e){return e.descriptor.lct.exists},parser:YF(3,(function(U,F,e){return Math.pow(2,e.descriptor.lct.size+1)}))},{label:"data",parts:[{label:"minCodeSize",parser:MF()},_F]}]},KF={label:"text",requires:function(U){var F=U.peekBytes(2);return 33===F[0]&&1===F[1]},parts:[{label:"codes",parser:vF(2),skip:!0},{label:"blockSize",parser:MF()},{label:"preData",parser:function(U,F,e){return U.readBytes(e.text.blockSize)}},_F]},HF={label:"frames",parts:[wF,{label:"application",requires:function(U,F,e){var t=U.peekBytes(2);return 33===t[0]&&255===t[1]},parts:[{label:"codes",parser:vF(2),skip:!0},{label:"blockSize",parser:MF()},{label:"id",parser:function(U,F,e){return U.readString(e.blockSize)}},_F]},{label:"comment",requires:function(U,F,e){var t=U.peekBytes(2);return 33===t[0]&&254===t[1]},parts:[{label:"codes",parser:vF(2),skip:!0},_F]},zF,KF],loop:function(U){var F=U.peekByte();return 33===F||44===F}},PF=[{label:"header",parts:[{label:"signature",parser:DF(3)},{label:"version",parser:DF(3)}]},{label:"lsd",parts:[{label:"width",parser:LF(!0)},{label:"height",parser:LF(!0)},{label:"gct",bits:{exists:{index:0},resolution:{index:1,length:3},sort:{index:4},size:{index:5,length:3}}},{label:"backgroundColorIndex",parser:MF()},{label:"pixelAspectRatio",parser:MF()}]},{label:"gct",requires:function(U,F){return F.lsd.gct.exists},parser:YF(3,(function(U,F){return Math.pow(2,F.lsd.gct.size+1)}))},HF];function OF(U){var F=new fF(new Uint8Array(U));this.raw=F.parse(PF),this.raw.hasImages=!1;for(var e=0;e<this.raw.frames.length;e++)if(this.raw.frames[e].image){this.raw.hasImages=!0;break}}OF.prototype.decompressFrame=function(U,F){if(U>=this.raw.frames.length)return null;var e=this.raw.frames[U];if(e.image){var t=e.image.descriptor.width*e.image.descriptor.height,Q=function(U,F,e){var t,Q,l,n,a,d,i,s,R,B,V,r,h,o,J,Z,c=4096,m=-1,S=e,W=new Array(e),E=new Array(c),p=new Array(c),u=new Array(c+1);for(a=(Q=1<<(r=U))+1,t=Q+2,i=m,l=(1<<(n=r+1))-1,R=0;R<Q;R++)E[R]=0,p[R]=R;for(V=s=h=o=Z=J=0,B=0;B<S;){if(0===o){if(s<n){V+=F[J]<<s,s+=8,J++;continue}if(R=V&l,V>>=n,s-=n,R>t||R==a)break;if(R==Q){l=(1<<(n=r+1))-1,t=Q+2,i=m;continue}if(i==m){u[o++]=p[R],i=R,h=R;continue}for(d=R,R==t&&(u[o++]=h,R=i);R>Q;)u[o++]=p[R],R=E[R];h=255&p[R],u[o++]=h,t<c&&(E[t]=i,p[t]=h,0==(++t&l)&&t<c&&(n++,l+=t)),i=d}o--,W[Z++]=u[o],B++}for(B=Z;B<S;B++)W[B]=0;return W}(e.image.data.minCodeSize,e.image.data.blocks,t);e.image.descriptor.lct.interlaced&&(Q=function(U,F){for(var e=new Array(U.length),t=U.length/F,Q=function(t,Q){var l=U.slice(Q*F,(Q+1)*F);e.splice.apply(e,[t*F,F].concat(l))},l=[0,4,2,1],n=[8,8,4,2],a=0,d=0;d<4;d++)for(var i=l[d];i<t;i+=n[d])Q(i,a),a++;return e}(Q,e.image.descriptor.width));var l={pixels:Q,dims:{top:e.image.descriptor.top,left:e.image.descriptor.left,width:e.image.descriptor.width,height:e.image.descriptor.height}};return e.image.descriptor.lct&&e.image.descriptor.lct.exists?l.colorTable=e.image.lct:l.colorTable=this.raw.gct,e.gce&&(l.delay=10*(e.gce.delay||10),l.disposalType=e.gce.extras.disposal,e.gce.extras.transparentColorGiven&&(l.transparentIndex=e.gce.transparentColorIndex)),F&&(l.patch=function(U){for(var F=U.pixels.length,e=new Uint8ClampedArray(4*F),t=0;t<F;t++){var Q=4*t,l=U.pixels[t],n=U.colorTable[l];e[Q]=n[0],e[Q+1]=n[1],e[Q+2]=n[2],e[Q+3]=l!==U.transparentIndex?255:0}return e}(l)),l}return null},OF.prototype.decompressFrames=function(U){for(var F=[],e=0;e<this.raw.frames.length;e++){this.raw.frames[e].image&&F.push(this.decompressFrame(e,U))}return F};const jF={};class AF extends XF{constructor(U,F="",e={}){super(U,F,e),this.streamAtlasDescParam=new mU("StreamAtlasDesc"),this.streamAtlasIndexParam=new hU("StreamAtlasIndex",0),this.format="RGBA",this.type="UNSIGNED_BYTE",this.__streamAtlas=!0,this.addParameter(this.streamAtlasDescParam),this.addParameter(this.streamAtlasIndexParam);const t=this.streamAtlasIndexParam;let Q;t.setRange([0,1]);let l=0;const n=U=>{t.value=l,Q&&setTimeout((()=>n(U)),this.getFrameDelay(l)),l=(l+1)%U};this.play=()=>{this.__resourcePromise.then((()=>{Q=!0;let U=t.getRange();if(!U)return void console.warn("numFrames is null");const F=U[1];n(F)}))},this.stop=()=>{Q=!1}}getFrameDelay(U){return 10*this.__unpackedData.frameDelays[U]}load(U,F="RGB"){return U in jF?(this.__resourcePromise=jF[U],this.__resourcePromise):(this.__resourcePromise=new Promise(((F,e)=>{nU.incrementWorkload(1),UU(U,(e=>{console.warn("Unpacking Gif client side:"+U);const t=performance.now(),Q=new OF(e).decompressFrames(!0),l=Math.sqrt(Q.length),n=[l,l];J.fract(l)>0&&(n[0]=Math.floor(n[0]+1),J.fract(l)>.5?n[1]=Math.floor(n[1]+1):n[1]=Math.floor(n[1]));const a=Q[0].dims.width,d=Q[0].dims.height,i=document.createElement("canvas"),s=i.getContext("2d"),R=document.createElement("canvas"),B=R.getContext("2d");R.width=a,R.height=d;const V=document.createElement("canvas"),r=V.getContext("2d");let h;V.width=n[0]*a,V.height=n[1]*d;const o=[],Z=(U,F)=>{const e=U.dims;o.push(U.delay/10),h&&e.width==h.width&&e.height==h.height||(i.width=e.width,i.height=e.height,h=null==s?void 0:s.createImageData(e.width,e.height)),h.data.set(U.patch),null==s||s.putImageData(h,0,0),2==U.disposalType&&(null==B||B.clearRect(0,0,R.width,R.height)),null==B||B.drawImage(i,e.left,e.top),null==r||r.drawImage(R,F%n[0]*a,Math.floor(F/n[0])*d)};for(let U=0;U<Q.length;U++)Z(Q[U],U);nU.incrementWorkDone(1);const c=null==r?void 0:r.getImageData(0,0,V.width,V.height),m=performance.now()-t;console.log(`Decode GIF '${U}' time:`+m),F({width:V.width,height:V.height,atlasSize:n,frameRange:[0,Q.length],frameDelays:o,imageData:c})}),(F=>{const t="Unable to Load URL:"+F+":"+U;console.warn(t),e(t)}))})),jF[U]=this.__resourcePromise,this.__resourcePromise.then((U=>{this.width=U.width,this.height=U.height,this.streamAtlasDescParam.value=new s(U.atlasSize[0],U.atlasSize[1],0,0),this.streamAtlasIndexParam.setRange(U.frameRange),this.__unpackedData=U,this.__data=U.imageData,this.loaded=!0,this.emit("loaded")})),this.__resourcePromise)}}n.register("GIFImage",AF);class qF extends yF{constructor(U,F={}){super(U,F),this.headlightModeParam=new JU("HeadLightMode",!1),this.addParameter(this.headlightModeParam),this.utf8decoder=new TextDecoder,this.shCoeffs=[]}__decodeData(U){const F=U.samples;if(F&&(this.luminanceData=JSON.parse(this.utf8decoder.decode(F)),this.luminanceData.shCoeffs))for(let U=0;U<9;U++)this.shCoeffs[U]=new B(this.luminanceData.shCoeffs[3*U+0],this.luminanceData.shCoeffs[3*U+1],this.luminanceData.shCoeffs[3*U+2]);return super.__decodeData(U)}dirToLuminance(U){const F=U.x,e=U.y,t=U.z,Q=this.shCoeffs[0].scale(.886227);return Q.addInPlace(this.shCoeffs[1].scale(1.023328*e)),Q.addInPlace(this.shCoeffs[2].scale(1.023328*t)),Q.addInPlace(this.shCoeffs[3].scale(1.023328*F)),Q.addInPlace(this.shCoeffs[4].scale(.858086*F*e)),Q.addInPlace(this.shCoeffs[5].scale(.858086*e*t)),Q.addInPlace(this.shCoeffs[6].scale(.743125*t*t-.247708)),Q.addInPlace(this.shCoeffs[7].scale(.858086*F*t)),Q.addInPlace(this.shCoeffs[8].scale(.429043*(F*F-e*e))),Q.luminance()}}n.register("EnvMap",qF);class $F extends k{constructor(){super(),this.__labelLibraries={},this.__language=function(){if(!globalThis.navigator)return"en";const U=new URLSearchParams(window.location.search);if(U.has("lang"))return U.get("lang");const F=globalThis.navigator;let e,t;const Q=U=>U.startsWith("en")?"En":U.startsWith("es")?"Es":U.startsWith("fr")?"Fr":U.startsWith("gb")||U.startsWith("de")?"Gb":U;if(Array.isArray(F.languages))for(e=0;e<F.languages.length;e++)if(t=F.languages[e],t&&t.length)return Q(t);return null}(),this.__foundLabelLibraries={}}loadLibrary(U,F){const e=U.substring(0,U.lastIndexOf("."));if(this.__foundLabelLibraries[e]=F,U.endsWith(".labels"))$(F,(U=>{this.__labelLibraries[e]=JSON.parse(U),this.emit("labelLibraryLoaded",{library:e})}));else if(U.endsWith(".xlsx")){const U=globalThis.XLSX;UU(F,(F=>{const t=new Uint8Array(F),Q=U.read(t,{type:"array"}),l={};Q.SheetNames.forEach((function(F){U.utils.sheet_to_json(Q.Sheets[F],{}).forEach((function(U){const F=U.Identifier;delete U.Identifier,l[F]=U}))})),this.__labelLibraries[e]=l,this.emit("labelLibraryLoaded",{library:e})}))}}isLibraryFound(U){return U in this.__foundLabelLibraries}isLibraryLoaded(U){return U in this.__labelLibraries}getLabelText(U,F){const e=this.__labelLibraries[U];if(!e)throw new Error("LabelLibrary: '"+U+"' not found in LabelManager. Found: ["+Object.keys(this.__labelLibraries)+"]");const t=e[F];if(!t)throw new Error("Label: '"+F+"' not found in LabelLibrary: '"+U+"'. Found: ["+Object.keys(e)+"]");const Q=t[this.__language];if(!Q){if(t.En)return t.En;throw new Error("labelText: '"+this.__language+"' not found in Label. Found: ["+Object.keys(t)+"]")}return Q}setLabelText(U,F,e){let t=this.__labelLibraries[U];t||(t={},this.__labelLibraries[U]=t);let Q=t[F];Q||(Q={},t[F]=Q),Q[this.__language]=e}setLanguage(U){this.__language=U}}const Ue=new $F;class Fe extends TF{constructor(U,F){super(U),this.requestedReRender=!1,this.libraryParam=new kU("Library"),this.textParam=new kU("Text",""),this.fontColorParam=new SU("FontColor",new B(0,0,0)),this.fontSizeParam=new hU("FontSize",22),this.fontParam=new kU("Font","Helvetica"),this.borderWidthParam=new hU("BorderWidth",2),this.outlineParam=new JU("Outline",!1),this.outlineColorParam=new SU("OutlineColor",new B(0,0,0)),this.backgroundParam=new JU("Background",!0),this.backgroundColorParam=new SU("BackgroundColor",new B("#FBC02D")),this.fillBackgroundParam=new JU("FillBackground",!0),this.strokeBackgroundOutlineParam=new JU("StrokeBackgroundOutline",!0),this.canvasElem=document.createElement("canvas");this.marginParam=new hU("Margin",11),this.borderRadiusParam=new hU("BorderRadius",11),this.addParameter(this.marginParam),this.addParameter(this.borderRadiusParam),this.addParameter(this.libraryParam),this.addParameter(this.textParam),this.addParameter(this.fontColorParam),this.addParameter(this.fontSizeParam),this.addParameter(this.fontParam),this.addParameter(this.borderWidthParam),this.addParameter(this.outlineParam),this.addParameter(this.outlineColorParam),this.addParameter(this.backgroundParam),this.addParameter(this.backgroundColorParam),this.addParameter(this.fillBackgroundParam),this.addParameter(this.strokeBackgroundOutlineParam);this.on("nameChanged",(()=>{this.loadLabelData()})),F&&(this.libraryParam.value=F),this.requestedReRender=!1,this.needsRender=!1,this.loadLabelData()}__parameterValueChanged(U){super.parameterValueChanged(U),this.requestedReRender||(this.requestedReRender=!0,this.loadLabelData())}loadLabelData(){Promise.all([(()=>new Promise((U=>{const F=this.libraryParam.value;if(""==F)return void U();if(!Ue.isLibraryFound(F))return console.warn("Label Library not found:",F),void U();const e=()=>{try{const U=this.getName(),e=Ue.getLabelText(F,U);this.textParam.value=e}catch(U){console.warn(U)}U()};Ue.isLibraryLoaded(F)?e():Ue.on("labelLibraryLoaded",(U=>{U.library==F&&e()}))})))(),(()=>new Promise((U=>{if(null!=document.fonts){const F=this.fontParam.value,e=this.fontSizeParam.value;document.fonts.load(e+'px "'+F+'"').then((()=>{U()}))}else U()})))()]).then((()=>{this.requestedReRender=!1,this.needsRender=!0,this.__loaded?this.emit("updated"):(this.__loaded=!0,this.emit("loaded"))}))}renderLabelToImage(){const U=this.canvasElem.getContext("2d",{alpha:!0});let F=this.textParam.value;""==F&&(F=this.getName());const e=this.fontParam.value,t=this.fontColorParam.value,Q=this.fontSizeParam.value,l=this.marginParam.value,n=this.borderWidthParam.value,a=this.borderRadiusParam.value,d=this.outlineParam.value,i=this.outlineColorParam.value,s=this.backgroundParam.value,R=this.backgroundColorParam.value,B=this.fillBackgroundParam.value,V=this.strokeBackgroundOutlineParam.value,r=l+n,h=F.split("\n");U.font=Q+'px "'+e+'"';let o=0;h.forEach((F=>{o=Math.max(U.measureText(F).width,o)}));const J=Q;this.width=Math.ceil(o+2*r),this.height=Math.ceil(J*h.length+2*r),U.canvas.width=this.width,U.canvas.height=this.height,this.canvasElem.width=this.width,this.canvasElem.height=this.height,U.fillStyle="rgba(0, 0, 0, 0.0)",U.fillRect(0,0,this.width,this.height),s&&(U.fillStyle=R.toHex(),U.strokeStyle=i.toHex(),function(U,F,e,t,Q,l,n=!1,a=!0,d){if(void 0===a&&(a=!0),void 0===l&&(l=5),"number"==typeof l)l={tl:l,tr:l,br:l,bl:l};else{const U={tl:0,tr:0,br:0,bl:0};for(const F in U)l[F]=l[F]||U[F]}U.beginPath(),U.moveTo(F+l.tl,e),U.lineTo(F+t-l.tr,e),U.quadraticCurveTo(F+t,e,F+t,e+l.tr),U.lineTo(F+t,e+Q-l.br),U.quadraticCurveTo(F+t,e+Q,F+t-l.br,e+Q),U.lineTo(F+l.bl,e+Q),U.quadraticCurveTo(F,e+Q,F,e+Q-l.bl),U.lineTo(F,e+l.tl),U.quadraticCurveTo(F,e,F+l.tl,e),U.closePath(),n&&U.fill(),a&&(U.lineWidth=d,U.stroke())}(U,n,n,this.width-2*n,this.height-2*n,a,B,V,n)),U.font=Q+'px "'+e+'"',U.textAlign="left",U.fillStyle=t.toHex(),U.textBaseline="hanging",h.forEach(((F,e)=>{U.fillText(F,r,r+e*J)})),d&&(U.strokeStyle=i.toHex(),U.lineWidth=1.5,U.strokeText(F,r,r)),this.__data=U.getImageData(0,0,this.width,this.height),this.needsRender=!1,this.emit("labelRendered",{width:this.width,height:this.height,data:this.__data})}getParams(){return this.needsRender&&this.renderLabelToImage(),super.getParams()}toJSON(U){return super.toJSON(U)}fromJSON(U,F){super.fromJSON(U,F)}}n.register("Label",Fe);class ee extends KU{constructor(){super(""),this.loaded=!1}connectWebcam(U,F,e=!1){const t={width:U,height:F,frameRate:{ideal:60,max:60}};t.facingMode=e?{exact:"environment"}:{facingMode:"user"};const Q=document.createElement("video");Q.style.display="none",Q.preload="auto",Q.crossOrigin="anonymous",document.body.appendChild(Q),navigator.mediaDevices.getUserMedia({audio:!1,video:t}).then((U=>{Q.srcObject=U,Q.onloadedmetadata=U=>{Q.play(),this.width=Q.videoWidth,this.height=Q.videoHeight,console.log("Webcam:["+this.width+", "+this.height+"]"),this.__data=Q,this.loaded=!0,this.emit("loaded");let F=0;const e=()=>{if(Q.paused||Q.ended)return;const U=Math.floor(60*Q.currentTime);F!=U&&(this.emit("updated"),F=U),setTimeout(e,20)};e()}})).catch((function(U){}))}setVideoStream(U){this.loaded=!1,this.width=U.videoWidth,this.height=U.videoHeight,this.start(),this.__data=U,this.loaded=!0,this.emit("loaded")}stop(){clearInterval(this.__intervalId)}start(){this.__intervalId=setInterval((()=>{this.emit("updated")}),20)}isLoaded(){return this.loaded}getParams(){return{type:this.type,format:this.format,width:this.width,height:this.height,data:this.__data,flipY:!0}}}n.register("VideoStreamImage2D",ee);class te extends qU{constructor(U){super(U),this.baseColorParam=new PU("BaseColor",new B(1,1,.5)),this.opacityParam=new hU("Opacity",1),this.lineThicknessParam=new hU("LineThickness",.01),this.overlayParam=new hU("Overlay",0),this.__shaderName="FatLinesShader",this.addParameter(this.baseColorParam),this.addParameter(this.opacityParam),this.addParameter(this.overlayParam),this.addParameter(this.lineThicknessParam)}}n.register("FatLinesMaterial",te);class Qe extends qU{constructor(U){super(U),this.baseColorParam=new PU("BaseColor",new B(1,1,.5)),this.pointSizeParam=new hU("PointSize",1),this.roundedParam=new hU("Rounded",1),this.borderWidthParam=new hU("BorderWidth",.2),this.overlayParam=new hU("Overlay",0),this.__shaderName="FatPointsShader",this.addParameter(this.baseColorParam),this.addParameter(this.pointSizeParam),this.addParameter(this.roundedParam),this.addParameter(this.borderWidthParam),this.addParameter(this.overlayParam)}}n.register("FatPointsMaterial",Qe);class le extends qU{constructor(U){super(U),this.baseColorParam=new PU("BaseColor",new B(1,1,.5)),this.__shaderName="FlatSurfaceShader",this.addParameter(this.baseColorParam)}}n.register("FlatSurfaceMaterial",le);class ne extends qU{constructor(U){super(U),this.baseColorParam=new PU("BaseColor",new B(1,1,.5)),this.opacityParam=new HU("Opacity",.7,[0,1]),this.overlayParam=new HU("Overlay",1e-6),this.stippleScaleParam=new hU("StippleScale",.01),this.stippleValueParam=new hU("StippleValue",0,[0,1]),this.occludedStippleValueParam=new hU("OccludedStippleValue",1,[0,1]),this.__shaderName="LinesShader",this.addParameter(this.baseColorParam),this.addParameter(this.opacityParam),this.addParameter(this.overlayParam),this.addParameter(this.stippleScaleParam),this.addParameter(this.stippleValueParam),this.addParameter(this.occludedStippleValueParam)}}n.register("LinesMaterial",ne);class ae extends qU{constructor(U){super(U),this.baseColorParam=new PU("BaseColor",new B(1,1,.5)),this.pointSizeParam=new HU("PointSize",2),this.overlayParam=new HU("Overlay",2e-5),this.__shaderName="PointsShader",this.addParameter(this.baseColorParam),this.addParameter(this.pointSizeParam),this.addParameter(this.overlayParam)}}n.register("PointsMaterial",ae);class de extends qU{constructor(U){super(U),this.baseColorParam=new PU("BaseColor",new B(1,1,.5)),this.__shaderName="ScreenSpaceShader",this.addParameter(this.baseColorParam)}}n.register("ScreenSpaceMaterial",de);class ie extends qU{constructor(U){super(U),this.baseColorParam=new PU("BaseColor",new B(1,1,.5)),this.opacityParam=new HU("Opacity",1,[0,1]),this.emissiveStrengthParam=new HU("EmissiveStrength",0,[0,1]),this.__shaderName="SimpleSurfaceShader",this.addParameter(this.baseColorParam),this.addParameter(this.opacityParam),this.addParameter(this.emissiveStrengthParam)}}n.register("SimpleSurfaceMaterial",ie);class se extends qU{constructor(U){super(U),this.baseColorParam=new PU("BaseColor",new B(1,1,.5)),this.normalParam=new PU("Normal",new B(1,1,.5)),this.ambientOcclusion=new HU("AmbientOcclusion",1,[0,1]),this.metallicParam=new HU("Metallic",.05,[0,1]),this.roughnessParam=new HU("Roughness",.5,[0,1]),this.reflectanceParam=new HU("Reflectance",.5,[0,1]),this.emissiveStrengthParam=new HU("EmissiveStrength",0,[0,1]),this.opacityParam=new HU("Opacity",1,[0,1]),this.__shaderName="StandardSurfaceShader",this.addParameter(this.baseColorParam),this.addParameter(this.normalParam),this.addParameter(this.ambientOcclusion),this.addParameter(this.metallicParam),this.addParameter(this.roughnessParam),this.addParameter(this.reflectanceParam),this.addParameter(this.emissiveStrengthParam),this.addParameter(this.opacityParam)}}n.register("StandardSurfaceMaterial",se);class Re extends DU{constructor(U){super(U),this.srcTree=null}setSrcTree(U,F){this.srcTree=U;const e=this.srcTree.clone(F);e.localXfoParam.value=new c,this.addChild(e,!1)}getSrcTree(){return this.srcTree}readBinary(U,F={}){super.readBinary(U,F);const e=U.loadStrArray();if(e.length>0)try{F.resolvePath(e,(U=>{this.setSrcTree(U,F)}),(U=>{console.warn(`Error loading InstanceItem: ${this.getPath()}, unable to resolve: ${e}. `+U.message)}))}catch(U){console.warn(`Error loading InstanceItem: ${this.getPath()}: `+U.message)}}toJSON(U={}){return super.toJSON(U)}fromJSON(U,F={}){}clone(U){const F=new Re;return F.copyFrom(this,U),F}}n.register("InstanceItem",Re);class Be extends DU{constructor(U){super(U),this.materialParam=new $U("Material"),this.overlay=!1,this.__cutAway=!1,this.__cutAwayVector=new i(1,0,0),this.__cutAwayDist=0,this.__layers=[]}setOverlay(U){this.overlay=U}isOverlay(){return this.overlay}addLayer(U){this.__layers.push(U)}getLayers(){return this.__layers}isCutawayEnabled(){return this.__cutAway}setCutawayEnabled(U){this.__cutAway=U,this.emit("cutAwayChanged")}getCutVector(){return this.__cutAwayVector}setCutVector(U){this.__cutAwayVector=U,this.emit("cutAwayChanged")}getCutDist(){return this.__cutAwayDist}setCutDist(U){this.__cutAwayDist=U,this.emit("cutAwayChanged")}readBinary(U,F){if(super.readBinary(U,F),F.versions["zea-engine"].compare([0,0,4])>=0){const e=U.loadStr();let t=F.assetItem.getMaterialLibrary().getMaterial(e,!1);if(t||(t=new qU(e,"SimpleSurfaceShader"),t.getParameter("BaseColor").loadValue(B.random(.25)),F.assetItem.getMaterialLibrary().addMaterial(t)),this.materialParam.loadValue(t),this.__layers=U.loadStrArray(),this.__layers.length>0)for(const U of this.__layers)F.addGeomToLayer(this,U)}}}let Ve=!1;class re extends IU{constructor(U,F,e){super("CalcGeomMatOperator"),this.globalXfo=new fU("GlobalXfo"),this.geomOffsetXfo=new fU("GeomOffsetXfo"),this.geomMat=new yU("GeomMat"),this.globalXfo.setParam(U),this.geomOffsetXfo.setParam(F),this.geomMat.setParam(e),this.addInput(this.globalXfo),this.addInput(this.geomOffsetXfo),this.addOutput(this.geomMat)}evaluate(){const U=this.globalXfo.getValue().toMat4(),F=this.geomOffsetXfo.getValue().toMat4();this.geomMat.setClean(U.multiply(F))}}class he extends Be{constructor(U,F,e,t){super(U),this.listenerIDs={},this.geomIndex=-1,this.assetItem=null,this.cullable=!0,this.geomOffsetXfoParam=new uU("GeomOffsetXfo"),this.geomParam=new wU("Geometry"),this.geomMatParam=new pU("GeomMat"),this.addParameter(this.geomParam),this.addParameter(this.materialParam),this.addParameter(this.geomOffsetXfoParam),this.addParameter(this.geomMatParam);const Q=()=>{this.setBoundingBoxDirty()};this.geomParam.on("valueChanged",Q),this.geomParam.on("boundingBoxChanged",Q),this.calcGeomMatOperator=new re(this.globalXfoParam,this.geomOffsetXfoParam,this.geomMatParam),F&&this.geomParam.loadValue(F),e&&this.materialParam.loadValue(e),t&&(this.localXfoParam.value=t)}_cleanBoundingBox(U){if(this.disableBoundingBox)return U;if(U=super._cleanBoundingBox(U),this.geomBBox){const F=this.geomMatParam.value;U.addPoint(F.transformVec3(this.geomBBox.p0)),U.addPoint(F.transformVec3(this.geomBBox.p1))}else{const F=this.geomParam.value;if(F)if(Ve){const e=this.geomMatParam.value;if(F instanceof sF){const t=F.__buffers.attrBuffers.positions.values,Q=U=>{const F=3*U;return new i(t.subarray(F,F+3))};for(let t=0;t<F.getNumVertices();t++)U.addPoint(e.transformVec3(Q(t)))}else{const t=F.getVertexAttribute("positions");for(let Q=0;Q<F.getNumVertices();Q++)U.addPoint(e.transformVec3(t.getValueRef(Q)))}}else U.addBox3(F.getBoundingBox(),this.geomMatParam.value)}return U}toJSON(U){return super.toJSON(U)}fromJSON(U,F){super.fromJSON(U,F),F.numGeomItems++}readBinary(U,F){super.readBinary(U,F),F.numGeomItems++;const e=U.loadUInt8(),t=U.loadUInt32(),Q=F.assetItem.getGeometryLibrary();this.geomIndex=t,this.assetItem=F.assetItem;const l=Q.getGeom(t);if(l)this.geomParam.loadValue(l);else{const U=U=>{const{range:e}=U;if(t>=e[0]&&t<e[1]){const U=Q.getGeom(t);U?this.geomParam.value=U:console.warn("Geom not loaded:",this.getName()),Q.removeListenerById("rangeLoaded",F)}},F=Q.on("rangeLoaded",U)}if(4&e&&(this.geomOffsetXfoParam.value=new c(U.loadFloat32Vec3(),U.loadFloat32Quat(),U.loadFloat32Vec3())),F.versions["zea-engine"].compare([0,0,4])<0){if(e&8){const e=F.assetItem.getMaterialLibrary(),t=U.loadStr();let Q=e.getMaterial(t);Q||(console.warn("Geom :'"+this.__name+"' Material not found:"+t),Q=e.getMaterial("Default")),this.materialParam.loadValue(Q)}else this.materialParam.loadValue(F.assetItem.getMaterialLibrary().getMaterial("Default"))}F.versions["zea-engine"].compare([3,0,0])<0?U.loadFloat32Vec2():this.geomBBox=new W(U.loadFloat32Vec3(),U.loadFloat32Vec3())}toString(U){return JSON.stringify(this.toJSON(U),null,2)}clone(U){const F=new he;return F.copyFrom(this,U),F}copyFrom(U,F){if(super.copyFrom(U,F),!U.geomParam.value&&-1!=U.geomIndex){const F=U.assetItem.getGeometryLibrary();this.assetItem=U.assetItem,this.geomIndex=U.geomIndex,this.geomBBox=U.geomBBox;const e=U=>{const{range:e}=U;if(this.geomIndex>=e[0]&&this.geomIndex<e[1]){const U=F.getGeom(this.geomIndex);U?this.geomParam.value=U:console.warn("Geom not loaded:",this.getName()),F.removeListenerById("rangeLoaded",this.listenerIDs.rangeLoaded)}};this.listenerIDs.rangeLoaded=F.on("rangeLoaded",e)}this.geomMatParam.setDirty(0)}static setCalculatePreciseBoundingBoxes(U){Ve=U}}n.register("GeomItem",he);class oe extends DU{constructor(U){super(U),this.itemsParam=new _U("Items",(U=>U instanceof DU)),this.__itemsEventHandlers=[],this.addParameter(this.itemsParam),this.itemsParam.on("itemAdded",(U=>{this.bindItem(U.item,U.index)})),this.itemsParam.on("itemRemoved",(U=>{this.unbindItem(U.item,U.index)}))}setSearchRoot(U){this.searchRoot=U}setOwner(U){this.searchRoot&&this.searchRoot!=this.getOwner()||(this.searchRoot=U),super.setOwner(U)}bindItem(U,F){if(!(U instanceof DU))return;const e={};e.pointerDown=U.on("pointerDown",(U=>{this.onPointerDown(U)})),e.pointerUp=U.on("pointerUp",(U=>{this.onPointerUp(U)})),e.pointerMove=U.on("pointerMove",(U=>{this.onPointerMove(U)})),e.pointerEnter=U.on("pointerEnter",(U=>{this.onPointerEnter(U)})),e.pointerLeave=U.on("pointerLeave",(U=>{this.onPointerLeave(U)})),this.__itemsEventHandlers.splice(F,0,e)}unbindItem(U,F){if(!(U instanceof DU))return;const e=this.__itemsEventHandlers[F];for(let F in e){const t=F.split(".");if(t.length>1){const Q=U.getParameter(t[0]);Q&&Q.removeListenerById(t[1],e[F])}else U.removeListenerById(F,e[F])}this.__itemsEventHandlers.splice(F,1)}addItem(U,F=!0){U?this.itemsParam.addItem(U,F):console.warn("Error adding item to group. Item is null")}removeItem(U,F=!0){const e=this.itemsParam.value;if(!e)return;const t=Array.from(e).indexOf(U);t&&this.itemsParam.removeItem(t,F)}clearItems(U=!0){const F=this.itemsParam.value;if(!F)return;const e=Array.from(F);for(let U=e.length-1;U>=0;U--)this.unbindItem(e[U],U);this.itemsParam.clearItems(U)}getItems(){return this.itemsParam.value}setItems(U){this.clearItems(!1),this.itemsParam.setItems(U)}toJSON(U){const F=super.toJSON(U),e=this.itemsParam.value;if(e){const t=Array.from(e),Q=[];t.forEach((F=>{const e=F.getPath();Q.push(U?U.makeRelative(e):e)})),F.treeItems=Q}return F}fromJSON(U,F){if(super.fromJSON(U,F),!U.treeItems)return void console.warn("Invalid Parameter JSON");if(!F)throw new Error("Unable to load JSON on a BaseGroup without a load context");let e=U.treeItems.length;const t=U=>{F.resolvePath(U,(U=>{this.addItem(U),e--,0==e&&this.loadDone()}),(()=>{console.warn("BaseGroup: '"+this.getName()+"'. Unable to load item:"+U)}))};for(const F of U.treeItems)t(F)}loadDone(){}copyFrom(U,F){super.copyFrom(U,F)}}class Je extends oe{constructor(U){super(U),this.highlightedParam=new JU("Highlighted",!1),this.highlightColorParam=new SU("HighlightColor",new B(.5,.5,1)),this.highlightFillParam=new hU("HighlightFill",0,[0,1]),this.addParameter(this.highlightedParam),this.highlightedParam.on("valueChanged",(()=>{this.updateHighlight()})),this.addParameter(this.highlightColorParam),this.highlightColorParam.on("valueChanged",(()=>{this.updateHighlight()})),this.addParameter(this.highlightFillParam),this.highlightFillParam.on("valueChanged",(()=>{this.updateHighlight()}))}updateVisibility(){if(super.updateVisibility()){const U=this.isVisible();return Array.from(this.itemsParam.value).forEach((F=>{F instanceof DU&&F.propagateVisibility(U?1:-1)})),!0}return!1}updateHighlight(){this.__updateHighlightHelper()}__updateHighlightHelper(){let U,F=!1;(this.highlightedParam.value||this.isSelected())&&(F=!0,U=this.highlightColorParam.value,U.a=this.highlightFillParam.value);const e="groupItemHighlight"+this.getId();Array.from(this.itemsParam.value).forEach((t=>{t instanceof DU&&(F?t.addHighlight(e,U,!0):t.removeHighlight(e,!0))}))}setSelected(U){super.setSelected(U),this.updateHighlight()}bindItem(U,F){super.bindItem(U,F);const e=this.__itemsEventHandlers[F];if(U instanceof DU){if(U instanceof DU&&this.highlightedParam.value){const F=this.highlightColorParam.value;F.a=this.highlightFillParam.value,U.addHighlight("groupItemHighlight"+this.getId(),F,!0)}this.isVisible()||U.propagateVisibility(-1),e["BoundingBox.valueChanged"]=U.boundingBoxParam.on("valueChanged",(U=>{this.setBoundingBoxDirty()}))}}unbindItem(U,F){super.unbindItem(U,F),U instanceof DU&&(this.highlightedParam.value&&U.removeHighlight("groupItemHighlight"+this.getId(),!0),this.isVisible()||U.propagateVisibility(1),U.traverse((U=>{U instanceof Be&&U.setCutawayEnabled(!1)}),!0))}clone(U){const F=new Je(this.__name+" clone");return F.copyFrom(this,U),F}}n.register("SelectionSet",Je);var Ze=eU("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgdHtzdGF0aWMgcmVwbGFjZUFsbCh0LGUscyl7cmV0dXJuIHQucmVwbGFjZShuZXcgUmVnRXhwKGUsImciKSxzKX1zdGF0aWMgc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0LGU9MCxzPTUpe3JldHVybiBKU09OLnN0cmluZ2lmeSh0LCgodCxlKT0+ZSYmZS50b0ZpeGVkP051bWJlcihlLnRvRml4ZWQocykpOmUpLGUpfXN0YXRpYyBoYXNoU3RyKHQpe2xldCBlLHMsYSxpPTA7aWYoMD09PXQubGVuZ3RoKXJldHVybiBpO2ZvcihlPTAsYT10Lmxlbmd0aDtlPGE7ZSsrKXM9dC5jaGFyQ29kZUF0KGUpLGk9KGk8PDUpLWkrcyxpfD0wO3JldHVybiBNYXRoLmFicyhpKX19Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0PTAsZT0wKXt0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgVWludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5P3RoaXMuX19kYXRhPXQ6Im51bWJlciI9PXR5cGVvZiB0JiYibnVtYmVyIj09dHlwZW9mIGU/KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMiksdGhpcy5fX2RhdGFbMF09dCx0aGlzLl9fZGF0YVsxXT1lKToib2JqZWN0Ij09dHlwZW9mIHQ/KHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMiksdGhpcy5mcm9tSlNPTih0KSk6dGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheSgyKX1nZXQgeCgpe3JldHVybiB0aGlzLl9fZGF0YVswXX1zZXQgeCh0KXt0aGlzLl9fZGF0YVswXT10fWdldCB5KCl7cmV0dXJuIHRoaXMuX19kYXRhWzFdfXNldCB5KHQpe3RoaXMuX19kYXRhWzFdPXR9c2V0KHQsZSl7dGhpcy5fX2RhdGFbMF09dCx0aGlzLl9fZGF0YVsxXT1lfXNldEZyb21PdGhlcih0KXt0aGlzLng9dC54LHRoaXMueT10Lnl9aXNFcXVhbCh0KXtyZXR1cm4gdGhpcy54PT10LngmJnRoaXMueT09dC55fW5vdEVxdWFsKHQpe3JldHVybiB0aGlzLnghPXQueCYmdGhpcy55IT10Lnl9YXBwcm94RXF1YWwodCxlPU51bWJlci5FUFNJTE9OKXtyZXR1cm4gTWF0aC5hYnModGhpcy54LXQueCk8ZSYmTWF0aC5hYnModGhpcy55LXQueSk8ZX1hZGQodCl7cmV0dXJuIG5ldyBlKHRoaXMueCt0LngsdGhpcy55K3QueSl9YWRkSW5QbGFjZSh0KXt0aGlzLngrPXQueCx0aGlzLnkrPXQueX1zdWJ0cmFjdCh0KXtyZXR1cm4gbmV3IGUodGhpcy54LXQueCx0aGlzLnktdC55KX1zdWJ0cmFjdEluUGxhY2UodCl7cmV0dXJuIHRoaXMueC09dC54LHRoaXMueS09dC55LHRoaXN9c2NhbGUodCl7cmV0dXJuIG5ldyBlKHRoaXMueCp0LHRoaXMueSp0KX1zY2FsZUluUGxhY2UodCl7dGhpcy54Kj10LHRoaXMueSo9dH1pbnZlcnQoKXtyZXR1cm4gbmV3IGUoMS90aGlzLngsMS90aGlzLnkpfWludmVydEluUGxhY2UoKXtyZXR1cm4gdGhpcy54PTEvdGhpcy54LHRoaXMueT0xL3RoaXMueSx0aGlzfW11bHRpcGx5KHQpe3JldHVybiBuZXcgZSh0aGlzLngqdC54LHRoaXMueSp0LnkpfW11bHRpcGx5SW5QbGFjZSh0KXt0aGlzLngqPXQueCx0aGlzLnkqPXQueX1sZW5ndGhTcXVhcmVkKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdO3JldHVybiB0KnQrZSplfWxlbmd0aCgpe3JldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcXVhcmVkKCkpfWRpc3RhbmNlVG8odCl7Y29uc3QgZT10aGlzLl9fZGF0YVswXS10Lngscz10aGlzLl9fZGF0YVsxXS10Lnk7cmV0dXJuIE1hdGguc3FydChlKmUrcypzKX1ub3JtYWxpemUoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLHM9dGhpcy5fX2RhdGFbMV07bGV0IGE9dCp0K3MqcztyZXR1cm4gYTxOdW1iZXIuRVBTSUxPTj9uZXcgZTooYT0xL01hdGguc3FydChhKSxuZXcgZSh0KmEscyphKSl9bm9ybWFsaXplSW5QbGFjZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXTtsZXQgcz10KnQrZSplO3M8TnVtYmVyLkVQU0lMT058fChzPTEvTWF0aC5zcXJ0KHMpLHRoaXMuc2V0KHQqcyxlKnMpKX1kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueX1jcm9zcyh0KXtyZXR1cm4gdGhpcy54KnQueS10aGlzLnkqdC54fWFuZ2xlVG8odCl7Y29uc3QgZT10aGlzLm5vcm1hbGl6ZSgpLmRvdCh0Lm5vcm1hbGl6ZSgpKTtyZXR1cm4gZT4xPzA6ZTwtMT9NYXRoLlBJOk1hdGguYWNvcyhlKX1zaWduZWRBbmdsZVRvKHQpe2NvbnN0IGU9dGhpcy5hbmdsZVRvKHQpO3JldHVybiB0aGlzLmNyb3NzKHQpPDA/LWU6ZX1yb3RhdGUodCl7Y29uc3Qgcz1NYXRoLmNvcyh0KSxhPU1hdGguc2luKHQpO3JldHVybiBuZXcgZSh0aGlzLngqcy10aGlzLnkqYSx0aGlzLngqYSt0aGlzLnkqcyl9bGVycCh0LHMpe2NvbnN0IGE9dGhpcy54LGk9dGhpcy55O3JldHVybiBuZXcgZShhK3MqKHQueC1hKSxpK3MqKHQueS1pKSl9c2V0UmFuZG9tRGlyKHQ9MSl7Y29uc3QgZT0yKk1hdGgucmFuZG9tKCkqTWF0aC5QSTtyZXR1cm4gdGhpcy5fX2RhdGFbMF09TWF0aC5jb3MoZSkqdCx0aGlzLl9fZGF0YVsxXT1NYXRoLnNpbihlKSp0LHRoaXN9c2V0UmFuZG9tKHQ9MSl7cmV0dXJuIHRoaXMuX19kYXRhWzBdPU1hdGgucmFuZG9tKCkqdCx0aGlzLl9fZGF0YVsxXT1NYXRoLnJhbmRvbSgpKnQsdGhpc31jbG9uZSgpe3JldHVybiBuZXcgZSh0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSl9YXNBcnJheSgpe3JldHVybiB0aGlzLl9fZGF0YX10b1N0cmluZygpe3JldHVybiB0LnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSl9dG9KU09OKCl7cmV0dXJue3g6dGhpcy54LHk6dGhpcy55fX1mcm9tSlNPTih0KXt0aGlzLng9dC54LHRoaXMueT10Lnl9cmVhZEJpbmFyeSh0KXt0aGlzLng9dC5sb2FkRmxvYXQzMigpLHRoaXMueT10LmxvYWRGbG9hdDMyKCl9c3RhdGljIGludGVyc2VjdGlvbk9mTGluZXModCxzLGEsaSl7Y29uc3Qgcj0odC54LXMueCkqKGEueS1pLnkpLSh0Lnktcy55KSooYS54LWkueCk7aWYoMD09cilyZXR1cm4gbnVsbDtjb25zdCBuPXQueCpzLnktdC55KnMueCxoPWEueCppLnktYS55KmkueCxvPWEueC1pLngsZD10Lngtcy54LF89YS55LWkueSxsPXQueS1zLnk7cmV0dXJuIG5ldyBlKChuKm8tZCpoKS9yLChuKl8tbCpoKS9yKX1pc1ZhbGlkKCl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fX2RhdGEpaWYodD09MS8wfHxpc05hTih0KSlyZXR1cm4hMTtyZXR1cm4hMH19Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0PTAsZT0wLHM9MCl7aWYodCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KXRoaXMuX19kYXRhPXQ7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnNvbGUud2FybigiZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjMyhuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgMykpIik7Y29uc3Qgcz10LGE9ZTt0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KHMsYSwzKX1lbHNlIm51bWJlciI9PXR5cGVvZiB0JiYibnVtYmVyIj09dHlwZW9mIGUmJiJudW1iZXIiPT10eXBlb2Ygcz8odGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheSgzKSx0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09cyk6bnVsbCE9dCYmIm9iamVjdCI9PXR5cGVvZiB0Pyh0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KDMpLHRoaXMuZnJvbUpTT04odCkpOnRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMyl9Z2V0IHgoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMF19c2V0IHgodCl7dGhpcy5fX2RhdGFbMF09dH1nZXQgeSgpe3JldHVybiB0aGlzLl9fZGF0YVsxXX1zZXQgeSh0KXt0aGlzLl9fZGF0YVsxXT10fWdldCB6KCl7cmV0dXJuIHRoaXMuX19kYXRhWzJdfXNldCB6KHQpe3RoaXMuX19kYXRhWzJdPXR9Z2V0IHh5KCl7cmV0dXJuIG5ldyBlKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdKX1nZXQgeXooKXtyZXR1cm4gbmV3IGUodGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbMl0pfXNldCh0LGUscyl7dGhpcy54PXQsdGhpcy55PXZvaWQgMCE9PWU/ZTp0LHRoaXMuej12b2lkIDAhPT1zP3M6dH1zZXREYXRhQXJyYXkodCl7dGhpcy5fX2RhdGE9dH1zZXRGcm9tT3RoZXIodCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10Lnp9aXNOdWxsKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMueCk8TnVtYmVyLkVQU0lMT04mJk1hdGguYWJzKHRoaXMueSk8TnVtYmVyLkVQU0lMT04mJk1hdGguYWJzKHRoaXMueik8TnVtYmVyLkVQU0lMT059aXMxMTEoKXtyZXR1cm4gTWF0aC5hYnMoMS10aGlzLngpPE51bWJlci5FUFNJTE9OJiZNYXRoLmFicygxLXRoaXMueSk8TnVtYmVyLkVQU0lMT04mJk1hdGguYWJzKDEtdGhpcy56KTxOdW1iZXIuRVBTSUxPTn1pc0VxdWFsKHQpe3JldHVybiB0aGlzLng9PXQueCYmdGhpcy55PT10LnkmJnRoaXMuej09dC56fW5vdEVxdWFsKHQpe3JldHVybiB0aGlzLnghPXQueCYmdGhpcy55IT10LnkmJnRoaXMueiE9dC56fWFwcHJveEVxdWFsKHQsZT1OdW1iZXIuRVBTSUxPTil7cmV0dXJuIE1hdGguYWJzKHRoaXMueC10LngpPGUmJk1hdGguYWJzKHRoaXMueS10LnkpPGUmJk1hdGguYWJzKHRoaXMuei10LnopPGV9YWRkKHQpe3JldHVybiBuZXcgcyh0aGlzLngrdC54LHRoaXMueSt0LnksdGhpcy56K3Queil9YWRkSW5QbGFjZSh0KXt0aGlzLngrPXQueCx0aGlzLnkrPXQueSx0aGlzLnorPXQuen1zdWJ0cmFjdCh0KXtyZXR1cm4gbmV3IHModGhpcy54LXQueCx0aGlzLnktdC55LHRoaXMuei10LnopfXN1YnRyYWN0SW5QbGFjZSh0KXt0aGlzLngtPXQueCx0aGlzLnktPXQueSx0aGlzLnotPXQuen1tdWx0aXBseSh0KXtyZXR1cm4gbmV3IHModGhpcy54KnQueCx0aGlzLnkqdC55LHRoaXMueip0LnopfW11bHRpcGx5SW5QbGFjZSh0KXt0aGlzLngqPXQueCx0aGlzLnkqPXQueSx0aGlzLnoqPXQuen1kaXZpZGUodCl7cmV0dXJuIG5ldyBzKHRoaXMueC90LngsdGhpcy55L3QueSx0aGlzLnovdC56KX1kaXZpZGVJblBsYWNlKHQpe3RoaXMueC89dC54LHRoaXMueS89dC55LHRoaXMuei89dC56fXNjYWxlKHQpe3JldHVybiBuZXcgcyh0aGlzLngqdCx0aGlzLnkqdCx0aGlzLnoqdCl9c2NhbGVJblBsYWNlKHQpe3RoaXMueCo9dCx0aGlzLnkqPXQsdGhpcy56Kj10fW5lZ2F0ZSgpe3JldHVybiBuZXcgcygtdGhpcy54LC10aGlzLnksLXRoaXMueil9aW52ZXJzZSgpe3JldHVybiBuZXcgcygxL3RoaXMueCwxL3RoaXMueSwxL3RoaXMueil9bGVuZ3RoU3F1YXJlZCgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdO3JldHVybiB0KnQrZSplK3Mqc31sZW5ndGgoKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3F1YXJlZCgpKX1kaXN0YW5jZVRvKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGFbMF0tdC54LHM9dGhpcy5fX2RhdGFbMV0tdC55LGE9dGhpcy5fX2RhdGFbMl0tdC56O3JldHVybiBNYXRoLnNxcnQoZSplK3MqcythKmEpfW5vcm1hbGl6ZSgpe2xldCB0PXRoaXMuX19kYXRhWzBdKnRoaXMuX19kYXRhWzBdK3RoaXMuX19kYXRhWzFdKnRoaXMuX19kYXRhWzFdK3RoaXMuX19kYXRhWzJdKnRoaXMuX19kYXRhWzJdO3JldHVybiB0PE51bWJlci5FUFNJTE9OP25ldyBzOih0PTEvTWF0aC5zcXJ0KHQpLG5ldyBzKHRoaXMuX19kYXRhWzBdKnQsdGhpcy5fX2RhdGFbMV0qdCx0aGlzLl9fZGF0YVsyXSp0KSl9bm9ybWFsaXplSW5QbGFjZSgpe2xldCB0PXRoaXMuX19kYXRhWzBdKnRoaXMuX19kYXRhWzBdK3RoaXMuX19kYXRhWzFdKnRoaXMuX19kYXRhWzFdK3RoaXMuX19kYXRhWzJdKnRoaXMuX19kYXRhWzJdO2lmKHQ8TnVtYmVyLkVQU0lMT04pcmV0dXJuO3Q9TWF0aC5zcXJ0KHQpO2NvbnN0IGU9MS90O3JldHVybiB0aGlzLl9fZGF0YVswXSo9ZSx0aGlzLl9fZGF0YVsxXSo9ZSx0aGlzLl9fZGF0YVsyXSo9ZSx0fXJlc2l6ZSh0KXtjb25zdCBlPXRoaXMuX19kYXRhWzBdKnRoaXMuX19kYXRhWzBdK3RoaXMuX19kYXRhWzFdKnRoaXMuX19kYXRhWzFdK3RoaXMuX19kYXRhWzJdKnRoaXMuX19kYXRhWzJdO2lmKGU8TnVtYmVyLkVQU0lMT04pcmV0dXJuO2NvbnN0IGE9dC9NYXRoLnNxcnQoZSk7cmV0dXJuIG5ldyBzKHRoaXMuX19kYXRhWzBdKmEsdGhpcy5fX2RhdGFbMV0qYSx0aGlzLl9fZGF0YVsyXSphKX1yZXNpemVJblBsYWNlKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGFbMF0qdGhpcy5fX2RhdGFbMF0rdGhpcy5fX2RhdGFbMV0qdGhpcy5fX2RhdGFbMV0rdGhpcy5fX2RhdGFbMl0qdGhpcy5fX2RhdGFbMl07aWYoZTxOdW1iZXIuRVBTSUxPTilyZXR1cm47Y29uc3Qgcz10L01hdGguc3FydChlKTt0aGlzLl9fZGF0YVswXSo9cyx0aGlzLl9fZGF0YVsxXSo9cyx0aGlzLl9fZGF0YVsyXSo9c31kb3QodCl7cmV0dXJuIHRoaXMueCp0LngrdGhpcy55KnQueSt0aGlzLnoqdC56fWNyb3NzKHQpe2NvbnN0IGU9dGhpcy54LGE9dGhpcy55LGk9dGhpcy56LHI9dC54LG49dC55LGg9dC56O3JldHVybiBuZXcgcyhhKmgtaSpuLGkqci1lKmgsZSpuLWEqcil9YW5nbGVUbyh0KXtjb25zdCBlPXRoaXMuZG90KHQpO3JldHVybiBlPjE/MDpNYXRoLmFjb3MoZSl9bGVycCh0LGUpe2NvbnN0IGE9dGhpcy54LGk9dGhpcy55LHI9dGhpcy56O3JldHVybiBuZXcgcyhhK2UqKHQueC1hKSxpK2UqKHQueS1pKSxyK2UqKHQuei1yKSl9YWJzKCl7cmV0dXJuIG5ldyBzKE1hdGguYWJzKHRoaXMueCksTWF0aC5hYnModGhpcy55KSxNYXRoLmFicyh0aGlzLnopKX1zZXRSYW5kb21EaXIodD0xKXtjb25zdCBlPTIqTWF0aC5yYW5kb20oKSpNYXRoLlBJLHM9MipNYXRoLnJhbmRvbSgpLTEsYT1NYXRoLnNxcnQoMS1zKnMpKnQ7cmV0dXJuIHRoaXMuX19kYXRhWzBdPU1hdGguY29zKGUpKmEsdGhpcy5fX2RhdGFbMV09TWF0aC5zaW4oZSkqYSx0aGlzLl9fZGF0YVsyXT1zKnQsdGhpc31zZXRSYW5kb20odD0xKXtyZXR1cm4gdGhpcy5fX2RhdGFbMF09KE1hdGgucmFuZG9tKCktLjUpKnQsdGhpcy5fX2RhdGFbMV09KE1hdGgucmFuZG9tKCktLjUpKnQsdGhpcy5fX2RhdGFbMl09KE1hdGgucmFuZG9tKCktLjUpKnQsdGhpc31jbG9uZSgpe3JldHVybiBuZXcgcyh0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSx0aGlzLl9fZGF0YVsyXSl9YXNBcnJheSgpe3JldHVybiB0aGlzLl9fZGF0YX10b1N0cmluZygpe3JldHVybiB0LnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSl9dG9KU09OKCl7cmV0dXJue3g6dGhpcy54LHk6dGhpcy55LHo6dGhpcy56fX1mcm9tSlNPTih0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuen1yZWFkQmluYXJ5KHQpe3RoaXMueD10LmxvYWRGbG9hdDMyKCksdGhpcy55PXQubG9hZEZsb2F0MzIoKSx0aGlzLno9dC5sb2FkRmxvYXQzMigpfWlzVmFsaWQoKXtmb3IoY29uc3QgdCBvZiB0aGlzLl9fZGF0YSlpZih0PT0xLzB8fGlzTmFOKHQpKXJldHVybiExO3JldHVybiEwfX1jbGFzcyBhe2NvbnN0cnVjdG9yKHQ9MCxlPTAscz0wLGE9MCl7aWYodCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KXRoaXMuX19kYXRhPXQ7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnNvbGUud2FybigiZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpIik7Y29uc3Qgcz10LGE9ZTt0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KHMsYSw0KX1lbHNlIm51bWJlciI9PXR5cGVvZiB0JiYibnVtYmVyIj09dHlwZW9mIGUmJiJudW1iZXIiPT10eXBlb2YgcyYmIm51bWJlciI9PXR5cGVvZiBhPyh0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KDQpLHRoaXMuX19kYXRhWzBdPXQsdGhpcy5fX2RhdGFbMV09ZSx0aGlzLl9fZGF0YVsyXT1zLHRoaXMuX19kYXRhWzNdPWEpOm51bGwhPXQmJiJvYmplY3QiPT10eXBlb2YgdD8odGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheSg0KSx0aGlzLmZyb21KU09OKHQpKTp0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KDQpfWdldCB4KCl7cmV0dXJuIHRoaXMuX19kYXRhWzBdfXNldCB4KHQpe3RoaXMuX19kYXRhWzBdPXR9Z2V0IHkoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMV19c2V0IHkodCl7dGhpcy5fX2RhdGFbMV09dH1nZXQgeigpe3JldHVybiB0aGlzLl9fZGF0YVsyXX1zZXQgeih0KXt0aGlzLl9fZGF0YVsyXT10fWdldCB0KCl7cmV0dXJuIHRoaXMuX19kYXRhWzNdfXNldCB0KHQpe3RoaXMuX19kYXRhWzNdPXR9Z2V0IHcoKXtyZXR1cm4gdGhpcy5fX2RhdGFbM119c2V0IHcodCl7dGhpcy5fX2RhdGFbM109dH1nZXQgeHl6KCl7cmV0dXJuIG5ldyBzKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdKX1zZXQodCxlLHMsYSl7dGhpcy54PXQsdGhpcy55PWUsdGhpcy56PXMsdGhpcy50PWF9c2V0RnJvbU90aGVyKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56LHRoaXMudD10LnR9aXNFcXVhbCh0KXtyZXR1cm4gdGhpcy54PT10LngmJnRoaXMueT09dC55JiZ0aGlzLno9PXQueiYmdGhpcy50PT10LnR9bm90RXF1YWwodCl7cmV0dXJuIHRoaXMueCE9dC54JiZ0aGlzLnkhPXQueSYmdGhpcy56IT10LnomJnRoaXMudCE9dC50fWFwcHJveEVxdWFsKHQsZT1OdW1iZXIuRVBTSUxPTil7cmV0dXJuIE1hdGguYWJzKHRoaXMueC10LngpPGUmJk1hdGguYWJzKHRoaXMueS10LnkpPGUmJk1hdGguYWJzKHRoaXMuei10LnopPGUmJk1hdGguYWJzKHRoaXMudC10LnQpPGV9YWRkKHQpe3JldHVybiBuZXcgYSh0aGlzLngrdC54LHRoaXMueSt0LnksdGhpcy56K3Queix0aGlzLnQrdC50KX1hZGRJblBsYWNlKHQpe3RoaXMueCs9dC54LHRoaXMueSs9dC55LHRoaXMueis9dC56LHRoaXMudCs9dC50fXN1YnRyYWN0KHQpe3JldHVybiBuZXcgYSh0aGlzLngtdC54LHRoaXMueS10LnksdGhpcy56LXQueix0aGlzLnQtdC50KX1zdWJ0cmFjdEluUGxhY2UodCl7dGhpcy54LT10LngsdGhpcy55LT10LnksdGhpcy56LT10LnosdGhpcy50LT10LnR9bXVsdGlwbHkodCl7cmV0dXJuIG5ldyBhKHRoaXMueCp0LngsdGhpcy55KnQueSx0aGlzLnoqdC56LHRoaXMudCp0LnQpfW11bHRpcGx5SW5QbGFjZSh0KXt0aGlzLngqPXQueCx0aGlzLnkqPXQueSx0aGlzLnoqPXQueix0aGlzLnQqPXQudH1kaXZpZGUodCl7cmV0dXJuIG5ldyBhKHRoaXMueC90LngsdGhpcy55L3QueSx0aGlzLnovdC56LHRoaXMudC90LnQpfWRpdmlkZUluUGxhY2UodCl7dGhpcy54Lz10LngsdGhpcy55Lz10LnksdGhpcy56Lz10LnosdGhpcy50Lz10LnR9c2NhbGUodCl7cmV0dXJuIG5ldyBhKHRoaXMueCp0LHRoaXMueSp0LHRoaXMueip0LHRoaXMudCp0KX1zY2FsZUluUGxhY2UodCl7dGhpcy5zZXQodGhpcy54KnQsdGhpcy55KnQsdGhpcy56KnQsdGhpcy50KnQpfWxlbmd0aCgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbMl07cmV0dXJuIE1hdGguc3FydCh0KnQrZSplK3MqcythKmEpfWxlbmd0aFNxdWFyZWQoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLGU9dGhpcy5fX2RhdGFbMV0scz10aGlzLl9fZGF0YVsyXSxhPXRoaXMuX19kYXRhWzNdO3JldHVybiB0KnQrZSplK3MqcythKmF9bm9ybWFsaXplKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdLHM9dGhpcy5fX2RhdGFbMl0saT10aGlzLl9fZGF0YVszXTtsZXQgcj10KnQrZSplK3MqcytpKmk7cmV0dXJuIHI8TnVtYmVyLkVQU0lMT04/bmV3IGE6KHI9MS9NYXRoLnNxcnQociksbmV3IGEodCpyLGUqcixzKnIpKX1ub3JtYWxpemVJblBsYWNlKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdLHM9dGhpcy5fX2RhdGFbMl0sYT10aGlzLl9fZGF0YVszXTtsZXQgaT10KnQrZSplK3MqcythKmE7aTxOdW1iZXIuRVBTSUxPTnx8KGk9MS9NYXRoLnNxcnQoaSksdGhpcy5zZXQodCppLGUqaSxzKmksYSppKSl9ZG90KHQpe3JldHVybiB0aGlzLngqdC54K3RoaXMueSp0LnkrdGhpcy56KnQueit0aGlzLnQqdC50fWNyb3NzKHQpe2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGk9dGhpcy56LHI9dGhpcy50LG49dC54LGg9dC55LG89dC56LGQ9dC50O3JldHVybiBuZXcgYShzKm8taSpoLGkqZC1yKm8scipuLWUqZCxlKmgtcypuKX1hbmdsZVRvKHQpe2NvbnN0IGU9dGhpcy5ub3JtYWxpemUoKSxzPXQubm9ybWFsaXplKCksYT1lLmRvdChzKTtyZXR1cm4gYT4xPzA6TWF0aC5hY29zKGEpfWxlcnAodCxlKXtjb25zdCBzPXRoaXMueCxpPXRoaXMueSxyPXRoaXMueixuPXRoaXMudDtyZXR1cm4gbmV3IGEocytlKih0LngtcyksaStlKih0LnktaSkscitlKih0LnotciksbitlKih0LnQtbikpfWNsb25lKCl7cmV0dXJuIG5ldyBhKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdLHRoaXMuX19kYXRhWzNdKX10b1ZlYzMoKXtyZXR1cm4gbmV3IHModGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbMl0pfWFzQXJyYXkoKXtyZXR1cm4gdGhpcy5fX2RhdGF9dG9TdHJpbmcoKXtyZXR1cm4gdC5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpfXRvSlNPTigpe3JldHVybnt4OnRoaXMueCx5OnRoaXMueSx6OnRoaXMueix0OnRoaXMudH19ZnJvbUpTT04odCl7dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMuej10LnosdGhpcy50PXQudH1yZWFkQmluYXJ5KHQpe3RoaXMueD10LmxvYWRGbG9hdDMyKCksdGhpcy55PXQubG9hZEZsb2F0MzIoKSx0aGlzLno9dC5sb2FkRmxvYXQzMigpLHRoaXMudD10LmxvYWRGbG9hdDMyKCl9aXNWYWxpZCgpe2Zvcihjb25zdCB0IG9mIHRoaXMuX19kYXRhKWlmKHQ9PTEvMHx8aXNOYU4odCkpcmV0dXJuITE7cmV0dXJuITB9fWNsYXNzIGl7Y29uc3RydWN0b3IodD0wLGU9MCxzPTAsYT0xKXtpZih0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXRoaXMuX19kYXRhPXQ7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnNvbGUud2FybigiZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpIik7Y29uc3Qgcz10LGE9ZTt0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KHMsYSw0KX1lbHNlIHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoNCksInN0cmluZyI9PXR5cGVvZiB0P3Quc3RhcnRzV2l0aCgiIyIpP3RoaXMuc2V0RnJvbUhleCh0KTp0aGlzLnNldEZyb21DU1NDb2xvck5hbWUodCk6KHRoaXMuX19kYXRhWzBdPXQsdGhpcy5fX2RhdGFbMV09ZSx0aGlzLl9fZGF0YVsyXT1zLHRoaXMuX19kYXRhWzNdPWEpfWdldCByKCl7cmV0dXJuIHRoaXMuX19kYXRhWzBdfXNldCByKHQpe3RoaXMuX19kYXRhWzBdPXR9Z2V0IGcoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMV19c2V0IGcodCl7dGhpcy5fX2RhdGFbMV09dH1nZXQgYigpe3JldHVybiB0aGlzLl9fZGF0YVsyXX1zZXQgYih0KXt0aGlzLl9fZGF0YVsyXT10fWdldCBhKCl7cmV0dXJuIHRoaXMuX19kYXRhWzNdfXNldCBhKHQpe3RoaXMuX19kYXRhWzNdPXR9c2V0KHQsZSxzLGE9MSl7dGhpcy5yPXQsdGhpcy5nPWUsdGhpcy5iPXMsdGhpcy5hPWF9c2V0RnJvbU90aGVyKHQpe3RoaXMucj10LnIsdGhpcy5nPXQuZyx0aGlzLmI9dC5iLHRoaXMuYT10LmF9c2V0RnJvbVNjYWxhckFycmF5KHQpe3RoaXMucj10WzBdLHRoaXMuZz10WzFdLHRoaXMuYj10WzJdLHRoaXMuYT00PT10Lmxlbmd0aD90WzNdOjF9Z2V0QXNSR0JBcnJheSgpe3JldHVyblsyNTUqdGhpcy5yLDI1NSp0aGlzLmcsMjU1KnRoaXMuYl19Z2V0QXNSR0JEaWN0KCl7cmV0dXJue3I6MjU1KnRoaXMucixnOjI1NSp0aGlzLmcsYjoyNTUqdGhpcy5ifX1zZXRGcm9tUkdCKHQsZSxzLGEpe3RoaXMucj10LzI1NSx0aGlzLmc9ZS8yNTUsdGhpcy5iPXMvMjU1LHRoaXMuYT1hP2EvMjU1OjF9c2V0RnJvbVJHQkFycmF5KHQpe3RoaXMucj10WzBdLzI1NSx0aGlzLmc9dFsxXS8yNTUsdGhpcy5iPXRbMl0vMjU1LHRoaXMuYT00PT10Lmxlbmd0aD90WzNdLzI1NToxfXNldEZyb21SR0JEaWN0KHQpe3RoaXMucj10LnIvMjU1LHRoaXMuZz10LmcvMjU1LHRoaXMuYj10LmIvMjU1LHRoaXMuYT00PT10LmE/dC5hLzI1NToxfXNldEZyb21IZXgodCl7Y29uc3QgZT1mdW5jdGlvbih0KXtjb25zdCBlPS9eIz8oW2EtZlxkXXsyfSkoW2EtZlxkXXsyfSkoW2EtZlxkXXsyfSkkL2kuZXhlYyh0KTtyZXR1cm4gZT97cjpwYXJzZUludChlWzFdLDE2KSxnOnBhcnNlSW50KGVbMl0sMTYpLGI6cGFyc2VJbnQoZVszXSwxNil9Om51bGx9KHQpO2U/dGhpcy5zZXRGcm9tUkdCKGUucixlLmcsZS5iKTpjb25zb2xlLndhcm4oIkludmFsaWQgaGV4IGNvZGU6Iit0KX1zZXRGcm9tQ1NTQ29sb3JOYW1lKHQpe2lmKHQuc3RhcnRzV2l0aCgiIyIpKXRoaXMuc2V0RnJvbUhleCh0KTtlbHNle2NvbnN0IGU9e2FsaWNlYmx1ZToiI2YwZjhmZiIsYW50aXF1ZXdoaXRlOiIjZmFlYmQ3IixhcXVhOiIjMDBmZmZmIixhcXVhbWFyaW5lOiIjN2ZmZmQ0IixhenVyZToiI2YwZmZmZiIsYmVpZ2U6IiNmNWY1ZGMiLGJpc3F1ZToiI2ZmZTRjNCIsYmxhY2s6IiMwMDAwMDAiLGJsYW5jaGVkYWxtb25kOiIjZmZlYmNkIixibHVlOiIjMDAwMGZmIixibHVldmlvbGV0OiIjOGEyYmUyIixicm93bjoiI2E1MmEyYSIsYnVybHl3b29kOiIjZGViODg3IixjYWRldGJsdWU6IiM1ZjllYTAiLGNoYXJ0cmV1c2U6IiM3ZmZmMDAiLGNob2NvbGF0ZToiI2QyNjkxZSIsY29yYWw6IiNmZjdmNTAiLGNvcm5mbG93ZXJibHVlOiIjNjQ5NWVkIixjb3Juc2lsazoiI2ZmZjhkYyIsY3JpbXNvbjoiI2RjMTQzYyIsY3lhbjoiIzAwZmZmZiIsZGFya2JsdWU6IiMwMDAwOGIiLGRhcmtjeWFuOiIjMDA4YjhiIixkYXJrZ29sZGVucm9kOiIjYjg4NjBiIixkYXJrZ3JheToiI2E5YTlhOSIsZGFya2dyZWVuOiIjMDA2NDAwIixkYXJra2hha2k6IiNiZGI3NmIiLGRhcmttYWdlbnRhOiIjOGIwMDhiIixkYXJrb2xpdmVncmVlbjoiIzU1NmIyZiIsZGFya29yYW5nZToiI2ZmOGMwMCIsZGFya29yY2hpZDoiIzk5MzJjYyIsZGFya3JlZDoiIzhiMDAwMCIsZGFya3NhbG1vbjoiI2U5OTY3YSIsZGFya3NlYWdyZWVuOiIjOGZiYzhmIixkYXJrc2xhdGVibHVlOiIjNDgzZDhiIixkYXJrc2xhdGVncmF5OiIjMmY0ZjRmIixkYXJrdHVycXVvaXNlOiIjMDBjZWQxIixkYXJrdmlvbGV0OiIjOTQwMGQzIixkZWVwcGluazoiI2ZmMTQ5MyIsZGVlcHNreWJsdWU6IiMwMGJmZmYiLGRpbWdyYXk6IiM2OTY5NjkiLGRvZGdlcmJsdWU6IiMxZTkwZmYiLGZpcmVicmljazoiI2IyMjIyMiIsZmxvcmFsd2hpdGU6IiNmZmZhZjAiLGZvcmVzdGdyZWVuOiIjMjI4YjIyIixmdWNoc2lhOiIjZmYwMGZmIixnYWluc2Jvcm86IiNkY2RjZGMiLGdob3N0d2hpdGU6IiNmOGY4ZmYiLGdvbGQ6IiNmZmQ3MDAiLGdvbGRlbnJvZDoiI2RhYTUyMCIsZ3JheToiIzgwODA4MCIsZ3JlZW46IiMwMDgwMDAiLGdyZWVueWVsbG93OiIjYWRmZjJmIixob25leWRldzoiI2YwZmZmMCIsaG90cGluazoiI2ZmNjliNCIsImluZGlhbnJlZCAiOiIjY2Q1YzVjIixpbmRpZ286IiM0YjAwODIiLGl2b3J5OiIjZmZmZmYwIixraGFraToiI2YwZTY4YyIsbGF2ZW5kZXI6IiNlNmU2ZmEiLGxhdmVuZGVyYmx1c2g6IiNmZmYwZjUiLGxhd25ncmVlbjoiIzdjZmMwMCIsbGVtb25jaGlmZm9uOiIjZmZmYWNkIixsaWdodGJsdWU6IiNhZGQ4ZTYiLGxpZ2h0Y29yYWw6IiNmMDgwODAiLGxpZ2h0Y3lhbjoiI2UwZmZmZiIsbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IiNmYWZhZDIiLGxpZ2h0Z3JleToiI2QzZDNkMyIsbGlnaHRncmVlbjoiIzkwZWU5MCIsbGlnaHRwaW5rOiIjZmZiNmMxIixsaWdodHNhbG1vbjoiI2ZmYTA3YSIsbGlnaHRzZWFncmVlbjoiIzIwYjJhYSIsbGlnaHRza3libHVlOiIjODdjZWZhIixsaWdodHNsYXRlZ3JheToiIzc3ODg5OSIsbGlnaHRzdGVlbGJsdWU6IiNiMGM0ZGUiLGxpZ2h0eWVsbG93OiIjZmZmZmUwIixsaW1lOiIjMDBmZjAwIixsaW1lZ3JlZW46IiMzMmNkMzIiLGxpbmVuOiIjZmFmMGU2IixtYWdlbnRhOiIjZmYwMGZmIixtYXJvb246IiM4MDAwMDAiLG1lZGl1bWFxdWFtYXJpbmU6IiM2NmNkYWEiLG1lZGl1bWJsdWU6IiMwMDAwY2QiLG1lZGl1bW9yY2hpZDoiI2JhNTVkMyIsbWVkaXVtcHVycGxlOiIjOTM3MGQ4IixtZWRpdW1zZWFncmVlbjoiIzNjYjM3MSIsbWVkaXVtc2xhdGVibHVlOiIjN2I2OGVlIixtZWRpdW1zcHJpbmdncmVlbjoiIzAwZmE5YSIsbWVkaXVtdHVycXVvaXNlOiIjNDhkMWNjIixtZWRpdW12aW9sZXRyZWQ6IiNjNzE1ODUiLG1pZG5pZ2h0Ymx1ZToiIzE5MTk3MCIsbWludGNyZWFtOiIjZjVmZmZhIixtaXN0eXJvc2U6IiNmZmU0ZTEiLG1vY2Nhc2luOiIjZmZlNGI1IixuYXZham93aGl0ZToiI2ZmZGVhZCIsbmF2eToiIzAwMDA4MCIsb2xkbGFjZToiI2ZkZjVlNiIsb2xpdmU6IiM4MDgwMDAiLG9saXZlZHJhYjoiIzZiOGUyMyIsb3JhbmdlOiIjZmZhNTAwIixvcmFuZ2VyZWQ6IiNmZjQ1MDAiLG9yY2hpZDoiI2RhNzBkNiIscGFsZWdvbGRlbnJvZDoiI2VlZThhYSIscGFsZWdyZWVuOiIjOThmYjk4IixwYWxldHVycXVvaXNlOiIjYWZlZWVlIixwYWxldmlvbGV0cmVkOiIjZDg3MDkzIixwYXBheWF3aGlwOiIjZmZlZmQ1IixwZWFjaHB1ZmY6IiNmZmRhYjkiLHBlcnU6IiNjZDg1M2YiLHBpbms6IiNmZmMwY2IiLHBsdW06IiNkZGEwZGQiLHBvd2RlcmJsdWU6IiNiMGUwZTYiLHB1cnBsZToiIzgwMDA4MCIscmViZWNjYXB1cnBsZToiIzY2MzM5OSIscmVkOiIjZmYwMDAwIixyb3N5YnJvd246IiNiYzhmOGYiLHJveWFsYmx1ZToiIzQxNjllMSIsc2FkZGxlYnJvd246IiM4YjQ1MTMiLHNhbG1vbjoiI2ZhODA3MiIsc2FuZHlicm93bjoiI2Y0YTQ2MCIsc2VhZ3JlZW46IiMyZThiNTciLHNlYXNoZWxsOiIjZmZmNWVlIixzaWVubmE6IiNhMDUyMmQiLHNpbHZlcjoiI2MwYzBjMCIsc2t5Ymx1ZToiIzg3Y2VlYiIsc2xhdGVibHVlOiIjNmE1YWNkIixzbGF0ZWdyYXk6IiM3MDgwOTAiLHNub3c6IiNmZmZhZmEiLHNwcmluZ2dyZWVuOiIjMDBmZjdmIixzdGVlbGJsdWU6IiM0NjgyYjQiLHRhbjoiI2QyYjQ4YyIsdGVhbDoiIzAwODA4MCIsdGhpc3RsZToiI2Q4YmZkOCIsdG9tYXRvOiIjZmY2MzQ3Iix0dXJxdW9pc2U6IiM0MGUwZDAiLHZpb2xldDoiI2VlODJlZSIsd2hlYXQ6IiNmNWRlYjMiLHdoaXRlOiIjZmZmZmZmIix3aGl0ZXNtb2tlOiIjZjVmNWY1Iix5ZWxsb3c6IiNmZmZmMDAiLHllbGxvd2dyZWVuOiIjOWFjZDMyIn1bdC50b0xvd2VyQ2FzZSgpXTtlJiZ0aGlzLnNldEZyb21IZXgoZSl9fXRvSGV4KCl7ZnVuY3Rpb24gdCh0KXtjb25zdCBlPU1hdGgucm91bmQoMjU1KnQpLnRvU3RyaW5nKDE2KTtyZXR1cm4gMT09ZS5sZW5ndGg/IjAiK2U6ZX1yZXR1cm4iIyIrdCh0aGlzLnIpK3QodGhpcy5nKSt0KHRoaXMuYil9aXNFcXVhbCh0KXtyZXR1cm4gdGhpcy5yPT10LnImJnRoaXMuZz09dC5nJiZ0aGlzLmI9PXQuYiYmdGhpcy5hPT10LmF9bm90RXF1YWxzKHQpe3JldHVybiB0aGlzLnIhPXQuciYmdGhpcy5nIT10LmcmJnRoaXMuYiE9dC5iJiZ0aGlzLmEhPXQuYX1hcHByb3hFcXVhbCh0LGU9TnVtYmVyLkVQU0lMT04pe3JldHVybiBNYXRoLmFicyh0aGlzLnItdC5yKTxlJiZNYXRoLmFicyh0aGlzLmctdC5nKTxlJiZNYXRoLmFicyh0aGlzLmItdC5iKTxlJiZNYXRoLmFicyh0aGlzLmEtdC5hKTxlfWFkZCh0KXtyZXR1cm4gbmV3IGkodGhpcy5yK3Qucix0aGlzLmcrdC5nLHRoaXMuYit0LmIsdGhpcy5hK3QuYSl9YWRkSW5QbGFjZSh0KXt0aGlzLnIrPXQucix0aGlzLmcrPXQuZyx0aGlzLmIrPXQuYix0aGlzLmErPXQuYX1zdWJ0cmFjdCh0KXtyZXR1cm4gbmV3IGkodGhpcy5yLXQucix0aGlzLmctdC5nLHRoaXMuYi10LmIsdGhpcy5hLXQuYSl9c2NhbGUodCl7cmV0dXJuIG5ldyBpKHRoaXMucip0LHRoaXMuZyp0LHRoaXMuYip0LHRoaXMuYSp0KX1zY2FsZUluUGxhY2UodCl7dGhpcy5yKj10LHRoaXMuZyo9dCx0aGlzLmIqPXQsdGhpcy5hKj10fWFwcGx5R2FtbWEodCl7dGhpcy5zZXQoTWF0aC5wb3codGhpcy5yLHQpLE1hdGgucG93KHRoaXMuZyx0KSxNYXRoLnBvdyh0aGlzLmIsdCksdGhpcy5hKX10b0xpbmVhcih0PTIuMil7cmV0dXJuIG5ldyBpKE1hdGgucG93KHRoaXMucix0KSxNYXRoLnBvdyh0aGlzLmcsdCksTWF0aC5wb3codGhpcy5iLHQpLHRoaXMuYSl9dG9HYW1tYSh0PTIuMil7cmV0dXJuIG5ldyBpKE1hdGgucG93KHRoaXMuciwxL3QpLE1hdGgucG93KHRoaXMuZywxL3QpLE1hdGgucG93KHRoaXMuYiwxL3QpLHRoaXMuYSl9bHVtaW5hbmNlKCl7cmV0dXJuLjIxMjYqdGhpcy5yKy43MTUyKnRoaXMuZysuMDcyMip0aGlzLmJ9bGVycCh0LGUpe2NvbnN0IHM9dGhpcy5yLGE9dGhpcy5nLHI9dGhpcy5iLG49dGhpcy5hO3JldHVybiBuZXcgaShzK2UqKHQuci1zKSxhK2UqKHQuZy1hKSxyK2UqKHQuYi1yKSxuK2UqKHQuYS1uKSl9c3RhdGljIHJhbmRvbSh0PTAsZT0hMSl7cmV0dXJuIHQ+MD9uZXcgaSh0K01hdGgucmFuZG9tKCkqKDEtdCksdCtNYXRoLnJhbmRvbSgpKigxLXQpLHQrTWF0aC5yYW5kb20oKSooMS10KSxlP3QrTWF0aC5yYW5kb20oKSooMS10KToxKTp0PDA/bmV3IGkoTWF0aC5yYW5kb20oKSooMSt0KSxNYXRoLnJhbmRvbSgpKigxK3QpLE1hdGgucmFuZG9tKCkqKDErdCksZT9NYXRoLnJhbmRvbSgpKigxK3QpOjEpOm5ldyBpKE1hdGgucmFuZG9tKCksTWF0aC5yYW5kb20oKSxNYXRoLnJhbmRvbSgpLGU/TWF0aC5yYW5kb20oKToxKX1jbG9uZSgpe3JldHVybiBuZXcgaSh0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSx0aGlzLl9fZGF0YVsyXSx0aGlzLl9fZGF0YVszXSl9YXNBcnJheSgpe3JldHVybiB0aGlzLl9fZGF0YX1hczNDb21wb25lbnRBcnJheSgpe3JldHVyblt0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSx0aGlzLl9fZGF0YVsyXV19dG9KU09OKCl7cmV0dXJue3I6dGhpcy5yLGc6dGhpcy5nLGI6dGhpcy5iLGE6dGhpcy5hfX1mcm9tSlNPTih0KXt0aGlzLnI9dC5yLHRoaXMuZz10LmcsdGhpcy5iPXQuYix0aGlzLmE9dC5hfXJlYWRCaW5hcnkodCl7dGhpcy5yPXQubG9hZEZsb2F0MzIoKSx0aGlzLmc9dC5sb2FkRmxvYXQzMigpLHRoaXMuYj10LmxvYWRGbG9hdDMyKCksdGhpcy5hPXQubG9hZEZsb2F0MzIoKX10b0NTU1N0cmluZygpe3JldHVybiJyZ2JhKCIrTWF0aC5yb3VuZCgyNTUqdGhpcy5yKSsiLCAiK01hdGgucm91bmQoMjU1KnRoaXMuZykrIiwgIitNYXRoLnJvdW5kKDI1NSp0aGlzLmIpKyIsICIrdGhpcy5hKyIpIn19Y2xhc3Mgcntjb25zdHJ1Y3Rvcih0PTAsZT0wLHM9MCxhPTApe2lmKCJudW1iZXIiIT10eXBlb2YgYXx8aXNOYU4oYSkpc3dpdGNoKGEpe2Nhc2UiWFlaIjp0aGlzLm9yZGVyPTA7YnJlYWs7Y2FzZSJZWlgiOnRoaXMub3JkZXI9MTticmVhaztjYXNlIlpYWSI6dGhpcy5vcmRlcj0yO2JyZWFrO2Nhc2UiWFpZIjp0aGlzLm9yZGVyPTM7YnJlYWs7Y2FzZSJaWVgiOnRoaXMub3JkZXI9NDticmVhaztjYXNlIllYWiI6dGhpcy5vcmRlcj01O2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIEV1bGVyIEFuZ2xlcyBPcmRlcjoiK2EpfWVsc2UgdGhpcy5vcmRlcj1hO2lmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7Y29uc3Qgcz10LGE9ZTt0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KHMsYSw0KX1lbHNlIHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMyksdGhpcy5fX2RhdGFbMF09dCx0aGlzLl9fZGF0YVsxXT1lLHRoaXMuX19kYXRhWzJdPXN9Z2V0IHgoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMF19c2V0IHgodCl7dGhpcy5fX2RhdGFbMF09dH1nZXQgeSgpe3JldHVybiB0aGlzLl9fZGF0YVsxXX1zZXQgeSh0KXt0aGlzLl9fZGF0YVsxXT10fWdldCB6KCl7cmV0dXJuIHRoaXMuX19kYXRhWzJdfXNldCB6KHQpe3RoaXMuX19kYXRhWzJdPXR9c2V0KHQsZSxzKXt0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09c310b1N0cmluZygpe3JldHVybiB0LnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSl9dG9KU09OKCl7cmV0dXJue3g6dGhpcy5fX2RhdGFbMF0seTp0aGlzLl9fZGF0YVsxXSx6OnRoaXMuX19kYXRhWzJdLG9yZGVyOnRoaXMub3JkZXJ9fWZyb21KU09OKHQpe3RoaXMuX19kYXRhWzBdPXQueCx0aGlzLl9fZGF0YVsxXT10LnksdGhpcy5fX2RhdGFbMl09dC56LHRoaXMub3JkZXI9dC5vcmRlcn19Y2xhc3Mgbntjb25zdHJ1Y3Rvcih0PTEsZT0wLGE9MCxpPTAscj0xLG49MCxoPTAsbz0wLGQ9MSl7aWYodCBpbnN0YW5jZW9mIHMmJmUgaW5zdGFuY2VvZiBzJiZhIGluc3RhbmNlb2Ygcyl0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KDkpLHRoaXMuc2V0KHQueCx0LnksdC56LGUueCxlLnksZS56LGEueCxhLnksYS56KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpdGhpcy5fX2RhdGE9dDtlbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7Y29uc29sZS53YXJuKCJEZXByZWNhdGVkLCBwbGVhc2UgdXNlIG5ldyBWZWMzKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA5KSkiKTtjb25zdCBzPXQsYT1lO3RoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkocyxhLDkpfWVsc2UgdGhpcy5fX2RhdGE9bmV3IEZsb2F0MzJBcnJheSg5KSx0aGlzLnNldCh0LGUsYSxpLHIsbixoLG8sZCl9Z2V0IG0wMCgpe3JldHVybiB0aGlzLl9fZGF0YVswXX1zZXQgbTAwKHQpe3RoaXMuX19kYXRhWzBdPXR9Z2V0IG0wMSgpe3JldHVybiB0aGlzLl9fZGF0YVsxXX1zZXQgbTAxKHQpe3RoaXMuX19kYXRhWzFdPXR9Z2V0IG0wMigpe3JldHVybiB0aGlzLl9fZGF0YVsyXX1zZXQgbTAyKHQpe3RoaXMuX19kYXRhWzJdPXR9Z2V0IG0xMCgpe3JldHVybiB0aGlzLl9fZGF0YVszXX1zZXQgbTEwKHQpe3RoaXMuX19kYXRhWzNdPXR9Z2V0IG0xMSgpe3JldHVybiB0aGlzLl9fZGF0YVs0XX1zZXQgbTExKHQpe3RoaXMuX19kYXRhWzRdPXR9Z2V0IG0xMigpe3JldHVybiB0aGlzLl9fZGF0YVs1XX1zZXQgbTEyKHQpe3RoaXMuX19kYXRhWzVdPXR9Z2V0IG0yMCgpe3JldHVybiB0aGlzLl9fZGF0YVs2XX1zZXQgbTIwKHQpe3RoaXMuX19kYXRhWzZdPXR9Z2V0IG0yMSgpe3JldHVybiB0aGlzLl9fZGF0YVs3XX1zZXQgbTIxKHQpe3RoaXMuX19kYXRhWzddPXR9Z2V0IG0yMigpe3JldHVybiB0aGlzLl9fZGF0YVs4XX1zZXQgbTIyKHQpe3RoaXMuX19kYXRhWzhdPXR9Z2V0IHhBeGlzKCl7cmV0dXJuIG5ldyBzKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEuYnVmZmVyLDAsMykpfXNldCB4QXhpcyh0KXt0aGlzLnhBeGlzLnNldCh0LngsdC55LHQueil9Z2V0IHlBeGlzKCl7cmV0dXJuIG5ldyBzKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEuYnVmZmVyLDEyLDMpKX1zZXQgeUF4aXModCl7dGhpcy55QXhpcy5zZXQodC54LHQueSx0LnopfWdldCB6QXhpcygpe3JldHVybiBuZXcgcyhuZXcgRmxvYXQzMkFycmF5KHRoaXMuX19kYXRhLmJ1ZmZlciwyNCwzKSl9c2V0IHpBeGlzKHQpe3RoaXMuekF4aXMuc2V0KHQueCx0LnksdC56KX1zZXQodD0xLGU9MCxzPTAsYT0wLGk9MSxyPTAsbj0wLGg9MCxvPTEpe3RoaXMuX19kYXRhWzBdPXQsdGhpcy5fX2RhdGFbMV09ZSx0aGlzLl9fZGF0YVsyXT1zLHRoaXMuX19kYXRhWzNdPWEsdGhpcy5fX2RhdGFbNF09aSx0aGlzLl9fZGF0YVs1XT1yLHRoaXMuX19kYXRhWzZdPW4sdGhpcy5fX2RhdGFbN109aCx0aGlzLl9fZGF0YVs4XT1vfXNldElkZW50aXR5KCl7dGhpcy5zZXQoKX1zZXRGcm9tTWF0KHQpe3RoaXMuX19kYXRhWzBdPXQubTAwLHRoaXMuX19kYXRhWzFdPXQubTAxLHRoaXMuX19kYXRhWzJdPXQubTAyLHRoaXMuX19kYXRhWzNdPXQubTEwLHRoaXMuX19kYXRhWzRdPXQubTExLHRoaXMuX19kYXRhWzVdPXQubTEyLHRoaXMuX19kYXRhWzZdPXQubTIwLHRoaXMuX19kYXRhWzddPXQubTIxLHRoaXMuX19kYXRhWzhdPXQubTIyfXNldEZyb21EaXJlY3Rpb25BbmRVcHZlY3Rvcih0LGUpe2NvbnN0IHM9dCxhPXMubGVuZ3RoKCk7aWYoYTxOdW1iZXIuRVBTSUxPTilyZXR1cm4gdm9pZCB0aGlzLnNldElkZW50aXR5KCk7cy5zY2FsZUluUGxhY2UoMS9hKTtjb25zdCBpPWUuY3Jvc3Mocykscj1pLmxlbmd0aCgpO3I+TnVtYmVyLkVQU0lMT04mJmkuc2NhbGVJblBsYWNlKDEvcik7Y29uc3Qgbj1zLmNyb3NzKGkpLGg9bi5sZW5ndGgoKTtoPk51bWJlci5FUFNJTE9OJiZuLnNjYWxlSW5QbGFjZSgxL2gpLHRoaXMuc2V0KGkueCxpLnksaS56LG4ueCxuLnksbi56LHMueCxzLnkscy56KX1pbnZlcnNlKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdLHM9dGhpcy5fX2RhdGFbMl0sYT10aGlzLl9fZGF0YVszXSxpPXRoaXMuX19kYXRhWzRdLHI9dGhpcy5fX2RhdGFbNV0saD10aGlzLl9fZGF0YVs2XSxvPXRoaXMuX19kYXRhWzddLGQ9dGhpcy5fX2RhdGFbOF0sXz1kKmktcipvLGw9LWQqYStyKmgsYz1vKmEtaSpoO2xldCB1PXQqXytlKmwrcypjO3JldHVybiB1Pyh1PTEvdSxuZXcgbihfKnUsKC1kKmUrcypvKSp1LChyKmUtcyppKSp1LGwqdSwoZCp0LXMqaCkqdSwoLXIqdCtzKmEpKnUsYyp1LCgtbyp0K2UqaCkqdSwoaSp0LWUqYSkqdSkpOihjb25zb2xlLndhcm4oIlVuYWJsZSB0byBpbnZlcnQgTWF0MyIpLG5ldyBuKX1pbnZlcnRJblBsYWNlKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdLHM9dGhpcy5fX2RhdGFbMl0sYT10aGlzLl9fZGF0YVszXSxpPXRoaXMuX19kYXRhWzRdLHI9dGhpcy5fX2RhdGFbNV0sbj10aGlzLl9fZGF0YVs2XSxoPXRoaXMuX19kYXRhWzddLG89dGhpcy5fX2RhdGFbOF0sZD1vKmktcipoLF89LW8qYStyKm4sbD1oKmEtaSpuO2xldCBjPXQqZCtlKl8rcypsO3JldHVybiBjPyhjPTEvYyx0aGlzLnNldChkKmMsKC1vKmUrcypoKSpjLChyKmUtcyppKSpjLF8qYywobyp0LXMqbikqYywoLXIqdCtzKmEpKmMsbCpjLCgtaCp0K2UqbikqYywoaSp0LWUqYSkqYyksITApOihjb25zb2xlLndhcm4oIlVuYWJsZSB0byBpbnZlcnQgTWF0MyIpLCExKX10cmFuc3Bvc2UoKXtyZXR1cm4gbmV3IG4odGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbM10sdGhpcy5fX2RhdGFbNl0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbNF0sdGhpcy5fX2RhdGFbN10sdGhpcy5fX2RhdGFbMl0sdGhpcy5fX2RhdGFbNV0sdGhpcy5fX2RhdGFbOF0pfXRyYW5zcG9zZUluUGxhY2UoKXtjb25zdCB0PXRoaXMuX19kYXRhWzFdLGU9dGhpcy5fX2RhdGFbMl0scz10aGlzLl9fZGF0YVs1XTt0aGlzLl9fZGF0YVsxXT10aGlzLl9fZGF0YVszXSx0aGlzLl9fZGF0YVsyXT10aGlzLl9fZGF0YVs2XSx0aGlzLl9fZGF0YVszXT10LHRoaXMuX19kYXRhWzVdPXRoaXMuX19kYXRhWzddLHRoaXMuX19kYXRhWzZdPWUsdGhpcy5fX2RhdGFbN109c310cmFuc2Zvcm1WZWMzKHQpe3JldHVybiBuZXcgcyh0aGlzLl9fZGF0YVswXSp0LngrdGhpcy5fX2RhdGFbMV0qdC55K3RoaXMuX19kYXRhWzJdKnQueix0aGlzLl9fZGF0YVszXSp0LngrdGhpcy5fX2RhdGFbNF0qdC55K3RoaXMuX19kYXRhWzVdKnQueix0aGlzLl9fZGF0YVs2XSp0LngrdGhpcy5fX2RhdGFbN10qdC55K3RoaXMuX19kYXRhWzhdKnQueil9Y2xvbmUoKXtyZXR1cm4gbmV3IG4odGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbMl0sdGhpcy5fX2RhdGFbM10sdGhpcy5fX2RhdGFbNF0sdGhpcy5fX2RhdGFbNV0sdGhpcy5fX2RhdGFbNl0sdGhpcy5fX2RhdGFbN10sdGhpcy5fX2RhdGFbOF0pfXJlYWRCaW5hcnkodCl7dGhpcy5fX2RhdGE9dC5sb2FkRmxvYXQzMkFycmF5KDkpfXRvSlNPTigpe3JldHVybiB0aGlzLl9fZGF0YX1mcm9tSlNPTih0KXt0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KHQpfXRvU3RyaW5nKCl7cmV0dXJuIHQuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKX1hc0FycmF5KCl7cmV0dXJuIHRoaXMuX19kYXRhfX1jbGFzcyBoe2NvbnN0cnVjdG9yKHQ9MSxlPTAscz0wLGE9MCxpPTAscj0xLG49MCxoPTAsbz0wLGQ9MCxfPTEsbD0wLGM9MCx1PTAsZj0wLG09MSl7aWYodCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSl0aGlzLl9fZGF0YT10O2Vsc2UgaWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtjb25zdCBzPXQsYT1lO3RoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkocyxhLDE2KX1lbHNlIHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMTYpLHRoaXMuc2V0KHQsZSxzLGEsaSxyLG4saCxvLGQsXyxsLGMsdSxmLG0pfWdldCBtMDAoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMF19c2V0IG0wMCh0KXt0aGlzLl9fZGF0YVswXT10fWdldCBtMDEoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMV19c2V0IG0wMSh0KXt0aGlzLl9fZGF0YVsxXT10fWdldCBtMDIoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMl19c2V0IG0wMih0KXt0aGlzLl9fZGF0YVsyXT10fWdldCBtMDMoKXtyZXR1cm4gdGhpcy5fX2RhdGFbM119c2V0IG0wMyh0KXt0aGlzLl9fZGF0YVszXT10fWdldCBtMTAoKXtyZXR1cm4gdGhpcy5fX2RhdGFbNF19c2V0IG0xMCh0KXt0aGlzLl9fZGF0YVs0XT10fWdldCBtMTEoKXtyZXR1cm4gdGhpcy5fX2RhdGFbNV19c2V0IG0xMSh0KXt0aGlzLl9fZGF0YVs1XT10fWdldCBtMTIoKXtyZXR1cm4gdGhpcy5fX2RhdGFbNl19c2V0IG0xMih0KXt0aGlzLl9fZGF0YVs2XT10fWdldCBtMTMoKXtyZXR1cm4gdGhpcy5fX2RhdGFbN119c2V0IG0xMyh0KXt0aGlzLl9fZGF0YVs3XT10fWdldCBtMjAoKXtyZXR1cm4gdGhpcy5fX2RhdGFbOF19c2V0IG0yMCh0KXt0aGlzLl9fZGF0YVs4XT10fWdldCBtMjEoKXtyZXR1cm4gdGhpcy5fX2RhdGFbOV19c2V0IG0yMSh0KXt0aGlzLl9fZGF0YVs5XT10fWdldCBtMjIoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMTBdfXNldCBtMjIodCl7dGhpcy5fX2RhdGFbMTBdPXR9Z2V0IG0yMygpe3JldHVybiB0aGlzLl9fZGF0YVsxMV19c2V0IG0yMyh0KXt0aGlzLl9fZGF0YVsxMV09dH1nZXQgbTMwKCl7cmV0dXJuIHRoaXMuX19kYXRhWzEyXX1zZXQgbTMwKHQpe3RoaXMuX19kYXRhWzEyXT10fWdldCBtMzEoKXtyZXR1cm4gdGhpcy5fX2RhdGFbMTNdfXNldCBtMzEodCl7dGhpcy5fX2RhdGFbMTNdPXR9Z2V0IG0zMigpe3JldHVybiB0aGlzLl9fZGF0YVsxNF19c2V0IG0zMih0KXt0aGlzLl9fZGF0YVsxNF09dH1nZXQgbTMzKCl7cmV0dXJuIHRoaXMuX19kYXRhWzE1XX1zZXQgbTMzKHQpe3RoaXMuX19kYXRhWzE1XT10fWdldCB4QXhpcygpe3JldHVybiBuZXcgcyhuZXcgRmxvYXQzMkFycmF5KHRoaXMuX19kYXRhLmJ1ZmZlciwwLDMpKX1zZXQgeEF4aXModCl7dGhpcy54QXhpcy5zZXQodC54LHQueSx0LnopfWdldCB5QXhpcygpe3JldHVybiBuZXcgcyhuZXcgRmxvYXQzMkFycmF5KHRoaXMuX19kYXRhLmJ1ZmZlciwxNiwzKSl9c2V0IHlBeGlzKHQpe3RoaXMueUF4aXMuc2V0KHQueCx0LnksdC56KX1nZXQgekF4aXMoKXtyZXR1cm4gbmV3IHMobmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YS5idWZmZXIsMzIsMykpfXNldCB6QXhpcyh0KXt0aGlzLnpBeGlzLnNldCh0LngsdC55LHQueil9Z2V0IHRyYW5zbGF0aW9uKCl7cmV0dXJuIG5ldyBzKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEuYnVmZmVyLDQ4LDMpKX1zZXQgdHJhbnNsYXRpb24odCl7dGhpcy50cmFuc2xhdGlvbi5zZXQodC54LHQueSx0LnopfXNldCh0PTEsZT0wLHM9MCxhPTAsaT0wLHI9MSxuPTAsaD0wLG89MCxkPTAsXz0xLGw9MCxjPTAsdT0wLGY9MCxtPTEpe3RoaXMuX19kYXRhWzBdPXQsdGhpcy5fX2RhdGFbMV09ZSx0aGlzLl9fZGF0YVsyXT1zLHRoaXMuX19kYXRhWzNdPWEsdGhpcy5fX2RhdGFbNF09aSx0aGlzLl9fZGF0YVs1XT1yLHRoaXMuX19kYXRhWzZdPW4sdGhpcy5fX2RhdGFbN109aCx0aGlzLl9fZGF0YVs4XT1vLHRoaXMuX19kYXRhWzldPWQsdGhpcy5fX2RhdGFbMTBdPV8sdGhpcy5fX2RhdGFbMTFdPWwsdGhpcy5fX2RhdGFbMTJdPWMsdGhpcy5fX2RhdGFbMTNdPXUsdGhpcy5fX2RhdGFbMTRdPWYsdGhpcy5fX2RhdGFbMTVdPW19c2V0SWRlbnRpdHkoKXt0aGlzLnNldCgpfXNldERhdGFBcnJheSh0KXt0aGlzLl9fZGF0YT10fXNldEZyb21NYXQ0KHQpe3RoaXMuX19kYXRhWzBdPXQubTAwLHRoaXMuX19kYXRhWzFdPXQubTAxLHRoaXMuX19kYXRhWzJdPXQubTAyLHRoaXMuX19kYXRhWzNdPXQubTAzLHRoaXMuX19kYXRhWzRdPXQubTEwLHRoaXMuX19kYXRhWzVdPXQubTExLHRoaXMuX19kYXRhWzZdPXQubTEyLHRoaXMuX19kYXRhWzddPXQubTEzLHRoaXMuX19kYXRhWzhdPXQubTIwLHRoaXMuX19kYXRhWzldPXQubTIxLHRoaXMuX19kYXRhWzEwXT10Lm0yMix0aGlzLl9fZGF0YVsxMV09dC5tMjMsdGhpcy5fX2RhdGFbMTJdPXQubTMwLHRoaXMuX19kYXRhWzEzXT10Lm0zMSx0aGlzLl9fZGF0YVsxNF09dC5tMzIsdGhpcy5fX2RhdGFbMTVdPXQubTMzfXRvTWF0Mygpe3JldHVybiBuZXcgbih0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVsxXSx0aGlzLl9fZGF0YVsyXSx0aGlzLl9fZGF0YVs0XSx0aGlzLl9fZGF0YVs1XSx0aGlzLl9fZGF0YVs2XSx0aGlzLl9fZGF0YVs4XSx0aGlzLl9fZGF0YVs5XSx0aGlzLl9fZGF0YVsxMF0pfXRyYW5zcG9zZUluUGxhY2UoKXtjb25zdCB0PXRoaXMuX19kYXRhWzFdLGU9dGhpcy5fX2RhdGFbMl0scz10aGlzLl9fZGF0YVszXSxhPXRoaXMuX19kYXRhWzZdLGk9dGhpcy5fX2RhdGFbN10scj10aGlzLl9fZGF0YVsxMV07dGhpcy5fX2RhdGFbMV09dGhpcy5fX2RhdGFbNF0sdGhpcy5fX2RhdGFbMl09dGhpcy5fX2RhdGFbOF0sdGhpcy5fX2RhdGFbM109dGhpcy5fX2RhdGFbMTJdLHRoaXMuX19kYXRhWzRdPXQsdGhpcy5fX2RhdGFbNl09dGhpcy5fX2RhdGFbOV0sdGhpcy5fX2RhdGFbN109dGhpcy5fX2RhdGFbMTNdLHRoaXMuX19kYXRhWzhdPWUsdGhpcy5fX2RhdGFbOV09YSx0aGlzLl9fZGF0YVsxMV09dGhpcy5fX2RhdGFbMTRdLHRoaXMuX19kYXRhWzEyXT1zLHRoaXMuX19kYXRhWzEzXT1pLHRoaXMuX19kYXRhWzE0XT1yfXRyYW5zcG9zZSgpe3JldHVybiBuZXcgaCh0aGlzLl9fZGF0YVswXSx0aGlzLl9fZGF0YVs0XSx0aGlzLl9fZGF0YVs4XSx0aGlzLl9fZGF0YVsxMl0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbNV0sdGhpcy5fX2RhdGFbOV0sdGhpcy5fX2RhdGFbMTNdLHRoaXMuX19kYXRhWzJdLHRoaXMuX19kYXRhWzZdLHRoaXMuX19kYXRhWzEwXSx0aGlzLl9fZGF0YVsxNF0sdGhpcy5fX2RhdGFbM10sdGhpcy5fX2RhdGFbN10sdGhpcy5fX2RhdGFbMTFdLHRoaXMuX19kYXRhWzE1XSl9aW52ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbM10saT10aGlzLl9fZGF0YVs0XSxyPXRoaXMuX19kYXRhWzVdLG49dGhpcy5fX2RhdGFbNl0sbz10aGlzLl9fZGF0YVs3XSxkPXRoaXMuX19kYXRhWzhdLF89dGhpcy5fX2RhdGFbOV0sbD10aGlzLl9fZGF0YVsxMF0sYz10aGlzLl9fZGF0YVsxMV0sdT10aGlzLl9fZGF0YVsxMl0sZj10aGlzLl9fZGF0YVsxM10sbT10aGlzLl9fZGF0YVsxNF0sZz10aGlzLl9fZGF0YVsxNV0seT10KnItZSppLHg9dCpuLXMqaSxwPXQqby1hKmksYj1lKm4tcypyLEk9ZSpvLWEqcix3PXMqby1hKm4sTj1kKmYtXyp1LEY9ZCptLWwqdSxWPWQqZy1jKnUsej1fKm0tbCpmLEE9XypnLWMqZixNPWwqZy1jKm07bGV0IFM9eSpNLXgqQStwKnorYipWLUkqRit3Kk47cmV0dXJuIFM/KFM9MS9TLG5ldyBoKChyKk0tbipBK28qeikqUywocypBLWUqTS1hKnopKlMsKGYqdy1tKkkrZypiKSpTLChsKkktXyp3LWMqYikqUywobipWLWkqTS1vKkYpKlMsKHQqTS1zKlYrYSpGKSpTLChtKnAtdSp3LWcqeCkqUywoZCp3LWwqcCtjKngpKlMsKGkqQS1yKlYrbypOKSpTLChlKlYtdCpBLWEqTikqUywodSpJLWYqcCtnKnkpKlMsKF8qcC1kKkktYyp5KSpTLChyKkYtaSp6LW4qTikqUywodCp6LWUqRitzKk4pKlMsKGYqeC11KmItbSp5KSpTLChkKmItXyp4K2wqeSkqUykpOihjb25zb2xlLndhcm4oIlVuYWJsZSB0byBpbnZlcnQgTWF0NCIpLHRoaXMpfWludmVydEluUGxhY2UoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLGU9dGhpcy5fX2RhdGFbMV0scz10aGlzLl9fZGF0YVsyXSxhPXRoaXMuX19kYXRhWzNdLGk9dGhpcy5fX2RhdGFbNF0scj10aGlzLl9fZGF0YVs1XSxuPXRoaXMuX19kYXRhWzZdLGg9dGhpcy5fX2RhdGFbN10sbz10aGlzLl9fZGF0YVs4XSxkPXRoaXMuX19kYXRhWzldLF89dGhpcy5fX2RhdGFbMTBdLGw9dGhpcy5fX2RhdGFbMTFdLGM9dGhpcy5fX2RhdGFbMTJdLHU9dGhpcy5fX2RhdGFbMTNdLGY9dGhpcy5fX2RhdGFbMTRdLG09dGhpcy5fX2RhdGFbMTVdLGc9dCpyLWUqaSx5PXQqbi1zKmkseD10KmgtYSppLHA9ZSpuLXMqcixiPWUqaC1hKnIsST1zKmgtYSpuLHc9byp1LWQqYyxOPW8qZi1fKmMsRj1vKm0tbCpjLFY9ZCpmLV8qdSx6PWQqbS1sKnUsQT1fKm0tbCpmO2xldCBNPWcqQS15KnoreCpWK3AqRi1iKk4rSSp3O3JldHVybiBNPyhNPTEvTSx0aGlzLnNldCgocipBLW4qeitoKlYpKk0sKHMqei1lKkEtYSpWKSpNLCh1KkktZipiK20qcCkqTSwoXypiLWQqSS1sKnApKk0sKG4qRi1pKkEtaCpOKSpNLCh0KkEtcypGK2EqTikqTSwoZip4LWMqSS1tKnkpKk0sKG8qSS1fKngrbCp5KSpNLChpKnotcipGK2gqdykqTSwoZSpGLXQqei1hKncpKk0sKGMqYi11KngrbSpnKSpNLChkKngtbypiLWwqZykqTSwocipOLWkqVi1uKncpKk0sKHQqVi1lKk4rcyp3KSpNLCh1KnktYypwLWYqZykqTSwobypwLWQqeStfKmcpKk0pLCEwKTooY29uc29sZS53YXJuKCJVbmFibGUgdG8gaW52ZXJ0IE1hdDQiKSwhMSl9c2V0SW52ZXJzZSh0KXtjb25zdCBlPXQuX19kYXRhWzBdLHM9dC5fX2RhdGFbMV0sYT10Ll9fZGF0YVsyXSxpPXQuX19kYXRhWzNdLHI9dC5fX2RhdGFbNF0sbj10Ll9fZGF0YVs1XSxoPXQuX19kYXRhWzZdLG89dC5fX2RhdGFbN10sZD10Ll9fZGF0YVs4XSxfPXQuX19kYXRhWzldLGw9dC5fX2RhdGFbMTBdLGM9dC5fX2RhdGFbMTFdLHU9dC5fX2RhdGFbMTJdLGY9dC5fX2RhdGFbMTNdLG09dC5fX2RhdGFbMTRdLGc9dC5fX2RhdGFbMTVdLHk9ZSpuLXMqcix4PWUqaC1hKnIscD1lKm8taSpyLGI9cypoLWEqbixJPXMqby1pKm4sdz1hKm8taSpoLE49ZCpmLV8qdSxGPWQqbS1sKnUsVj1kKmctYyp1LHo9XyptLWwqZixBPV8qZy1jKmYsTT1sKmctYyptO2xldCBTPXkqTS14KkErcCp6K2IqVi1JKkYrdypOO2lmKCFTKXRocm93IG5ldyBFcnJvcigiVW5hYmxlIHRvIGludmVydCBNYXQ0Iik7Uz0xL1MsdGhpcy5zZXQoKG4qTS1oKkErbyp6KSpTLChhKkEtcypNLWkqeikqUywoZip3LW0qSStnKmIpKlMsKGwqSS1fKnctYypiKSpTLChoKlYtcipNLW8qRikqUywoZSpNLWEqVitpKkYpKlMsKG0qcC11KnctZyp4KSpTLChkKnctbCpwK2MqeCkqUywocipBLW4qVitvKk4pKlMsKHMqVi1lKkEtaSpOKSpTLCh1KkktZipwK2cqeSkqUywoXypwLWQqSS1jKnkpKlMsKG4qRi1yKnotaCpOKSpTLChlKnotcypGK2EqTikqUywoZip4LXUqYi1tKnkpKlMsKGQqYi1fKngrbCp5KSpTKX1tdWx0aXBseSh0KXtjb25zdCBlPXRoaXMuX19kYXRhWzBdLHM9dGhpcy5fX2RhdGFbMV0sYT10aGlzLl9fZGF0YVsyXSxpPXRoaXMuX19kYXRhWzNdLHI9dGhpcy5fX2RhdGFbNF0sbj10aGlzLl9fZGF0YVs1XSxvPXRoaXMuX19kYXRhWzZdLGQ9dGhpcy5fX2RhdGFbN10sXz10aGlzLl9fZGF0YVs4XSxsPXRoaXMuX19kYXRhWzldLGM9dGhpcy5fX2RhdGFbMTBdLHU9dGhpcy5fX2RhdGFbMTFdLGY9dGhpcy5fX2RhdGFbMTJdLG09dGhpcy5fX2RhdGFbMTNdLGc9dGhpcy5fX2RhdGFbMTRdLHk9dGhpcy5fX2RhdGFbMTVdLHg9dC5hc0FycmF5KCk7bGV0IHA9eFswXSxiPXhbMV0sST14WzJdLHc9eFszXTtjb25zdCBOPW5ldyBoO3JldHVybiBOLm0wMD1wKmUrYipyK0kqXyt3KmYsTi5tMDE9cCpzK2IqbitJKmwrdyptLE4ubTAyPXAqYStiKm8rSSpjK3cqZyxOLm0wMz1wKmkrYipkK0kqdSt3KnkscD14WzRdLGI9eFs1XSxJPXhbNl0sdz14WzddLE4ubTEwPXAqZStiKnIrSSpfK3cqZixOLm0xMT1wKnMrYipuK0kqbCt3Km0sTi5tMTI9cCphK2IqbytJKmMrdypnLE4ubTEzPXAqaStiKmQrSSp1K3cqeSxwPXhbOF0sYj14WzldLEk9eFsxMF0sdz14WzExXSxOLm0yMD1wKmUrYipyK0kqXyt3KmYsTi5tMjE9cCpzK2IqbitJKmwrdyptLE4ubTIyPXAqYStiKm8rSSpjK3cqZyxOLm0yMz1wKmkrYipkK0kqdSt3KnkscD14WzEyXSxiPXhbMTNdLEk9eFsxNF0sdz14WzE1XSxOLm0zMD1wKmUrYipyK0kqXyt3KmYsTi5tMzE9cCpzK2IqbitJKmwrdyptLE4ubTMyPXAqYStiKm8rSSpjK3cqZyxOLm0zMz1wKmkrYipkK0kqdSt3KnksTn1tdWx0aXBseUluUGxhY2UodCl7Y29uc3QgZT10aGlzLmFzQXJyYXkoKSxzPWVbMF0sYT1lWzFdLGk9ZVsyXSxyPWVbM10sbj1lWzRdLGg9ZVs1XSxvPWVbNl0sZD1lWzddLF89ZVs4XSxsPWVbOV0sYz1lWzEwXSx1PWVbMTFdLGY9ZVsxMl0sbT1lWzEzXSxnPWVbMTRdLHk9ZVsxNV0seD10LmFzQXJyYXkoKTtsZXQgcD14WzBdLGI9eFsxXSxJPXhbMl0sdz14WzNdO3JldHVybiB0aGlzLm0wMD1wKnMrYipuK0kqXyt3KmYsdGhpcy5tMDE9cCphK2IqaCtJKmwrdyptLHRoaXMubTAyPXAqaStiKm8rSSpjK3cqZyx0aGlzLm0wMz1wKnIrYipkK0kqdSt3KnkscD14WzRdLGI9eFs1XSxJPXhbNl0sdz14WzddLHRoaXMubTEwPXAqcytiKm4rSSpfK3cqZix0aGlzLm0xMT1wKmErYipoK0kqbCt3Km0sdGhpcy5tMTI9cCppK2IqbytJKmMrdypnLHRoaXMubTEzPXAqcitiKmQrSSp1K3cqeSxwPXhbOF0sYj14WzldLEk9eFsxMF0sdz14WzExXSx0aGlzLm0yMD1wKnMrYipuK0kqXyt3KmYsdGhpcy5tMjE9cCphK2IqaCtJKmwrdyptLHRoaXMubTIyPXAqaStiKm8rSSpjK3cqZyx0aGlzLm0yMz1wKnIrYipkK0kqdSt3KnkscD14WzEyXSxiPXhbMTNdLEk9eFsxNF0sdz14WzE1XSx0aGlzLm0zMD1wKnMrYipuK0kqXyt3KmYsdGhpcy5tMzE9cCphK2IqaCtJKmwrdyptLHRoaXMubTMyPXAqaStiKm8rSSpjK3cqZyx0aGlzLm0zMz1wKnIrYipkK0kqdSt3KnksdGhpc31wb3N0TXVsdGlwbHlJblBsYWNlKHQpe2NvbnN0IGU9dC5hc0FycmF5KCkscz1lWzBdLGE9ZVsxXSxpPWVbMl0scj1lWzNdLG49ZVs0XSxoPWVbNV0sbz1lWzZdLGQ9ZVs3XSxfPWVbOF0sbD1lWzldLGM9ZVsxMF0sdT1lWzExXSxmPWVbMTJdLG09ZVsxM10sZz1lWzE0XSx5PWVbMTVdLHg9dGhpcy5hc0FycmF5KCk7bGV0IHA9eFswXSxiPXhbMV0sST14WzJdLHc9eFszXTtyZXR1cm4gdGhpcy5tMDA9cCpzK2IqbitJKl8rdypmLHRoaXMubTAxPXAqYStiKmgrSSpsK3cqbSx0aGlzLm0wMj1wKmkrYipvK0kqYyt3KmcsdGhpcy5tMDM9cCpyK2IqZCtJKnUrdyp5LHA9eFs0XSxiPXhbNV0sST14WzZdLHc9eFs3XSx0aGlzLm0xMD1wKnMrYipuK0kqXyt3KmYsdGhpcy5tMTE9cCphK2IqaCtJKmwrdyptLHRoaXMubTEyPXAqaStiKm8rSSpjK3cqZyx0aGlzLm0xMz1wKnIrYipkK0kqdSt3KnkscD14WzhdLGI9eFs5XSxJPXhbMTBdLHc9eFsxMV0sdGhpcy5tMjA9cCpzK2IqbitJKl8rdypmLHRoaXMubTIxPXAqYStiKmgrSSpsK3cqbSx0aGlzLm0yMj1wKmkrYipvK0kqYyt3KmcsdGhpcy5tMjM9cCpyK2IqZCtJKnUrdyp5LHA9eFsxMl0sYj14WzEzXSxJPXhbMTRdLHc9eFsxNV0sdGhpcy5tMzA9cCpzK2IqbitJKl8rdypmLHRoaXMubTMxPXAqYStiKmgrSSpsK3cqbSx0aGlzLm0zMj1wKmkrYipvK0kqYyt3KmcsdGhpcy5tMzM9cCpyK2IqZCtJKnUrdyp5LHRoaXN9dHJhbnNsYXRlSW5QbGFjZSh0KXtjb25zdCBlPXRoaXMuX19kYXRhLHM9dC54LGE9dC55LGk9dC56O3JldHVybiBlWzEyXT1lWzBdKnMrZVs0XSphK2VbOF0qaStlWzEyXSxlWzEzXT1lWzFdKnMrZVs1XSphK2VbOV0qaStlWzEzXSxlWzE0XT1lWzJdKnMrZVs2XSphK2VbMTBdKmkrZVsxNF0sZVsxNV09ZVszXSpzK2VbN10qYStlWzExXSppK2VbMTVdLHRoaXN9c2V0TG9va0F0KHQsZSxzKXtjb25zdCBhPXQuc3VidHJhY3QoZSksaT1hLmxlbmd0aCgpO2lmKGk8TnVtYmVyLkVQU0lMT04pcmV0dXJuIHZvaWQgdGhpcy5zZXRJZGVudGl0eSgpO2Euc2NhbGVJblBsYWNlKDEvaSk7Y29uc3Qgcj1zLmNyb3NzKGEpLG49ci5sZW5ndGgoKTtuPk51bWJlci5FUFNJTE9OJiZyLnNjYWxlSW5QbGFjZSgxL24pO2NvbnN0IGg9YS5jcm9zcyhyKSxvPWgubGVuZ3RoKCk7bz5OdW1iZXIuRVBTSUxPTiYmaC5zY2FsZUluUGxhY2UoMS9vKSx0aGlzLnNldChyLngsci55LHIueiwwLGgueCxoLnksaC56LDAsYS54LGEueSxhLnosMCx0LngsdC55LHQueiwxKX1zZXRSb3RhdGlvbih0LGUpe2NvbnN0IHM9dC5sZW5ndGgoKTtpZihNYXRoLmFicyhzKTxOdW1iZXIuRVBTSUxPTilyZXR1cm4gbnVsbDtjb25zdCBhPXQueC9zLGk9dC55L3Mscj10LnovcyxuPU1hdGguc2luKGUpLGg9TWF0aC5jb3MoZSksbz0xLWgsZD10aGlzLl9fZGF0YTtyZXR1cm4gZFswXT1hKmEqbytoLGRbMV09aSphKm8rcipuLGRbMl09ciphKm8taSpuLGRbM109MCxkWzRdPWEqaSpvLXIqbixkWzVdPWkqaSpvK2gsZFs2XT1yKmkqbythKm4sZFs3XT0wLGRbOF09YSpyKm8raSpuLGRbOV09aSpyKm8tYSpuLGRbMTBdPXIqcipvK2gsZFsxMV09MCxkWzEyXT0wLGRbMTNdPTAsZFsxNF09MCxkWzE1XT0xLHRoaXN9c2V0WFJvdGF0aW9uKHQpe2NvbnN0IGU9TWF0aC5zaW4odCkscz1NYXRoLmNvcyh0KSxhPXRoaXMuX19kYXRhO3JldHVybiBhWzBdPTEsYVsxXT0wLGFbMl09MCxhWzNdPTAsYVs0XT0wLGFbNV09cyxhWzZdPWUsYVs3XT0wLGFbOF09MCxhWzldPS1lLGFbMTBdPXMsYVsxMV09MCxhWzEyXT0wLGFbMTNdPTAsYVsxNF09MCxhWzE1XT0xLHRoaXN9c2V0WVJvdGF0aW9uKHQpe2NvbnN0IGU9TWF0aC5zaW4odCkscz1NYXRoLmNvcyh0KSxhPXRoaXMuX19kYXRhO3JldHVybiBhWzBdPXMsYVsxXT0wLGFbMl09LWUsYVszXT0wLGFbNF09MCxhWzVdPTEsYVs2XT0wLGFbN109MCxhWzhdPWUsYVs5XT0wLGFbMTBdPXMsYVsxMV09MCxhWzEyXT0wLGFbMTNdPTAsYVsxNF09MCxhWzE1XT0xLHRoaXN9c2V0WlJvdGF0aW9uKHQpe2NvbnN0IGU9TWF0aC5zaW4odCkscz1NYXRoLmNvcyh0KSxhPXRoaXMuX19kYXRhO3JldHVybiBhWzBdPXMsYVsxXT1lLGFbMl09MCxhWzNdPTAsYVs0XT0tZSxhWzVdPXMsYVs2XT0wLGFbN109MCxhWzhdPTAsYVs5XT0wLGFbMTBdPTEsYVsxMV09MCxhWzEyXT0wLGFbMTNdPTAsYVsxNF09MCxhWzE1XT0xLHRoaXN9dHJhbnNmb3JtVmVjNCh0KXtjb25zdCBlPXRoaXMuX19kYXRhLHM9dC54LGk9dC55LHI9dC56LG49dC50O3JldHVybiBuZXcgYShlWzBdKnMrZVs0XSppK2VbOF0qcitlWzEyXSpuLGVbMV0qcytlWzVdKmkrZVs5XSpyK2VbMTNdKm4sZVsyXSpzK2VbNl0qaStlWzEwXSpyK2VbMTRdKm4sZVszXSpzK2VbN10qaStlWzExXSpyK2VbMTVdKm4pfXRyYW5zZm9ybVZlYzModCl7Y29uc3QgZT10aGlzLl9fZGF0YSxhPXQueCxpPXQueSxyPXQuejtyZXR1cm4gbmV3IHMoZVswXSphK2VbNF0qaStlWzhdKnIrZVsxMl0sZVsxXSphK2VbNV0qaStlWzldKnIrZVsxM10sZVsyXSphK2VbNl0qaStlWzEwXSpyK2VbMTRdKX1yb3RhdGVWZWMzKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGEsYT10LngsaT10Lnkscj10Lno7cmV0dXJuIG5ldyBzKGVbMF0qYStlWzRdKmkrZVs4XSpyLGVbMV0qYStlWzVdKmkrZVs5XSpyLGVbMl0qYStlWzZdKmkrZVsxMF0qcil9c2V0UGVyc3BlY3RpdmVNYXRyaXgodCxlLHMsYSl7Y29uc3QgaT1NYXRoLnRhbiguNSpNYXRoLlBJLS41KnQpLHI9MS8ocy1hKTt0aGlzLnNldChpL2UsMCwwLDAsMCxpLDAsMCwwLDAsKHMrYSkqciwtMSwwLDAscyphKnIqMiwwKX1zZXRPcnRob2dyYXBoaWNNYXRyaXgodCxlLHMsYSxpLHIpe2NvbnN0IG49MS8odC1lKSxoPTEvKHMtYSksbz0xLyhpLXIpO3RoaXMuc2V0KC0yKm4sMCwwLDAsMCwtMipoLDAsMCwwLDAsMipvLDAsKHQrZSkqbiwoYStzKSpoLChyK2kpKm8sMSl9c2V0U2NhbGUodCxlLGEpe3QgaW5zdGFuY2VvZiBzP3RoaXMuc2V0KHQueCwwLDAsMCwwLHQueSwwLDAsMCwwLHQueiwwLDAsMCwwLDEpOnRoaXMuc2V0KHQsMCwwLDAsMCxlLDAsMCwwLDAsYSwwLDAsMCwwLDEpfXNldEZyb21NYXQzeDRBcnJheSh0KXt0aGlzLnNldCh0WzBdLHRbMV0sdFsyXSwwLHRbM10sdFs0XSx0WzVdLDAsdFs2XSx0WzddLHRbOF0sMCx0WzldLHRbMTBdLHRbMTFdLDEpfWNsb25lKCl7cmV0dXJuIG5ldyBoKHRoaXMuX19kYXRhWzBdLHRoaXMuX19kYXRhWzFdLHRoaXMuX19kYXRhWzJdLHRoaXMuX19kYXRhWzNdLHRoaXMuX19kYXRhWzRdLHRoaXMuX19kYXRhWzVdLHRoaXMuX19kYXRhWzZdLHRoaXMuX19kYXRhWzddLHRoaXMuX19kYXRhWzhdLHRoaXMuX19kYXRhWzldLHRoaXMuX19kYXRhWzEwXSx0aGlzLl9fZGF0YVsxMV0sdGhpcy5fX2RhdGFbMTJdLHRoaXMuX19kYXRhWzEzXSx0aGlzLl9fZGF0YVsxNF0sdGhpcy5fX2RhdGFbMTVdKX10b1N0cmluZygpe3JldHVybiB0LnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSl9dG9KU09OKCl7cmV0dXJuIHRoaXMuX19kYXRhfWZyb21KU09OKHQpe3RoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkodCl9cmVhZEJpbmFyeSh0KXt0aGlzLl9fZGF0YT10LmxvYWRGbG9hdDMyQXJyYXkoMTYpfWFzQXJyYXkoKXtyZXR1cm4gdGhpcy5fX2RhdGF9fWNsYXNzIG97Y29uc3RydWN0b3IodD0wLGU9MCxzPTAsYT0xKXtpZih0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXRoaXMuX19kYXRhPXQ7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe2NvbnNvbGUud2FybigiZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpIik7Y29uc3Qgcz10LGE9ZTt0aGlzLl9fZGF0YT1uZXcgRmxvYXQzMkFycmF5KHMsYSw0KX1lbHNlIHRoaXMuX19kYXRhPW5ldyBGbG9hdDMyQXJyYXkoNCksIm9iamVjdCI9PXR5cGVvZiB0Pyh0aGlzLl9fZGF0YVswXT0wLHRoaXMuX19kYXRhWzFdPTAsdGhpcy5fX2RhdGFbMl09MCx0aGlzLl9fZGF0YVszXT0xLHRoaXMuZnJvbUpTT04odCkpOih0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09cyx0aGlzLl9fZGF0YVszXT1hKX1nZXQgeCgpe3JldHVybiB0aGlzLl9fZGF0YVswXX1zZXQgeCh0KXt0aGlzLl9fZGF0YVswXT10fWdldCB5KCl7cmV0dXJuIHRoaXMuX19kYXRhWzFdfXNldCB5KHQpe3RoaXMuX19kYXRhWzFdPXR9Z2V0IHooKXtyZXR1cm4gdGhpcy5fX2RhdGFbMl19c2V0IHoodCl7dGhpcy5fX2RhdGFbMl09dH1nZXQgdygpe3JldHVybiB0aGlzLl9fZGF0YVszXX1zZXQgdyh0KXt0aGlzLl9fZGF0YVszXT10fXNldCh0LGUscyxhKXt0aGlzLl9fZGF0YVswXT10LHRoaXMuX19kYXRhWzFdPWUsdGhpcy5fX2RhdGFbMl09cyx0aGlzLl9fZGF0YVszXT1hfXNldERhdGFBcnJheSh0KXt0aGlzLl9fZGF0YT10fXNldEZyb21PdGhlcih0KXt0aGlzLl9fZGF0YVswXT10LngsdGhpcy5fX2RhdGFbMV09dC55LHRoaXMuX19kYXRhWzJdPXQueix0aGlzLl9fZGF0YVszXT10Lnd9c2V0RnJvbUV1bGVyQW5nbGVzKHQpe2NvbnN0IGU9bmV3IHM7c3dpdGNoKHQub3JkZXIpe2Nhc2UgMDplLnNldCh0LngsLXQueSx0LnopO2JyZWFrO2Nhc2UgMTplLnNldCh0LnksLXQueix0LngpO2JyZWFrO2Nhc2UgMjplLnNldCh0LnosLXQueCx0LnkpO2JyZWFrO2Nhc2UgMzplLnNldCh0LngsdC56LHQueSk7YnJlYWs7Y2FzZSA0OmUuc2V0KHQueix0LnksdC54KTticmVhaztjYXNlIDU6ZS5zZXQodC55LHQueCx0LnopO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEV1bGVyQW5nbGVzIG9yZGVyOiAke3Qub3JkZXJ9YCl9Y29uc3QgYT0uNSplLngsaT0uNSplLnkscj0uNSplLnosbj1NYXRoLmNvcyhhKSxoPU1hdGguY29zKGkpLG89TWF0aC5jb3MociksZD1NYXRoLnNpbihhKSxfPU1hdGguc2luKGkpLGw9TWF0aC5zaW4ociksYz1uKm8sdT1uKmwsZj1kKm8sbT1kKmwsZz1oKmYtXyp1LHk9aCptK18qYyx4PWgqdS1fKmY7c3dpdGNoKHRoaXMudz1oKmMrXyptLHQub3JkZXIpe2Nhc2UgMDp0aGlzLng9Zyx0aGlzLnk9LXksdGhpcy56PXg7YnJlYWs7Y2FzZSAxOnRoaXMueD14LHRoaXMueT1nLHRoaXMuej0teTticmVhaztjYXNlIDI6dGhpcy54PS15LHRoaXMueT14LHRoaXMuej1nO2JyZWFrO2Nhc2UgMzp0aGlzLng9Zyx0aGlzLnk9eCx0aGlzLno9eTticmVhaztjYXNlIDQ6dGhpcy54PXgsdGhpcy55PXksdGhpcy56PWc7YnJlYWs7Y2FzZSA1OnRoaXMueD15LHRoaXMueT1nLHRoaXMuej14O2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEV1bGVyQW5nbGVzIG9yZGVyOiAke3Qub3JkZXJ9YCl9fXRvRXVsZXJBbmdsZXModCl7Y29uc3QgZT1uZXcgcztzd2l0Y2godCl7Y2FzZSAwOmUuc2V0KHRoaXMueix0aGlzLngsdGhpcy55KTticmVhaztjYXNlIDE6ZS5zZXQodGhpcy54LHRoaXMueSx0aGlzLnopO2JyZWFrO2Nhc2UgMjplLnNldCh0aGlzLnksdGhpcy56LHRoaXMueCk7YnJlYWs7Y2FzZSAzOmUuc2V0KHRoaXMueSwtdGhpcy54LHRoaXMueik7YnJlYWs7Y2FzZSA0OmUuc2V0KHRoaXMueCwtdGhpcy56LHRoaXMueSk7YnJlYWs7Y2FzZSA1OmUuc2V0KHRoaXMueiwtdGhpcy55LHRoaXMueCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcm90YXRpb24gb3JkZXI6Iit0KX1jb25zdCBhPW5ldyBzLGk9ZS54KmUueStlLnoqdGhpcy53O2lmKGk+LjQ5OTk5KWEueT0yKk1hdGguYXRhbjIoZS54LHRoaXMudyksYS56PS41Kk1hdGguUEksYS54PTA7ZWxzZSBpZihpPC0uNDk5OTkpYS55PS0yKk1hdGguYXRhbjIoZS54LHRoaXMudyksYS56PS0uNSpNYXRoLlBJLGEueD0wO2Vsc2V7Y29uc3QgdD1lLngqZS54LHM9ZS55KmUueSxyPWUueiplLno7YS55PU1hdGguYXRhbjIoMiplLnkqdGhpcy53LTIqZS54KmUueiwxLTIqcy0yKnIpLGEuej1NYXRoLmFzaW4oMippKSxhLng9TWF0aC5hdGFuMigyKmUueCp0aGlzLnctMiplLnkqZS56LDEtMip0LTIqcil9c3dpdGNoKHQpe2Nhc2UgMDpyZXR1cm4gbmV3IHIoYS55LGEueixhLngsdCk7Y2FzZSAxOnJldHVybiBuZXcgcihhLngsYS55LGEueix0KTtjYXNlIDI6cmV0dXJuIG5ldyByKGEueixhLngsYS55LHQpO2Nhc2UgMzpyZXR1cm4gbmV3IHIoLWEueSxhLngsYS56LHQpO2Nhc2UgNDpyZXR1cm4gbmV3IHIoYS54LGEueiwtYS55LHQpO2Nhc2UgNTpyZXR1cm4gbmV3IHIoYS56LC1hLnksYS54LHQpfX1zZXRGcm9tQXhpc0FuZEFuZ2xlKHQsZSl7Y29uc3Qgcz1lLzIsYT10Lm5vcm1hbGl6ZSgpLnNjYWxlKE1hdGguc2luKHMpKTt0aGlzLnNldChhLngsYS55LGEueixNYXRoLmNvcyhzKSl9c2V0RnJvbURpcmVjdGlvbkFuZFVwdmVjdG9yKHQsZSl7Y29uc3Qgcz1uZXcgbjtzLnNldEZyb21EaXJlY3Rpb25BbmRVcHZlY3Rvcih0LGUpLHRoaXMuc2V0RnJvbU1hdDMocyl9c2V0RnJvbTJWZWN0b3JzKHQsZSl7Y29uc3Qgcz10LmNyb3NzKGUpLGE9dC5kb3QoZSksaT1NYXRoLnNxcnQoMiooMSthKSk7dGhpcy5zZXQocy54L2kscy55L2kscy56L2ksaS8yKSx0aGlzLm5vcm1hbGl6ZUluUGxhY2UoKX1zZXRGcm9tTWF0Myh0KXtjb25zdCBlPXQuYXNBcnJheSgpLHM9ZVswXStlWzRdK2VbOF07bGV0IGE7aWYocz4wKWE9TWF0aC5zcXJ0KHMrMSksdGhpcy5fX2RhdGFbM109LjUqYSxhPS41L2EsdGhpcy5fX2RhdGFbMF09KGVbNV0tZVs3XSkqYSx0aGlzLl9fZGF0YVsxXT0oZVs2XS1lWzJdKSphLHRoaXMuX19kYXRhWzJdPShlWzFdLWVbM10pKmE7ZWxzZXtsZXQgdD0wO2VbNF0+ZVswXSYmKHQ9MSksZVs4XT5lWzMqdCt0XSYmKHQ9Mik7Y29uc3Qgcz0odCsxKSUzLGk9KHQrMiklMzthPU1hdGguc3FydChlWzMqdCt0XS1lWzMqcytzXS1lWzMqaStpXSsxKSx0aGlzLl9fZGF0YVt0XT0uNSphLGE9LjUvYSx0aGlzLl9fZGF0YVszXT0oZVszKnMraV0tZVszKmkrc10pKmEsdGhpcy5fX2RhdGFbc109KGVbMypzK3RdK2VbMyp0K3NdKSphLHRoaXMuX19kYXRhW2ldPShlWzMqaSt0XStlWzMqdCtpXSkqYX10aGlzLm5vcm1hbGl6ZUluUGxhY2UoKX1zZXRGcm9tTWF0NCh0KXtjb25zdCBlPXQuYXNBcnJheSgpLHM9ZVswXStlWzVdK2VbMTBdO2xldCBhO2lmKHM+MClhPU1hdGguc3FydChzKzEpLHRoaXMuX19kYXRhWzNdPS41KmEsYT0uNS9hLHRoaXMuX19kYXRhWzBdPShlWzZdLWVbOV0pKmEsdGhpcy5fX2RhdGFbMV09KGVbOF0tZVsyXSkqYSx0aGlzLl9fZGF0YVsyXT0oZVsxXS1lWzRdKSphO2Vsc2V7bGV0IHQ9MDtlWzVdPmVbMF0mJih0PTEpLGVbMTBdPmVbNCp0K3RdJiYodD0yKTtjb25zdCBzPSh0KzEpJTMsaT0odCsyKSUzO2E9TWF0aC5zcXJ0KGVbNCp0K3RdLWVbNCpzK3NdLWVbNCppK2ldKzEpLHRoaXMuX19kYXRhW3RdPS41KmEsYT0uNS9hLHRoaXMuX19kYXRhWzNdPShlWzQqcytpXS1lWzQqaStzXSkqYSx0aGlzLl9fZGF0YVtzXT0oZVs0KnMrdF0rZVs0KnQrc10pKmEsdGhpcy5fX2RhdGFbaV09KGVbNCppK3RdK2VbNCp0K2ldKSphfXRoaXMubm9ybWFsaXplSW5QbGFjZSgpfWlzSWRlbnRpdHkoKXtyZXR1cm4gdGhpcy5nZXRBbmdsZSgpPE51bWJlci5FUFNJTE9OfWdldEFuZ2xlKCl7cmV0dXJuIDIqTWF0aC5hY29zKHRoaXMudyl9aXNFcXVhbCh0KXtyZXR1cm4gdGhpcy54PT10LngmJnRoaXMueT09dC55JiZ0aGlzLno9PXQueiYmdGhpcy53PT10Lnd9bm90RXF1YWxzKHQpe3JldHVybiB0aGlzLnghPXQueCYmdGhpcy55IT10LnkmJnRoaXMueiE9dC56JiZ0aGlzLnchPXQud31hcHByb3hFcXVhbCh0LGU9TnVtYmVyLkVQU0lMT04pe3JldHVybiBNYXRoLmFicyh0aGlzLngtdC54KTxlJiZNYXRoLmFicyh0aGlzLnktdC55KTxlJiZNYXRoLmFicyh0aGlzLnotdC56KTxlJiZNYXRoLmFicyh0aGlzLnctdC53KTxlfWFkZCh0KXtyZXR1cm4gbmV3IG8odGhpcy54K3QueCx0aGlzLnkrdC55LHRoaXMueit0LnosdGhpcy53K3Qudyl9YWRkSW5QbGFjZSh0KXt0aGlzLngrPXQueCx0aGlzLnkrPXQueSx0aGlzLnorPXQueix0aGlzLncrPXQud31zdWJ0cmFjdCh0KXtyZXR1cm4gbmV3IG8odGhpcy54LXQueCx0aGlzLnktdC55LHRoaXMuei10LnosdGhpcy53LXQudyl9c2NhbGUodCl7cmV0dXJuIG5ldyBvKHRoaXMueCp0LHRoaXMueSp0LHRoaXMueip0LHRoaXMudyp0KX1zY2FsZUluUGxhY2UodCl7dGhpcy54Kj10LHRoaXMueSo9dCx0aGlzLnoqPXQsdGhpcy53Kj10fWxlbmd0aCgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbM107cmV0dXJuIE1hdGguc3FydCh0KnQrZSplK3MqcythKmEpfWxlbmd0aFNxdWFyZWQoKXtjb25zdCB0PXRoaXMuX19kYXRhWzBdLGU9dGhpcy5fX2RhdGFbMV0scz10aGlzLl9fZGF0YVsyXSxhPXRoaXMuX19kYXRhWzNdO3JldHVybiB0KnQrZSplK3MqcythKmF9bm9ybWFsaXplKCl7Y29uc3QgdD10aGlzLl9fZGF0YVswXSxlPXRoaXMuX19kYXRhWzFdLHM9dGhpcy5fX2RhdGFbMl0sYT10aGlzLl9fZGF0YVszXTtsZXQgaT10KnQrZSplK3MqcythKmE7cmV0dXJuIGk8TnVtYmVyLkVQU0lMT04/bmV3IG86KGk9MS9NYXRoLnNxcnQoaSksbmV3IG8odCppLGUqaSxzKmksYSppKSl9bm9ybWFsaXplSW5QbGFjZSgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFbMF0sZT10aGlzLl9fZGF0YVsxXSxzPXRoaXMuX19kYXRhWzJdLGE9dGhpcy5fX2RhdGFbM107bGV0IGk9dCp0K2UqZStzKnMrYSphO2k8TnVtYmVyLkVQU0lMT058fChpPTEvTWF0aC5zcXJ0KGkpLHRoaXMuc2V0KHQqaSxlKmkscyppLGEqaSkpfWRvdCh0KXtyZXR1cm4gdGhpcy54KnQueCt0aGlzLnkqdC55K3RoaXMueip0LnordGhpcy53KnQud31jcm9zcyh0KXtjb25zdCBlPXRoaXMueCxzPXRoaXMueSxhPXRoaXMueixpPXRoaXMudyxyPXQueCxuPXQueSxoPXQueixkPXQudztyZXR1cm4gbmV3IG8ocypoLWEqbixhKmQtaSpoLGkqci1lKmQsZSpuLXMqcil9Y29uanVnYXRlKCl7cmV0dXJuIG5ldyBvKC10aGlzLngsLXRoaXMueSwtdGhpcy56LHRoaXMudyl9aW52ZXJzZSgpe3JldHVybiB0aGlzLmNvbmp1Z2F0ZSgpfWFsaWduV2l0aCh0KXt0aGlzLmRvdCh0KTwwJiZ0aGlzLnNldCgtdGhpcy54LC10aGlzLnksLXRoaXMueiwtdGhpcy53KX1tdWx0aXBseSh0KXtjb25zdCBlPXRoaXMuX19kYXRhWzBdLHM9dGhpcy5fX2RhdGFbMV0sYT10aGlzLl9fZGF0YVsyXSxpPXRoaXMuX19kYXRhWzNdLHI9dC5fX2RhdGFbMF0sbj10Ll9fZGF0YVsxXSxoPXQuX19kYXRhWzJdLGQ9dC5fX2RhdGFbM107cmV0dXJuIG5ldyBvKGUqZCtpKnIrcypoLWEqbixzKmQraSpuK2Eqci1lKmgsYSpkK2kqaCtlKm4tcypyLGkqZC1lKnItcypuLWEqaCl9bXVsdGlwbHlJblBsYWNlKHQpe2NvbnN0IGU9dGhpcy5fX2RhdGFbMF0scz10aGlzLl9fZGF0YVsxXSxhPXRoaXMuX19kYXRhWzJdLGk9dGhpcy5fX2RhdGFbM10scj10Ll9fZGF0YVswXSxuPXQuX19kYXRhWzFdLGg9dC5fX2RhdGFbMl0sbz10Ll9fZGF0YVszXTt0aGlzLnNldChlKm8raSpyK3MqaC1hKm4scypvK2kqbithKnItZSpoLGEqbytpKmgrZSpuLXMqcixpKm8tZSpyLXMqbi1hKmgpfXJvdGF0ZVZlYzModCl7Y29uc3QgZT1uZXcgbyh0LngsdC55LHQueiwwKSxhPXRoaXMubXVsdGlwbHkoZSkubXVsdGlwbHkodGhpcy5jb25qdWdhdGUoKSk7cmV0dXJuIG5ldyBzKGEueCxhLnksYS56KX1yb3RhdGVYKHQpe3QqPS41O2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGE9dGhpcy56LGk9dGhpcy53LHI9TWF0aC5zaW4odCksbj1NYXRoLmNvcyh0KTt0aGlzLng9ZSpuK2kqcix0aGlzLnk9cypuK2Eqcix0aGlzLno9YSpuLXMqcix0aGlzLnc9aSpuLWUqcn1yb3RhdGVZKHQpe3QqPS41O2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGE9dGhpcy56LGk9dGhpcy53LHI9TWF0aC5zaW4odCksbj1NYXRoLmNvcyh0KTt0aGlzLng9ZSpuLWEqcix0aGlzLnk9cypuK2kqcix0aGlzLno9YSpuK2Uqcix0aGlzLnc9aSpuLXMqcn1yb3RhdGVaKHQpe3QqPS41O2NvbnN0IGU9dGhpcy54LHM9dGhpcy55LGE9dGhpcy56LGk9dGhpcy53LHI9TWF0aC5zaW4odCksbj1NYXRoLmNvcyh0KTt0aGlzLng9ZSpuK3Mqcix0aGlzLnk9cypuLWUqcix0aGlzLno9YSpuK2kqcix0aGlzLnc9aSpuLWEqcn10b01hdDMoKXtjb25zdCB0PXRoaXMueCxlPXRoaXMueSxzPXRoaXMueixhPXRoaXMudyxpPXQrdCxyPWUrZSxoPXMrcyxvPXQqaSxkPWUqaSxfPWUqcixsPXMqaSxjPXMqcix1PXMqaCxmPWEqaSxtPWEqcixnPWEqaCx5PW5ldyBuO3JldHVybiB5Lm0wMD0xLV8tdSx5Lm0xMD1kLWcseS5tMjA9bCttLHkubTAxPWQrZyx5Lm0xMT0xLW8tdSx5Lm0yMT1jLWYseS5tMDI9bC1tLHkubTEyPWMrZix5Lm0yMj0xLW8tXyx5fWdldFhheGlzKCl7Y29uc3QgdD10aGlzLngqdGhpcy55LGU9dGhpcy54KnRoaXMueixhPXRoaXMueSp0aGlzLnksaT10aGlzLnkqdGhpcy53LHI9dGhpcy56KnRoaXMueixuPXRoaXMueip0aGlzLnc7cmV0dXJuIG5ldyBzKDEtMioocithKSwyKih0K24pLDIqKGUtaSkpfWdldFlheGlzKCl7Y29uc3QgdD10aGlzLngqdGhpcy54LGU9dGhpcy54KnRoaXMueSxhPXRoaXMueCp0aGlzLncsaT10aGlzLnkqdGhpcy56LHI9dGhpcy56KnRoaXMueixuPXRoaXMueip0aGlzLnc7cmV0dXJuIG5ldyBzKDIqKGUtbiksMS0yKihyK3QpLDIqKGkrYSkpfWdldFpheGlzKCl7Y29uc3QgdD10aGlzLngqdGhpcy54LGU9dGhpcy54KnRoaXMueixhPXRoaXMueCp0aGlzLncsaT10aGlzLnkqdGhpcy55LHI9dGhpcy55KnRoaXMueixuPXRoaXMueSp0aGlzLnc7cmV0dXJuIG5ldyBzKDIqKG4rZSksMiooci1hKSwxLTIqKGkrdCkpfW1pcnJvcih0KXtzd2l0Y2godCl7ZGVmYXVsdDpyZXR1cm4gbmV3IG8odGhpcy56LHRoaXMudyx0aGlzLngsdGhpcy55KTtjYXNlIDE6cmV0dXJuIG5ldyBvKC10aGlzLncsdGhpcy56LHRoaXMueSwtdGhpcy54KTtjYXNlIDI6cmV0dXJuIG5ldyBvKHRoaXMueCx0aGlzLnksdGhpcy56LC10aGlzLncpfX10b01hdDQoKXtjb25zdCB0PXRoaXMueCxlPXRoaXMueSxzPXRoaXMueixhPXRoaXMudyxpPXQrdCxyPWUrZSxuPXMrcyxvPXQqaSxkPWUqaSxfPWUqcixsPXMqaSxjPXMqcix1PXMqbixmPWEqaSxtPWEqcixnPWEqbix5PW5ldyBoO3JldHVybiB5Lm0wMD0xLV8tdSx5Lm0xMD1kLWcseS5tMjA9bCttLHkubTAxPWQrZyx5Lm0xMT0xLW8tdSx5Lm0yMT1jLWYseS5tMDI9bC1tLHkubTEyPWMrZix5Lm0yMj0xLW8tXyx5fWxlcnAodCxlKXtjb25zdCBzPW5ldyBvKHRoaXMueCtlKih0LngtdGhpcy54KSx0aGlzLnkrZSoodC55LXRoaXMueSksdGhpcy56K2UqKHQuei10aGlzLnopLHRoaXMudytlKih0LnctdGhpcy53KSk7cmV0dXJuIHMubm9ybWFsaXplSW5QbGFjZSgpLHN9c2xlcnAodCxlKXtjb25zdCBzPXRoaXMuZG90KHQpLGE9ZS8yO2xldCBpPU1hdGguYWNvcyhzKTtpPDAmJihpPS1pKTtjb25zdCByPU1hdGguc2luKGkpLG49TWF0aC5zaW4oYSppKSxoPU1hdGguc2luKCgxLWEpKmkpL3IsZD1uL3IsXz1uZXcgbyhoKnRoaXMueCtkKnQueCxoKnRoaXMueStkKnQueSxoKnRoaXMueitkKnQueixoKnRoaXMudytkKnQudyk7cmV0dXJuIF8ubm9ybWFsaXplSW5QbGFjZSgpLF99Y2xvbmUoKXtyZXR1cm4gbmV3IG8odGhpcy5fX2RhdGFbMF0sdGhpcy5fX2RhdGFbMV0sdGhpcy5fX2RhdGFbMl0sdGhpcy5fX2RhdGFbM10pfWFzQXJyYXkoKXtyZXR1cm4gdGhpcy5fX2RhdGF9dG9TdHJpbmcoKXtyZXR1cm4gdC5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpfXRvSlNPTigpe3JldHVybnt4OnRoaXMueCx5OnRoaXMueSx6OnRoaXMueix3OnRoaXMud319ZnJvbUpTT04odCl7dGhpcy5fX2RhdGFbMF09dC54LHRoaXMuX19kYXRhWzFdPXQueSx0aGlzLl9fZGF0YVsyXT10LnosdGhpcy5fX2RhdGFbM109dC53LHRoaXMubm9ybWFsaXplSW5QbGFjZSgpfXJlYWRCaW5hcnkodCl7dGhpcy54PXQubG9hZEZsb2F0MzIoKSx0aGlzLnk9dC5sb2FkRmxvYXQzMigpLHRoaXMuej10LmxvYWRGbG9hdDMyKCksdGhpcy53PXQubG9hZEZsb2F0MzIoKX19Y2xhc3MgZHtzdGF0aWMgcmFkVG9EZWcodCl7cmV0dXJuIHQvKE1hdGguUEkvMTgwKX1zdGF0aWMgZGVnVG9SYWQodCl7cmV0dXJuIHQqKE1hdGguUEkvMTgwKX1zdGF0aWMgaXNOdW1lcmljKHQpe3JldHVybiFpc05hTihwYXJzZUZsb2F0KHQpKSYmaXNGaW5pdGUodCl9c3RhdGljIHJhbmRvbUludCh0LGUpe3JldHVybiB0PU1hdGguY2VpbCh0KSxlPU1hdGguZmxvb3IoZSksTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihlLXQpKSt0fXN0YXRpYyBsZXJwKHQsZSxzKXtyZXR1cm4gdCtzKihlLXQpfXN0YXRpYyBjbGFtcCh0LGUscyl7cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHQsZSkscyl9c3RhdGljIG5lYXJlc3RQb3cyKHQpe3JldHVybiBNYXRoLnBvdygyLE1hdGgucm91bmQoTWF0aC5sb2codCkvTWF0aC5sb2coMikpKX1zdGF0aWMgbmVhcmVzdFBvdzEwKHQpe3JldHVybiBNYXRoLnBvdygxMCxNYXRoLnJvdW5kKE1hdGgubG9nMTAodCkvTWF0aC5sb2cxMCgxMCkpKX1zdGF0aWMgbmV4dFBvdzIodCl7aWYoMD09dGhpcy5mcmFjdChNYXRoLmxvZzIodCkpKXJldHVybiB0O2xldCBlPTA7Zm9yKDt0PjA7KWUrKyx0Pj49MTtyZXR1cm4gMTw8ZX1zdGF0aWMgZnJhY3QodCl7cmV0dXJuIDA9PXQ/MDp0PDA/dD4tMT8tdDotdCVNYXRoLmZsb29yKC10KTp0PDE/dDp0JU1hdGguZmxvb3IodCl9c3RhdGljIHJlbWFwKHQsZSxzLGEsaSl7cmV0dXJuIGErKHQtZSkvKHMtZSkqKGktYSl9c3RhdGljIHNtb290aFN0ZXAodCxlLHMpe2NvbnN0IGE9dGhpcy5jbGFtcCgocy10KS8oZS10KSwwLDEpO3JldHVybiBhKmEqKDMtMiphKX1zdGF0aWMgbGluU3RlcCh0LGUscyl7cmV0dXJuIHRoaXMuY2xhbXAoKHMtdCkvKGUtdCksMCwxKX1zdGF0aWMgZGVjb2RlMTZCaXRGbG9hdEZyb20yeFVJbnQ4KHQpe2NvbnN0IGU9dFswXSxzPSgxMjAmZSk+PjM7bGV0IGE9MD09cz8wOjIwNDg7Y29uc3QgaT1hKygoNyZlKTw8OCkrdFsxXTthPTA9PXM/MTowO3JldHVybigxMjgmZT8xOi0xKSppKk1hdGgucG93KDIscythLTE2KX1zdGF0aWMgZW5jb2RlMTZCaXRGbG9hdEludG8yeFVJbnQ4KHQpe2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkoMikscz10Pj0wPzEyODowO3Q9TWF0aC5hYnModCk7bGV0IGEsaT0xNSxyPTEwMjQ7Zm9yKGxldCBlPTE1O2U+MDtlLS0pdDxyJiYoci89MixpLS0pO2E9MD09aT90L3IvMjoodC1yKS9yO2NvbnN0IG49TWF0aC5yb3VuZCgyMDQ4KmEpLGg9bi8yNTYsbz1uLTI1NipoO3JldHVybiBlWzBdPXMrOCppK2gsZVsxXT1vLHQ+PTIwNDgmJihlWzBdPTI1NSksZX1zdGF0aWMgZW5jb2RlMTZCaXRGbG9hdCh0KXtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkoMSk7ZVswXT10O3JldHVybih0PT57bGV0IGU9dD4+MTYmMzI3Njgscz10Pj4xMiYyMDQ3O2NvbnN0IGE9dD4+MjMmMjU1O3JldHVybiBhPDEwMz9lOmE+MTQyPyhlfD0zMTc0NCxlfD0oMjU1PT1hPzA6MSkmJjgzODg2MDcmdCxlKTphPDExMz8oc3w9MjA0OCxlfD0ocz4+MTE0LWEpKyhzPj4xMTMtYSYxKSxlKTooZXw9YS0xMTI8PDEwfHM+PjEsZSs9MSZzLGUpfSkobmV3IEludDMyQXJyYXkoZS5idWZmZXIpWzBdKX1zdGF0aWMgZGVjb2RlMTZCaXRGbG9hdCh0KXtjb25zdCBlPSgzMjc2OCZ0KT4+MTUscz0oMzE3NDQmdCk+PjEwLGE9MTAyMyZ0O3JldHVybiAwPT1zPyhlPy0xOjEpKk1hdGgucG93KDIsLTE0KSooYS9NYXRoLnBvdygyLDEwKSk6MzE9PXM/YT9OYU46MS8wKihlPy0xOjEpOihlPy0xOjEpKk1hdGgucG93KDIscy0xNSkqKDErYS9NYXRoLnBvdygyLDEwKSl9c3RhdGljIGNvbnZlcnRGbG9hdDMyQXJyYXlUb1VJbnQxNkFycmF5KHQpe2NvbnN0IGU9bmV3IFVpbnQxNkFycmF5KHQubGVuZ3RoKSxzPW5ldyBJbnQzMkFycmF5KHQuYnVmZmVyKSxhPXQ9PntsZXQgZT10Pj4xNiYzMjc2OCxzPXQ+PjEyJjIwNDc7Y29uc3QgYT10Pj4yMyYyNTU7cmV0dXJuIGE8MTAzP2U6YT4xNDI/KGV8PTMxNzQ0LGV8PSgyNTU9PWE/MDoxKSYmODM4ODYwNyZ0LGUpOmE8MTEzPyhzfD0yMDQ4LGV8PShzPj4xMTQtYSkrKHM+PjExMy1hJjEpLGUpOihlfD1hLTExMjw8MTB8cz4+MSxlKz0xJnMsZSl9O2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKWVbaV09YShzW2ldKTtyZXR1cm4gZX19Y2xhc3MgX3tjb25zdHJ1Y3Rvcih0LHMpe3RoaXMucDA9dCBpbnN0YW5jZW9mIGU/dDpuZXcgZShOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSx0aGlzLnAxPXMgaW5zdGFuY2VvZiBlP3M6bmV3IGUoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLE51bWJlci5ORUdBVElWRV9JTkZJTklUWSl9c2V0KHQsZSl7dGhpcy5wMD10LHRoaXMucDE9ZX1yZXNldCgpe3RoaXMucDAueD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5wMS54PU51bWJlci5ORUdBVElWRV9JTkZJTklUWSx0aGlzLnAwLnk9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHRoaXMucDEueT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9aXNWYWxpZCgpe3JldHVybiB0aGlzLnAwLnghPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSYmdGhpcy5wMS54IT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkmJnRoaXMucDAueSE9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZJiZ0aGlzLnAxLnkhPU51bWJlci5ORUdBVElWRV9JTkZJTklUWX1hZGRQb2ludCh0KXsodGhpcy5wMC54PT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl8fHQueDx0aGlzLnAwLngpJiYodGhpcy5wMC54PXQueCksKHRoaXMucDAueT09TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfHx0Lnk8dGhpcy5wMC55KSYmKHRoaXMucDAueT10LnkpLCh0aGlzLnAxLnk9PU51bWJlci5ORUdBVElWRV9JTkZJTklUWXx8dC54PnRoaXMucDEueCkmJih0aGlzLnAxLng9dC54KSwodGhpcy5wMS55PT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl8fHQueT50aGlzLnAxLnkpJiYodGhpcy5wMS55PXQueSl9c2l6ZSgpe3JldHVybiB0aGlzLnAxLmRpc3RhbmNlVG8odGhpcy5wMCl9ZGlhZ29uYWwoKXtyZXR1cm4gdGhpcy5wMS5zdWJ0cmFjdCh0aGlzLnAwKX1jZW50ZXIoKXtjb25zdCB0PXRoaXMucDEuc3VidHJhY3QodGhpcy5wMCk7cmV0dXJuIHQuc2NhbGVJblBsYWNlKC41KSx0LmFkZEluUGxhY2UodGhpcy5wMCksdH10b0pTT04oKXtyZXR1cm57cDA6dGhpcy5wMC50b0pTT04oKSxwMTp0aGlzLnAxLnRvSlNPTigpfX10b1N0cmluZygpe3JldHVybiB0LnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSl9fWNsYXNzIGx7Y29uc3RydWN0b3IodD1uZXcgcyxlPTApe3RoaXMucG9zPXQgaW5zdGFuY2VvZiBzP3Q6bmV3IHMsdGhpcy5yYWRpdXM9ZX1jbG9uZSgpe3JldHVybiBuZXcgbCh0aGlzLnBvcy5jbG9uZSgpLHRoaXMucmFkaXVzKX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiB0LmludGVyc2VjdHNTcGhlcmUodGhpcyl9dG9KU09OKCl7cmV0dXJue3Bvczp0aGlzLnBvcy50b0pTT04oKSxyYWRpdXM6dGhpcy5yYWRpdXN9fXRvU3RyaW5nKCl7cmV0dXJuIHQuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKX19Y2xhc3MgY3tjb25zdHJ1Y3Rvcih0LGUpe3QgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/KHRoaXMucDA9bmV3IHMobmV3IEZsb2F0MzJBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsMykpLHRoaXMucDE9bmV3IHMobmV3IEZsb2F0MzJBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQrMTIsMykpKToodGhpcy5wMD10IGluc3RhbmNlb2Ygcz90Om5ldyBzKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSx0aGlzLnAxPWUgaW5zdGFuY2VvZiBzP2U6bmV3IHMoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpKX1nZXQgbWluKCl7cmV0dXJuIHRoaXMucDB9Z2V0IG1heCgpe3JldHVybiB0aGlzLnAxfXNldCh0LGUpe3RoaXMucDA9dCx0aGlzLnAxPWV9cmVzZXQoKXt0aGlzLnAwLng9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHRoaXMucDAueT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5wMC56PU51bWJlci5QT1NJVElWRV9JTkZJTklUWSx0aGlzLnAxLng9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLHRoaXMucDEueT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksdGhpcy5wMS56PU51bWJlci5ORUdBVElWRV9JTkZJTklUWX1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMucDAueCE9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZJiZ0aGlzLnAxLnghPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSYmdGhpcy5wMC55IT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkmJnRoaXMucDEueSE9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZJiZ0aGlzLnAwLnohPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSYmdGhpcy5wMS56IT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9YWRkUG9pbnQodCl7dC54IT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkmJnQueCE9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZJiYodC54PHRoaXMucDAueCYmKHRoaXMucDAueD10LngpLHQueD50aGlzLnAxLngmJih0aGlzLnAxLng9dC54KSksdC55IT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkmJnQueSE9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZJiYodC55PHRoaXMucDAueSYmKHRoaXMucDAueT10LnkpLHQueT50aGlzLnAxLnkmJih0aGlzLnAxLnk9dC55KSksdC56IT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkmJnQueiE9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZJiYodC56PHRoaXMucDAueiYmKHRoaXMucDAuej10LnopLHQuej50aGlzLnAxLnomJih0aGlzLnAxLno9dC56KSl9YWRkQm94Myh0LGUpe2U/KHRoaXMuYWRkUG9pbnQoZS50cmFuc2Zvcm1WZWMzKHQucDApKSx0aGlzLmFkZFBvaW50KGUudHJhbnNmb3JtVmVjMyhuZXcgcyh0LnAwLngsdC5wMC55LHQucDEueikpKSx0aGlzLmFkZFBvaW50KGUudHJhbnNmb3JtVmVjMyhuZXcgcyh0LnAwLngsdC5wMS55LHQucDAueikpKSx0aGlzLmFkZFBvaW50KGUudHJhbnNmb3JtVmVjMyhuZXcgcyh0LnAxLngsdC5wMC55LHQucDAueikpKSx0aGlzLmFkZFBvaW50KGUudHJhbnNmb3JtVmVjMyhuZXcgcyh0LnAwLngsdC5wMS55LHQucDEueikpKSx0aGlzLmFkZFBvaW50KGUudHJhbnNmb3JtVmVjMyhuZXcgcyh0LnAxLngsdC5wMC55LHQucDEueikpKSx0aGlzLmFkZFBvaW50KGUudHJhbnNmb3JtVmVjMyhuZXcgcyh0LnAxLngsdC5wMS55LHQucDAueikpKSx0aGlzLmFkZFBvaW50KGUudHJhbnNmb3JtVmVjMyh0LnAxKSkpOih0aGlzLmFkZFBvaW50KHQucDApLHRoaXMuYWRkUG9pbnQodC5wMSkpfXNpemUoKXtyZXR1cm4gdGhpcy5wMS5kaXN0YW5jZVRvKHRoaXMucDApfWRpYWdvbmFsKCl7cmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCl9Y2VudGVyKCl7Y29uc3QgdD10aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApO3JldHVybiB0LnNjYWxlSW5QbGFjZSguNSksdC5hZGRJblBsYWNlKHRoaXMucDApLHR9dG9NYXQ0KCl7Y29uc3QgdD10aGlzLnAxLngtdGhpcy5wMC54LGU9dGhpcy5wMS55LXRoaXMucDAueSxzPXRoaXMucDEuei10aGlzLnAwLno7cmV0dXJuIG5ldyBoKHQsMCwwLDAsMCxlLDAsMCwwLDAscywwLHRoaXMucDAueCx0aGlzLnAwLnksdGhpcy5wMC56LDEpfWdldEJvdW5kaW5nU3BoZXJlKCl7cmV0dXJuIG5ldyBsKHRoaXMuY2VudGVyKCksLjUqdGhpcy5kaWFnb25hbCgpLmxlbmd0aCgpKX1pbnRlcnNlY3RzQm94KHQpe3JldHVybiEodC5tYXgueDx0aGlzLm1pbi54fHx0Lm1pbi54PnRoaXMubWF4Lnh8fHQubWF4Lnk8dGhpcy5taW4ueXx8dC5taW4ueT50aGlzLm1heC55fHx0Lm1heC56PHRoaXMubWluLnp8fHQubWluLno+dGhpcy5tYXgueil9aW50ZXJzZWN0c1NwaGVyZSh0KXtyZXR1cm4obmV3IHMpLmRpc3RhbmNlVG8odC5wb3MpPD10LnJhZGl1cyp0LnJhZGl1c31pbnRlcnNlY3RzUGxhbmUodCl7bGV0IGUscztyZXR1cm4gdC5ub3JtYWwueD4wPyhlPXQubm9ybWFsLngqdGhpcy5taW4ueCxzPXQubm9ybWFsLngqdGhpcy5tYXgueCk6KGU9dC5ub3JtYWwueCp0aGlzLm1heC54LHM9dC5ub3JtYWwueCp0aGlzLm1pbi54KSx0Lm5vcm1hbC55PjA/KGUrPXQubm9ybWFsLnkqdGhpcy5taW4ueSxzKz10Lm5vcm1hbC55KnRoaXMubWF4LnkpOihlKz10Lm5vcm1hbC55KnRoaXMubWF4Lnkscys9dC5ub3JtYWwueSp0aGlzLm1pbi55KSx0Lm5vcm1hbC56PjA/KGUrPXQubm9ybWFsLnoqdGhpcy5taW4ueixzKz10Lm5vcm1hbC56KnRoaXMubWF4LnopOihlKz10Lm5vcm1hbC56KnRoaXMubWF4Lnoscys9dC5ub3JtYWwueip0aGlzLm1pbi56KSxlPD0tdC53JiZzPj0tdC53fWNsb25lKCl7cmV0dXJuIG5ldyBjKHRoaXMucDAuY2xvbmUoKSx0aGlzLnAxLmNsb25lKCkpfXRvSlNPTigpe3JldHVybntwMDp0aGlzLnAwLnRvSlNPTigpLHAxOnRoaXMucDEudG9KU09OKCl9fWZyb21KU09OKHQpe2NvbnN0IGU9e3g6ZC5pc051bWVyaWModC5wMC54KT90LnAwLng6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHk6ZC5pc051bWVyaWModC5wMC55KT90LnAwLnk6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHo6ZC5pc051bWVyaWModC5wMC56KT90LnAwLno6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSxzPXt4OmQuaXNOdW1lcmljKHQucDEueCk/dC5wMS54Ok51bWJlci5ORUdBVElWRV9JTkZJTklUWSx5OmQuaXNOdW1lcmljKHQucDEueSk/dC5wMS55Ok51bWJlci5ORUdBVElWRV9JTkZJTklUWSx6OmQuaXNOdW1lcmljKHQucDEueik/dC5wMS56Ok51bWJlci5ORUdBVElWRV9JTkZJTklUWX07dGhpcy5wMC5mcm9tSlNPTihlKSx0aGlzLnAxLmZyb21KU09OKHMpfXNldEZyb21GbG9hdDMyQXJyYXkodCl7dGhpcy5wMD1uZXcgcyh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQpLHRoaXMucDE9bmV3IHModC5idWZmZXIsdC5ieXRlT2Zmc2V0KzEyKX10b1N0cmluZygpe3JldHVybiB0LnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSl9fWxldCB1PXt9LGY9e30sbT1bXTtjbGFzcyBne3N0YXRpYyByZWdpc3Rlcih0LGUpe3QgaW4gdSYmY29uc29sZS53YXJuKGBUaGVyZSdzIGEgY2xhc3MgcmVnaXN0ZXJlZCB3aXRoICcke3R9JyBuYW1lYCk7Y29uc3Qgcz1tLmxlbmd0aDttLnB1c2goZSksZltzXT10LHVbdF09c31zdGF0aWMgZ2V0Q2xhc3NEZWZpbml0aW9uKHQpe2lmKCEodCBpbiB1KSl0aHJvdyBuZXcgRXJyb3IoYCR7dH0gY2xhc3MgaXMgbm90IHJlZ2lzdGVyZWRgKTtyZXR1cm4gbVt1W3RdXX1zdGF0aWMgZ2V0Q2xhc3NOYW1lKHQpe2NvbnN0IGU9bS5pbmRleE9mKHQpO2lmKGU+PTAmJmZbZV0pcmV0dXJuIGZbZV07dGhyb3cgbmV3IEVycm9yKCJjbGFzcyBpcyBub3QgcmVnaXN0ZXJlZCIpfXN0YXRpYyBjb25zdHJ1Y3RDbGFzcyh0KXtjb25zdCBlPW1bdVt0XV07aWYoIWUpdGhyb3cgbmV3IEVycm9yKGAke3R9IGNsYXNzIGlzIG5vdCByZWdpc3RlcmVkYCk7cmV0dXJuIG5ldyBlfXN0YXRpYyBmbHVzaCgpe3U9e30sZj17fSxtPVtdfX1sZXQgeT0wO2NsYXNzIHh7Y29uc3RydWN0b3IoKXt0aGlzLl9faWQ9Kyt5fWdldElkKCl7cmV0dXJuIHRoaXMuX19pZH1nZXRDbGFzc05hbWUoKXtyZXR1cm4gZy5nZXRDbGFzc05hbWUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKX19Y2xhc3MgcHtjb25zdHJ1Y3Rvcigpe319Y2xhc3MgYiBleHRlbmRzIHh7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMubGlzdGVuZXJzPXt9fW9uKHQsZSl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKCJNaXNzaW5nIGxpc3RlbmVyLiIpO3RoaXMubGlzdGVuZXJzW3RdfHwodGhpcy5saXN0ZW5lcnNbdF09W10pO2NvbnN0IHM9dGhpcy5saXN0ZW5lcnNbdF07aWYocy5pbmNsdWRlcyhlKSl0aHJvdyBuZXcgRXJyb3IoYExpc3RlbmVyICIke2UubmFtZX0iIGFscmVhZHkgY29ubmVjdGVkIHRvIGV2ZW50ICIke3R9Ii5gKTtjb25zdCBhPXMubGVuZ3RoO3JldHVybiBzW2FdPWUsYX1vbmNlKHQsZSl7Y29uc3Qgcz1hPT57ZShhKSx0aGlzLm9mZih0LHMpfTtyZXR1cm4gdGhpcy5vbih0LHMpfW9mZih0LGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcigiTWlzc2luZyBjYWxsYmFjayBmdW5jdGlvbiAobGlzdGVuZXIpLiIpO2lmKCJudW1iZXIiPT10eXBlb2YgZSlyZXR1cm4gY29uc29sZS53YXJuKCJEZXByZWNhdGVkLiBVbi1yZWdpc3RlciB1c2luZyB0aGUgb3JpZ2luYWwgbGlzdGVuZXIgaW5zdGVhZC4iKSx2b2lkIHRoaXMucmVtb3ZlTGlzdGVuZXJCeUlkKHQsZSk7Y29uc3Qgcz10aGlzLmxpc3RlbmVyc1t0XXx8W10sYT1bXTtpZihzLmZvckVhY2goKCh0LHMpPT57dD09PWUmJmEucHVzaChzKX0pKSwwPT1hLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYExpc3RlbmVyICIke2UubmFtZX0iIGlzIG5vdCBjb25uZWN0ZWQgdG8gIiR7dH0iIGV2ZW50YCk7Zm9yKGNvbnN0IHQgb2YgYSlzW3RdPW51bGx9cmVtb3ZlTGlzdGVuZXJCeUlkKHQsZSl7Y29uc3Qgcz10aGlzLmxpc3RlbmVyc1t0XTtpZihzKXtpZighc1tlXSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgSUQiKTtzW2VdPW51bGx9ZWxzZSBjb25zb2xlLndhcm4oImNhbGxiYWNrIDoiK2UrIiB3YXMgbm90IGNvbm5lY3RlZCB0byB0aGlzIGV2ZW50OiIrdCl9ZW1pdCh0LGU9bmV3IHApeyh0aGlzLmxpc3RlbmVyc1t0XXx8W10pLmZvckVhY2goKHQ9Pnt0JiZ0KGUpfSkpfX1jbGFzcyBJIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMubmFtZT10fX1jbGFzcyB3IGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMubmFtZT10fX1jbGFzcyBOIGV4dGVuZHMgYntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5wYXJhbUV2ZW50TGlzdGVuZXJJRHM9e30sdGhpcy5wYXJhbU1hcHBpbmc9e30sdGhpcy5wYXJhbXM9W10sdGhpcy5kZXByZWNhdGVkUGFyYW1NYXBwaW5nPXt9fWdldE51bVBhcmFtZXRlcnMoKXtyZXR1cm4gdGhpcy5wYXJhbXMubGVuZ3RofWdldFBhcmFtZXRlcnMoKXtyZXR1cm4gdGhpcy5wYXJhbXN9Z2V0UGFyYW1ldGVySW5kZXgodCl7cmV0dXJuIHRoaXMucGFyYW1NYXBwaW5nW3RdfWdldFBhcmFtZXRlckJ5SW5kZXgodCl7cmV0dXJuIHRoaXMucGFyYW1zW3RdfWhhc1BhcmFtZXRlcih0KXtyZXR1cm4gdCBpbiB0aGlzLnBhcmFtTWFwcGluZ31hZGRQYXJhbWV0ZXJEZXByZWNhdGlvbk1hcHBpbmcodCxlKXt0aGlzLmRlcHJlY2F0ZWRQYXJhbU1hcHBpbmdbdF09ZX1nZXRQYXJhbWV0ZXIodCl7bGV0IGU9dGhpcy5wYXJhbU1hcHBpbmdbdF07aWYobnVsbD09ZSl7Y29uc3Qgcz10aGlzLmRlcHJlY2F0ZWRQYXJhbU1hcHBpbmdbdF07aWYoIXMpcmV0dXJuIG51bGw7Y29uc29sZS53YXJuKGBQYXJhbWV0ZXIgbmFtZSAke3R9IGlzIG5vdyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICR7c30gaW5zdGVhZC5gKSxlPXRoaXMucGFyYW1NYXBwaW5nW3NdfXJldHVybiB0aGlzLnBhcmFtc1tlXX1wYXJhbWV0ZXJWYWx1ZUNoYW5nZWQodCl7dGhpcy5lbWl0KCJwYXJhbWV0ZXJWYWx1ZUNoYW5nZWQiLHQpfWFkZFBhcmFtZXRlcih0KXtyZXR1cm4gdGhpcy5pbnNlcnRQYXJhbWV0ZXIodCx0aGlzLnBhcmFtcy5sZW5ndGgpfWluc2VydFBhcmFtZXRlcih0LGUpe2NvbnN0IHM9dC5nZXROYW1lKCk7bnVsbCE9dGhpcy5wYXJhbU1hcHBpbmdbc10mJihjb25zb2xlLndhcm4oIlJlcGxhY2luZyBQYXJhbWV0ZXI6IitzKSx0aGlzLnJlbW92ZVBhcmFtZXRlcihzKSksdC5zZXRPd25lcih0aGlzKSx0aGlzLnBhcmFtRXZlbnRMaXN0ZW5lcklEc1tzXT10Lm9uKCJ2YWx1ZUNoYW5nZWQiLChlPT57Y29uc3Qgcz17cGFyYW06dH07Zm9yKGNvbnN0IHQgaW4gZSlzW3RdPWVbdF07dGhpcy5wYXJhbWV0ZXJWYWx1ZUNoYW5nZWQocyl9KSksdGhpcy5wYXJhbXMuc3BsaWNlKGUsMCx0KTtmb3IobGV0IHQ9ZTt0PHRoaXMucGFyYW1zLmxlbmd0aDt0KyspdGhpcy5wYXJhbU1hcHBpbmdbdGhpcy5wYXJhbXNbdF0uZ2V0TmFtZSgpXT10O2NvbnN0IGE9bmV3IEkocyk7cmV0dXJuIHRoaXMuZW1pdCgicGFyYW1ldGVyQWRkZWQiLGEpLHR9cmVtb3ZlUGFyYW1ldGVyKHQpe2lmKG51bGw9PXRoaXMucGFyYW1NYXBwaW5nW3RdKXRocm93IG5ldyBFcnJvcigiVW5hYmxlIHRvIHJlbW92ZSBQYXJhbWV0ZXI6Iit0KTtjb25zdCBlPXRoaXMucGFyYW1NYXBwaW5nW3RdO3RoaXMucGFyYW1zW3RoaXMucGFyYW1NYXBwaW5nW3RdXS5yZW1vdmVMaXN0ZW5lckJ5SWQoInZhbHVlQ2hhbmdlZCIsdGhpcy5wYXJhbUV2ZW50TGlzdGVuZXJJRHNbdF0pLHRoaXMucGFyYW1zLnNwbGljZShlLDEpLGRlbGV0ZSB0aGlzLnBhcmFtTWFwcGluZ1t0XTtmb3IobGV0IHQ9ZTt0PHRoaXMucGFyYW1zLmxlbmd0aDt0KyspdGhpcy5wYXJhbU1hcHBpbmdbdGhpcy5wYXJhbXNbdF0uZ2V0TmFtZSgpXT10O2NvbnN0IHM9bmV3IHcodCk7dGhpcy5lbWl0KCJwYXJhbWV0ZXJSZW1vdmVkIixzKX1yZXBsYWNlUGFyYW1ldGVyKHQpe2NvbnN0IGU9dC5nZXROYW1lKCk7aWYobnVsbD09dGhpcy5wYXJhbU1hcHBpbmdbZV0pdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gcmVwbGFjZSBQYXJhbWV0ZXI6IitlKTtjb25zdCBzPXRoaXMucGFyYW1NYXBwaW5nW2VdO3JldHVybiB0aGlzLnJlbW92ZVBhcmFtZXRlcihlKSx0aGlzLmluc2VydFBhcmFtZXRlcih0LHMpLHR9dG9KU09OKHQpe2NvbnN0IGU9e3R5cGU6dGhpcy5nZXRDbGFzc05hbWUoKX0scz17fTtsZXQgYT0wO2Zvcihjb25zdCBlIG9mIHRoaXMucGFyYW1zKXtjb25zdCBpPWUudG9KU09OKHQpO2kmJihzW2UuZ2V0TmFtZSgpXT1pLGErKyl9cmV0dXJuIGE+MCYmKGUucGFyYW1zPXMpLGV9ZnJvbUpTT04odCxlKXtpZih0LnBhcmFtcylmb3IoY29uc3QgcyBpbiB0LnBhcmFtcyl7Y29uc3QgYT10LnBhcmFtc1tzXSxpPXRoaXMuZ2V0UGFyYW1ldGVyKHMpO2k/YS5wYXJhbVBhdGg/bnVsbD09ZXx8ZS5yZXNvbHZlUGF0aChhLnBhcmFtUGF0aCwodD0+e3RoaXMucmVwbGFjZVBhcmFtZXRlcih0KX0pLCgoKT0+e2NvbnNvbGUud2FybigiVW5hYmxlIHRvIHJlc29sdmUgc2hhcmVkIHBhcmFtZXRlcjoiK2EucGFyYW1QYXRoKX0pKTppLmZyb21KU09OKGEsZSk6Y29uc29sZS53YXJuKCJQYXJhbSBub3QgZm91bmQ6IitzKX19cmVhZEJpbmFyeSh0LGUpe2lmKChudWxsPT1lP3ZvaWQgMDplLnZlcnNpb25zWyJ6ZWEtZW5naW5lIl0uY29tcGFyZShbMCwwLDNdKSk+PTApe2NvbnN0IHM9dC5sb2FkVUludDMyKCk7Zm9yKGxldCBhPTA7YTxzO2ErKyl7Y29uc3Qgcz10LmxvYWRTdHIoKSxhPXQubG9hZFN0cigpO2xldCBpPXRoaXMuZ2V0UGFyYW1ldGVyKGEpO2lmKCFpKXtpZihpPWcuY29uc3RydWN0Q2xhc3MocyksIWkpe2NvbnNvbGUuZXJyb3IoIlVuYWJsZSB0byBjb25zdHJ1Y3QgcHJvcDoiK2ErIiBvZiB0eXBlOiIrcyk7Y29udGludWV9aS5zZXROYW1lKGEpLHRoaXMuYWRkUGFyYW1ldGVyKGkpfWkucmVhZEJpbmFyeSh0LGUpfX19dG9TdHJpbmcodCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksbnVsbCwyKX1jb3B5RnJvbSh0LGUpe2xldCBzPXQuZ2V0TnVtUGFyYW1ldGVycygpO2Zvcig7cy0tOyl7Y29uc3QgZT10LmdldFBhcmFtZXRlckJ5SW5kZXgocyksYT10aGlzLmdldFBhcmFtZXRlcihlLmdldE5hbWUoKSk7YT9hLmxvYWRWYWx1ZShlLnZhbHVlKTp0aGlzLmFkZFBhcmFtZXRlcihlLmNsb25lKCkpfX19ZnVuY3Rpb24gRih0LGUpe3JldHVybiF0LnNvbWUoKCh0LHMpPT5NYXRoLmFicyhlW3NdLXQpPi4wMDEpKX1jbGFzcyBWIGV4dGVuZHMgeHtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpcy5kYXRhPW5ldyBGbG9hdDMyQXJyYXkoMCksdGhpcy5kYXRhVHlwZU5hbWU9dCx0aGlzLnN0cmlkZT1lLHRoaXMuaW5pdFJhbmdlKDApLHRoaXMuc3BsaXRzPXt9LHRoaXMuc3BsaXRWYWx1ZXM9W119c2V0TWVzaCh0KXt0aGlzLm1lc2g9dH1hc0FycmF5KCl7cmV0dXJuIHRoaXMuZGF0YX1nZXREYXRhVHlwZU5hbWUoKXtyZXR1cm4gdGhpcy5kYXRhVHlwZU5hbWV9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5kYXRhLmxlbmd0aC90aGlzLnN0cmlkZX1zZXRDb3VudCh0KXtjb25zdCBlPXRoaXMuZGF0YS5sZW5ndGgscz10KnRoaXMuc3RyaWRlO2lmKHM+ZSl7Y29uc3QgdD1uZXcgRmxvYXQzMkFycmF5KHMpO3Quc2V0KHRoaXMuZGF0YSwwKSx0aGlzLmRhdGE9dCx0aGlzLmluaXRSYW5nZShlKX1lbHNlIHM8ZSYmKHRoaXMuZGF0YT10aGlzLmRhdGEuc2xpY2UoMCxzKSk7dGhpcy5zcGxpdHM9e30sdGhpcy5zcGxpdFZhbHVlcz1bXX1pbml0UmFuZ2UodCl7Zm9yKGxldCBlPXQ7ZTx0aGlzLmRhdGEubGVuZ3RoO2UrKyl0aGlzLmRhdGFbZV09TnVtYmVyLk5hTn1nZXQgbnVtRWxlbWVudHMoKXtyZXR1cm4gdGhpcy5zdHJpZGV9Z2V0RmxvYXQzMlZhbHVlKHQpe3JldHVybiB0aGlzLmRhdGFbdF19c2V0RmxvYXQzMlZhbHVlKHQsZSl7dGhpcy5kYXRhW3RdPWV9Z2V0U3BsaXRzKCl7cmV0dXJuIHRoaXMuc3BsaXRzfWdldEZhY2VWZXJ0ZXhWYWx1ZVJlZl9hcnJheSh0LGUpe2NvbnN0IHM9dGhpcy5tZXNoLmdldEZhY2VWZXJ0ZXhJbmRleCh0LGUpO3JldHVybiBzIGluIHRoaXMuc3BsaXRzJiZ0IGluIHRoaXMuc3BsaXRzW3NdP3RoaXMuc3BsaXRWYWx1ZXNbdGhpcy5zcGxpdHNbc11bdF1dOnRoaXMuZGF0YS5zdWJhcnJheShzKnRoaXMuc3RyaWRlLChzKzEpKnRoaXMuc3RyaWRlKX1zZXRGYWNlVmVydGV4VmFsdWVfYXJyYXkodCxlLHMpe2NvbnN0IGE9dGhpcy5tZXNoLmdldEZhY2VWZXJ0ZXhJbmRleCh0LGUpO3RoaXMuc2V0RmFjZVZlcnRleFZhbHVlX0J5VmVydGV4SW5kZXgodCxhLHMpfXNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KHQsZSxzKXtjb25zdCBhPXRoaXMuZGF0YS5zdWJhcnJheShlKnRoaXMuc3RyaWRlLChlKzEpKnRoaXMuc3RyaWRlKTtpZihmdW5jdGlvbih0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZighTnVtYmVyLmlzTmFOKHRbZV0pKXJldHVybiEwO3JldHVybiExfShhKSlpZihGKGEscykpO2Vsc2V7aWYoZSBpbiB0aGlzLnNwbGl0cyl7Y29uc3QgYT10aGlzLnNwbGl0c1tlXTtmb3IoY29uc3QgZSBpbiBhKXtjb25zdCBpPWFbZV07aWYoRih0aGlzLnNwbGl0VmFsdWVzW2ldLHMpKXJldHVybiB2b2lkKGFbdF09aSl9aWYodCBpbiB0aGlzLnNwbGl0c1tlXSlyZXR1cm4gdm9pZCh0aGlzLnNwbGl0VmFsdWVzW3RoaXMuc3BsaXRzW2VdW3RdXT1zKX1lbHNlIHRoaXMuc3BsaXRzW2VdPXt9O3RoaXMuc3BsaXRzW2VdW3RdPXRoaXMuc3BsaXRWYWx1ZXMubGVuZ3RoLHRoaXMuc3BsaXRWYWx1ZXMucHVzaChzKX1lbHNlIGEuc2V0KHMpfXNldFNwbGl0VmVydGV4VmFsdWVfYXJyYXkodCxlLHMpe2lmKHQgaW4gdGhpcy5zcGxpdHN8fCh0aGlzLnNwbGl0c1t0XT17fSksZSBpbiB0aGlzLnNwbGl0c1t0XSl7aWYoRih0aGlzLnNwbGl0VmFsdWVzW3RoaXMuc3BsaXRzW3RdW2VdXSxzKSlyZXR1cm47Y29uc29sZS53YXJuKCJGYWNlIFZlcnRleCBBbHJlYWR5IFNwbGl0IHdpdGggZGlmZmVyZW50IHZhbHVlIil9dGhpcy5zcGxpdHNbdF1bZV09dGhpcy5zcGxpdFZhbHVlcy5sZW5ndGgsdGhpcy5zcGxpdFZhbHVlcy5wdXNoKHMpfXNldFNwbGl0VmVydGV4VmFsdWVzKHQsZSxzKXt0IGluIHRoaXMuc3BsaXRzfHwodGhpcy5zcGxpdHNbdF09e30pO2NvbnN0IGE9dGhpcy5zcGxpdFZhbHVlcy5sZW5ndGg7dGhpcy5zcGxpdFZhbHVlcy5wdXNoKHMpO2Zvcihjb25zdCBzIG9mIGUpdGhpcy5zcGxpdHNbdF1bc109YX1nZW5lcmF0ZVNwbGl0VmFsdWVzKHQsZSl7aWYoMD09ZSlyZXR1cm4gdGhpcy5kYXRhO2NvbnN0IHM9dGhpcy5nZXRDb3VudCgpLGE9bmV3IEZsb2F0MzJBcnJheSgocytlKSp0aGlzLnN0cmlkZSk7YS5zZXQodGhpcy5kYXRhKTtmb3IoY29uc3QgZSBpbiB0KXtjb25zdCBpPXRbZV07Zm9yKGNvbnN0IHQgaW4gaSl7Y29uc3Qgcj1zK2lbdF07aWYoZSBpbiB0aGlzLnNwbGl0cyYmdCBpbiB0aGlzLnNwbGl0c1tlXSl7Y29uc3Qgcz10aGlzLnNwbGl0c1tlXVt0XTt0aGlzLnNwbGl0VmFsdWVzW3NdLmZvckVhY2goKCh0LGUpPT57YVtyKnRoaXMuc3RyaWRlK2VdPXR9KSl9ZWxzZXtjb25zdCB0PXBhcnNlSW50KGUpO2ZvcihsZXQgZT0wO2U8dGhpcy5zdHJpZGU7ZSsrKWFbcip0aGlzLnN0cmlkZStlXT10aGlzLmRhdGFbdCp0aGlzLnN0cmlkZStlXX19fXJldHVybiBhfXRvSlNPTih0KXtyZXR1cm57ZGF0YTp0aGlzLmRhdGEsZGF0YVR5cGU6dGhpcy5kYXRhVHlwZU5hbWUsbGVuZ3RoOnRoaXMuZGF0YS5sZW5ndGgvdGhpcy5zdHJpZGV9fWZyb21KU09OKHQpe2NvbnN0IGU9dC5kYXRhLm1hcCgodD0+ZC5pc051bWVyaWModCk/dDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpKTt0aGlzLmRhdGE9RmxvYXQzMkFycmF5LmZyb20oZSl9bG9hZFNwbGl0VmFsdWVzKHQpe2NvbnN0IGU9dC5sb2FkVUludDMyQXJyYXkoKTtpZigwPT1lLmxlbmd0aClyZXR1cm47bGV0IHM9MCxhPTA7Zm9yKDs7KXtjb25zdCB0PWVbcysrXSxpPWVbcysrXSxyPXt9O2ZvcihsZXQgdD0wO3Q8aTt0Kyspe2NvbnN0IHQ9ZVtzKytdLGk9ZVtzKytdO3JbdF09aSxpPj1hJiYoYT1pKzEpfWlmKHRoaXMuc3BsaXRzW3RdPXIscz49ZS5sZW5ndGgpYnJlYWt9Y29uc3QgaT10aGlzLnN0cmlkZSxyPXQubG9hZEZsb2F0MzJBcnJheShhKmkpO3RoaXMuc3BsaXRWYWx1ZXM9W107Zm9yKGxldCB0PTA7dDxhO3QrKyl7Y29uc3QgZT1yLnNsaWNlKHQqaSx0KmkraSk7dGhpcy5zcGxpdFZhbHVlcy5wdXNoKGUpfX10b1N0cmluZygpe3JldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLG51bGwsMil9Z2VuQnVmZmVyKCl7cmV0dXJue3ZhbHVlczp0aGlzLmRhdGEsY291bnQ6dGhpcy5nZXRDb3VudCgpLGRhdGFUeXBlOnRoaXMuZGF0YVR5cGVOYW1lLG5vcm1hbGl6ZWQ6dGhpcy5ub3JtYWxpemVkfX19Y2xhc3MgeiBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlcigiVmVjMyIsMyksdGhpcy5ub3JtYWxpemVkPSExfWdldFZhbHVlUmVmKHQpe2lmKHQ+PXRoaXMuZGF0YS5sZW5ndGgvdGhpcy5zdHJpZGUpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHZlcnRleCBpbmRleDoiK3QrIi4gTnVtIFZlcnRpY2VzOiIrdGhpcy5kYXRhLmxlbmd0aC8zKTtjb25zdCBlPXQqdGhpcy5zdHJpZGUsYT10aGlzLmRhdGEuc3ViYXJyYXkoZSxlK3RoaXMuc3RyaWRlKTtyZXR1cm4gbmV3IHMoYSl9Z2V0VmFsdWUodCl7aWYodD49dGhpcy5kYXRhLmxlbmd0aC90aGlzLnN0cmlkZSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgdmVydGV4IGluZGV4OiIrdCsiLiBOdW0gVmVydGljZXM6Iit0aGlzLmRhdGEubGVuZ3RoLzMpO2NvbnN0IGU9dCp0aGlzLnN0cmlkZSxhPXRoaXMuZGF0YS5zbGljZShlLGUrdGhpcy5zdHJpZGUpO3JldHVybiBuZXcgcyhhKX1zZXRWYWx1ZSh0LGUpe2lmKHQ+PXRoaXMuZGF0YS5sZW5ndGgvdGhpcy5zdHJpZGUpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHZlcnRleCBpbmRleDoiK3QrIi4gTnVtIFZlcnRpY2VzOiIrdGhpcy5kYXRhLmxlbmd0aC8zKTtjb25zdCBzPXQqdGhpcy5zdHJpZGU7dGhpcy5kYXRhLnNldChlLmFzQXJyYXkoKSxzKX1nZXRGYWNlVmVydGV4VmFsdWVSZWYodCxlKXtjb25zdCBhPXRoaXMuZ2V0RmFjZVZlcnRleFZhbHVlUmVmX2FycmF5KHQsZSk7cmV0dXJuIG5ldyBzKGEpfXNldEZhY2VWZXJ0ZXhWYWx1ZSh0LGUscyl7dGhpcy5zZXRGYWNlVmVydGV4VmFsdWVfYXJyYXkodCxlLHMuYXNBcnJheSgpKX1zZXRTcGxpdFZlcnRleFZhbHVlKHQsZSxzKXt0aGlzLnNldFNwbGl0VmVydGV4VmFsdWVfYXJyYXkodCxlLHMuYXNBcnJheSgpKX19Zy5yZWdpc3RlcigiVmVjM0F0dHJpYnV0ZSIseik7Y2xhc3MgQSBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlcigiVmVjMiIsMiksdGhpcy5ub3JtYWxpemVkPSExfWdldFZhbHVlUmVmKHQpe2lmKHQ+PXRoaXMuZGF0YS5sZW5ndGgvdGhpcy5zdHJpZGUpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHZlcnRleCBpbmRleDoiK3QrIi4gTnVtIFZlcnRpY2VzOiIrdGhpcy5kYXRhLmxlbmd0aC8zKTtjb25zdCBzPXQqdGhpcy5zdHJpZGUsYT10aGlzLmRhdGEuc3ViYXJyYXkocyxzK3RoaXMuc3RyaWRlKTtyZXR1cm4gbmV3IGUoYSl9Z2V0VmFsdWUodCl7aWYodD49dGhpcy5kYXRhLmxlbmd0aC90aGlzLnN0cmlkZSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgdmVydGV4IGluZGV4OiIrdCsiLiBOdW0gVmVydGljZXM6Iit0aGlzLmRhdGEubGVuZ3RoLzMpO2NvbnN0IHM9dCp0aGlzLnN0cmlkZSxhPXRoaXMuZGF0YS5zbGljZShzLHMrdGhpcy5zdHJpZGUpO3JldHVybiBuZXcgZShhKX1zZXRWYWx1ZSh0LGUpe2lmKHQ+PXRoaXMuZGF0YS5sZW5ndGgvdGhpcy5zdHJpZGUpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHZlcnRleCBpbmRleDoiK3QrIi4gTnVtIFZlcnRpY2VzOiIrdGhpcy5kYXRhLmxlbmd0aC8zKTtjb25zdCBzPXQqdGhpcy5zdHJpZGU7dGhpcy5kYXRhLnNldChlLmFzQXJyYXkoKSxzKX1nZXRGYWNlVmVydGV4VmFsdWVSZWYodCxzKXtjb25zdCBhPXRoaXMuZ2V0RmFjZVZlcnRleFZhbHVlUmVmX2FycmF5KHQscyk7cmV0dXJuIG5ldyBlKGEpfXNldEZhY2VWZXJ0ZXhWYWx1ZSh0LGUscyl7dGhpcy5zZXRGYWNlVmVydGV4VmFsdWVfYXJyYXkodCxlLHMuYXNBcnJheSgpKX1zZXRTcGxpdFZlcnRleFZhbHVlKHQsZSxzKXt0aGlzLnNldFNwbGl0VmVydGV4VmFsdWVfYXJyYXkodCxlLHMuYXNBcnJheSgpKX19Zy5yZWdpc3RlcigiVmVjMkF0dHJpYnV0ZSIsQSk7Y2xhc3MgTSBleHRlbmRzIE57Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuX19ib3VuZGluZ0JveD1uZXcgYyx0aGlzLl9fYm91bmRpbmdCb3hEaXJ0eT0hMCx0aGlzLl9fbWV0YURhdGE9bmV3IE1hcCx0aGlzLl9fbmFtZT0iIix0aGlzLl9fbnVtVmVydGljZXM9MCx0aGlzLl9fdmVydGV4QXR0cmlidXRlcz1uZXcgTWFwLHRoaXMuZGVidWdDb2xvcj1uZXcgaSgxLDAsMCwxKSx0aGlzLm5hbWU9IiIsdGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoInBvc2l0aW9ucyIsbmV3IHopfWNsZWFyKCl7dGhpcy5zZXROdW1WZXJ0aWNlcygwKX1zZXREZWJ1Z05hbWUodCl7dGhpcy5uYW1lPXR9YWRkVmVydGV4QXR0cmlidXRlKHQsZSl7ZS5zZXRDb3VudCh0aGlzLl9fbnVtVmVydGljZXMpLHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLnNldCh0LGUpfWhhc1ZlcnRleEF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuaGFzKHQpfWdldFZlcnRleEF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KHQpfWdldFZlcnRleEF0dHJpYnV0ZXMoKXtjb25zdCB0PXt9O2Zvcihjb25zdFtlLHNdb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZW50cmllcygpKXRbZV09cztyZXR1cm4gdH1nZXQgcG9zaXRpb25zKCl7cmV0dXJuIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLmdldCgicG9zaXRpb25zIil9bnVtVmVydGljZXMoKXtyZXR1cm4gdGhpcy5fX251bVZlcnRpY2VzfWdldE51bVZlcnRpY2VzKCl7cmV0dXJuIHRoaXMuX19udW1WZXJ0aWNlc31zZXROdW1WZXJ0aWNlcyh0KXt0aGlzLl9fbnVtVmVydGljZXM9dCx0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5mb3JFYWNoKCh0PT50LnNldENvdW50KHRoaXMuX19udW1WZXJ0aWNlcykpKSx0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKX1nZXRCb3VuZGluZ0JveCgpe3JldHVybiB0aGlzLl9fYm91bmRpbmdCb3hEaXJ0eSYmdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpLHRoaXMuX19ib3VuZGluZ0JveH1zZXRCb3VuZGluZ0JveERpcnR5KCl7dGhpcy5fX2JvdW5kaW5nQm94RGlydHk9ITAsdGhpcy5lbWl0KCJib3VuZGluZ0JveENoYW5nZWQiKX11cGRhdGVCb3VuZGluZ0JveCgpe2NvbnN0IHQ9dGhpcy5wb3NpdGlvbnMsZT1uZXcgYztpZih0KXtjb25zdCBzPXQuZ2V0Q291bnQoKTtmb3IobGV0IGE9MDthPHM7YSsrKWUuYWRkUG9pbnQodC5nZXRWYWx1ZVJlZihhKSl9dGhpcy5fX2JvdW5kaW5nQm94PWUsdGhpcy5fX2JvdW5kaW5nQm94RGlydHk9ITF9Z2V0TWV0YWRhdGEodCl7cmV0dXJuIHRoaXMuX19tZXRhRGF0YS5nZXQodCl9aGFzTWV0YWRhdGEodCl7cmV0dXJuIHRoaXMuX19tZXRhRGF0YS5oYXModCl9c2V0TWV0YWRhdGEodCxlKXt0aGlzLl9fbWV0YURhdGEuc2V0KHQsZSl9ZGVsZXRlTWV0YWRhdGEodCl7dGhpcy5fX21ldGFEYXRhLmRlbGV0ZSh0KX1nZW5CdWZmZXJzKHQpe2NvbnN0IGU9e307Zm9yKGNvbnN0W3Qsc11vZiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcyllW3RdPXMuZ2VuQnVmZmVyKCk7cmV0dXJue251bVZlcnRpY2VzOnRoaXMubnVtVmVydGljZXMoKSxhdHRyQnVmZmVyczplfX1sb2FkQmFzZUdlb21CaW5hcnkodCl7dGhpcy5uYW1lPXQubG9hZFN0cigpO2NvbnN0IGE9dC5sb2FkVUludDgoKTt0aGlzLmRlYnVnQ29sb3I9dC5sb2FkUkdCRmxvYXQzMkNvbG9yKCk7Y29uc3QgaT10LmxvYWRVSW50MzIoKTt0aGlzLl9fYm91bmRpbmdCb3guc2V0KHQubG9hZEZsb2F0MzJWZWMzKCksdC5sb2FkRmxvYXQzMlZlYzMoKSksdGhpcy5zZXROdW1WZXJ0aWNlcyhpKTtjb25zdCByPXRoaXMucG9zaXRpb25zO2xldCBuLGg7MiZhJiYobj10aGlzLmdldFZlcnRleEF0dHJpYnV0ZSgibm9ybWFscyIpLG58fChuPW5ldyB6LHRoaXMuYWRkVmVydGV4QXR0cmlidXRlKCJub3JtYWxzIixuKSkpLDQmYSYmKGg9dGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoInRleENvb3JkcyIpLGh8fChoPW5ldyBBLHRoaXMuYWRkVmVydGV4QXR0cmlidXRlKCJ0ZXhDb29yZHMiLGgpKSk7Y29uc3Qgbz0odCxlLGEsaSk9Pntmb3IobGV0IG49dFswXTtuPHRbMV07bisrKXtjb25zdCB0PW5ldyBzKGlbMypuKzBdLzI1NSxpWzMqbisxXS8yNTUsaVszKm4rMl0vMjU1KTt0Lm11bHRpcGx5SW5QbGFjZShhKSx0LmFkZEluUGxhY2UoZSksciYmci5zZXRWYWx1ZShuLHQpfX0sZD0odCxlLGEsaSk9PnthLmlzTnVsbCgpJiZhLnNldCgxLDEsMSk7Zm9yKGxldCByPXRbMF07cjx0WzFdO3IrKyl7Y29uc3QgdD1uZXcgcyhpWzMqciswXS8yNTUsaVszKnIrMV0vMjU1LGlbMypyKzJdLzI1NSk7dC5tdWx0aXBseUluUGxhY2UoYSksdC5hZGRJblBsYWNlKGUpLHQubm9ybWFsaXplSW5QbGFjZSgpLG4uc2V0VmFsdWUocix0KX19LGw9KHQscyxhLGkpPT57Zm9yKGxldCByPXRbMF07cjx0WzFdO3IrKyl7Y29uc3QgdD1uZXcgZShpWzIqciswXS8yNTUsaVsyKnIrMV0vMjU1KTt0Lm11bHRpcGx5SW5QbGFjZShhKSx0LmFkZEluUGxhY2UocyksaC5zZXRWYWx1ZShyLHQpfX0sdT10LmxvYWRVSW50MzIoKTtpZigxPT11KXt7Y29uc3QgZT10aGlzLl9fYm91bmRpbmdCb3gscz10LmxvYWRVSW50OEFycmF5KDMqaSk7byhbMCxpXSxlLnAwLGUuZGlhZ29uYWwoKSxzKX1pZihuKXtjb25zdCBlPW5ldyBjKHQubG9hZEZsb2F0MzJWZWMzKCksdC5sb2FkRmxvYXQzMlZlYzMoKSkscz10LmxvYWRVSW50OEFycmF5KDMqaSk7ZChbMCxpXSxlLnAwLGUuZGlhZ29uYWwoKSxzKSxuLmxvYWRTcGxpdFZhbHVlcyh0KX1pZihoKXtjb25zdCBlPW5ldyBfKHQubG9hZEZsb2F0MzJWZWMyKCksdC5sb2FkRmxvYXQzMlZlYzIoKSkscz10LmxvYWRVSW50OEFycmF5KDIqaSk7bChbMCxpXSxlLnAwLGUuZGlhZ29uYWwoKSxzKSxoLmxvYWRTcGxpdFZhbHVlcyh0KX19ZWxzZXtjb25zdCBlPVtdO2xldCBzPTA7Zm9yKGxldCBhPTA7YTx1O2ErKyl7Y29uc3QgYT10LmxvYWRVSW50MzIoKSxpPXtyYW5nZTpbcyxzK2FdLGJib3g6bmV3IGModC5sb2FkRmxvYXQzMlZlYzMoKSx0LmxvYWRGbG9hdDMyVmVjMygpKSxub3JtYWxzUmFuZ2U6bmV3IGMsdGV4Q29vcmRzUmFuZ2U6bmV3IF99O24mJmkubm9ybWFsc1JhbmdlLnNldCh0LmxvYWRGbG9hdDMyVmVjMygpLHQubG9hZEZsb2F0MzJWZWMzKCkpLGgmJmkudGV4Q29vcmRzUmFuZ2Uuc2V0KHQubG9hZEZsb2F0MzJWZWMyKCksdC5sb2FkRmxvYXQzMlZlYzIoKSksZS5wdXNoKGkpLHMrPWF9Y29uc3QgYT10LmxvYWRVSW50OEFycmF5KDMqaSk7bGV0IHI9bnVsbCxmPW51bGw7biYmKHI9dC5sb2FkVUludDhBcnJheSgzKmkpKSxoJiYoZj10LmxvYWRVSW50OEFycmF5KDIqaSkpO2ZvcihsZXQgdD0wO3Q8dTt0Kyspe3tjb25zdCBzPWVbdF0uYmJveDtvKGVbdF0ucmFuZ2Uscy5wMCxzLmRpYWdvbmFsKCksYSl9aWYobil7Y29uc3Qgcz1lW3RdLm5vcm1hbHNSYW5nZTtkKGVbdF0ucmFuZ2Uscy5wMCxzLmRpYWdvbmFsKCkscil9aWYoaCl7Y29uc3Qgcz1lW3RdLnRleENvb3Jkc1JhbmdlO2woZVt0XS5yYW5nZSxzLnAwLHMuZGlhZ29uYWwoKSxmKX19biYmbi5sb2FkU3BsaXRWYWx1ZXModCksaCYmaC5sb2FkU3BsaXRWYWx1ZXModCl9fXRvSlNPTih0KXtjb25zdCBlPXN1cGVyLnRvSlNPTih0KTt0JiZ0LnNraXBUb3BvbG9neXx8KGUubnVtVmVydGljZXM9dGhpcy5fX251bVZlcnRpY2VzfHwwKTtjb25zdCBzPXt9O2Zvcihjb25zdFtlLGFdb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZW50cmllcygpKXQmJiJza2lwQXR0cmlidXRlcyJpbiB0JiZ0LnNraXBBdHRyaWJ1dGVzLmluY2x1ZGVzKGUpfHwoc1tlXT1hLnRvSlNPTih0KSk7cmV0dXJuIGUudmVydGV4QXR0cmlidXRlcz1zLGV9ZnJvbUpTT04odCxlKXt0aGlzLmNsZWFyKCksc3VwZXIuZnJvbUpTT04odCxlKSx0aGlzLnNldE51bVZlcnRpY2VzKHQubnVtVmVydGljZXMpO2Zvcihjb25zdCBlIGluIHQudmVydGV4QXR0cmlidXRlcyl7bGV0IHM9dGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KGUpO2NvbnN0IGE9dC52ZXJ0ZXhBdHRyaWJ1dGVzW2VdO3M/cy5mcm9tSlNPTihhKTpjb25zb2xlLndhcm4oImF0dHIgdW5kZWZpbmVkLCBjYW5ub3QgZXhlY3V0ZSBmcm9tSlNPTigpIil9dGhpcy5lbWl0KCJnZW9tRGF0YVRvcG9sb2d5Q2hhbmdlZCIpfXRvU3RyaW5nKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksbnVsbCwyKX19Y2xhc3MgUyBleHRlbmRzIE17Y29uc3RydWN0b3IoKXtzdXBlcigpfWNsZWFyKCl7dGhpcy5zZXROdW1WZXJ0aWNlcygwKSx0aGlzLmVtaXQoImdlb21EYXRhVG9wb2xvZ3lDaGFuZ2VkIil9bG9hZEJpbih0KXt0aGlzLm5hbWU9dC5sb2FkU3RyKCk7Y29uc3QgZT10LmxvYWRVSW50MzIoKTt0aGlzLl9fYm91bmRpbmdCb3guc2V0KHQubG9hZEZsb2F0MzJWZWMzKCksdC5sb2FkRmxvYXQzMlZlYzMoKSksdGhpcy5zZXROdW1WZXJ0aWNlcyhlKTtjb25zdCBhPXRoaXMuZ2V0VmVydGV4QXR0cmlidXRlKCJwb3NpdGlvbnMiKTtpZighYSl0aHJvdyBFcnJvcigicG9zaXRpb25zIGlzIHVuZGVmaW5lZCIpO2lmKGU8MjU2KXtjb25zdCBpPXRoaXMuX19ib3VuZGluZ0JveC50b01hdDQoKSxyPXQubG9hZFVJbnQ4QXJyYXkoMyplKTtmb3IobGV0IHQ9MDt0PGU7dCsrKXtjb25zdCBlPW5ldyBzKHJbMyp0KzBdLzI1NSxyWzMqdCsxXS8yNTUsclszKnQrMl0vMjU1KTthLnNldFZhbHVlKHQsaS50cmFuc2Zvcm1WZWMzKGUpKX19ZWxzZXtjb25zdCBpPXQubG9hZFVJbnQzMigpLHI9W107Zm9yKGxldCBlPTA7ZTxpO2UrKyl7Y29uc3QgZT10LmxvYWRVSW50MzJWZWMyKCkscz10LmxvYWRGbG9hdDMyVmVjMygpLGE9dC5sb2FkRmxvYXQzMlZlYzMoKTtyLnB1c2goe3JhbmdlOmUsYmJveDpuZXcgYyhzLGEpfSl9Y29uc3Qgbj10LmxvYWRVSW50OEFycmF5KDMqZSk7Zm9yKGxldCB0PTA7dDxpO3QrKyl7Y29uc3QgZT1yW3RdLmJib3gudG9NYXQ0KCk7Zm9yKGxldCBpPXJbdF0ucmFuZ2UueDtpPHJbdF0ucmFuZ2UueTtpKyspe2NvbnN0IHQ9bmV3IHMoblszKmkrMF0vMjU1LG5bMyppKzFdLzI1NSxuWzMqaSsyXS8yNTUpO2Euc2V0VmFsdWUoaSxlLnRyYW5zZm9ybVZlYzModCkpfX19fXJlYWRCaW5hcnkodCxlKXtzdXBlci5sb2FkQmFzZUdlb21CaW5hcnkodCksdGhpcy5lbWl0KCJnZW9tRGF0YUNoYW5nZWQiKX19Zy5yZWdpc3RlcigiUG9pbnRzIixTKTtjbGFzcyBFIGV4dGVuZHMgTXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGhpcy5fX2luZGljZXM9bmV3IFVpbnQzMkFycmF5fWNsZWFyKCl7dGhpcy5zZXROdW1TZWdtZW50cygwKSx0aGlzLnNldE51bVZlcnRpY2VzKDApLHRoaXMuZW1pdCgiZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQiKX1nZXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX19pbmRpY2VzfWdldE51bVNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX19pbmRpY2VzLmxlbmd0aC8yfXNldE51bVNlZ21lbnRzKHQpe2lmKHQ+dGhpcy5nZXROdW1TZWdtZW50cygpKXtjb25zdCBlPW5ldyBVaW50MzJBcnJheSgyKnQpO2Uuc2V0KHRoaXMuX19pbmRpY2VzKSx0aGlzLl9faW5kaWNlcz1lfWVsc2UgdGhpcy5fX2luZGljZXM9dGhpcy5fX2luZGljZXMuc2xpY2UoMCwyKnQpfXNldFNlZ21lbnRWZXJ0ZXhJbmRpY2VzKHQsZSxzKXtpZih0Pj10aGlzLl9faW5kaWNlcy5sZW5ndGgvMil0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgbGluZSBpbmRleDoiK3QrIi4gTnVtIFNlZ21lbnRzOiIrdGhpcy5fX2luZGljZXMubGVuZ3RoLzIpO3RoaXMuX19pbmRpY2VzWzIqdCswXT1lLHRoaXMuX19pbmRpY2VzWzIqdCsxXT1zfWdldFNlZ21lbnRWZXJ0ZXhJbmRleCh0LGUpe3JldHVybiB0PHRoaXMuZ2V0TnVtU2VnbWVudHMoKT90aGlzLl9faW5kaWNlc1syKnQrZV06LTF9Z2VuQnVmZmVycyh0KXtjb25zdCBlPXN1cGVyLmdlbkJ1ZmZlcnMoKTtsZXQgcztyZXR1cm4gcz1lLm51bVZlcnRpY2VzPE1hdGgucG93KDIsOCk/bmV3IFVpbnQ4QXJyYXkodGhpcy5fX2luZGljZXMpOmUubnVtVmVydGljZXM8TWF0aC5wb3coMiwxNik/bmV3IFVpbnQxNkFycmF5KHRoaXMuX19pbmRpY2VzKTp0aGlzLl9faW5kaWNlcyxlLmluZGljZXM9cyxlfXJlYWRCaW5hcnkodCxlKXtzdXBlci5sb2FkQmFzZUdlb21CaW5hcnkodCksdGhpcy5zZXROdW1TZWdtZW50cyh0LmxvYWRVSW50MzIoKSk7Y29uc3Qgcz10LmxvYWRVSW50OCgpOzE9PXM/dGhpcy5fX2luZGljZXM9dC5sb2FkVUludDhBcnJheSgpOjI9PXM/dGhpcy5fX2luZGljZXM9dC5sb2FkVUludDE2QXJyYXkoKTo0PT1zJiYodGhpcy5fX2luZGljZXM9dC5sb2FkVUludDMyQXJyYXkoKSksdGhpcy5lbWl0KCJnZW9tRGF0YUNoYW5nZWQiKX10b0pTT04odCl7Y29uc3QgZT1zdXBlci50b0pTT04odCk7cmV0dXJuIHQmJnQuc2tpcFRvcG9sb2d5fHwoZS5pbmRpY2VzPUFycmF5LmZyb20odGhpcy5fX2luZGljZXMpKSxlfWZyb21KU09OKHQsZSl7c3VwZXIuZnJvbUpTT04odCxlKSx0LmluZGljZXMmJih0aGlzLl9faW5kaWNlcz1VaW50MzJBcnJheS5mcm9tKHQuaW5kaWNlcykpfX1nLnJlZ2lzdGVyKCJMaW5lcyIsRSk7Y2xhc3MgTyBleHRlbmRzIE17Y29uc3RydWN0b3IoKXtzdXBlcigpLHRoaXMuZWRnZUZhY2VzPVtdLHRoaXMuZmFjZUVkZ2VzPVtbXV0sdGhpcy5mYWNlQ291bnRzPVtdLHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcz1uZXcgVWludDMyQXJyYXksdGhpcy5fX2xvZ1RvcG9sb2d5V2FybmluZ3M9ITEsdGhpcy5fX2VkZ2VBdHRyaWJ1dGVzPW5ldyBNYXAsdGhpcy5fX2ZhY2VBdHRyaWJ1dGVzPW5ldyBNYXAsdGhpcy5udW1FZGdlcz0wLHRoaXMuZWRnZVZlcnRzPVtdLHRoaXMudmVydGV4RWRnZXM9W10sdGhpcy5lZGdlQW5nbGVzPW5ldyBGbG9hdDMyQXJyYXksdGhpcy5lZGdlVmVjcz1bXX1pbml0KCl7fWNsZWFyKCl7c3VwZXIuY2xlYXIoKSx0aGlzLmVkZ2VWZXJ0cz1bXSx0aGlzLnZlcnRleEVkZ2VzPVtdLHRoaXMubnVtRWRnZXM9MCx0aGlzLmVkZ2VBbmdsZXM9bmV3IEZsb2F0MzJBcnJheSx0aGlzLmVtaXQoImdlb21EYXRhVG9wb2xvZ3lDaGFuZ2VkIil9YWRkVmVydGV4QXR0cmlidXRlKHQsZSl7c3VwZXIuYWRkVmVydGV4QXR0cmlidXRlKHQsZSksZS5zZXRNZXNoKHRoaXMpfWdldEZhY2VDb3VudHMoKXtyZXR1cm4gdGhpcy5mYWNlQ291bnRzfWdldE51bUZhY2VzKCl7cmV0dXJuIDA9PXRoaXMuZmFjZUNvdW50cy5sZW5ndGg/MDp0aGlzLmZhY2VDb3VudHMucmVkdWNlKCgodCxlKT0+dCtlKSl9c2V0RmFjZUNvdW50cyh0KXtsZXQgZT0wLHM9Mztmb3IoY29uc3QgYSBvZiB0KWUrPWEqcyxzKys7aWYoMD09dGhpcy5nZXROdW1GYWNlcygpKXRoaXMuX19mYWNlVmVydGV4SW5kaWNlcz1uZXcgVWludDMyQXJyYXkoZSk7ZWxzZXtjb25zdCBhPW5ldyBVaW50MzJBcnJheShlKTtsZXQgaT0wLHI9MDtlPTAscz0zLHQuZm9yRWFjaCgoKHQsZSk9Pntjb25zdCBuPWkrTWF0aC5taW4odCx0aGlzLmZhY2VDb3VudHNbZV0pKnM7YS5zZXQodGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzLnNsaWNlKGksbiksciksaSs9dGhpcy5mYWNlQ291bnRzW2VdKnMscis9dCpzLHMrK30pKSx0aGlzLl9fZmFjZVZlcnRleEluZGljZXM9YX10aGlzLmZhY2VDb3VudHM9dH1nZXRGYWNlVmVydGV4Q291bnQodCl7bGV0IGU9MCxzPTA7cmV0dXJuIHRoaXMuZmFjZUNvdW50cy5zb21lKCgoYSxpKT0+KGUrPWEsZT50JiYocz1pKzMsITApKSkpLHN9Z2V0RmFjZVZlcnRleE9mZnNldCh0KXtsZXQgZT0wLHM9MDtyZXR1cm4gdGhpcy5mYWNlQ291bnRzLnNvbWUoKChhLGkpPT5lK2E+dD8ocys9KHQtZSkqKGkrMyksITApOihlKz1hLHMrPWEqKGkrMyksITEpKSksc31zZXRGYWNlVmVydGV4SW5kaWNlcyh0LGUpe2NvbnN0IHM9dGhpcy5nZXRGYWNlVmVydGV4Q291bnQodCk7aWYoZS5sZW5ndGghPXMpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGluZGljZXMgZm9yIGZhY2U6JHt0fSB2ZXJ0ZXhJbmRpY2VzOiR7ZX0uIEV4cGVjdGVkICR7c30gaW5kaWNlc2ApO2NvbnN0IGE9dGhpcy5nZXRGYWNlVmVydGV4T2Zmc2V0KHQpO3RoaXMuX19mYWNlVmVydGV4SW5kaWNlcy5zZXQoZSxhKX1hZGRGYWNlKHQpe2NvbnN0IGU9Wy4uLnRoaXMuZmFjZUNvdW50c107aWYoZS5sZW5ndGg8PXQubGVuZ3RoLTMpe2ZvcihsZXQgcz1lLmxlbmd0aDtzPHQubGVuZ3RoLTM7cysrKWVbc109MDtlW3QubGVuZ3RoLTNdPTF9ZWxzZSBlW3QubGVuZ3RoLTNdKys7dGhpcy5zZXRGYWNlQ291bnRzKGUpO2xldCBzPTAsYT0wO3JldHVybiB0aGlzLmZhY2VDb3VudHMuc29tZSgoKGUsaSk9PmkrMz09dC5sZW5ndGg/KHMrPWUtMSxhKz0oZS0xKSooaSszKSwhMCk6KHMrPWUsYSs9ZSooaSszKSwhMSkpKSx0aGlzLl9fZmFjZVZlcnRleEluZGljZXMuc2V0KHQsYSksc31nZXRGYWNlVmVydGV4SW5kaWNlcyh0KXtjb25zdCBlPVtdLHM9dGhpcy5nZXRGYWNlVmVydGV4T2Zmc2V0KHQpLGE9dGhpcy5nZXRGYWNlVmVydGV4Q291bnQodCk7Zm9yKGxldCB0PTA7dDxhO3QrKyllLnB1c2godGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzW3MrdF0pO3JldHVybiBlfWdldEZhY2VWZXJ0ZXhJbmRleCh0LGUpe2NvbnN0IHM9dGhpcy5nZXRGYWNlVmVydGV4T2Zmc2V0KHQpO3JldHVybiB0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbcytlXX1hZGRGYWNlQXR0cmlidXRlKHQsZSl7cmV0dXJuIGUuc2V0Q291bnQodGhpcy5nZXROdW1GYWNlcygpKSx0aGlzLl9fZmFjZUF0dHJpYnV0ZXMuc2V0KHQsZSksZX1oYXNGYWNlQXR0cmlidXRlKHQpe3JldHVybiB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMuaGFzKHQpfWdldEZhY2VBdHRyaWJ1dGUodCl7cmV0dXJuIHRoaXMuX19mYWNlQXR0cmlidXRlcy5nZXQodCl9YWRkRWRnZUF0dHJpYnV0ZSh0LGUpe2Uuc2V0Q291bnQodGhpcy5udW1FZGdlcyksdGhpcy5fX2VkZ2VBdHRyaWJ1dGVzLnNldCh0LGUpfWhhc0VkZ2VBdHRyaWJ1dGUodCl7cmV0dXJuIHRoaXMuX19lZGdlQXR0cmlidXRlcy5oYXModCl9Z2V0RWRnZUF0dHJpYnV0ZSh0KXtyZXR1cm4gdGhpcy5fX2VkZ2VBdHRyaWJ1dGVzLmdldCh0KX1nZW5Ub3BvbG9neUluZm8oKXtsZXQgdD17fTt0aGlzLnZlcnRleEVkZ2VzPVtdLHRoaXMuZWRnZUZhY2VzPVtdLHRoaXMuZWRnZVZlcnRzPVtdLHRoaXMuZmFjZUVkZ2VzPVtdLHRoaXMubnVtRWRnZXM9MDtjb25zdCBlPXRoaXMucG9zaXRpb25zLHM9KHMsYSk9PntsZXQgaT1zLHI9YTtpZihyPGkpe2NvbnN0IHQ9aTtpPXIscj10fWNvbnN0IG49aSsiPiIrcjtpZihuIGluIHQpcmV0dXJuIHRbbl07Y29uc3QgaD1lLmdldFZhbHVlUmVmKGkpLG89ZS5nZXRWYWx1ZVJlZihyKS5zdWJ0cmFjdChoKSxkPXtlZGdlSW5kZXg6dGhpcy5lZGdlRmFjZXMubGVuZ3RoLzIsZWRnZVZlYzpvfTtyZXR1cm4gdFtuXT1kLHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpLHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpLHRoaXMuZWRnZVZlcnRzLnB1c2goaSksdGhpcy5lZGdlVmVydHMucHVzaChyKSx0aGlzLm51bUVkZ2VzKyssZH0sYT0odCxlLGEpPT57Y29uc3QgaT1zKHQsZSkuZWRnZUluZGV4O2lmKGU8dCl7Y29uc3QgdD0yKmkrMDt0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyYmLTEhPXRoaXMuZWRnZUZhY2VzW3RdJiZjb25zb2xlLndhcm4oIkVkZ2UgcG9seSAwIGFscmVhZHkgc2V0LiBNZXNoIGlzIG5vbi1tYW5pZm9sZC4iKSx0aGlzLmVkZ2VGYWNlc1t0XT1hfWVsc2V7Y29uc3QgdD0yKmkrMTt0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyYmLTEhPXRoaXMuZWRnZUZhY2VzW3RdJiZjb25zb2xlLndhcm4oIkVkZ2UgcG9seSAxIGFscmVhZHkgc2V0LiBNZXNoIGlzIG5vbi1tYW5pZm9sZC4iKSx0aGlzLmVkZ2VGYWNlc1t0XT1hfWEgaW4gdGhpcy5mYWNlRWRnZXN8fCh0aGlzLmZhY2VFZGdlc1thXT1bXSksdGhpcy5mYWNlRWRnZXNbYV0ucHVzaChpKSxudWxsPT10aGlzLnZlcnRleEVkZ2VzW3RdJiYodGhpcy52ZXJ0ZXhFZGdlc1t0XT1uZXcgU2V0KSxudWxsPT10aGlzLnZlcnRleEVkZ2VzW2VdJiYodGhpcy52ZXJ0ZXhFZGdlc1tlXT1uZXcgU2V0KSx0aGlzLnZlcnRleEVkZ2VzW3RdLmFkZChpKSx0aGlzLnZlcnRleEVkZ2VzW2VdLmFkZChpKX0saT10aGlzLmdldE51bUZhY2VzKCk7Zm9yKGxldCB0PTA7dDxpO3QrKyl7Y29uc3QgZT10aGlzLmdldEZhY2VWZXJ0ZXhJbmRpY2VzKHQpO2ZvcihsZXQgcz0wO3M8ZS5sZW5ndGg7cysrKXthKGVbc10sZVsocysxKSVlLmxlbmd0aF0sdCl9fX1jb21wdXRlRmFjZU5vcm1hbHMoKXtjb25zdCB0PXRoaXMucG9zaXRpb25zLGU9bmV3IHo7dGhpcy5hZGRGYWNlQXR0cmlidXRlKCJub3JtYWxzIixlKTtjb25zdCBhPXRoaXMuZ2V0TnVtRmFjZXMoKTtmb3IobGV0IGk9MDtpPGE7aSsrKXtjb25zdCBhPXRoaXMuZ2V0RmFjZVZlcnRleEluZGljZXMoaSkscj10LmdldFZhbHVlUmVmKGFbMF0pO2xldCBuPXQuZ2V0VmFsdWVSZWYoYVsxXSk7Y29uc3QgaD1uZXcgcztmb3IobGV0IGU9MjtlPGEubGVuZ3RoO2UrKyl7Y29uc3Qgcz10LmdldFZhbHVlUmVmKGFbZV0pLGk9bi5zdWJ0cmFjdChyKSxvPXMuc3VidHJhY3Qocik7aC5hZGRJblBsYWNlKGkuY3Jvc3Mobykubm9ybWFsaXplKCkpLG49c31oLmxlbmd0aFNxdWFyZWQoKTxOdW1iZXIuRVBTSUxPTnx8ZS5zZXRWYWx1ZShpLGgubm9ybWFsaXplKCkpfX1jYWxjdWxhdGVFZGdlQW5nbGVzKCl7MD09dGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGgmJnRoaXMuZ2VuVG9wb2xvZ3lJbmZvKCksdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtjb25zdCB0PXRoaXMucG9zaXRpb25zLGU9dGhpcy5nZXRGYWNlQXR0cmlidXRlKCJub3JtYWxzIik7dGhpcy5lZGdlVmVjcz1bXSx0aGlzLmVkZ2VBbmdsZXM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLm51bUVkZ2VzKTtmb3IobGV0IHM9MDtzPHRoaXMuZWRnZUZhY2VzLmxlbmd0aDtzKz0yKXtjb25zdCBhPXRoaXMuZWRnZVZlcnRzW3NdLGk9dGhpcy5lZGdlVmVydHNbcysxXSxyPXQuZ2V0VmFsdWVSZWYoaSkuc3VidHJhY3QodC5nZXRWYWx1ZVJlZihhKSk7ci5ub3JtYWxpemVJblBsYWNlKCksdGhpcy5lZGdlVmVjcy5wdXNoKHIpO2NvbnN0IG49dGhpcy5lZGdlRmFjZXNbc10saD10aGlzLmVkZ2VGYWNlc1tzKzFdO2lmKC0xPT1ufHwtMT09aCl7dGhpcy5lZGdlQW5nbGVzW3MvMl09MipNYXRoLlBJO2NvbnRpbnVlfWNvbnN0IG89ZS5nZXRWYWx1ZVJlZihuKSxkPWUuZ2V0VmFsdWVSZWYoaCk7dGhpcy5lZGdlQW5nbGVzW3MvMl09by5hbmdsZVRvKGQpfX1jb21wdXRlVmVydGV4Tm9ybWFscyh0PTEpe3RoaXMuY2FsY3VsYXRlRWRnZUFuZ2xlcygpO2NvbnN0IGU9dGhpcy5nZXRGYWNlQXR0cmlidXRlKCJub3JtYWxzIiksYT1uZXcgejt0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgibm9ybWFscyIsYSk7Y29uc3QgaT0odCxlKT0+e2Euc2V0VmFsdWUodCxlKX0scj0odCxlKT0+e2xldCBzLGE7Y29uc3QgaT10aGlzLmZhY2VFZGdlc1t0XTtmb3IoY29uc3QgdCBvZiBpKSh0aGlzLmVkZ2VWZXJ0c1syKnRdPT1lfHx0aGlzLmVkZ2VWZXJ0c1syKnQrMV09PWUpJiYocz9hPXRoaXMuZWRnZVZlY3NbdF06cz10aGlzLmVkZ2VWZWNzW3RdKTtyZXR1cm5bcyxhXX07Zm9yKGxldCBoPTA7aDx0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aDtoKyspe2lmKG51bGw9PXRoaXMudmVydGV4RWRnZXNbaF0pY29udGludWU7Y29uc3Qgbz10aGlzLnZlcnRleEVkZ2VzW2hdLGQ9W10sXz10PT57bGV0IGU9ITE7Zm9yKGNvbnN0IHMgb2YgZClpZihlPXMuaW5jbHVkZXModCksZSlicmVhaztlfHxkLnB1c2goW3RdKX07Zm9yKGNvbnN0IGUgb2Ygbyl7Y29uc3Qgcz10aGlzLmVkZ2VGYWNlc1syKmVdLGE9dGhpcy5lZGdlRmFjZXNbMiplKzFdO2lmKC0xIT1zJiYtMSE9YSYmdGhpcy5lZGdlQW5nbGVzW2VdPHQpe2xldCB0PS0xLGU9LTE7Zm9yKGxldCBpPTA7aTxkLmxlbmd0aDtpKyspLTE9PXQmJmRbaV0uaW5jbHVkZXMocykmJih0PWkpLC0xPT1lJiZkW2ldLmluY2x1ZGVzKGEpJiYoZT1pKTstMT09dCYmLTE9PWU/ZC5wdXNoKFtzLGFdKTotMSE9dCYmLTEhPWU/dCE9ZSYmKGRbdF09ZFt0XS5jb25jYXQoZFtlXSksZC5zcGxpY2UoZSwxKSk6KC0xPT10JiZkW2VdLnB1c2gocyksLTE9PWUmJmRbdF0ucHVzaChhKSl9ZWxzZS0xIT1zJiZfKHMpLC0xIT1hJiZfKGEpfWQuc29ydCgoKHQsZSk9PnQubGVuZ3RoPGUubGVuZ3RoPzE6dC5sZW5ndGg+ZS5sZW5ndGg/LTE6MCkpO2xldCBsPSEwO2Zvcihjb25zdCB0IG9mIGQpe2NvbnN0IG89bmV3IHM7Zm9yKGNvbnN0IHMgb2YgdCl7Y29uc3QgdD1yKHMsaCk7bGV0IGE7dFswXSYmdFsxXT8oYT10WzBdLmFuZ2xlVG8odFsxXSksby5hZGRJblBsYWNlKChuPXMsZS5nZXRWYWx1ZVJlZihuKSkuc2NhbGUoYSkpKTpjb25zb2xlLndhcm4oInZhcmlhYmxlIHdlaWdodCBpcyB1bmRlZmluZWQgYmVjYXVzZSBmYWNlRWRnZXNbMF0gb3IgZmFjZUVkZ2VzWzFdIGlzIHVuZGVmaW5lZCIpfW8ubm9ybWFsaXplSW5QbGFjZSgpLGw/KGkoaCxvKSxsPSExKTphLnNldFNwbGl0VmVydGV4VmFsdWVzKGgsdCxvLmFzQXJyYXkoKSl9fXZhciBuO3JldHVybiBhfWNvbXB1dGVIYXJkRWRnZXNJbmRpY2VzKHQ9MSl7MD09dGhpcy5lZGdlVmVydHMubGVuZ3RoJiZ0aGlzLmNhbGN1bGF0ZUVkZ2VBbmdsZXMoKTtjb25zdCBlPVtdLHM9dD0+e2UucHVzaCh0aGlzLmVkZ2VWZXJ0c1t0XSksZS5wdXNoKHRoaXMuZWRnZVZlcnRzW3QrMV0pfTtmb3IobGV0IGU9MDtlPHRoaXMuZWRnZUFuZ2xlcy5sZW5ndGg7ZSsrKXRoaXMuZWRnZUFuZ2xlc1tlXT50JiZzKDIqZSk7cmV0dXJuIFVpbnQzMkFycmF5LmZyb20oZSl9Z2VuQnVmZmVycyh0KXtjb25zdCBlPXt9O2xldCBzPTA7Zm9yKGNvbnN0Wyx0XW9mIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzKXtjb25zdCBhPXQuZ2V0U3BsaXRzKCk7Zm9yKGNvbnN0IHQgaW4gYSl7dCBpbiBlfHwoZVt0XT17fSk7Y29uc3QgaT1hW3RdO2Zvcihjb25zdCBhIGluIGkpe2NvbnN0IGk9cGFyc2VJbnQoYSk7aSBpbiBlW3RdfHwoZVt0XVtpXT1zLHMrKyl9fX1jb25zdCBhPXRoaXMucG9zaXRpb25zLmdldENvdW50KCksaT1hK3M7bGV0IHI7dCYmMD09dC5pbmNsdWRlSW5kaWNlc3x8KHI9dGhpcy5nZW5lcmF0ZVRyaWFuZ3VsYXRlZEluZGljZXMoaSxhLGUpKTtjb25zdCBuPXt9O2Zvcihjb25zdFt0LGFdb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpe2xldCBpO2k9MD09cz9hLmFzQXJyYXkoKTphLmdlbmVyYXRlU3BsaXRWYWx1ZXMoZSxzKTtjb25zdCByPWEuc3RyaWRlLGg9aS5sZW5ndGgvcjtuW3RdPXt2YWx1ZXM6aSxjb3VudDpoLGRpbWVuc2lvbjpyLG5vcm1hbGl6ZWQ6Im5vcm1hbHMiPT10LGRhdGFUeXBlOmEuZ2V0RGF0YVR5cGVOYW1lKCl9fXJldHVybntudW1WZXJ0aWNlczp0aGlzLm51bVZlcnRpY2VzKCksbnVtUmVuZGVyVmVydHM6aSxpbmRpY2VzOnIsYXR0ckJ1ZmZlcnM6bn19Y29tcHV0ZU51bVRyaWFuZ2xlcygpe2xldCB0PTMsZT0wO2Zvcihjb25zdCBzIG9mIHRoaXMuZmFjZUNvdW50cyllKz1zKih0LTIpLHQrKztyZXR1cm4gZX1nZW5lcmF0ZVRyaWFuZ3VsYXRlZEluZGljZXModCxlLHMpe2NvbnN0IGE9dGhpcy5jb21wdXRlTnVtVHJpYW5nbGVzKCk7bGV0IGk7aT10PE1hdGgucG93KDIsOCk/bmV3IFVpbnQ4QXJyYXkoMyphKTp0PE1hdGgucG93KDIsMTYpP25ldyBVaW50MTZBcnJheSgzKmEpOm5ldyBVaW50MzJBcnJheSgzKmEpO2xldCByPTA7Y29uc3Qgbj1mdW5jdGlvbih0LGEpe3QgaW4gcyYmYSBpbiBzW3RdJiYodD1lK3NbdF1bYV0pLGlbcl09dCxyKyt9LGg9dGhpcy5nZXROdW1GYWNlcygpO2ZvcihsZXQgdD0wO3Q8aDt0Kyspe2NvbnN0IGU9dGhpcy5nZXRGYWNlVmVydGV4SW5kaWNlcyh0KTtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKylzPj0zJiYobihlWzBdLHQpLG4oZVtzLTFdLHQpKSxuKGVbc10sdCl9cmV0dXJuIGl9cmVhZEJpbmFyeSh0LGUpe3N1cGVyLmxvYWRCYXNlR2VvbUJpbmFyeSh0KSx0aGlzLnNldEZhY2VDb3VudHMoQXJyYXkuZnJvbSh0LmxvYWRVSW50MzJBcnJheSgpKSk7Y29uc3Qgcz10aGlzLmdldE51bUZhY2VzKCksYT10LmxvYWRVSW50OEFycmF5KHMpLGk9dC5sb2FkU0ludDMyVmVjMigpLHI9dC5sb2FkVUludDgoKTtsZXQgbjtpZigxPT1yKW49dC5sb2FkVUludDhBcnJheSgpO2Vsc2UgaWYoMj09ciluPXQubG9hZFVJbnQxNkFycmF5KCk7ZWxzZXtpZig0IT1yKXRocm93IEVycm9yKCJmYWNlVmVydGV4SW5kZXhEZWx0YXMgdW5kZWZpbmVkIik7bj10LmxvYWRVSW50MzJBcnJheSgpfWxldCBoPTMsbz0wO2NvbnN0IGQ9dGhpcy5mYWNlQ291bnRzLm1hcCgoKHQsZSk9Pntjb25zdCBzPW87cmV0dXJuIG8rPXQqaCxoKyssc30pKTtsZXQgXz0wLGw9MDtjb25zdCBjPVtdO2ZvcihsZXQgdD0wO3Q8czt0Kyspe2NvbnN0IGU9YVt0XSxzPWRbZV0scj1lKzM7Y1t0XT1zO2ZvcihsZXQgZT0wO2U8cjtlKyspe2NvbnN0IGE9cytlLHI9bltfK2VdK2kueDtpZigwPT10KXRoaXMuX19mYWNlVmVydGV4SW5kaWNlc1thXT1yO2Vsc2V7bGV0IHM9Y1t0LTFdO3MrPWU8bD9lOmwtMSx0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbYV09dGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzW3NdK3J9fV8rPXIsZFtlXSs9cixsPXJ9dGhpcy5oYXNWZXJ0ZXhBdHRyaWJ1dGUoIm5vcm1hbHMiKXx8dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpLHRoaXMuZW1pdCgiZ2VvbURhdGFDaGFuZ2VkIil9dG9KU09OKHQpe2NvbnN0IGU9c3VwZXIudG9KU09OKHQpO3JldHVybiB0JiZ0LnNraXBUb3BvbG9neXx8KGUuZmFjZUNvdW50cz1BcnJheS5mcm9tKHRoaXMuZmFjZUNvdW50cyksZS5mYWNlVmVydGV4SW5kaWNlcz1BcnJheS5mcm9tKHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcykpLGV9ZnJvbUpTT04odCxlKXtzdXBlci5mcm9tSlNPTih0LGUpLHQuZmFjZUNvdW50cyYmKHRoaXMuZmFjZUNvdW50cz10LmZhY2VDb3VudHMpLHQuZmFjZVZlcnRleEluZGljZXMmJih0aGlzLl9fZmFjZVZlcnRleEluZGljZXM9VWludDMyQXJyYXkuZnJvbSh0LmZhY2VWZXJ0ZXhJbmRpY2VzKSl9fWcucmVnaXN0ZXIoIk1lc2giLE8pO2NsYXNzIFB7Y29uc3RydWN0b3IodCxlPTAscz0hMCl7dGhpcy5fX2RhdGE9dCx0aGlzLl9fYnl0ZU9mZnNldD1lLHRoaXMuX19kYXRhVmlldz1uZXcgRGF0YVZpZXcodGhpcy5fX2RhdGEpLHRoaXMuX19pc01vYmlsZURldmljZT1zLHRoaXMudXRmOGRlY29kZXI9bmV3IFRleHREZWNvZGVyfWdldCBpc01vYmlsZURldmljZSgpe3JldHVybiB0aGlzLl9faXNNb2JpbGVEZXZpY2V9Z2V0IGRhdGEoKXtyZXR1cm4gdGhpcy5fX2RhdGF9Z2V0IGJ5dGVMZW5ndGgoKXtyZXR1cm4gdGhpcy5fX2RhdGFWaWV3LmJ5dGVMZW5ndGh9Z2V0IHJlbWFpbmluZ0J5dGVMZW5ndGgoKXtyZXR1cm4gdGhpcy5fX2RhdGFWaWV3LmJ5dGVMZW5ndGgtdGhpcy5fX2J5dGVPZmZzZXR9cG9zKCl7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0fXNlZWsodCl7dGhpcy5fX2J5dGVPZmZzZXQ9dH1hZHZhbmNlKHQpe3RoaXMuX19ieXRlT2Zmc2V0Kz10fWxvYWRVSW50OCgpe2NvbnN0IHQ9dGhpcy5fX2RhdGFWaWV3LmdldFVpbnQ4KHRoaXMuX19ieXRlT2Zmc2V0KTtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXQrPTEsdH1sb2FkVUludDE2KCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0VWludDE2KHRoaXMuX19ieXRlT2Zmc2V0LCEwKTtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXQrPTIsdH1sb2FkVUludDMyKCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0VWludDMyKHRoaXMuX19ieXRlT2Zmc2V0LCEwKTtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXQrPTQsdH1sb2FkU0ludDMyKCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0SW50MzIodGhpcy5fX2J5dGVPZmZzZXQsITApO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9NCx0fWxvYWRGbG9hdDE2KCl7Y29uc3QgdD10aGlzLmxvYWRVSW50MTYoKTtyZXR1cm4gZC5kZWNvZGUxNkJpdEZsb2F0KHQpfWxvYWRVRmxvYXQxNigpe2NvbnN0IHQ9dGhpcy5sb2FkRmxvYXQxNigpO3JldHVybiB0PDA/MjA0OC10OnR9bG9hZEZsb2F0MTZGcm9tMnhVSW50OCgpe3Rocm93IEVycm9yKCJsb2FkRmxvYXQxNkZyb20yeFVJbnQ4IG5vdCBpbXBsZW1lbnRlZCEiKX1sb2FkVUludDMyRnJvbTJ4VUZsb2F0MTYoKXtyZXR1cm4gdGhpcy5sb2FkVUZsb2F0MTYoKSs0MDk2KnRoaXMubG9hZFVGbG9hdDE2KCl9bG9hZFNJbnQzMkZyb20yeEZsb2F0MTYoKXtyZXR1cm4gdGhpcy5sb2FkRmxvYXQxNigpKzIwNDgqdGhpcy5sb2FkRmxvYXQxNigpfWxvYWRGbG9hdDMyKCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCk7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0Kz00LHR9bG9hZFVJbnQ4QXJyYXkodCxlPSExKXtudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSk7Y29uc3Qgcz1uZXcgVWludDhBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KTtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXQrPXQsc31sb2FkVUludDE2QXJyYXkodCxlPSExKXtpZihudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSksMD09dClyZXR1cm4gbmV3IFVpbnQxNkFycmF5O2xldCBzO2lmKHRoaXMucmVhZFBhZCgyKSx0aGlzLl9faXNNb2JpbGVEZXZpY2Upe3M9bmV3IFVpbnQxNkFycmF5KHQpO2ZvcihsZXQgZT0wO2U8dDtlKyspc1tlXT10aGlzLl9fZGF0YVZpZXcuZ2V0VWludDE2KHRoaXMuX19ieXRlT2Zmc2V0LCEwKSx0aGlzLl9fYnl0ZU9mZnNldCs9Mn1lbHNlIHM9bmV3IFVpbnQxNkFycmF5KHRoaXMuX19kYXRhLHRoaXMuX19ieXRlT2Zmc2V0LHQpLHRoaXMuX19ieXRlT2Zmc2V0Kz0yKnQ7cmV0dXJuIHN9bG9hZFVJbnQzMkFycmF5KHQsZT0hMSl7aWYobnVsbD09dCYmKHQ9dGhpcy5sb2FkVUludDMyKCkpLDA9PXQpcmV0dXJuIG5ldyBVaW50MzJBcnJheTtsZXQgcztpZih0aGlzLnJlYWRQYWQoNCksdGhpcy5fX2lzTW9iaWxlRGV2aWNlKXtzPW5ldyBVaW50MzJBcnJheSh0KTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXNbZV09dGhpcy5fX2RhdGFWaWV3LmdldFVpbnQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCksdGhpcy5fX2J5dGVPZmZzZXQrPTR9ZWxzZSBzPW5ldyBVaW50MzJBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KSx0aGlzLl9fYnl0ZU9mZnNldCs9NCp0O3JldHVybiBzfWxvYWRGbG9hdDMyQXJyYXkodCxlPSExKXtpZihudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSksMD09dClyZXR1cm4gbmV3IEZsb2F0MzJBcnJheTtsZXQgcztpZih0aGlzLnJlYWRQYWQoNCksdGhpcy5fX2lzTW9iaWxlRGV2aWNlKXtzPW5ldyBGbG9hdDMyQXJyYXkodCk7Zm9yKGxldCBlPTA7ZTx0O2UrKylzW2VdPXRoaXMuX19kYXRhVmlldy5nZXRGbG9hdDMyKHRoaXMuX19ieXRlT2Zmc2V0LCEwKSx0aGlzLl9fYnl0ZU9mZnNldCs9NH1lbHNlIHM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KSx0aGlzLl9fYnl0ZU9mZnNldCs9NCp0O3JldHVybiBzfWxvYWRTdHIoKXtjb25zdCB0PXRoaXMubG9hZFVJbnQzMigpLGU9bmV3IFVpbnQ4QXJyYXkodGhpcy5fX2RhdGEsdGhpcy5fX2J5dGVPZmZzZXQsdCk7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0Kz10LHRoaXMudXRmOGRlY29kZXIuZGVjb2RlKGUpfWxvYWRTdHJBcnJheSgpe2NvbnN0IHQ9dGhpcy5sb2FkVUludDMyKCksZT1bXTtmb3IobGV0IHM9MDtzPHQ7cysrKWVbc109dGhpcy5sb2FkU3RyKCk7cmV0dXJuIGV9bG9hZFNJbnQzMlZlYzIoKXtjb25zdCB0PXRoaXMubG9hZFNJbnQzMigpLHM9dGhpcy5sb2FkU0ludDMyKCk7cmV0dXJuIG5ldyBlKHQscyl9bG9hZFVJbnQzMlZlYzIoKXtjb25zdCB0PXRoaXMubG9hZFVJbnQzMigpLHM9dGhpcy5sb2FkVUludDMyKCk7cmV0dXJuIG5ldyBlKHQscyl9bG9hZEZsb2F0MTZWZWMyKCl7Y29uc3QgdD10aGlzLmxvYWRGbG9hdDE2KCkscz10aGlzLmxvYWRGbG9hdDE2KCk7cmV0dXJuIG5ldyBlKHQscyl9bG9hZEZsb2F0MzJWZWMyKCl7Y29uc3QgdD10aGlzLmxvYWRGbG9hdDMyKCkscz10aGlzLmxvYWRGbG9hdDMyKCk7cmV0dXJuIG5ldyBlKHQscyl9bG9hZEZsb2F0MTZWZWMzKCl7Y29uc3QgdD10aGlzLmxvYWRGbG9hdDE2KCksZT10aGlzLmxvYWRGbG9hdDE2KCksYT10aGlzLmxvYWRGbG9hdDE2KCk7cmV0dXJuIG5ldyBzKHQsZSxhKX1sb2FkRmxvYXQzMlZlYzMoKXtjb25zdCB0PXRoaXMubG9hZEZsb2F0MzIoKSxlPXRoaXMubG9hZEZsb2F0MzIoKSxhPXRoaXMubG9hZEZsb2F0MzIoKTtyZXR1cm4gbmV3IHModCxlLGEpfWxvYWRGbG9hdDE2UXVhdCgpe2NvbnN0IHQ9dGhpcy5sb2FkRmxvYXQxNigpLGU9dGhpcy5sb2FkRmxvYXQxNigpLHM9dGhpcy5sb2FkRmxvYXQxNigpLGE9dGhpcy5sb2FkRmxvYXQxNigpO3JldHVybiBuZXcgbyh0LGUscyxhKX1sb2FkRmxvYXQzMlF1YXQoKXtjb25zdCB0PXRoaXMubG9hZEZsb2F0MzIoKSxlPXRoaXMubG9hZEZsb2F0MzIoKSxzPXRoaXMubG9hZEZsb2F0MzIoKSxhPXRoaXMubG9hZEZsb2F0MzIoKTtyZXR1cm4gbmV3IG8odCxlLHMsYSl9bG9hZFJHQkZsb2F0MzJDb2xvcigpe2NvbnN0IHQ9dGhpcy5sb2FkRmxvYXQzMigpLGU9dGhpcy5sb2FkRmxvYXQzMigpLHM9dGhpcy5sb2FkRmxvYXQzMigpO3JldHVybiBuZXcgaSh0LGUscyl9bG9hZFJHQkFGbG9hdDMyQ29sb3IoKXtjb25zdCB0PXRoaXMubG9hZEZsb2F0MzIoKSxlPXRoaXMubG9hZEZsb2F0MzIoKSxzPXRoaXMubG9hZEZsb2F0MzIoKSxhPXRoaXMubG9hZEZsb2F0MzIoKTtyZXR1cm4gbmV3IGkodCxlLHMsYSl9bG9hZFJHQlVJbnQ4Q29sb3IoKXtjb25zdCB0PXRoaXMubG9hZFVJbnQ4KCksZT10aGlzLmxvYWRVSW50OCgpLHM9dGhpcy5sb2FkVUludDgoKTtyZXR1cm4gbmV3IGkodC8yNTUsZS8yNTUscy8yNTUpfWxvYWRSR0JBVUludDhDb2xvcigpe2NvbnN0IHQ9dGhpcy5sb2FkVUludDgoKSxlPXRoaXMubG9hZFVJbnQ4KCkscz10aGlzLmxvYWRVSW50OCgpLGE9dGhpcy5sb2FkVUludDgoKTtyZXR1cm4gbmV3IGkodC8yNTUsZS8yNTUscy8yNTUsYS8yNTUpfWxvYWRCb3gyKCl7cmV0dXJuIG5ldyBfKHRoaXMubG9hZEZsb2F0MzJWZWMyKCksdGhpcy5sb2FkRmxvYXQzMlZlYzIoKSl9bG9hZEJveDMoKXtyZXR1cm4gbmV3IGModGhpcy5sb2FkRmxvYXQzMlZlYzMoKSx0aGlzLmxvYWRGbG9hdDMyVmVjMygpKX1yZWFkUGFkKHQpe2NvbnN0IGU9dGhpcy5fX2J5dGVPZmZzZXQldDswIT1lJiYodGhpcy5fX2J5dGVPZmZzZXQrPXQtZSl9fWNsYXNzIFR7Y29uc3RydWN0b3IodD0iIil7aWYodGhpcy5icmFuY2g9IiIsdCl7Y29uc3QgZT10LnNwbGl0KCItIikscz1lWzBdLnNwbGl0KCIuIik7dGhpcy5tYWpvcj1wYXJzZUludChzWzBdKSx0aGlzLm1pbm9yPXBhcnNlSW50KHNbMV0pLHRoaXMucGF0Y2g9cGFyc2VJbnQoc1syXSksMj09ZS5sZW5ndGgmJih0aGlzLmJyYW5jaD1lWzFdKX1lbHNlIHRoaXMubWFqb3I9MCx0aGlzLm1pbm9yPTAsdGhpcy5wYXRjaD0wfWNvbXBhcmUodCl7Y29uc3QgZT1bdGhpcy5tYWpvcix0aGlzLm1pbm9yLHRoaXMucGF0Y2hdO2ZvcihsZXQgcz0wO3M8MztzKyspaWYoZVtzXSE9PXRbc10pcmV0dXJuIGVbc10tdFtzXTtyZXR1cm4gMH19c2VsZi5vbm1lc3NhZ2U9ZnVuY3Rpb24odCl7KCh0LGUpPT57Zm9yKGNvbnN0IGUgaW4gdC5jb250ZXh0LnZlcnNpb25zKXtjb25zdCBzPXQuY29udGV4dC52ZXJzaW9uc1tlXSxhPW5ldyBUKCIiKTthLm1ham9yPXMubWFqb3IsYS5taW5vcj1zLm1pbm9yLGEucGF0Y2g9cy5wYXRjaCxhLmJyYW5jaD1zLmJyYW5jaCx0LmNvbnRleHQudmVyc2lvbnNbZV09YX1jb25zdCBzPVtdLGE9dC50b2NbdC5nZW9tc1JhbmdlWzBdXSxpPVtdO2ZvcihsZXQgZT10Lmdlb21zUmFuZ2VbMF07ZTx0Lmdlb21zUmFuZ2VbMV07ZSsrKXtjb25zdCByPW5ldyBQKHQuYnVmZmVyU2xpY2UsdC50b2NbZV0tYSx0LmlzTW9iaWxlRGV2aWNlKSxuPXIubG9hZFN0cigpLGg9ci5wb3MoKTtsZXQgbztzd2l0Y2gobil7Y2FzZSJQb2ludHMiOm89bmV3IFM7YnJlYWs7Y2FzZSJMaW5lcyI6bz1uZXcgRTticmVhaztjYXNlIk1lc2giOm89bmV3IE87YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlVuc3VwcG9ydGVkIEdlb20gdHlwZToiK24pfXRyeXtyLnNlZWsoaCksby5yZWFkQmluYXJ5KHIsdC5jb250ZXh0KX1jYXRjaCh0KXtjb25zb2xlLndhcm4oIkVycm9yIGxvYWRpbmc6IitvLm5hbWUrIlxuOiIrdCkscy5wdXNoKHt9KTtjb250aW51ZX1jb25zdCBkPW8uZ2VuQnVmZmVycyh0LmdlbkJ1ZmZlcnNPcHRzKTtkLmluZGljZXMmJmkucHVzaChkLmluZGljZXMuYnVmZmVyKTtmb3IoY29uc3QgdCBpbiBkLmF0dHJCdWZmZXJzKXtjb25zdCBlPWQuYXR0ckJ1ZmZlcnNbdF07aS5wdXNoKGUudmFsdWVzLmJ1ZmZlcil9ZC52ZXJ0ZXhOZWlnaGJvcnMmJmkucHVzaChkLnZlcnRleE5laWdoYm9ycy5idWZmZXIpO2NvbnN0IF89by5nZXRCb3VuZGluZ0JveCgpO2kucHVzaChfLnAwLl9fZGF0YS5idWZmZXIpLGkucHVzaChfLnAxLl9fZGF0YS5idWZmZXIpLHMucHVzaCh7bmFtZTpvLm5hbWUsdHlwZTpuLGdlb21CdWZmZXJzOmQsYmJveDpffSl9ZSh7Z2VvbUxpYnJhcnlJZDp0Lmdlb21MaWJyYXJ5SWQsZ2VvbUZpbGVJRDp0Lmdlb21GaWxlSUQsZ2VvbUluZGV4T2Zmc2V0OnQuZ2VvbUluZGV4T2Zmc2V0LGdlb21zUmFuZ2U6dC5nZW9tc1JhbmdlLGdlb21EYXRhczpzfSxpKX0pKHQuZGF0YSwoKHQsZSk9PntzZWxmLnBvc3RNZXNzYWdlKHQsZSl9KSl9fSgpOwoK",null,!1);class ce extends N{constructor(U,F){super(),this.geomFileID=U,this.geomCount=F}}class me extends N{constructor(U){super(),this.range=U}}const Se=e.hardwareConcurrency-1;let We=0;const Ee=[],pe=[],ue=(U,F)=>{const e=We;if(!Ee[e]){pe[e]=new Map;const U=new Ze;U.onmessage=U=>{const F=U.data;pe[e][F.geomLibraryId](F)},Ee[e]=U}pe[e][U]=e=>{if(F(e))for(let F=0;F<pe.length;F++)pe[F][U]&&(delete pe[F][U],0==Object.keys(pe[F]).length&&(Ee[F].terminate(),Ee[F]=null))};const t=Ee[e];return We=(e+1)%Se,t};class Ne extends k{constructor(){super(),this.listenerIDs={},this.__numGeoms=-1,this.geoms=[],this.basePath="",this.__loadedCount=0,this.__streamInfos={},this.__genBuffersOpts={},this.loadCount=0,this.queue=[],this.on("streamFileParsed",(U=>{if(this.loadCount--,this.loadCount<Se&&this.queue.length){const{geomFileID:U,geomsData:F}=this.queue.pop();this.readBinaryBuffer(U,F.buffer,this.loadContext)}})),this.clear()}clear(){this.__loadedCount=0,this.__numGeoms=-1,this.geoms=[]}isLoaded(){return this.__loadedCount==this.__numGeoms}loadGeomFile(U,F=!1){return F&&nU.incrementWorkload(1),new Promise((F=>{const e=this.basePath+U+".zgeoms";nU.loadFile("archive",e).then((t=>{const Q=t[Object.keys(t)[0]],l=this.on("streamFileParsed",(e=>{e.geomFileID==U&&(nU.incrementWorkDone(1),this.removeListenerById("streamFileParsed",l),F())}));this.loadCount<Se?(this.loadCount++,this.readBinaryBuffer(e,Q.buffer,this.loadContext)):this.queue.splice(0,0,{geomFileID:U,geomsData:Q})}))}))}loadGeomFilesStream(U,F,e){const t=U.numGeomsPerFile.length;nU.incrementWorkload(t),this.__numGeoms=U.numGeoms,this.basePath=F,this.loadContext=e;for(let U=0;U<t;U++)this.loadGeomFile(U,!1)}setGenBufferOption(U,F){this.__genBuffersOpts[U]=F}setNumGeoms(U){this.__numGeoms=U}getNumGeoms(){return this.__numGeoms}getGeom(U){return U>=this.geoms.length?null:this.geoms[U]}readBinaryBuffer(U,F,t){const Q=new BU(F,0,e.isMobileDevice),l=Q.loadUInt32(),n=Q.loadUInt32();if(this.__streamInfos[U]={total:l,done:0},0==l){const F=new ce(U,0);return void this.emit("streamFileParsed",F)}-1==this.__numGeoms&&(this.__numGeoms=l);const a=Q.loadUInt32Array(l),d=Math.max(1,Math.floor(l/Se+1));let i=0;for(;i<l;){const e=a[i];let s,R;i+d>=l?(R=[i,l],s=F.byteLength):(R=[i,i+d],s=a[R[1]]);const B=F.slice(e,s);i+=d,ue(this.getId(),(U=>this.__receiveGeomDatas(U))).postMessage({geomLibraryId:this.getId(),geomFileID:U,toc:a,geomIndexOffset:n,geomsRange:R,isMobileDevice:Q.isMobileDevice,bufferSlice:B,genBuffersOpts:this.__genBuffersOpts,context:{versions:t.versions}},[B])}}__receiveGeomDatas(U){const{geomLibraryId:F,geomFileID:e,geomDatas:t,geomIndexOffset:Q,geomsRange:l}=U;if(F!=this.getId())throw new Error("Receiving workload for a different GeomLibrary");const n=Q+l[0],a=[n,Q+l[1]];for(let U=0;U<t.length;U++){const F=t[U];if(!F.type)continue;let e;switch(F.type){case"Points":e=new RF(F);break;case"Lines":e=new BF(F);break;case"Mesh":case"Plane":case"Sphere":case"Cone":e=new VF(F);break;default:throw new Error("Unsupported Geom type:")}this.geoms[n+U]=e}const d=new me(a);this.emit("rangeLoaded",d);const i=a[1]-a[0],s=this.__streamInfos[e];if(s.done+=i,s.done==s.total){const U=new ce(e,s.done);this.emit("streamFileParsed",U)}return this.__loadedCount+=i,this.__loadedCount==this.__numGeoms&&this.emit("loaded"),this.__loadedCount==this.__numGeoms}toJSON(){return{numGeoms:this.geoms.length}}toString(){return JSON.stringify(this.toJSON(),null,2)}static shutDownWorkers(){Ee.forEach(((U,F)=>{U.terminate()}))}}class ke extends k{constructor(U="MaterialLibrary"){super(),this.__images={},this.__materials={},this.name="",this.__name=U,this.lod=0,e.isMobileDevice&&(this.lod=1),this.clear()}clear(){this.__images={},this.__materials={Default:new qU("Default","SimpleSurfaceShader")}}getPath(){return[this.__name]}resolvePath(U,F=0){return null}getNumMaterials(){return Object.keys(this.__materials).length}getMaterials(){return Object.values(this.__materials)}getMaterialNames(){const U=[];for(const F in this.__materials)U.push(F);return U}hasMaterial(U){return U in this.__materials}addMaterial(U){U.setOwner(this),this.__materials[U.getName()]=U}getMaterial(U,F=!0){const e=this.__materials[U];if(!e&&F)throw new Error("Material:"+U+" not found in library:"+this.getMaterialNames());return e}hasImage(U){return U in this.__images}addImage(U){U.setOwner(this),this.__images[U.getName()]=U}getImage(U,F=!0){const e=this.__images[U];if(!e&&F)throw new Error("Image:"+U+" not found in library:"+this.getImageNames());return e}getImageNames(){const U=[];for(const F in this.__images)U.push(F);return U}load(U){const F=new XMLHttpRequest;F.open("GET",U,!0),F.ontimeout=()=>{throw new Error("The request for "+U+" timed out.")},F.onload=()=>{4===F.readyState&&(200===F.status?this.fromJSON(JSON.parse(F.responseText)):console.warn(F.statusText))},F.send(null)}toJSON(U={}){return{numMaterials:this.getNumMaterials()}}fromJSON(U,F={}){F.lod=this.lod;for(const F in U.textures){const e=new XF(F);e.fromJSON(U.textures[F]),this.__images[F]=e}for(const F in U.materials){const e=new qU(F);e.fromJSON(U.materials[F]),this.addMaterial(e)}}readBinary(U,F={}){this.name=U.loadStr(),F.lod=this.lod,F.materialLibrary=this;const e=U.loadUInt32();for(let t=0;t<e;t++){const e=U.loadStr(),t=n.constructClass(e);t.readBinary(U,F),this.__images[t.getName()]=t}const t=U.loadUInt32();if(t>0){const e=U.loadUInt32Array(t);for(let Q=0;Q<t;Q++){let t;switch(U.loadStr()){case"StandardMaterial":case"TransparentMaterial":case"StandardSurfaceShader":t=n.constructClass("StandardSurfaceMaterial");break;case"SimpleSurfaceShader":case"SimpleSurfaceMaterial":t=n.constructClass("SimpleSurfaceMaterial");break;case"PointsShader":case"PointsMaterial":t=n.constructClass("PointsMaterial");break;case"FatPointsShader":case"FatPointsMaterial":t=n.constructClass("FatPointsMaterial");break;case"LinesShader":case"LinesMaterial":t=n.constructClass("LinesMaterial");break;default:t=new qU("")}U.seek(e[Q]),t.readBinary(U,F),this.addMaterial(t)}}this.emit("loaded")}toString(){return JSON.stringify(this.toJSON(),null,2)}}const be=U=>{switch(U.toLowerCase()){case"millimeters":return.001;case"centimeters":return.01;case"decimeters":return.1;case"meters":return 1;case"kilometers":return 1e3;case"inches":return.0254;case"feet":return.3048;case"miles":return 1609.34}return 1};class Ce extends DU{constructor(U=""){super(U),this.geomLibrary=new Ne,this.materialLibrary=new ke,this.loaded=!1,this.unitsScale=1,this.units="meters"}load(U){return Promise.reject(`This method is not implemented for this Asset Item: ${U}`)}isLoaded(){return this.loaded}getEngineDataVersion(){return this.engineDataVersion}getGeometryLibrary(){return this.geomLibrary}getMaterialLibrary(){return this.materialLibrary}getUnitsConversion(){return this.unitsScale}readBinary(U,F){F.assetItem=this,F.numTreeItems=0,F.units||(F.units="meters"),F.numGeomItems=0,F.versions["zea-engine"]||(F.versions["zea-engine"]=new RU(U.loadStr())),this.engineDataVersion=F.versions["zea-engine"];const e=()=>{this.units=U.loadStr();const e=be(this.units),t=be(F.units);this.unitsScale=e/t,F.units=this.units;const Q=this.localXfoParam,l=Q.value;l.sc.scaleInPlace(this.unitsScale),Q.value=l};let t;F.versions["zea-engine"].compare([0,0,6])>0&&e();const Q={};F.addGeomToLayer=(U,F)=>{if(!Q[F]){t||(t=new DU("Layers"),this.addChild(t,!1));const U=new Je(F);t.addChild(U,!1),Q[F]=U}Q[F].addItem(U)};const l=[];F.resolvePath=(U,F,e)=>{if(!U)throw new Error("Path not specified");try{const e=this.resolvePath(U);F(e)}catch(t){l.push((()=>{try{const e=this.resolvePath(U);F(e)}catch(U){if(!e)throw U;e(U)}}))}},F.addPLCB=U=>l.push(U),this.materialLibrary.readBinary(U,F),super.readBinary(U,F),F.versions["zea-engine"].compare([0,0,5])>=0&&F.versions["zea-engine"].compare([0,0,7])<0&&e();for(const U of l)U();this.loaded=!0}toJSON(U={}){U.makeRelative=U=>{const F=this.getPath(),e=U.slice(0,F.length);for(let t=0;t<e.length-1;t++)if(e[t]!=F[t])return console.warn("Param Path is not relative to the asset. May not be able to be resolved at load time:"+U),U;const t=U.slice(F.length-1);return t[0]=".",t},U.assetItem=this;return super.toJSON(U)}fromJSON(U,F={}){F||(F={}),F.assetItem=this,F.numTreeItems=0,F.numGeomItems=0,null==F.version&&(F.version=0),F.assetItem=this;const e=[];F.resolvePath=(U,F)=>{if(!U)throw new Error("Path not specified");const t=this.resolvePath(U);t?F(t):e.push((()=>{const e=this.resolvePath(U);e?F(e):console.warn("Path unable to be resolved:"+U)}))},F.addPLCB=U=>e.push(U),super.fromJSON(U,F);for(const U of e)U()}clone(U){const F=new Ce;return F.copyFrom(this,U),F}copyFrom(U,F){this.geomLibrary=U.geomLibrary,this.materialLibrary=U.materialLibrary,this.loaded=U.loaded,U.loaded||U.once("loaded",(e=>{const t=U.localXfoParam.value,Q=this.localXfoParam.value;Q.sc=t.sc.clone(),this.localXfoParam.value=Q,U.getChildren().forEach((U=>{U&&U!=Ce&&this.addChild(U.clone(F),!1,!1)})),this.loaded=!0,this.emit("loaded",e)})),super.copyFrom(U,F)}}n.register("AssetItem",Ce);class Te extends k{constructor(U){super(),this.units=U?U.units:"meters",this.assets=U?U.assets:{},this.resources=U?U.resources:{},this.versions={},this.url="",this.folder="",this.sdk="",this.assetItem=null,this.numTreeItems=0,this.numGeomItems=0,this.postLoadCallbacks=[],this.asyncCount=0}incrementAsync(){this.asyncCount++}decrementAsync(){this.asyncCount--,0==this.asyncCount&&this.emit("done")}resolvePath(U,F,e){try{const e=this.assetItem.resolvePath(U);F(e)}catch(t){this.postLoadCallbacks.push((()=>{try{const e=this.assetItem.resolvePath(U);F(e)}catch(U){if(!e)throw new Error(U.message);e(U)}}))}}addPLCB(U){this.postLoadCallbacks.push(U)}}class Ge extends DU{constructor(U,F){super(U),this.imageParam=new NU("Image"),this.pixelsPerMeterParam=new hU("PixelsPerMeter",1e3),this.alphaParam=new hU("Alpha",1),this.colorParam=new SU("Color",new B(1,1,1)),this.alignedToCameraParam=new JU("AlignedToCamera",!1),this.drawOnTopParam=new JU("DrawOnTop",!1),this.fixedSizeOnscreenParam=new JU("FixedSizeOnscreen",!1),this.pivotParam=new ZU("Pivot",new d(.5,0));const e=this.addParameter(this.imageParam);F&&(e.value=F),this.addParameter(this.pixelsPerMeterParam),this.addParameter(this.alphaParam),this.addParameter(this.colorParam),this.addParameter(this.alignedToCameraParam),this.addParameter(this.drawOnTopParam),this.addParameter(this.fixedSizeOnscreenParam),this.addParameter(this.pivotParam)}}n.register("BillboardItem",Ge);class Xe extends DU{constructor(U="Camera"){super(U),this.isOrthographicParam=new hU("isOrthographic",0),this.fovParam=new hU("fov",1),this.nearParam=new hU("near",.1),this.farParam=new hU("far",1e3),this.focalDistanceParam=new hU("focalDistance",5),this.viewHeight=0,this.__orthoIntervalId=-1,this.__focusIntervalId=-1,this.addParameter(this.isOrthographicParam),this.addParameter(this.fovParam),this.addParameter(this.nearParam),this.addParameter(this.farParam),this.addParameter(this.focalDistanceParam);const F=U=>{this.emit("projectionParamChanged",U)};this.isOrthographicParam.on("valueChanged",F),this.fovParam.on("valueChanged",F),this.nearParam.on("valueChanged",F),this.farParam.on("valueChanged",F),this.setPositionAndTarget(new i(3,3,1.75),new i(0,0,1)),this.setLensFocalLength("28mm"),this.adjustNearAndFarPlanesToFocalDist=!0,this.nearDistFactor=.01,this.farDistFactor=100,this.frameOnBoundingSphere=!1}getNear(){return this.nearParam.value}setNear(U){this.nearParam.value=U}getFar(){return this.farParam.value}setFar(U){this.farParam.value=U}getFov(){return this.fovParam.value}setFov(U){this.fovParam.value=U}getFrustumHeight(){return this.viewHeight}setFrustumHeight(U){this.viewHeight=U,this.emit("projectionParamChanged")}setLensFocalLength(U){const F={"10mm":100.4,"11mm":95,"12mm":90,"14mm":81.2,"15mm":77.3,"17mm":70.4,"18mm":67.4,"19mm":64.6,"20mm":61.9,"24mm":53.1,"28mm":46.4,"30mm":43.6,"35mm":37.8,"45mm":29.9,"50mm":27,"55mm":24.6,"60mm":22.6,"70mm":19.5,"75mm":18.2,"80mm":17.1,"85mm":16.1,"90mm":15.2,"100mm":13.7,"105mm":13,"120mm":11.4,"125mm":11,"135mm":10.2,"150mm":9.1,"170mm":8.1,"180mm":7.6,"210mm":6.5,"300mm":4.6,"400mm":3.4,"500mm":2.7,"600mm":2.3,"800mm":1.7};U in F?this.fovParam.value=J.degToRad(F[U]):console.warn("Camera lense focal length not supported:"+U)}getFocalDistance(){return this.focalDistanceParam.value}setFocalDistance(U){U<1e-4&&console.error("Never set focal distance to zero"),this.focalDistanceParam.value=U,this.adjustNearAndFarPlanesToFocalDist&&(this.nearParam.value=U*this.nearDistFactor,this.farParam.value=U*this.farDistFactor)}isOrthographic(){return 1==this.isOrthographicParam.value}setIsOrthographic(U,F=0){if(this.__orthoIntervalId&&clearInterval(this.__orthoIntervalId),U>.5){const U=this.fovParam.value,F=this.focalDistanceParam.value;this.viewHeight=Math.sin(.5*U)*F*2}if(0==F)this.isOrthographicParam.value=U;else{const e=Math.round(F/20);let t=0;const Q=this.isOrthographicParam.value,l=()=>{const F=J.lerp(Q,U,t/e);this.isOrthographicParam.value=F,t++,t<=e?this.__orthoIntervalId=window.setTimeout(l,20):(this.__orthoIntervalId=-1,this.emit("movementFinished"))};l()}}setPositionAndTarget(U,F){this.setFocalDistance(U.distanceTo(F));const e=new c;e.setLookAt(U,F,new i(0,0,1)),this.globalXfoParam.value=e,this.emit("movementFinished")}getTargetPosition(){const U=this.focalDistanceParam.value,F=this.globalXfoParam.value,e=F.ori.getZaxis();return e.scaleInPlace(-U),e.addInPlace(F.tr),e}frameView(U,F){const e=this.focalDistanceParam.value,t=this.fovParam.value,Q=this.globalXfoParam.value.clone(),l=U.getWidth()/U.getHeight(),n=2*Math.atan(Math.tan(.5*t)*l);let a=e;if(this.frameOnBoundingSphere){const U=new W;for(const e of F)U.addBox3(e.boundingBoxParam.value);if(!U.isValid())return void console.warn("Bounding box not valid.");const l=Q.ori.getZaxis().scale(-e),n=Q.tr.add(l),d=U.center().subtract(n);Q.tr.addInPlace(d),a=U.size()/Math.tan(t)}else{const U=[];if(F.forEach((F=>{F.traverse((F=>{if(!(F instanceof DU))return!1;if(F.disableBoundingBox)return!1;if(F instanceof he){const e=F.geomParam.value;if(e){const t=e.getBoundingBox();if(t.isValid()){const e=F.geomMatParam.value;return U.push(e.transformVec3(t.p0)),U.push(e.transformVec3(new i(t.p0.x,t.p0.y,t.p1.z))),U.push(e.transformVec3(new i(t.p0.x,t.p1.y,t.p0.z))),U.push(e.transformVec3(new i(t.p1.x,t.p0.y,t.p0.z))),U.push(e.transformVec3(new i(t.p0.x,t.p1.y,t.p1.z))),U.push(e.transformVec3(new i(t.p1.x,t.p0.y,t.p1.z))),U.push(e.transformVec3(new i(t.p1.x,t.p1.y,t.p0.z))),void U.push(e.transformVec3(t.p1))}}}if(0==F.getNumChildren()){const e=F.boundingBoxParam.value;if(e.isValid())return U.push(new i(e.p0.x,e.p0.y,e.p0.z)),U.push(new i(e.p0.x,e.p0.y,e.p1.z)),U.push(new i(e.p0.x,e.p1.y,e.p0.z)),U.push(new i(e.p1.x,e.p0.y,e.p0.z)),U.push(new i(e.p0.x,e.p1.y,e.p1.z)),U.push(new i(e.p1.x,e.p0.y,e.p1.z)),U.push(new i(e.p1.x,e.p1.y,e.p0.z)),void U.push(new i(e.p1.x,e.p1.y,e.p1.z))}}))})),0==U.length)return;const e=this.isOrthographic()?0:n/2,s=this.isOrthographic()?0:t/2,R={};R.XPos=new i(Math.cos(e),0,Math.sin(e)),R.XNeg=new i(-Math.cos(e),0,Math.sin(e)),R.YPos=new i(0,Math.cos(s),Math.sin(s)),R.YNeg=new i(0,-Math.cos(s),Math.sin(s)),R.ZPos=new i(0,0,1),R.ZNeg=new i(0,0,-1);const B={},V={};for(const U in R)B[U]=Q.ori.rotateVec3(R[U]),V[U]=Number.NEGATIVE_INFINITY;const r=new i;U.forEach(((U,F)=>{if(!Number.isFinite(U.x)||!Number.isFinite(U.y)||!Number.isFinite(U.z))return;const e=U.subtract(Q.tr);for(const U in R){const F=e.dot(B[U]);F>V[U]&&F!=Number.POSITIVE_INFINITY&&(V[U]=F)}r.addInPlace(U)}));for(const U in V)if(V[U]==Number.POSITIVE_INFINITY)return;r.scaleInPlace(1/U.length);let h=0;if(this.isOrthographic()){const U=new i(.5*(-V.XNeg+V.XPos),.5*(-V.YNeg+V.YPos),.5*(-V.ZNeg+V.ZPos)),F=V.ZNeg+V.ZPos;h=2*F,U.z=-V.ZNeg+h,Q.tr.addInPlace(Q.ori.rotateVec3(U)),a=2*F;const e=V.XPos+V.XNeg,t=V.YPos+V.YNeg;this.viewHeight=Math.max(t,e/l);const n=.1;this.viewHeight+=this.viewHeight*n}else{const U=n/2,F=t/2,e=new d(Math.cos(U)*V.XPos,Math.sin(U)*V.XPos),l=e.add(new d(Math.sin(U),-Math.cos(U))),s=new d(-Math.cos(U)*V.XNeg,Math.sin(U)*V.XNeg),R=s.add(new d(-Math.sin(U),-Math.cos(U))),B=d.intersectionOfLines(e,l,s,R),o=new d(Math.cos(F)*V.YPos,Math.sin(F)*V.YPos),J=o.add(new d(Math.sin(F),-Math.cos(F))),Z=new d(-Math.cos(F)*V.YNeg,Math.sin(F)*V.YNeg),c=Z.add(new d(-Math.sin(F),-Math.cos(F))),m=d.intersectionOfLines(o,J,Z,c);if(null===B||null===m)return void console.warn("xP or yP === null");h=Math.max(B.y,m.y);const S=new i(B.x,m.x,h);Q.tr.addInPlace(Q.ori.rotateVec3(S)),a=r.distanceTo(Q.tr);const W=a*.1;Q.tr.addInPlace(Q.ori.rotateVec3(new i(0,0,W))),h+=W}if(this.adjustNearAndFarPlanesToFocalDist){V.ZPos-=h,V.ZNeg+=h;const U=V.ZNeg*this.nearDistFactor,F=-V.ZPos*this.farDistFactor;this.nearParam.value=U,this.farParam.value=F}}this.setFocalDistance(a),this.globalXfoParam.value=Q,this.emit("movementFinished")}updateProjectionMatrix(U,F){const e=this.isOrthographicParam.value,t=this.fovParam.value,Q=this.nearParam.value,l=this.farParam.value,n=new h;if(e>0){const U=.5*this.viewHeight,e=-U,t=U,a=U*-F,d=U*F;n.setOrthographicMatrix(a,d,e,t,Q,l)}e<1&&U.setPerspectiveMatrix(t,F,Q,l),1==e?U.setFromMat4(n):e>0&&U.set(J.lerp(U.m00,n.m00,e),J.lerp(U.m01,n.m01,e),J.lerp(U.m02,n.m02,e),J.lerp(U.m03,n.m03,e),J.lerp(U.m10,n.m10,e),J.lerp(U.m11,n.m11,e),J.lerp(U.m12,n.m12,e),J.lerp(U.m13,n.m13,e),J.lerp(U.m20,n.m20,e),J.lerp(U.m21,n.m21,e),J.lerp(U.m22,n.m22,e),J.lerp(U.m23,n.m23,e),J.lerp(U.m30,n.m30,e),J.lerp(U.m31,n.m31,e),J.lerp(U.m32,n.m32,e),J.lerp(U.m33,n.m33,e))}}n.register("Camera",Xe);class ge extends IU{constructor(U,F){super(),this.bindXfo=new c,this.invBindXfo=new c,this.groupGlobalXfo=new fU("GroupGlobalXfo"),this.groupTransformXfo=new gU("GroupTransformXfo"),this.groupGlobalXfo.setParam(U),this.groupTransformXfo.setParam(F),this.addInput(this.groupGlobalXfo),this.addOutput(this.groupTransformXfo)}setBindXfo(U){this.bindXfo=U,this.invBindXfo=U.inverse(),this.setDirty()}evaluate(){if(this.invBindXfo){const U=this.groupGlobalXfo.getValue();this.groupTransformXfo.setClean(U.multiply(this.invBindXfo))}else this.groupTransformXfo.setClean(new c)}}class ye extends IU{constructor(F,e){super(),this.groupTransformXfo=new fU("GroupTransformXfo"),this.memberGlobalXfo=new gU("MemberGlobalXfo",U.OperatorOutputMode.OP_READ_WRITE),this.groupTransformXfo.setParam(F),this.memberGlobalXfo.setParam(e),this.addInput(this.groupTransformXfo),this.addOutput(this.memberGlobalXfo),this._enabled=!0}disable(){this._enabled=!1,this.setDirty()}enable(){this._enabled=!0,this.setDirty()}evaluate(){const U=this.memberGlobalXfo.getValue();if(this._enabled){const F=this.groupTransformXfo.getValue();this.memberGlobalXfo.setClean(F.multiply(U))}else this.memberGlobalXfo.setClean(U)}}const Ie={disabled:0,manual:1,first:2,average:3,globalOri:4};class xe extends oe{constructor(U=""){super(U),this.initialXfoModeParam=new oU("InitialXfoMode",Ie.average,["manual","first","average","global"]),this.groupTransformParam=new uU("GroupTransform",new c),this.calculatingGroupXfo=!1,this.memberXfoOps=[],this.addParameter(this.initialXfoModeParam),this.initialXfoModeParam.on("valueChanged",(()=>{this.calcGroupXfo()})),this.addParameter(this.groupTransformParam),this.groupTransformOp=new ge(this.globalXfoParam,this.groupTransformParam)}static get INITIAL_XFO_MODES(){return Ie}updateHighlight(){setTimeout((()=>{let U,F=!1;this.isSelected()&&(F=!0,U=this.getHighlight(),U.a=.2);const e="kinematicGroupItemHighlight"+this.getId();Array.from(this.itemsParam.value).forEach((t=>{t instanceof DU&&(F?t.addHighlight(e,U,!0):t.removeHighlight(e,!0))}))}),1)}setSelected(U){super.setSelected(U),this.updateHighlight()}calcGroupXfo(){const U=Array.from(this.itemsParam.value);if(0==U.length)return;this.calculatingGroupXfo=!0,this.memberXfoOps.forEach((U=>U.disable()));const F=this.initialXfoModeParam.value;let e;if(F==Ie.manual)e=this.globalXfoParam.value;else if(F==Ie.first&&U[0]instanceof DU)e=U[0].globalXfoParam.value;else if(F==Ie.average){e=new c,e.ori.set(0,0,0,0);let F=0;U.forEach(((U,t)=>{if(U instanceof DU){const t=U.globalXfoParam.value;e.tr.addInPlace(t.tr),e.ori.addInPlace(t.ori),F++}})),e.tr.scaleInPlace(1/F),e.ori.normalizeInPlace()}else{if(F!=Ie.globalOri)throw new Error("Invalid GROUP_XFO_MODES.");{e=new c;let F=0;U.forEach(((U,t)=>{if(U instanceof DU){const t=U.globalXfoParam.value;e.tr.addInPlace(t.tr),F++}})),e.tr.scaleInPlace(1/F)}}this.globalXfoParam.value=e,this.groupTransformOp.setBindXfo(e),this.memberXfoOps.forEach((U=>U.enable())),this.calculatingGroupXfo=!1}bindItem(U,F){if(super.bindItem(U,F),U instanceof DU){if(this.isSelected()){const F=this.getHighlight();F.a=.2;const e="kinematicGroupItemHighlight"+this.getId();U.addHighlight(e,F,!0)}{const e=U.globalXfoParam,t=new ye(this.groupTransformParam,e);this.memberXfoOps.splice(F,0,t),this.__itemsEventHandlers[F]||(this.__itemsEventHandlers[F]={});this.__itemsEventHandlers[F]["BoundingBox.valueChanged"]=U.boundingBoxParam.on("valueChanged",(U=>{this.setBoundingBoxDirty()}))}}}unbindItem(U,F){if(super.unbindItem(U,F),U instanceof DU){if(this.isSelected()){const F="kinematicGroupItemHighlight"+this.getId();U.removeHighlight(F,!0)}this.memberXfoOps[F].detach(),this.memberXfoOps.splice(F,1),this.setBoundingBoxDirty()}}addItem(U,F=!0){super.addItem(U,F),F&&this.calcGroupXfo()}removeItem(U,F=!0){super.removeItem(U,F),F&&this.calcGroupXfo()}setItems(U){super.setItems(U),this.calcGroupXfo()}clearItems(U=!0){super.clearItems(U),this.memberXfoOps=[],U&&this.calcGroupXfo()}loadDone(){this.calculatingGroupXfo=!0,this.calcGroupXfo(),this.calculatingGroupXfo=!1}clone(U){const F=new xe;return F.copyFrom(this,U),F}}n.register("KinematicGroup",xe);class fe extends oe{constructor(U){super(U),this.materialParam=new $U("Material"),this.__backupMaterials={},this.addParameter(this.materialParam),this.materialParam.on("valueChanged",(()=>{this.__updateMaterial()}))}updateHighlight(){this.__updateHighlightHelper()}__updateHighlightHelper(){let U,F=!1;this.isSelected()&&(U=this.getHighlight(),F=!0,U.a=.2);const e="kinematicGroupItemHighlight"+this.getId();Array.from(this.itemsParam.value).forEach((t=>{t instanceof DU&&(F?t.addHighlight(e,U,!0):t.removeHighlight(e,!0))}))}setSelected(U){super.setSelected(U),this.updateHighlight()}__updateMaterial(){this.__updateMaterialHelper()}__updateMaterialHelper(){const U=this.materialParam.value;Array.from(this.itemsParam.value).forEach((F=>{F.traverse((F=>{if(F instanceof Be){const e=F.materialParam;if(U){const F=e.value;F==U||F&&"LinesShader"==F.getShaderName()||(this.__backupMaterials[e.getId()]=F,e.value=U)}else this.__backupMaterials[e.getId()]&&(e.value=this.__backupMaterials[e.getId()])}}))}))}bindItem(U,F){if(super.bindItem(U,F),!(U instanceof DU))return;if(this.isSelected()){const F=this.getHighlight();F.a=.2;const e="materialGroupItemHighlight"+this.getId();U.addHighlight(e,F,!0)}const e=this.materialParam.value;e&&U.traverse((U=>{if(U instanceof Be){const F=U.materialParam;if(e){const U=F.value;U==e||U&&"LinesShader"==U.getShaderName()||(this.__backupMaterials[F.getId()]=U,F.value=e)}}}),!0)}__unbindItem(U,F){if(super.unbindItem(U,F),U instanceof DU&&this.isSelected()){const F="materialGroupItemHighlight"+this.getId();U.removeHighlight(F,!0)}}clone(U){const F=new fe(this.__name+"clone");return F.copyFrom(this,U),F}}n.register("MaterialGroup",fe);class Me extends IU{constructor(U,F){super(),this.groupGlobalXfo=new fU("GroupGlobalXfo"),this.cuttingPlane=new XU("CuttingPlane"),this.groupGlobalXfo.setParam(U),this.cuttingPlane.setParam(F),this.addInput(this.groupGlobalXfo),this.addOutput(this.cuttingPlane)}evaluate(){const U=this.groupGlobalXfo.getValue(),F=U.ori.getZaxis(),e=U.tr.dot(F);this.cuttingPlane.setClean(new s(F.x,F.y,F.z,-e))}}class ve extends oe{constructor(U=""){super(U),this.cutAwayEnabledParam=new JU("CutAwayEnabled",!1),this.cutPlaneParam=new mU("CutPlane",new s(1,0,0)),this.addParameter(this.cutAwayEnabledParam),this.addParameter(this.cutPlaneParam),this.cutPlaneOp=new Me(this.globalXfoParam,this.cutPlaneParam),this.cutAwayEnabledParam.on("valueChanged",(U=>{this.updateCutaway(U)})),this.cutPlaneParam.on("valueChanged",(U=>{this.updateCutaway(U)}));const F=new qU("plane","FlatSurfaceShader");F.getParameter("BaseColor").value=new B(1,1,1,.2);const e=new he("PlaneGeom",new kF(1,1),F);e.setSelectable(!1),this.addChild(e);const t=new qU("border","LinesShader");t.getParameter("BaseColor").value=new B(1,0,0,1);const Q=new he("BorderGeom",new ZF(1,1),t);Q.setSelectable(!1),this.addChild(Q)}updateCutaway(U){const F=this.cutAwayEnabledParam.value,e=this.cutPlaneParam.value,t=e.xyz,Q=e.w;U instanceof Be?(U.setCutawayEnabled(F),U.setCutVector(t),U.setCutDist(Q)):Array.from(this.itemsParam.value).forEach((U=>{U.traverse((U=>{U instanceof Be&&(U.setCutawayEnabled(F),U.setCutVector(t),U.setCutDist(Q))}),!0)}))}bindItem(U,F){if(!(U instanceof DU))return;this.cutAwayEnabledParam.value&&this.updateCutaway(U);const e=new W;Array.from(this.itemsParam.value).forEach((U=>{U instanceof DU&&e.addBox3(U.boundingBoxParam.value)}));{const U=e.p1.x-e.p0.x,F=e.p1.y-e.p0.y,t=new c;t.sc.set(U,F,1),this.getChild(0).localXfoParam.value=t,this.getChild(1).localXfoParam.value=t}}unbindItem(U,F){U instanceof DU&&U.traverse((U=>{U instanceof Be&&U.setCutawayEnabled(!1)}),!0)}clone(U){const F=new ve;return F.copyFrom(this,U),F}}n.register("CuttingPlane",ve);class De extends DU{constructor(U=5,F=50,e=new B("#DCDCDC")){super("GridTree"),this.disableBoundingBox=!0,this.setSelectable(!1);const t=new qU("gridMaterial","LinesShader");t.getParameter("BaseColor").value=e,t.getParameter("Overlay").value=0,t.getParameter("StippleValue").value=0,t.getParameter("OccludedStippleValue").value=1;const Q=new WF(U,U,F,F,!0),l=new he("GridItem",Q,t);l.setSelectable(!1),this.addChild(l,!1);const n=new dF;n.setNumVertices(2),n.setNumSegments(1),n.setSegmentVertexIndices(0,0,1);const a=n.getVertexAttribute("positions");a.getValueRef(0).set(-.5*U,0,0),a.getValueRef(1).set(.5*U,0,0);const d=new qU("gridXAxisMaterial","LinesShader");d.getParameter("BaseColor").value=new B(e.luminance(),0,0),d.getParameter("Overlay").value=0,d.getParameter("StippleValue").value=0,d.getParameter("OccludedStippleValue").value=1;const s=new he("xAxisLine",n,d);s.setSelectable(!1),this.addChild(s,!1);const R=new qU("gridYAxisMaterial","LinesShader");R.getParameter("BaseColor").value=new B(0,e.luminance(),0),R.getParameter("Overlay").value=0,R.getParameter("StippleValue").value=0,R.getParameter("OccludedStippleValue").value=1,R.setSelectable(!1);const V=new he("yAxisLine",n,R);V.setSelectable(!1);const r=new c;r.ori.setFromAxisAndAngle(new i(0,0,1),.5*Math.PI),V.geomOffsetXfoParam.value=r,this.addChild(V,!1);const h=this._cleanBoundingBox(this.boundingBoxParam.value);this.boundingBoxParam.value=h}_cleanBoundingBox(U){return U.reset(),U}}n.register("GridTreeItem",De);const Le=new B("#DCDCDC");class Ye extends Ce{constructor(U){super(U),this.geomLibrary.on("loaded",(()=>{this.emit("geomsLoaded")}))}readBinary(U,F){F.versions["zea-engine"]||(F.versions["zea-mesh"]=new RU(U.loadStr()));const e=U.loadUInt32();return super.readBinary(U,F),F.versions["zea-engine"].compare([2,1,0])<0&&U.loadFloat32Vec2(),this.geomLibrary.setNumGeoms(U.loadUInt32()),e}load(U,F=new Te){return new Promise(((t,Q)=>{const l=U.lastIndexOf("/")>-1?U.substring(0,U.lastIndexOf("/"))+"/":"",n=U.lastIndexOf("/")>-1?U.substring(U.lastIndexOf("/")+1):"",a=n.substring(0,n.lastIndexOf("."));let d=0;F.assetItem=this,F.url=U,F.folder=l,nU.incrementWorkload(1),this.geomLibrary.on("loaded",(()=>{nU.incrementWorkDone(1)})),nU.loadFile("archive",U).then((U=>{let Q;if(U.tree2)Q=new BU(U.tree2.buffer,0,e.isMobileDevice);else{const t=U.tree?U.tree:U[Object.keys(U)[0]];Q=new BU(t.buffer,0,e.isMobileDevice),F.versions["zea-engine"]=new RU}if(d=this.readBinary(Q,F),this.loaded=!0,this.emit("loaded"),0==d&&U.geoms)this.geomLibrary.readBinaryBuffer(n,U.geoms.buffer,F);else{const U=l+a,e={numGeomsPerFile:d,numGeoms:this.geomLibrary.getNumGeoms()};this.geomLibrary.loadGeomFilesStream(e,U,F)}t()}),(U=>{this.emit("error",U),Q(U)}))}))}}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
function _e(U,F,e,t){return new(e||(e=Promise))((function(Q,l){function n(U){try{d(t.next(U))}catch(U){l(U)}}function a(U){try{d(t.throw(U))}catch(U){l(U)}}function d(U){var F;U.done?Q(U.value):(F=U.value,F instanceof e?F:new e((function(U){U(F)}))).then(n,a)}d((t=t.apply(U,F||[])).next())}))}n.register("VLAAsset",Ye);class we extends K{constructor(){super(),this.__activated=!1}activateTool(){if(this.__activated)throw new Error("Tool already activate");this.__activated=!0,this.emit("activatedChanged",{activated:this.__activated})}deactivateTool(){this.__activated=!1,this.emit("activatedChanged",{activated:this.__activated})}onPointerDown(U){}onPointerMove(U){}onPointerUp(U){}onPointerDoublePress(U){}onPointerEnter(U){}onPointerLeave(U){}onWheel(U){}onKeyDown(U){}onKeyUp(U){}onTouchCancel(U){}}const ze={OPAQUE:1,TRANSPARENT:2,OVERLAY:4};class Ke extends K{constructor(){super(),this.enabled=!0,this.passIndex=-1,this.__gl=null,this.renderer=null,this.__renderer=null,this.enabledParam=new JU("Enabled",!0),this.enabled=!0,this.passIndex=0,this.addParameter(this.enabledParam),this.enabledParam.on("valueChanged",(()=>this.enabled=this.enabledParam.value))}parameterValueChanged(U){super.parameterValueChanged(U),this.renderer&&this.renderer.requestRedraw()}init(U,F){if(null==F)throw new Error("Missing constructor argument.");this.__gl=U.gl,this.renderer=U,this.__renderer=U,this.passIndex=F}setPassIndex(U){this.passIndex=U}getPassType(){return ze.OPAQUE}itemAddedToScene(U,F){throw Error(`${this.constructor.name} must implement itemAddedToScene and itemRemovedFromScene`)}itemRemovedFromScene(U,F){throw Error(`${this.constructor.name} must implement itemAddedToScene and itemRemovedFromScene`)}startPresenting(){}stopPresenting(){}draw(U){throw Error("draw not implemented on GLPass")}drawHighlightedGeoms(U){}drawGeomData(U){}getGeomItemAndDist(U){throw Error("getGeomItemAndDist not implemented on GLPass")}}const He={pan:0,dolly:1,focussing:2,look:3,turntable:4,tumbler:5,trackball:6};class Pe extends we{constructor(U){super(),this.__mouseWheelMovementDist=0,this.__mouseWheelZoomCount=0,this.__mouseWheelZoomId=-1,this.orbitRateParam=new hU("OrbitRate",e.isMobileDevice?.5:1),this.dollySpeedParam=new hU("DollySpeed",.02),this.mouseWheelDollySpeedParam=new hU("MouseWheelDollySpeed",.1),this.orbitAroundCursor=new JU("OrbitAroundCursor",!0),this.walkSpeedParam=new hU("WalkSpeed",5),this.walkModeCollisionDetection=new JU("WalkModeCollisionDetection",!1),this.appData=U,this.__defaultManipulationState=He.turntable,this.__manipulationState=this.__defaultManipulationState,this.__pointerDown=!1,this.__dragging=0,this.aimFocusOnTouchTap=1,this.aimFocusOnMouseClick=2,this.enabledWASDWalkMode=!1,this.__keyboardMovement=!1,this.__keysPressed=[],this.__velocity=new i,this.__prevVelocityIntegrationTime=-1,this.__ongoingTouches={},this.addParameter(this.orbitRateParam),this.addParameter(this.dollySpeedParam),this.addParameter(this.mouseWheelDollySpeedParam),this.addParameter(this.orbitAroundCursor),this.addParameter(this.walkSpeedParam),this.addParameter(this.walkModeCollisionDetection)}activateTool(){super.activateTool(),this.appData&&this.appData.renderer&&(this.prevCursor=this.appData.renderer.getGLCanvas().style.cursor,this.appData.renderer.getGLCanvas().style.cursor="cursor")}deactivateTool(){super.deactivateTool(),this.appData&&this.appData.renderer&&(this.appData.renderer.getGLCanvas().style.cursor=this.appData.renderer.getGLCanvas().style.cursor)}setDefaultManipulationMode(U){if(this.__defaultManipulationState="string"==typeof U?He[U]:U,!Object.values(He).includes(this.__defaultManipulationState))throw new Error("Invalid Camera Manipulation Mode. Must be one of "+Object.keys(He))}look(U,F){const{viewport:e}=U,t=e.getCamera(),Q=this.orbitRateParam.value,l=t.globalXfoParam.value,n=new o;n.rotateZ(F.x/e.getWidth()*Math.PI*Q),l.ori=n.multiply(l.ori);const a=new o;a.rotateX(F.y/e.getHeight()*Math.PI*Q),l.ori.multiplyInPlace(a),t.globalXfoParam.value=l}turntable(U,F){const{viewport:e}=U,t=e.getCamera(),Q=this.orbitRateParam.value,l=t.globalXfoParam.value,n=l.ori.inverse().rotateVec3(l.tr.subtract(this.__orbitTarget)),a=new o;a.rotateZ(F.x/e.getWidth()*2*Math.PI*-Q),l.ori=a.multiply(l.ori);const d=new o;d.rotateX(F.y/e.getHeight()*Math.PI*-Q),l.ori.multiplyInPlace(d),l.tr=this.__orbitTarget.add(l.ori.rotateVec3(n)),t.globalXfoParam.value=l}tumbler(U,F){const{viewport:e}=U,t=e.getCamera(),Q=this.orbitRateParam.value,l=t.globalXfoParam.value,n=l.ori.getXaxis(),a=l.ori.getYaxis(),d=l.ori.getZaxis(),i=n.scale(-F.x).add(a.scale(F.y)).cross(d);i.normalizeInPlace();const s=F.length(),R=l.ori.inverse().rotateVec3(l.tr.subtract(this.__orbitTarget)),B=new o;B.setFromAxisAndAngle(i,s/e.getWidth()*Math.PI*-Q),l.ori=B.multiply(l.ori),l.tr=this.__orbitTarget.add(l.ori.rotateVec3(R)),t.globalXfoParam.value=l}trackball(U,F){const{viewport:e}=U,t=e.getCamera(),Q=this.orbitRateParam.value,l=t.globalXfoParam.value,n=l.ori.getXaxis(),a=l.ori.getYaxis(),d=l.ori.getZaxis(),i=n.scale(-F.x).add(a.scale(F.y)).cross(d);i.normalizeInPlace();const s=F.length(),R=l.ori.inverse().rotateVec3(l.tr.subtract(this.__orbitTarget)),B=new o;B.setFromAxisAndAngle(i,s/e.getWidth()*Math.PI*-Q),l.ori=B.multiply(l.ori),l.tr=this.__orbitTarget.add(l.ori.rotateVec3(R)),t.globalXfoParam.value=l}pan(U,F){const{viewport:e}=U,t=e.getCamera(),Q=new c,l=new i(1,0,0),n=new i(0,1,0);if(t.isOrthographic()){const U=t.getFrustumHeight(),a=U*(e.getWidth()/e.getHeight());Q.tr=l.scale(-F.x/e.getWidth()*a),Q.tr.addInPlace(n.scale(F.y/e.getHeight()*U))}else{const U=t.getFocalDistance(),a=t.getFov(),d=2*U*Math.tan(.5*a),i=d*(e.getWidth()/e.getHeight());Q.tr=l.scale(-F.x/e.getWidth()*i),Q.tr.addInPlace(n.scale(F.y/e.getHeight()*d))}const a=t.globalXfoParam.value;t.globalXfoParam.value=a.multiply(Q)}dolly(U,F){const{viewport:e}=U,t=e.getCamera(),Q=t.getFocalDistance(),l=()=>{const U=F.y*this.dollySpeedParam.value*Q,e=new c;e.tr.set(0,0,U);const l=t.globalXfoParam.value;t.globalXfoParam.value=l.multiply(e)},n=()=>{const U=F.y*this.dollySpeedParam.value,e=t.getFrustumHeight(),Q=e*U;t.setFrustumHeight(e+Q)};t.isOrthographic()?n():l()}initDrag(U){const{pointerPos:F}=U;U.setCapture(this),this.__pointerDown=!0;const{viewport:e}=U,t=e.getCamera(),Q=t.globalXfoParam.value,l=this.orbitAroundCursor.value;if(null!=U.intersectionData&&l){this.__orbitTarget=U.intersectionData.intersectionPos;const F=Q.inverse().transformVec3(U.intersectionData.intersectionPos);t.setFocalDistance(-F.z)}else this.__orbitTarget=Q.tr.add(Q.ori.getZaxis().scale(-t.getFocalDistance()));this.__prevPointerPos=F,this.__dragging=1}endDrag(U){U.getCapture()==this&&U.releaseCapture(),this.__dragging=0,this.__pointerDown=!1}aimFocus(U,F,e=-1,t=400){this.__focusIntervalId&&clearInterval(this.__focusIntervalId);const Q=Math.round(t/20),l=this.__manipulationState;let n=0;const a=()=>{const t=U.globalXfoParam.value,d=U.getFocalDistance(),i=F.subtract(t.tr),s=i.normalizeInPlace(),R=t.clone();if(l==He.turntable||l==He.look){{const U=t.ori.getZaxis().clone();U.z=0;const F=i.negate();F.z=0;const e=new o;e.setFrom2Vectors(U,F),R.ori=e.multiply(R.ori)}{const U=t.ori.getXaxis().clone(),F=t.ori.getZaxis().clone(),e=i.negate();e.subtractInPlace(U.scale(e.dot(U))),e.normalizeInPlace();const Q=new o;F.cross(e).dot(U)>0?Q.rotateX(F.angleTo(e)):Q.rotateX(-F.angleTo(e)),R.ori=R.ori.multiply(Q)}{const U=R.ori.getXaxis().clone(),F=U.clone();F.z=0,F.normalizeInPlace();const e=new o;e.setFrom2Vectors(U,F),R.ori=e.multiply(R.ori)}}else{const U=t.ori.getZaxis().clone(),F=i.negate(),e=new o;e.setFrom2Vectors(U,F),R.ori=e.multiply(R.ori)}const B=Math.pow(n/Q,2),V=t.clone();if(V.ori=t.ori.lerp(R.ori,B),e>0){const U=i.scale(s-e);V.tr.addInPlace(U.scale(B))}U.setFocalDistance(d+(s-d)*B),U.globalXfoParam.value=V,n++,n<=Q?this.__focusIntervalId=setTimeout(a,20):(this.__focusIntervalId=void 0,this.emit("movementFinished"),U.emit("movementFinished"))};a()}orientPointOfView(U,F,e,t=0,Q=400){this.__focusIntervalId&&clearInterval(this.__focusIntervalId);const l=Math.round(Q/20);let n=0;const a=()=>{const Q=U.globalXfoParam.value,d=U.getTargetPosition(),i=Math.pow(n/l,2),s=F.subtract(Q.tr),R=s.normalizeInPlace(),B=s.scale(R-t),V=Q.tr.add(B.scale(i)),r=d.lerp(e,i);U.setPositionAndTarget(V,r),n++,n<=l?this.__focusIntervalId=setTimeout(a,20):(this.__focusIntervalId=void 0,this.emit("movementFinished"),U.emit("movementFinished"))};a()}onPointerDoublePress(U){const F=F=>{const e=U.viewport.getCamera(),t=e.globalXfoParam.value.tr.add(F.dir.scale(U.intersectionData.dist));this.aimFocus(e,t),U.aimTarget=t,U.aimDistance=U.intersectionData.dist,this.emit("aimingFocus",U),e.emit("aimingFocus",U),U.stopPropagation()};if(U.intersectionData&&this.aimFocusOnMouseClick){if(U.pointerType===X.mouse&&2==this.aimFocusOnMouseClick){const e=U;F(e.pointerRay),e.preventDefault()}if(U.pointerType===X.touch&&2==this.aimFocusOnTouchTap){F(U.pointerRay)}}}onPointerDown(U){if(U.pointerType===X.mouse){1==this.__dragging&&this.endDrag(U),this.initDrag(U);const F=U;2==F.button?this.__manipulationState=He.pan:F.ctrlKey&&F.altKey?this.__manipulationState=He.dolly:F.ctrlKey||2==F.button?this.__manipulationState=He.look:this.__manipulationState=this.__defaultManipulationState,F.preventDefault()}else U.pointerType===X.touch&&this._onTouchStart(U);U.stopPropagation()}onPointerMove(U){0!=this.__dragging&&(U.pointerType===X.mouse&&this._onMouseMove(U),U.pointerType===X.touch&&this._onTouchMove(U),this.__dragging=2,U.stopPropagation())}_onMouseMove(U){if(!this.__pointerDown)return;const F=U.pointerPos,e=F.subtract(this.__prevPointerPos);switch(this.__manipulationState){case He.turntable:this.turntable(U,e);break;case He.tumbler:this.tumbler(U,e);break;case He.trackball:this.trackball(U,e);break;case He.look:this.look(U,e);break;case He.pan:this.pan(U,F.subtract(this.__prevPointerPos));break;case He.dolly:this.dolly(U,e)}this.__prevPointerPos=F,U.preventDefault()}_onTouchMove(U){const F=U.touches;if(1==F.length){const e=F[0],t=new d(e.clientX,e.clientY),Q=this.__ongoingTouches[e.identifier];if(!Q)return;const l=t.subtract(Q.pos);switch(this.__defaultManipulationState){case He.look:l.scaleInPlace(6),this.look(U,l);break;case He.turntable:this.turntable(U,l);break;case He.tumbler:this.tumbler(U,l);break;case He.trackball:this.trackball(U,l)}Q.pos=t}else if(2==F.length){const e=F[0],t=this.__ongoingTouches[e.identifier],Q=F[1],l=this.__ongoingTouches[Q.identifier];if(!t||!l)return;const n=new d(e.clientX,e.clientY),a=new d(Q.clientX,Q.clientY),s=l.pos.subtract(t.pos).length()-a.subtract(n).length(),R=n.subtract(t.pos),B=a.subtract(l.pos),V=R.add(B);V.scaleInPlace(.5);const r=.002*s,{viewport:h}=U,J=h.getCamera(),Z=J.getFocalDistance(),m=J.getFov(),S=new i(1,0,0),W=new i(0,1,0),E=2*Z*Math.tan(.5*m),p=E*(h.getWidth()/h.getHeight()),u=new c;u.tr=S.scale(-V.x/h.getWidth()*p),u.tr.addInPlace(W.scale(V.y/h.getHeight()*E));const N=r*Z;switch(J.setFocalDistance(Z+N),u.tr.z+=N,this.__defaultManipulationState){case He.tumbler:case He.trackball:const U=l.pos.subtract(t.pos),F=a.subtract(n);let e=U.normalize().angleTo(F.normalize());U.cross(F)<0&&(e=-e);const Q=new o;Q.rotateZ(e),u.ori.multiplyInPlace(Q)}const k=J.globalXfoParam.value;J.globalXfoParam.value=k.multiply(u),t.pos=n,l.pos=a}}onPointerUp(U){if(1==this.__dragging){if(this.endDrag(U),U.intersectionData&&(U.pointerType===X.mouse&&1==this.aimFocusOnMouseClick||U.pointerType===X.touch&&1==this.aimFocusOnTouchTap)){const F=U.viewport.getCamera(),e=F.globalXfoParam.value,t=(U.pointerType,U.pointerRay),Q=e.tr.add(t.dir.scale(U.intersectionData.dist));this.aimFocus(F,Q),U.aimTarget=Q,U.aimDistance=U.intersectionData.dist,this.emit("aimingFocus",U),F.emit("aimingFocus",U),U.stopPropagation(),U.pointerType===X.mouse&&U.preventDefault()}}else if(2==this.__dragging){if(U.pointerType===X.mouse){this.endDrag(U),this.emit("movementFinished");U.viewport.getCamera().emit("movementFinished")}else if(U.pointerType===X.touch){const F=U,{changedTouches:e,touches:t}=F;for(let U=0;U<e.length;U++)this.__endTouch(e[U]);0==Object.keys(this.__ongoingTouches).length?this.endDrag(U):t.length||(this.endDrag(U),this.__ongoingTouches={}),F.preventDefault()}U.stopPropagation()}}onPointerEnter(U){}onPointerLeave(U){this.__keysPressed.length>0&&(this.__keysPressed=[],this.__velocity.set(0,0,0),this.__keyboardMovement=!1)}onWheel(U){const F=U.viewport.getCamera(),e=this.mouseWheelDollySpeedParam.value,t=U.shiftKey?.1:.5,Q=F.globalXfoParam.value;let l;if(!F.isOrthographic())if(null!=U.intersectionData){l=Q.tr.subtract(U.intersectionData.intersectionPos),l.normalizeInPlace();const e=Q.inverse().transformVec3(U.intersectionData.intersectionPos);F.setFocalDistance(-e.z)}else l=Q.ori.getZaxis();const n=U.deltaY<0?-1:1,a=()=>{const U=F.getFocalDistance(),e=U*this.__mouseWheelMovementDist;Q.tr.addInPlace(l.scale(e)),F.setFocalDistance(U+e),F.globalXfoParam.value=Q,this.__mouseWheelZoomCount++,this.__mouseWheelZoomCount<6?this.__mouseWheelZoomId=window.setTimeout(a,10):(this.__mouseWheelZoomId=-1,this.emit("movementFinished"),F.emit("movementFinished"))},d=()=>{const e=F.getFrustumHeight(),t=e*this.__mouseWheelMovementDist;if(F.setFrustumHeight(e+t),U.intersectionData){const l=Q.tr.subtract(U.intersectionData.intersectionPos),n=Q.ori.getZaxis();l.subtractInPlace(n.scale(l.dot(n))),Q.tr.addInPlace(l.scale(t/(e+t))),F.globalXfoParam.value=Q}this.__mouseWheelZoomCount++,this.__mouseWheelZoomCount<6?this.__mouseWheelZoomId=window.setTimeout(d,10):(this.__mouseWheelZoomId=-1,this.emit("movementFinished"),F.emit("movementFinished"))};this.__mouseWheelZoomId>0?(this.__mouseWheelMovementDist+=n*e*t*.5/6,this.__mouseWheelZoomCount=0):(this.__mouseWheelMovementDist=n*e*t/6,this.__mouseWheelZoomCount=0,F.isOrthographic()?d():a()),U.preventDefault(),U.stopPropagation()}integrateVelocityChange(U){const{viewport:F}=U,e=F.getCamera(),t=performance.now();if(this.__prevVelocityIntegrationTime>0){const U=(t-this.__prevVelocityIntegrationTime)/1e3,Q=this.walkSpeedParam.value;if(Q>0){const t=new c;t.tr=this.__velocity.normalize().scale(Q*U);const l=e.globalXfoParam.value.multiply(t);if(this.walkModeCollisionDetection.value){const U=1.5,e=1.5,t=.5,Q=new c(l.tr),n=new Z(l.tr,new i(0,0,-1)),a=F.getRenderer().raycastCluster(Q,n,e,t,ze.OPAQUE);if(a.length>0){let F=0;a.forEach((U=>{F+=U.dist})),F/=a.length,l.tr=n.start.add(n.dir.scale(F-U))}}e.globalXfoParam.value=l}}this.__prevVelocityIntegrationTime=t}onKeyDown(U){if(!this.enabledWASDWalkMode)return;const F=U.key.toLowerCase();if(!this.__keysPressed.includes(F)){switch(F){case"w":this.__velocity.z-=1;break;case"s":this.__velocity.z+=1;break;case"a":this.__velocity.x-=1;break;case"d":this.__velocity.x+=1;break;default:return}if(U.stopPropagation(),this.__keysPressed.push(F),!this.__keyboardMovement){this.__keyboardMovement=!0,this.__prevVelocityIntegrationTime=performance.now();const F=()=>{this.integrateVelocityChange(U),this.__keyboardMovement&&window.requestAnimationFrame(F)};window.requestAnimationFrame(F)}}}onKeyUp(U){const F=U.key.toLowerCase();if(!this.__keysPressed.includes(F))return;switch(F){case"w":this.__velocity.z+=1;break;case"s":this.__velocity.z-=1;break;case"a":this.__velocity.x+=1;break;case"d":this.__velocity.x-=1;break;default:return}U.stopPropagation();const e=this.__keysPressed.indexOf(F);this.__keysPressed.splice(e,1),0==this.__keysPressed.length&&(this.__keyboardMovement=!1)}__startTouch(U){this.__ongoingTouches[U.identifier]={identifier:U.identifier,pos:new d(U.clientX,U.clientY)}}__endTouch(U){delete this.__ongoingTouches[U.identifier]}_onTouchStart(U){const F=U.changedTouches;for(let U=0;U<F.length;U++)this.__startTouch(F[U]);this.initDrag(U)}onTouchEnd(U){U.preventDefault(),U.stopPropagation();const F=U.changedTouches;for(let U=0;U<F.length;U++)this.__endTouch(F[U]);0==Object.keys(this.__ongoingTouches).length&&this.endDrag(U)}onTouchCancel(U){U.preventDefault();const F=U.touches;for(let U=0;U<F.length;U++)this.__endTouch(F[U]);0==Object.keys(this.__ongoingTouches).length&&this.endDrag(U)}static get MANIPULATION_MODES(){return He}}const Oe=function(U,F){let e=null;if(null!=F.webglContextType)try{e=U.getContext(F.webglContextType,F),e.name=F.webglContextType}catch(U){}else{const t=["webgl2","webgl"];for(let Q=0;Q<t.length;Q++){const l=t[Q];try{e=U.getContext(l,F),e.name=l}catch(U){}if(e)break}}if(!e)throw new Error("WebGL not supported on your system");return e.sizeInBytes=function(U){switch(U){case this.BYTE:case this.UNSIGNED_BYTE:return 1;case this.SHORT:case this.UNSIGNED_SHORT:return 2;case this.INT:case this.UNSIGNED_INT:case this.FLOAT:return 4;default:throw new Error("unknown type")}},"webgl2"==e.name?(e.floatTexturesSupported=!0,e.__ext_float_linear=e.getExtension("OES_texture_float_linear"),e.__ext_texture_half_float_linear=e.getExtension("OES_texture_half_float_linear"),e.__ext_color_buffer_float=e.getExtension("EXT_color_buffer_float")):(e.__ext_float=e.getExtension("OES_texture_float"),e.__ext_float?(e.floatTexturesSupported=!0,e.__ext_float_linear=e.getExtension("OES_texture_float_linear")):console.warn("OES_texture_float is not available"),e.__ext_half_float=e.getExtension("OES_texture_half_float"),e.__ext_half_float&&(e.HALF_FLOAT=e.__ext_half_float.HALF_FLOAT_OES,e.floatTexturesSupported=!0,e.__ext_texture_half_float_linear=e.getExtension("OES_texture_half_float_linear")),e.__ext_color_buffer_float=e.getExtension("EXT_color_buffer_float"),e.__ext_std_derivatives=e.getExtension("OES_standard_derivatives"),e.__ext_Inst=e.getExtension("ANGLE_instanced_arrays"),e.__ext_Inst&&(e.vertexAttribDivisor=e.__ext_Inst.vertexAttribDivisorANGLE.bind(e.__ext_Inst),e.drawArraysInstanced=e.__ext_Inst.drawArraysInstancedANGLE.bind(e.__ext_Inst),e.drawElementsInstanced=e.__ext_Inst.drawElementsInstancedANGLE.bind(e.__ext_Inst)),e.__ext_VAO=e.getExtension("OES_vertex_array_object"),e.__ext_VAO&&(e.createVertexArray=e.__ext_VAO.createVertexArrayOES.bind(e.__ext_VAO),e.deleteVertexArray=e.__ext_VAO.deleteVertexArrayOES.bind(e.__ext_VAO),e.bindVertexArray=e.__ext_VAO.bindVertexArrayOES.bind(e.__ext_VAO)),e.__ext_element_index_uint=e.getExtension("OES_element_index_uint"),e.__ext_WEBGL_depth_texture=e.getExtension("WEBGL_depth_texture"),e.__ext_WEBGL_depth_texture&&(e.UNSIGNED_INT_24_8=e.__ext_WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL),e.DRAW_FRAMEBUFFER=e.FRAMEBUFFER),e.__ext_frag_depth=e.getExtension("EXT_frag_depth"),e.setupInstancedQuad=function(){const U=new Float32Array([0,1,2,3]),F=new Uint16Array([0,1,2,2,1,3]);this.__quadVertexIdsBuffer=this.createBuffer(),this.bindBuffer(this.ARRAY_BUFFER,this.__quadVertexIdsBuffer),this.bufferData(this.ARRAY_BUFFER,U,this.STATIC_DRAW),this.__quadIndexBuffer=this.createBuffer(),this.bindBuffer(this.ELEMENT_ARRAY_BUFFER,this.__quadIndexBuffer),this.bufferData(this.ELEMENT_ARRAY_BUFFER,F,this.STATIC_DRAW),this.__quadattrbuffers={vertexIDs:{buffer:this.__quadVertexIdsBuffer,dataType:"Float32",dimension:1,count:U.length,shared:!0}}},e.drawQuad=function(){this.drawElements(this.TRIANGLES,6,this.UNSIGNED_SHORT,0)},e},je=function(U,F){if(!F.width||!F.height){if(!F.width)throw new Error("Invalid texture params. 'width' not provided");if(!F.height)throw new Error("Invalid texture params. 'height' not provided")}const e=U.getParameter(U.MAX_TEXTURE_SIZE);if(F.width<=0||F.width>e||F.height<=0||F.height>e)throw new Error("GLTextureParams: Invalid texture size. width:"+F.width+" height:"+F.height+" maxSize:"+e);const t={width:F.width,height:F.height},Q=F=>isNaN(F)?U[F]:F,l=(U,e)=>{U in F?t[U]=Q(F[U]):e&&(t[U]=Q(e))};if(l("format"),l("internalFormat",t.format),l("type",U.UNSIGNED_BYTE),l("minFilter",F.filter?F.filter:U.LINEAR),l("magFilter",F.filter?F.filter:U.LINEAR),l("wrapS",F.wrap?F.wrap:U.CLAMP_TO_EDGE),l("wrapT",F.wrap?F.wrap:U.CLAMP_TO_EDGE),l("flipY",!1),l("mipMapped",!1),l("depthInternalFormat"),l("depthFormat"),l("depthType"),t.format==U.FLOAT)if("webgl2"==U.name)t.filter!=U.LINEAR||U.__ext_float_linear||(console.warn("Floating point texture filtering not supported on result device"),t.filter=U.NEAREST);else if(U.__ext_float)t.filter!=U.LINEAR||U.__ext_float_linear||(console.warn("Floating point texture filtering not supported on result device"),t.filter=U.NEAREST);else{if(!U.__ext_half_float)throw new Error("OES_texture_half_float is not available");t.format=U.HALF_FLOAT,t.filter!=U.LINEAR||U.__ext_texture_half_float_linear||(console.warn("Half Float texture filtering not supported on result device"),t.filter=U.NEAREST)}else if(t.format==U.HALF_FLOAT)if("webgl2"==U.name);else{if(!U.__ext_half_float)throw new Error("OES_texture_half_float is not available");if(t.filter!=U.LINEAR||U.__ext_texture_half_float_linear||(console.warn("Half Float texture filtering not supported on result device"),t.filter=U.NEAREST),t.channels==U.RGB)throw new Error("OES_texture_half_float onlysupports RGBA textures")}else if("sRGB"==t.format&&!U.__ext_sRGB)throw new Error("EXT_sRGB is not available");return null!=t.format&&"webgl2"==U.name&&t.internalFormat==t.format&&(t.type==U.FLOAT?t.format==U.RED?t.internalFormat=U.R32F:t.format==U.RG?t.internalFormat=U.RG32F:t.format==U.RGB?t.internalFormat=U.RGB32F:t.format==U.RGBA&&(t.internalFormat=U.RGBA32F):t.type==U.HALF_FLOAT?t.format==U.RED?t.internalFormat=U.R16F:t.format==U.RGB?t.internalFormat=U.RGB16F:t.format==U.RGBA&&(t.internalFormat=U.RGBA16F):t.type==U.UNSIGNED_BYTE&&(t.format==U.RED&&(t.internalFormat=U.R8),t.format==U.RGB?t.internalFormat=U.RGB8:t.format==U.RGBA&&(t.internalFormat=U.RGBA8))),null!=t.depthFormat&&("webgl2"==U.name?t.depthType==U.UNSIGNED_SHORT?t.depthInternalFormat=U.DEPTH_COMPONENT16:t.depthType==U.UNSIGNED_INT&&(t.depthInternalFormat=U.UNSIGNED_INT):t.depthInternalFormat=t.depthFormat),t};class Ae extends _{constructor(U,F){if(super(),this.__image=null,this.__internalFormat=0,this.__type=0,this.__format=0,this.__wrapParam=0,this.params={},this.__minFilter=0,this.__magFilter=0,this.__wrapS=0,this.__wrapT=0,this.__flipY=!1,this.__mipMapped=!1,this.invert=!1,this.alphaFromLuminance=!1,this.__gltex=null,this.__typeParam="",this.__formatParam="",this.__gl=U,this.ready=!1,this.width=0,this.height=0,this.textureType=1,this.textureDesc=[0,0,0,0],this.__loaded=!1,this.__bound=!1,null!=F)if(F instanceof KU){this.__image=F,this.__image.setMetadata("gltexture",this);const U=()=>{const U=this.__image.getParams(),F=U.width,e=U.height,t=U.data;this.bufferData(t,F,e)};this.__image.on("updated",U),this.__image.isLoaded()?this.configure(this.__image.getParams()):this.__image.on("loaded",(()=>{this.configure(this.__image.getParams())}))}else this.configure(F)}isLoaded(){return this.__loaded}getImage(){return this.__image}getInternalFormat(){return this.__internalFormat}getType(){return this.__type}getFormat(){return this.__format}getWrap(){return this.__wrapParam}getMipMapped(){return this.__mipMapped}configure(U){const F=this.__gl,e=je(F,U);this.params=e,this.__format=e.format,this.__internalFormat=e.internalFormat,this.__type=e.type,this.__minFilter=e.minFilter,this.__magFilter=e.magFilter,this.__wrapS=e.wrapS,this.__wrapT=e.wrapT,this.__flipY="flipY"in U&&U.flipY,this.__mipMapped="mipMapped"in U&&U.mipMapped,this.invert="invert"in U&&U.invert,this.alphaFromLuminance="alphaFromLuminance"in U&&U.alphaFromLuminance,this.textureType=1,this.textureDesc[0]=this.width,this.textureDesc[1]=this.height,1==this.textureType&&this.__format==F.RGBA&&(this.textureType=2),this.__gltex&&F.deleteTexture(this.__gltex),this.__gltex=F.createTexture(),this.__updateGLTexParams();const t=e.width,Q=e.height,l=U.data;l?this.bufferData(l,t,Q,!1,!1):this.resize(t,Q,!1,!1),this.__loaded||(this.emit("ready"),this.__loaded=!0)}__updateGLTexParams(){const U=this.__gl;U.bindTexture(U.TEXTURE_2D,this.__gltex),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_MAG_FILTER,this.__minFilter),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_MIN_FILTER,this.__magFilter),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_WRAP_S,this.__wrapS),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_WRAP_T,this.__wrapT)}bufferData(U,F=-1,e=-1,t=!0,Q=!0){const l=this.__gl;if(t&&l.bindTexture(l.TEXTURE_2D,this.__gltex),null!=U){if(U instanceof Image||U instanceof ImageData||U instanceof HTMLCanvasElement||U instanceof HTMLImageElement||U instanceof HTMLVideoElement)l.texImage2D(l.TEXTURE_2D,0,this.__internalFormat,this.__format,this.__type,U),this.width=U.width,this.height=U.height;else{-1==F&&(F=this.width),-1==e&&(e=this.height);const t=F*e;let Q;switch(this.__format){case l.RED:case l.RED_INTEGER:case l.ALPHA:case l.LUMINANCE:case l.LUMINANCE_ALPHA:Q=1;break;case l.RG:Q=2,l.pixelStorei(l.UNPACK_ALIGNMENT,2);break;case l.RGB:Q=3;break;case l.RGBA:Q=4;break;default:console.warn("Reaching default case: numChannels:=1"),Q=1}U.length!=t*Q&&console.warn("Invalid data for Image width:"+F+" height:"+e+" format:"+this.__formatParam+" type:"+this.__typeParam+" Data Length:"+U.length+" Expected:"+t*Q),this.__type==l.HALF_FLOAT&&U instanceof Float32Array&&(U=J.convertFloat32ArrayToUInt16Array(U)),"webgl2"==l.name?l.texImage2D(l.TEXTURE_2D,0,this.__internalFormat,F,e,0,this.__format,this.__type,U,0):l.texImage2D(l.TEXTURE_2D,0,this.__internalFormat,F,e,0,this.__format,this.__type,U),this.width=F,this.height=e}this.__mipMapped&&l.generateMipmap(l.TEXTURE_2D)}else l.texImage2D(l.TEXTURE_2D,0,this.__internalFormat,this.width,this.height,0,this.__format,this.__type,null),this.width=F,this.height=e;Q&&this.emit("updated")}clear(){const U=this.__gl,F=this.width*this.height;let e,t;switch(this.__format){case U.RED:case U.RED_INTEGER:case U.ALPHA:case U.LUMINANCE:case U.LUMINANCE_ALPHA:e=1;break;case U.RG:e=2;break;case U.RGB:e=3;break;case U.RGBA:e=4;break;default:throw new Error("Invalid Format")}switch(this.__type){case U.UNSIGNED_BYTE:t=new Uint8Array(F*e);break;case U.HALF_FLOAT:t=new Uint16Array(F*e);break;case U.FLOAT:t=new Float32Array(F*e);break;default:throw new Error("Invalid Type")}"webgl2"==U.name?U.texImage2D(U.TEXTURE_2D,0,this.__internalFormat,this.width,this.height,0,this.__format,this.__type,t,0):U.texImage2D(U.TEXTURE_2D,0,this.__internalFormat,this.width,this.height,0,this.__format,this.__type,t)}resize(U,F,e=!1,t=!0){const Q=this.__gl;if(this.width!=U||this.height!=F){const l=Q.getParameter(Q.MAX_TEXTURE_SIZE);if(U<0||U>l||F<0||F>l)throw new Error("gl-texture2d: Invalid texture size. width:"+U+" height:"+F+" maxSize:"+l);if(e){const e=Q.createTexture();Q.bindTexture(Q.TEXTURE_2D,e),Q.texImage2D(Q.TEXTURE_2D,0,this.__internalFormat,U,F,0,this.__format,this.__type,null);const t=Q.createFramebuffer();Q.bindFramebuffer(Q.FRAMEBUFFER,t),Q.framebufferTexture2D(Q.FRAMEBUFFER,Q.COLOR_ATTACHMENT0,Q.TEXTURE_2D,this.__gltex,0),Q.bindTexture(Q.TEXTURE_2D,e),Q.copyTexImage2D(Q.TEXTURE_2D,0,this.__internalFormat,0,0,this.width,this.height,0),Q.bindFramebuffer(Q.FRAMEBUFFER,null),Q.deleteFramebuffer(t),this.__gl.deleteTexture(this.__gltex),this.__gltex=e,this.__updateGLTexParams()}else this.width>0&&this.height,Q.bindTexture(Q.TEXTURE_2D,this.__gltex),Q.texImage2D(Q.TEXTURE_2D,0,this.__internalFormat,U,F,0,this.__format,this.__type,null);if(this.width=U,this.height=F,t){const e=new b(U,F);this.emit("resized",e)}}}populate(U,F,e,t=0,Q=0,l=!0){const n=this.__gl;l&&n.bindTexture(n.TEXTURE_2D,this.__gltex),n.texSubImage2D(n.TEXTURE_2D,0,t,Q,F,e,this.__format,this.__type,U)}getSize(){return[this.width,this.height]}get glTex(){return this.__gltex}getTexHdl(){return this.__gltex}preBind(U,F){return{textureTypeUnif:F[U.name+"Type"],textureDescUnif:F[U.name+"Desc"]}}bindToUniform(U,F,e){if(!this.__loaded)return!1;if(!this.__gltex)throw new Error("Unable to bind non-initialized or deleted texture.");const t=U.boundTextures++,Q=this.__gl;return Q.activeTexture(Q.TEXTURE0+t),Q.bindTexture(Q.TEXTURE_2D,this.__gltex),Q.uniform1i(F.location,t),e&&(e.textureTypeUnif&&Q.uniform1i(e.textureTypeUnif.location,this.textureType),e.textureDescUnif&&Q.uniform4fv(e.textureDescUnif.location,this.textureDesc)),!0}destroy(){super.destroy(),this.__image&&this.__image.setMetadata("gltexture",void 0),this.__gl.deleteTexture(this.__gltex),this.__gltex=null}}let qe={bool:"Boolean",int:"SInt32",uint:"UInt32",float:"Float32",ivec2:"Vec2",ivec3:"Vec3",ivec4:"Vec4",vec2:"Vec2",vec3:"Vec3",vec4:"Vec4",color:"Color",mat3:"Mat3",mat4:"Mat4",sampler2D:"BaseImage",samplerCube:"BaseImage"};const $e=/\s+/;class Ut{constructor(){this.__shaderModules={},this.materialTemplates={}}setShaderModule(U,F){U in this.__shaderModules||(this.__shaderModules[U]=F)}getShaderModule(U){return this.__shaderModules[U]}getShaderModuleNames(){const U=[];for(const F in this.__shaderModules)U.push(F);return U}parseAttr(U,F,e,t){if(!(U[1]in qe))throw new Error("Error while parsing \nType not recognized:"+U[1]);const Q=U[2].slice(0,U[2].length-1);e.attributes[Q]={type:qe[U[1]],instanced:F},"color"==U[1]&&(U[1]="vec4",U.join(" "))}handleImport(U,F,e,t,Q){if(e in this.__shaderModules){const l=this.__shaderModules[e];if(!l)throw Error("snippet not loaded or does not exists!");const n=this.parseShaderHelper(F,l,t,Q);t.push(e),U.glsl=U.glsl+n.glsl,U.numLines+=n.numLines,U.uniforms=Object.assign(Object.assign({},U.uniforms),n.uniforms),U.attributes=Object.assign(Object.assign({},U.attributes),n.attributes)}else console.log("shaderName: "+F),console.log("SNIPPET NOT FOUND: "+e)}parseShader(U,F){return this.parseShaderHelper(U,F,[],0)}parseShaderHelper(U,F,e,t){const Q=(U,F)=>{U.glsl=U.glsl+F+"\n",U.numLines++};e.push(U);const l={glsl:"",numLines:0,uniforms:{},attributes:{}},n=(F=F.toString()).split("\n");for(let F=0;F<n.length;F++){let a=n[F];const d=a.trim(),i=d.split($e);switch(i[0]){case"<%include":case"import":{const F=d.split(/'|"|`/)[1].split("/").pop();e.includes(F)||this.handleImport(l,U,F,e,t);break}case"attribute":this.parseAttr(i,!1,l,a),Q(l,a);break;case"instancedattribute":this.parseAttr(i,!0,l,a),i[0]="attribute",a=i.join(" "),Q(l,a);break;case"uniform":{let F=1;4==i.length&&(F=2);const e=i[F];if(!(e in qe))throw new Error("Error while parsing :"+U+" \nType not recognized:"+i[1]);const t=i[F+1].slice(0,i[F+1].length-1);t.includes("[")?l.uniforms[t.substring(0,t.indexOf("["))]=qe[e]:l.uniforms[t]=qe[e],"struct"==l.uniforms[t]&&console.log(i),"color"==i[1]&&(i[1]="vec4",a=i.join(" ")),Q(l,a);break}default:Q(l,a)}}return l}}const Ft=new Ut;let et=0;class tt extends A{constructor(U,F){super(F),U&&(this.__gl=U),this.__shaderStagesGLSL={},this.__shaderStages={},this.__shaderProgramHdls={},this.__gltextures={},this.__id=et++}setGLContext(U){this.__gl=U}setShaderStage(U,F){this.__shaderStagesGLSL[U]=F,this.clearProgramsCache()}getShaderStage(U){return this.__shaderStagesGLSL[U]}clearProgramsCache(){const U=this.__gl;for(const F in this.__shaderProgramHdls){const e=this.__shaderProgramHdls[F];for(const F in e.shaderHdls)U.deleteShader(e.shaderHdls[F]);U.deleteProgram(e.shaderProgramHdl)}}static isTransparent(){return!1}static isOverlay(){return!1}__compileShaderStage(U,F,e,t){const Q=this.__gl;if(t||(t=Q.shaderopts),t){if(t.repl)for(const F in t.repl)U=a.replaceAll(U,F,t.repl[F]);if(t.directives){U=t.directives.join("\n")+"\n"+U}}let l;"webgl2"==Q.name&&(U=a.replaceAll(U,"attribute","in"),U="vertexShader"==e?a.replaceAll(U,"varying","out"):a.replaceAll(U,"varying","in"),l="#version 300 es\n",U="#version 300 es\n"+(U=a.replaceAll(U,"texture2D","texture")));const n=Q.createShader(F);if(!n)throw Error("shaderHdl not defined");if(Q.shaderSource(n,U),Q.compileShader(n),!Q.getShaderParameter(n,Q.COMPILE_STATUS)){console.log("Errors in :"+this.constructor.name);const F=Q.getShaderInfoLog(n).split("\n"),t={};for(let U=0;U<F.length;U++){if(F[U].startsWith("'")){F[U-1]=F[U-1]+F[U],delete F[U],U--;continue}const e=F[U].split(":");if(e.length>=2){const Q=parseInt(e[2]);isNaN(Q)||(t[Q]?t[Q].push(F[U]):t[Q]=[F[U]])}}const l=[],a=U.split("\n");for(const U in t){const F=Number.parseInt(U)-1;for(let U=Math.max(0,F-4);U<F;U++)l.push((F+1+" ").padStart(3)+a[U]);l.push((F+1+">").padStart(3)+a[F]);for(let U=F+1;U<Math.min(a.length-1,F+5);U++)l.push((F+1+" ").padStart(3)+a[U]);const e=t[U];for(const U of e)l.push(U)}throw new Error("An error occurred compiling the shader \n=================\n"+this.constructor.name+"."+e+": \n\n"+l.join("\n"))}return n}__createProgram(U){const F=this.__gl;this.__shaderCompilationAttempted=!0;const e=F.createProgram();if(!e)throw Error("shaderProgramHdl not defined");const t={};this.__shaderStages.VERTEX_SHADER||(this.__shaderStages.VERTEX_SHADER=Ft.parseShader("VERTEX_SHADER",this.__shaderStagesGLSL.VERTEX_SHADER));const Q=this.__shaderStages.VERTEX_SHADER.glsl;if(null!=Q){const l=this.__compileShaderStage(Q,F.VERTEX_SHADER,"vertexShader",U);if(!l)return!1;F.attachShader(e,l),t[F.VERTEX_SHADER]=l}this.__shaderStages.FRAGMENT_SHADER||(this.__shaderStages.FRAGMENT_SHADER=Ft.parseShader("FRAGMENT_SHADER",this.__shaderStagesGLSL.FRAGMENT_SHADER));const l=this.__shaderStages.FRAGMENT_SHADER.glsl;if(null!=l){const Q=Object.assign({},F.shaderopts,U);Q.frag&&(Q.defines=Q.frag.defines+Q.defines);const n=this.__compileShaderStage(l,F.FRAGMENT_SHADER,"fragmentShader",Q);if(!n)return!1;F.attachShader(e,n),t[F.FRAGMENT_SHADER]=n}if(F.linkProgram(e),!F.getProgramParameter(e,F.LINK_STATUS)){const U=F.getProgramInfoLog(e);if(!U)throw Error("info not defined");if(U.includes("D3D shader compilation failed")){const U=F.getExtension("WEBGL_debug_shaders");if(U){const e=U.getTranslatedShaderSource(t[F.VERTEX_SHADER]);console.log(e)}}throw console.log("vertexShaderGLSL:"+Q),console.log("fragmentShaderGLSL:"+l),new Error("Unable to link the shader program:"+this.constructor.name+"\n==================\n"+U)}const n=this.__extractAttributeAndUniformLocations(e,U);return n.shaderHdls=t,n.shaderProgramHdl=e,n}__extractAttributeAndUniformLocations(U,F){const e=this.__gl,t=this.getAttributes(),Q={attrs:{},unifs:{}};for(const F in t){const l=e.getAttribLocation(U,F);if(null==l){console.warn("Shader attribute not found:"+F);continue}const n=t[F];Q.attrs[F]={name:F,location:l,type:n.type,instanced:n.instanced}}const l=this.getUniforms();for(let t in l){const n=l[t];if(F&&F.repl)for(const U in F.repl)t=t.replace(U,F.repl[U]);const a=e.getUniformLocation(U,t);null!=a&&(Q.unifs[t]={name:t,location:a,type:n})}return Q}getAttributes(){const U={};for(const F in this.__shaderStages){const e=this.__shaderStages[F];for(const F in e.attributes)U[F]=e.attributes[F]}return U}getUniforms(){const U={};for(const F in this.__shaderStages){const e=this.__shaderStages[F];for(const F in e.uniforms)U[F]=e.uniforms[F]}return U}isCompiledForTarget(U){const F=U||this.getId();return null!=this.__shaderProgramHdls[F]}compileForTarget(U,F){const e=U||this.getId();let t=this.__shaderProgramHdls[e];return t||!1!==t&&(t=this.__createProgram(F||{}),t.shaderkey=e,this.__shaderProgramHdls[e]=t),t}compile(){this.compileForTarget()}bind(U,F){const e=this.__gl;if(U.glShader!=this){const t=this.compileForTarget(F,U.shaderopts);if(t==={})return console.warn(this.constructor.name+" is not compiled for "+F),!1;const Q=t.shaderProgramHdl;e.useProgram(Q),U.glShader=this,U.shaderkey=t.shaderkey,U.unifs=t.unifs,U.attrs=t.attrs,U.boundTextures=0,U.glGeom=void 0,U.bindRendererUnifs&&U.bindRendererUnifs(t.unifs)}return U.supportsInstancing=!0,!0}unbind(U){return U.glShader=null,U.shaderkey="",U.unifs={},U.attrs={},!0}getGeomDataShaderName(){return""}getSelectedShaderName(){return""}static supportsInstancing(){return!0}static getPackedMaterialData(U){return new Float32Array(4)}static getMaterialTemplate(){throw new Error("Shader does not provide a material template.")}destroy(){const U=this.__gl;for(const F in this.__shaderProgramHdls){const e=this.__shaderProgramHdls[F];U.deleteProgram(e.shaderProgramHdl)}this.__shaderProgramHdls={}}}new qU;class Qt{constructor(U,F,t=!1){this.colorTextureResizeEventId=-1,this.__depthTexture=null,this.__fbo=null,this.__prevBoundFbo=null,!e.isIOSDevice||"webgl"!=U.name||F.getType()!=U.FLOAT&&F.getType()!=U.HALF_FLOAT||console.error("IOS devices are unable to render to float textures."),this.__gl=U,this.__colorTexture=F,this.__createDepthTexture=t,this.__clearColor=new B(0,0,0,0),this.__colorTexture&&(this.colorTextureResizeEventId=this.__colorTexture.on("resized",(U=>{this.resize(this.__colorTexture.width,this.__colorTexture.height,!1)}))),this.setup()}textureResized(U){this.resize(this.__colorTexture.width,this.__colorTexture.height,!1)}setClearColor(U){this.__clearColor=U}getWidth(){return this.__colorTexture.width}getHeight(){return this.__colorTexture.height}getSize(){return[this.__colorTexture.width,this.__colorTexture.height]}getColorTexture(){return this.__colorTexture}getDepthTextureGL(){return this.__depthTexture}get width(){return this.__colorTexture.width}get height(){return this.__colorTexture.height}get size(){return[this.__colorTexture.width,this.__colorTexture.height]}get colorTexture(){return this.__colorTexture}setColorTexture(U){const F=this.__gl;this.__colorTexture=U,F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,this.__colorTexture.glTex,0)}get depthTextureGL(){return this.__depthTexture}setup(){const U=this.__gl;if(this.__fbo=U.createFramebuffer(),"webgl2"==U.name?U.bindFramebuffer(U.DRAW_FRAMEBUFFER,this.__fbo):U.bindFramebuffer(U.FRAMEBUFFER,this.__fbo),this.__colorTexture&&("webgl2"==U.name?U.framebufferTexture2D(U.DRAW_FRAMEBUFFER,U.COLOR_ATTACHMENT0,U.TEXTURE_2D,this.__colorTexture.glTex,0):U.framebufferTexture2D(U.FRAMEBUFFER,U.COLOR_ATTACHMENT0,U.TEXTURE_2D,this.__colorTexture.glTex,0)),this.__createDepthTexture)if("webgl2"==U.name||U.__ext_WEBGL_depth_texture)U.activeTexture(U.TEXTURE0),this.__depthTexture=U.createTexture(),U.bindTexture(U.TEXTURE_2D,this.__depthTexture),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_MAG_FILTER,U.LINEAR),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_MIN_FILTER,U.LINEAR),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_WRAP_S,U.CLAMP_TO_EDGE),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_WRAP_T,U.CLAMP_TO_EDGE),"webgl2"==U.name?(U.texImage2D(U.TEXTURE_2D,0,U.DEPTH_COMPONENT24,this.width,this.height,0,U.DEPTH_COMPONENT,U.UNSIGNED_INT,null),U.framebufferTexture2D(U.DRAW_FRAMEBUFFER,U.DEPTH_ATTACHMENT,U.TEXTURE_2D,this.__depthTexture,0)):(U.texImage2D(U.TEXTURE_2D,0,U.DEPTH_COMPONENT,this.width,this.height,0,U.DEPTH_COMPONENT,U.UNSIGNED_INT,null),U.framebufferTexture2D(U.FRAMEBUFFER,U.DEPTH_ATTACHMENT,U.TEXTURE_2D,this.__depthTexture,0));else{const F=U.createRenderbuffer();U.bindRenderbuffer(U.RENDERBUFFER,F),U.renderbufferStorage(U.RENDERBUFFER,U.DEPTH_COMPONENT16,this.width,this.height),U.framebufferRenderbuffer(U.FRAMEBUFFER,U.DEPTH_ATTACHMENT,U.RENDERBUFFER,F)}this.__checkFramebuffer(),"webgl2"==U.name?U.bindFramebuffer(U.DRAW_FRAMEBUFFER,null):U.bindFramebuffer(U.FRAMEBUFFER,null)}resize(U,F,e){const t=this.__gl;e&&this.__colorTexture.resize(U,F,!1,!1),"webgl2"==t.name?t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.__fbo):t.bindFramebuffer(t.FRAMEBUFFER,this.__fbo),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.__colorTexture.glTex,0),this.__depthTexture&&(t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.__depthTexture),"webgl2"==t.name?t.texImage2D(t.TEXTURE_2D,0,t.DEPTH_COMPONENT24,this.width,this.height,0,t.DEPTH_COMPONENT,t.UNSIGNED_INT,null):t.texImage2D(t.TEXTURE_2D,0,t.DEPTH_COMPONENT,this.width,this.height,0,t.DEPTH_COMPONENT,t.UNSIGNED_INT,null)),this.__checkFramebuffer()}__checkFramebuffer(){const U=this.__gl;let F;if(F="webgl2"==U.name?U.checkFramebufferStatus(U.DRAW_FRAMEBUFFER):U.checkFramebufferStatus(U.FRAMEBUFFER),F!==U.FRAMEBUFFER_COMPLETE)switch(U.bindTexture(U.TEXTURE_2D,null),"webgl2"==U.name?U.bindFramebuffer(U.DRAW_FRAMEBUFFER,null):U.bindFramebuffer(U.FRAMEBUFFER,null),console.warn("Error creating Fbo width:",this.width,", height:",this.height," Texture Type:",this.__colorTexture.getType()),F){case U.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");case U.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw new Error("There is no attachment.");case U.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("Height and width of the attachment are not the same.");case U.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");case 36061:throw new Error("The framebuffer is unsupported");default:throw new Error("Incomplete Frambuffer")}}bindForWriting(U){U&&(this.__prevBoundFbo=U.boundRendertarget,U.boundRendertarget=this.__fbo);const F=this.__gl;"webgl2"==F.name?F.bindFramebuffer(F.DRAW_FRAMEBUFFER,this.__fbo):F.bindFramebuffer(F.FRAMEBUFFER,this.__fbo),F.viewport(0,0,this.width,this.height)}unbindForWriting(U){U&&(U.boundRendertarget=this.__prevBoundFbo);const F=this.__gl;"webgl2"==F.name?F.bindFramebuffer(F.DRAW_FRAMEBUFFER,this.__prevBoundFbo):F.bindFramebuffer(F.FRAMEBUFFER,this.__prevBoundFbo)}bind(U){this.bindForWriting(U)}unbind(U){if(U)this.unbindForWriting(U);else{const U=this.__gl;U.bindFramebuffer(U.FRAMEBUFFER,null)}}bindForReading(U){const F=this.__gl;"webgl2"==F.name?F.bindFramebuffer(F.READ_FRAMEBUFFER,this.__fbo):F.bindFramebuffer(F.FRAMEBUFFER,this.__fbo)}unbindForReading(){const U=this.__gl;"webgl2"==U.name?U.bindFramebuffer(U.READ_FRAMEBUFFER,null):U.bindFramebuffer(U.FRAMEBUFFER,null)}clear(){const U=this.__gl;U.colorMask(!0,!0,!0,!0);const F=this.__clearColor.asArray();U.clearColor(F[0],F[1],F[2],F[3]),this.__createDepthTexture?U.clear(U.COLOR_BUFFER_BIT|U.DEPTH_BUFFER_BIT):U.clear(U.COLOR_BUFFER_BIT)}bindAndClear(U){this.bind(U),this.clear()}destroy(){const U=this.__gl;U.bindFramebuffer(U.FRAMEBUFFER,null),U.deleteFramebuffer(this.__fbo),this.__fbo=null,this.__colorTexture.removeListenerById("resized",this.colorTextureResizeEventId)}}class lt extends k{constructor(U,F){super(),this.params={},this.width=0,this.height=0,this.__gl=U,this.textureTargets=[],this.depthTexture=null,this.textureDesc=[0,0,0,0],this.clearColor=new B(0,0,0,0),this.colorMask=[!0,!0,!0,!0],F&&this.configure(F)}configure(U){const F=this.__gl,e=je(F,U);this.textureTargets.forEach((U=>{F.deleteTexture(U)})),this.textureTargets=[],this.depthTexture&&(F.deleteTexture(this.depthTexture),this.depthTexture=null),this.frameBuffer&&F.deleteFramebuffer(this.frameBuffer),this.params=e,this.type=e.type,this.format=e.format,this.internalFormat=e.internalFormat,this.filter=e.filter,this.wrap=e.wrap,this.flipY=e.flipY,this.width=e.width,this.height=e.height,this.textureType=1,this.textureDesc[0]=this.width,this.textureDesc[1]=this.height;const t=null!=U.numColorChannels?U.numColorChannels:null!=e.format?1:0;for(let U=0;U<t;U++){F.activeTexture(F.TEXTURE0+1);const U=F.createTexture();F.bindTexture(F.TEXTURE_2D,U),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_S,e.wrapS),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_T,e.wrapT),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MIN_FILTER,e.minFilter),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MAG_FILTER,e.magFilter),F.texImage2D(F.TEXTURE_2D,0,this.internalFormat,e.width,e.height,0,this.format,this.type,null),this.textureTargets.push(U)}if(e.depthFormat){if("webgl"==F.name&&!F.__ext_WEBGL_depth_texture)throw new Error("Depth textures not support on this device");F.activeTexture(F.TEXTURE0),this.depthTexture=F.createTexture(),F.bindTexture(F.TEXTURE_2D,this.depthTexture),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_S,e.wrapS),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_T,e.wrapT),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MIN_FILTER,e.minFilter),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MAG_FILTER,e.magFilter),F.texImage2D(F.TEXTURE_2D,0,e.depthInternalFormat,e.width,e.height,0,e.depthFormat,e.depthType,null)}if(this.frameBuffer=F.createFramebuffer(),this.bindForWriting(),this.textureTargets.length>0){this.textureTargets.length>1&&"webgl"==F.name&&F.drawBuffers;const U=[];for(let e=0;e<this.textureTargets.length;e++)F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0+e,F.TEXTURE_2D,this.textureTargets[e],0),U.push(F.COLOR_ATTACHMENT0+e);this.textureTargets.length>1&&F.drawBuffers(U)}this.depthTexture&&F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.DEPTH_ATTACHMENT,F.TEXTURE_2D,this.depthTexture,0),this.checkFramebuffer()}checkFramebuffer(){this.bindForWriting();const U=this.__gl,F=U.checkFramebufferStatus(U.DRAW_FRAMEBUFFER);if(F!=U.FRAMEBUFFER_COMPLETE)switch(F){case U.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");case U.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw new Error("There is no attachment.");case U.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("Height and width of the attachment are not the same.");case U.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");case 36061:throw new Error("The framebuffer is unsupported");default:throw new Error("Incomplete Frambuffer")}this.unbindForWriting()}bindForWriting(U,F=!1){U&&(this.__prevBoundFbo=U.boundRendertarget,U.boundRendertarget=this.frameBuffer);const e=this.__gl;"webgl2"==e.name?e.bindFramebuffer(e.DRAW_FRAMEBUFFER,this.frameBuffer):e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),e.viewport(0,0,this.width,this.height),F&&this.clear()}unbindForWriting(U){U&&(U.boundRendertarget=this.__prevBoundFbo);const F=this.__gl;"webgl2"==F.name?F.bindFramebuffer(F.DRAW_FRAMEBUFFER,this.__prevBoundFbo):F.bindFramebuffer(F.FRAMEBUFFER,this.__prevBoundFbo)}clear(U=!0){const F=this.__gl,e=this.colorMask;F.colorMask(e[0],e[1],e[2],e[3]);const t=this.clearColor.asArray();F.clearColor(t[0],t[1],t[2],t[3]);let Q=0;this.textureTargets.length>0&&(Q|=F.COLOR_BUFFER_BIT),this.depthTexture&&(Q|=F.DEPTH_BUFFER_BIT),F.clear(Q)}bindForReading(){const U=this.__gl;"webgl2"==U.name?U.bindFramebuffer(U.READ_FRAMEBUFFER,this.frameBuffer):U.bindFramebuffer(U.FRAMEBUFFER,this.frameBuffer)}unbindForReading(){const U=this.__gl;"webgl2"==U.name?U.bindFramebuffer(U.READ_FRAMEBUFFER,null):U.bindFramebuffer(U.FRAMEBUFFER,null)}bindColorTexture(U,F,e=0){const t=this.__gl,Q=U.boundTextures++;return t.uniform1i(F.location,Q),t.activeTexture(t.TEXTURE0+Q),t.bindTexture(t.TEXTURE_2D,this.textureTargets[e]),!0}bindDepthTexture(U,F){const e=this.__gl,t=U.boundTextures++;return e.uniform1i(F.location,t),e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,this.depthTexture),!0}unbind(U){this.unbindForWriting(U)}resize(U,F,e=!1){const t=this.__gl;if(this.width!=U||this.height!=F){const Q=t.getParameter(t.MAX_TEXTURE_SIZE);if(U<0||U>Q||F<0||F>Q)throw new Error(`GLRenderTarget: Invalid texture size. width: ${U} height: ${F} maxSize: ${Q}`);e&&this.bindForReading();const l=this.params;for(let Q=0;Q<this.textureTargets.length;Q++){const n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,l.wrapS),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,l.wrapT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,l.minFilter),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,l.magFilter),t.texImage2D(t.TEXTURE_2D,0,this.internalFormat,U,F,0,this.format,this.type,null),e&&t.copyTexImage2D(t.TEXTURE_2D,0,this.internalFormat,0,0,Math.min(U,this.width),Math.min(F,this.height),0),t.deleteTexture(this.textureTargets[Q]),this.textureTargets[Q]=n}if(l.depthFormat){if("webgl"==t.name&&!t.__ext_WEBGL_depth_texture)throw new Error("Depth textures not support on this device");t.activeTexture(t.TEXTURE0);const Q=t.createTexture();t.bindTexture(t.TEXTURE_2D,Q),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,l.wrapS),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,l.wrapT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,l.minFilter),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,l.magFilter),t.texImage2D(t.TEXTURE_2D,0,l.depthInternalFormat,U,F,0,l.depthFormat,l.depthType,null),e&&t.copyTexImage2D(t.TEXTURE_2D,0,this.internalFormat,0,0,Math.min(U,this.width),Math.min(F,this.height),0),t.deleteTexture(this.depthTexture),this.depthTexture=Q}if(e&&this.unbindForReading(),this.width=U,this.height=F,this.frameBuffer&&t.deleteFramebuffer(this.frameBuffer),this.frameBuffer=t.createFramebuffer(),this.bindForWriting(),this.textureTargets.length>0){this.textureTargets.length>1&&"webgl"==t.name&&t.drawBuffers;const U=[];for(let F=0;F<this.textureTargets.length;F++)t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+F,t.TEXTURE_2D,this.textureTargets[F],0),U.push(t.COLOR_ATTACHMENT0+F);this.textureTargets.length>1&&t.drawBuffers(U)}this.depthTexture&&t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,this.depthTexture,0),this.checkFramebuffer()}}bindToUniform(U,F,e){const t=U.boundTextures++,Q=this.__gl.TEXTURE0+t,l=this.__gl;return l.activeTexture(Q),l.bindTexture(l.TEXTURE_2D,this.textureTargets[0]),l.uniform1i(F.location,t),e&&(e.textureTypeUnif&&l.uniform1i(e.textureTypeUnif.location,this.textureType),e.textureDescUnif&&this.__gl.uniform4fv(e.textureDescUnif.location,this.textureDesc)),!0}destroy(){const U=this.__gl;this.textureTargets.forEach((F=>{U.deleteTexture(F)})),this.textureTargets=[],this.depthTexture&&(U.deleteTexture(this.depthTexture),this.depthTexture=null),this.frameBuffer&&U.deleteFramebuffer(this.frameBuffer)}}Ft.setShaderModule("imageAtlas.glsl","#define GLSLIFY 1\n// Note: On mobile, I can't seem to pass around a stuct containing sampler2D.\n// I have to unpack the struct and pass its members. :(\n// struct ImageAtlas {\n//     sampler2D layout;\n//     sampler2D image;\n//     vec4 desc;\n// };\n\nimport 'GLSLUtils.glsl'\n\nvec4 getSubImageLayout(int index, in sampler2D atlasLayout, in vec4 atlasDesc){\n    return fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n}\nvec2 calcSubImageTexCoords(vec2 texCoord, int index, in sampler2D atlasLayout, in vec4 atlasDesc){\n    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n    // The following line is a hack to fix artifacts in our PBR lighting\n    // We were seeing loads of lighting garbage on some sufaces that were orthogonal\n    // to the world. The UV coordinates would have been landing right on the edges\n    // of our subimages and were often sampling outside the image. This couuld\n    // have been because of filtering, or an error in the uv coords. \n    texCoord = clamp(texCoord, vec2(0.01, 0.01), vec2(0.99, 0.99));\n    vec2 subimageTexel = texCoord * layoutData.zw;\n    // subimageTexel = clamp(subimageTexel, vec2(0.0, 0.0), vec2(1.0, 1.0));\n    return subimageTexel + layoutData.xy;\n}\nvec4 sampleSubImage(vec2 texCoord, int index, in sampler2D atlasLayout, in sampler2D atlasImage, in vec4 atlasDesc){\n    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n    vec2 atlasCoords = calcSubImageTexCoords(texCoord, index, atlasLayout, atlasDesc);\n    return texture2D(atlasImage, atlasCoords);\n}"),Ft.setShaderModule("surfaceGeomData.glsl","#define GLSLIFY 1\n  uniform int floatGeomBuffer;\n  uniform int passId;\n\n  import 'GLSLBits.glsl'\n  \n  vec4 setFragColor_geomData(vec3 v_viewPos, int floatGeomBuffer, int passId, float v_drawItemId, int isOrthographic){\n    vec4 fragColor;\n\n    float viewDist;\n    if (isOrthographic > 0) {\n      viewDist = v_viewPos.z;\n    } else {\n      viewDist = length(v_viewPos);\n    }\n    if (floatGeomBuffer != 0) {\n      fragColor.r = float(passId); \n      fragColor.g = float(v_drawItemId);\n      fragColor.b = 0.0;// TODO: store poly-id or something.\n      fragColor.a = viewDist;\n    }\n    else {\n      ///////////////////////////////////\n      // UInt8 buffer\n      fragColor.r = mod(v_drawItemId, 256.) / 255.;\n      fragColor.g = (floor(v_drawItemId / 256.) + float(passId) * 32.) / 255.;\n\n      // encode the dist as a 16 bit float\n      vec2 float16bits = encode16BitFloatInto2xUInt8(viewDist);\n      fragColor.b = float16bits.x;\n      fragColor.a = float16bits.y;\n    }\n\n    return fragColor;\n  }"),Ft.setShaderModule("surfaceHighlight.glsl","#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor(int id) {\n    return highlightColor;\n}\n\n#endif\n\nvec4 setFragColor_highlight(float v_drawItemId){\n  vec4 fragColor; \n  int drawItemId = int(v_drawItemId + 0.5);\n  fragColor = getHighlightColor(drawItemId);\n  return fragColor;\n}\n"),Ft.setShaderModule("computeViewNormal.glsl","#define GLSLIFY 1\n  \n#ifdef ENABLE_ES3\nvec3 computeViewNormal(vec3 viewPos) {\n  vec3 fdx = dFdx(viewPos);\n  vec3 fdy = dFdy(viewPos);\n  return normalize(cross(fdx, fdy));\n}\n#else \nvec3 computeViewNormal(vec3 viewPos) {\n  return vec3(0.0, 0.0, 0.0);\n}\n#endif\n"),Ft.setShaderModule("calcFatLinesViewPos.glsl","#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nvec3 calcFatLinesViewPos(int vertexID, mat4 modelViewMatrix, inout vec3 viewNormal, inout vec2 texCoord, inout vec3 pos) {\n\n  int seqentialIndex_0 = int(mod(segmentIndices.x, 2.));\n  int seqentialIndex_1 = int(mod(segmentIndices.y, 2.));\n  int index_0 = int(segmentIndices.x) / 2;\n  int index_1 = int(segmentIndices.y) / 2;\n\n  vec3 viewPos;\n  vec4 data_0 = fetchTexel(positionsTexture, positionsTextureSize, index_0);\n  vec4 data_1 = fetchTexel(positionsTexture, positionsTextureSize, index_1);\n\n  // During XR sessions, there is a scaling applied to the view matrix\n  // which causes a distortion to the line width. We extract that scale here\n  // and use to correct the distortion.\n  // See also: FatPointsShader\n  vec3 viewZ = modelViewMatrix[2].xyz;\n  float viewScale = length(viewZ);\n\n  vec4 pos_0 = modelViewMatrix * vec4(data_0.xyz, 1.0);\n  vec4 pos_1 = modelViewMatrix * vec4(data_1.xyz, 1.0);\n  // Note: multiply the per-vertex line thickness with the line thickness uniform value;\n  float lineThickness_0 = LineThickness * data_0.w * viewScale;\n  float lineThickness_1 = LineThickness * data_1.w * viewScale;\n\n  if (vertexID < 2) {\n    pos = data_0.xyz;\n    viewPos = pos_0.xyz;\n  }\n  else {\n    pos = data_1.xyz;\n    viewPos = pos_1.xyz;\n  }\n  if (pos_1 != pos_0) {\n    vec3 segmentDir = normalize(pos_1.xyz - pos_0.xyz);\n    vec3 viewVector = normalize(viewPos);\n\n    if (vertexID < 2) {\n      vec3 segmentStartDir = segmentDir;\n      if (seqentialIndex_0 != 0) {\n        //if index_0 == 0, get the last index in the line as previous\n        int index_prev = (index_0 > 0) ? (index_0-1) : (positionsTextureSize-1);\n        vec4 data_prev = fetchTexel(positionsTexture, positionsTextureSize, index_prev);\n        vec4 pos_prev = modelViewMatrix * vec4(data_prev.xyz, 1.0);\n        segmentStartDir = normalize(segmentDir + normalize(pos_0.xyz - pos_prev.xyz));\n        // segmentStartDir = segmentDir;\n      }\n      // vec3 startBiTangent = normalize(cross(segmentStartDir, viewVector));\n      // viewNormal = normalize(cross(segmentStartDir, startBiTangent));\n      vec3 startBiTangent = normalize(vec3(-segmentStartDir.y, segmentStartDir.x, 0.0));\n      viewNormal = normalize(-viewVector);\n      // Move the endpoints to overlap a bit more.\n      //viewPos -= vec3(segmentStartDir * lineThickness_0 * 0.25);\n      if (mod(vertexIDs, 2.0) == 0.0) {\n        viewPos += vec3(startBiTangent * lineThickness_0);\n        texCoord.x = 1.0;\n      }\n      else {\n        viewPos -= vec3(startBiTangent * lineThickness_0);\n        texCoord.x = 0.0;\n      }\n      texCoord.y = 0.0;\n    }\n    else {\n      vec3 segmentEndDir = segmentDir;\n      if (seqentialIndex_1 != 0) {\n        //if index_1 == numPoints-1, get the first index in the line as next\n        int index_next = (index_1 < (positionsTextureSize-1)) ? (index_1+1) : 0;\n        vec4 data_next = fetchTexel(positionsTexture, positionsTextureSize, index_next);\n        vec4 pos_next = modelViewMatrix * vec4(data_next.xyz, 1.0);\n        segmentEndDir = normalize(segmentDir + normalize(pos_next.xyz - pos_1.xyz));\n        // segmentEndDir = segmentDir;\n      }\n      // vec3 endBiTangent = normalize(cross(segmentEndDir, viewVector));\n      // viewNormal = normalize(cross(segmentEndDir, endBiTangent));\n      vec3 endBiTangent = normalize(vec3(-segmentEndDir.y, segmentEndDir.x, 0.0));\n      viewNormal = normalize(-viewVector);\n      // Move the endpoints to overlap a bit more.\n      //viewPos += vec3(segmentEndDir * lineThickness_1 * 0.25);\n      if (mod(vertexIDs, 2.0) == 0.0) {\n        viewPos += vec3(endBiTangent * lineThickness_1);\n        texCoord.x = 1.0;\n      }\n      else {\n        viewPos -= vec3(endBiTangent * lineThickness_1);\n        texCoord.x = 0.0;\n      }\n      texCoord.y = 1.0;\n    }\n\n    // Move the line towards the viewer by the line thickness.\n    // this is to avoid depth issues when lines are rendered over meshes. \n    viewPos.z += (lineThickness_0 + lineThickness_1) * 0.5;\n  }\n\n  return viewPos;\n}\n\n"),Ft.setShaderModule("constants.glsl","#define GLSLIFY 1\n#define PI 3.141592653589793\n#define TwoPI (2.0 * PI)\n#define HalfPI (0.5 * PI)\n\n"),Ft.setShaderModule("convolve-helpers.glsl","#define GLSLIFY 1\n\n#ifdef ENVMAP_CUBE\n\nuniform samplerCube envMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture(envMap, dir);\n}\n\n#else \n\nuniform sampler2D   envMap;\n\nimport 'envmap-octahedral.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dirToSphOctUv(dir);\n  vec4 texel = texture2D(envMap, vec2(uv.x, 1.0 - uv.y));\n  return vec4(texel.rgb/texel.a, 1.0); // TODO: Check this line. Do we need it?\n}\n\n#endif \n\nvec3 cubeFaceUvToDir(float u, float v, int faceId) {\n\n  // normalize into [-1, 1] range\n  float n_u = 2.0 * u - 1.0;\n  float n_v = 2.0 * v - 1.0;\n\n  vec3 dir;\n  switch (faceId)\n  {\n  case 0: //TEXTURE_CUBE_MAP_POSITIVE_X:\n    dir.x = 1.0f;\n    dir.y = n_v;\n    dir.z = -n_u;\n    break;\n  case 1: //TEXTURE_CUBE_MAP_NEGATIVE_X:\n    dir.x = -1.0f;\n    dir.y = n_v;\n    dir.z = n_u;\n    break;\n  case 3: //TEXTURE_CUBE_MAP_POSITIVE_Y:\n    dir.x = n_u;\n    dir.y = 1.0f;\n    dir.z = -n_v;\n    break;\n  case 2: //TEXTURE_CUBE_MAP_NEGATIVE_Y:\n    dir.x = n_u;\n    dir.y = -1.0f;\n    dir.z = n_v;\n    break;\n  case 4: //TEXTURE_CUBE_MAP_POSITIVE_Z:\n    dir.x = n_u;\n    dir.y = n_v;\n    dir.z = 1.0f;\n    break;\n  case 5: //TEXTURE_CUBE_MAP_NEGATIVE_Z:\n    dir.x = -n_u;\n    dir.y = n_v;\n    dir.z = -1.0f;\n    break;\n  }\n  return normalize(dir);\n}\n\n"),Ft.setShaderModule("cutaways.glsl","#define GLSLIFY 1\nconst int GEOMITEM_FLAG_CUTAWAY = 1; // 1<<0;\nconst int GEOMITEM_INVISIBLE_IN_GEOMDATA = 2; // 1<<1;\n\n#define RAY_EPS 0.0000001\nstruct Ray {\n  vec3 start;\n  vec3 dir;\n};\n\nfloat intersectRayPlane(Ray ray, Ray plane) {\n  vec3 w = ray.start - plane.start;\n  float D = dot(plane.dir, ray.dir);\n  float N = dot(-plane.dir, w);\n\n  if (abs(D) < RAY_EPS) {\n    // segment is parallel to plane\n    if (N == 0.0)\n      return -1.0; // segment lies in plane\n    else\n      return -1.0; // no intersection\n  }\n  // they are not parallel\n  // compute intersect param\n  float sI = N / D;\n  if (sI < -RAY_EPS) {\n    return -1.0; // no intersection\n  }\n  return sI;\n}\n\nbool cutaway(vec3 worldPos, vec3 planeNormal, float planeDist) {\n\n  vec3 planePos = planeNormal * planeDist;\n  vec3 planeDir = worldPos + planePos;\n  float planeOffset = dot(planeDir, planeNormal);\n  if (planeOffset > 0.0) {\n    return true;\n  }\n  return false;\n}\n"),Ft.setShaderModule("debugColors.glsl","#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\n\nvec3 getDebugColor(float id) {\n  int sel = int(round(mod(round(id), 16.0)));\n  \n  if (sel==0)\n    return vec3(0.0, 1.0, 1.0);\n  else if (sel==1)\n    return vec3(0.0, 1.0, 0.0);\n  else if (sel==2)\n    return vec3(1.0, 0.0, 1.0);\n  else if (sel==3)\n    return vec3(0.75, 0.75, 0.0);\n  else if (sel==4)\n    return vec3(0.0, 0.75, 0.75);\n  else if (sel==5)\n    return vec3(0.75, 0.0, 0.75);\n  else if (sel==6)\n    return vec3(0.45, 0.95, 0.0);\n  else if (sel==7)\n    return vec3(0.0, 0.45, 0.95);\n  else if (sel==8)\n    return vec3(0.95, 0.0, 0.45);\n  else if (sel==9)\n    return vec3(0.95, 0.45, 0.0);\n  else if (sel==10)\n    return vec3(0.0, 0.95, 0.45);\n  else if (sel==11)\n    return vec3(0.45, 0.0, 0.95);\n  else if (sel==12)\n    return vec3(0.45, 0.45, 0.95);\n  else if (sel==13)\n    return vec3(0.0, 0.0, 0.45);\n  else if (sel==14)\n    return vec3(0.0, 0.45, 0.45);\n  else if (sel==15)\n    return vec3(0.45, 0.0, 0.45);\n  else return vec3(0.2, 0.2, 0.2);\n}\n\n"),Ft.setShaderModule("drawItemId.glsl","#define GLSLIFY 1\n\n#ifdef ENABLE_MULTI_DRAW\n\nuniform sampler2D drawIdsTexture;\n\n#ifdef EMULATE_MULTI_DRAW\n\nuniform int drawId;\nint getDrawItemId() {\n  return drawId;\n}\n\n#else // EMULATE_MULTI_DRAW\n\nint getDrawItemId() {\n  ivec2 drawIdsTextureSize = textureSize(drawIdsTexture, 0);\n  ivec2 drawIdsArrayCoords = ivec2(gl_DrawID % drawIdsTextureSize.x, gl_DrawID / drawIdsTextureSize.x);\n  return int(texelFetch(drawIdsTexture, drawIdsArrayCoords, 0).r + 0.5);\n}\n\n#endif // EMULATE_MULTI_DRAW\n\n#else // ENABLE_MULTI_DRAW\n\nuniform int drawItemId;\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\nattribute float instancedIds;    // instanced attribute..\nuniform int instancedDraw;\n\nint getDrawItemId() {\n  if (instancedDraw == 0) {\n    return drawItemId;\n  }\n  else {\n    return int(instancedIds);\n  }\n}\n\n#else\n\nint getDrawItemId() {\n  return drawItemId;\n}\n\n#endif // ENABLE_FLOAT_TEXTURES\n#endif // ENABLE_MULTI_DRAW\n\n"),Ft.setShaderModule("drawItemTexture.glsl","#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\nuniform sampler2D instancesTexture;\nuniform highp int instancesTextureSize;\n\nconst int pixelsPerItem = 6;\n\nvec4 getInstanceData(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 0);\n}\n\n#else\n\nuniform vec4 drawItemData;\n\nvec4 getInstanceData(int id) {\n  return drawItemData;\n}\n\n#endif\n\n"),Ft.setShaderModule("envmap-dualfisheye.glsl","#define GLSLIFY 1\n\nvec2 dualfisheyeUVsFromDir(vec3 dir) {\n  vec2 result;\n  float angle = 0.465;\n  if (dir.x < 0.0) {\n    result = vec2(((dir.z * -angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);\n  }\n  else {\n    result = vec2( 0.5 + ((dir.z * angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);\n  }\n  return result;\n}\n\n"),Ft.setShaderModule("envmap-equirect.glsl","#define GLSLIFY 1 \nimport 'constants.glsl'\n\nvec2 latLongUVsFromDir(vec3 dir) {\n  // Math function taken from...\n  // http://gl.ict.usc.edu/Data/HighResProbes/\n  // Note: Scaling from u=[0,2], v=[0,1] to u=[0,1], v=[0,1]\n  float phi = acos(dir.z);\n  float theta = atan(dir.x, dir.y);\n  return vec2((1.0 + theta / PI) / 2.0, phi / PI);\n}\n\n// Note: when u == 0.5 z = 1.0\nvec3 dirFromLatLongUVs(float u, float v) {\n  // http://gl.ict.usc.edu/Data/HighResProbes/\n  float theta = PI*((u * 2.0) - 1.0);\n  float phi = PI*v;\n  return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec3 dirFromPolar(vec2 polar) {\n  float u = polar.x / (PI * 2.0);\n  float v = polar.y / PI;\n  return dirFromLatLongUVs(u, v);\n}\n\n"),Ft.setShaderModule("envmap-octahedral.glsl","#define GLSLIFY 1\nimport 'constants.glsl'\nimport 'GLSLUtils.glsl'\n#define sectorize(value) step(0.0, (value))*2.0-1.0\n#define sum(value) dot(clamp((value), 1.0, 1.0), (value))\n\nvec2 dirToSphOctUv(vec3 normal) {\n  normal = normalize(normal);\n  vec3 aNorm = abs(normal);\n  vec3 sNorm = sectorize(normal);\n  \n  vec2 dir = aNorm.xy;\n  float orient = atan(dir.x, max(dir.y,0.0000000000000001))/HalfPI;\n\n  dir = vec2(aNorm.z, length(aNorm.xy));\n  float pitch = atan(dir.y, dir.x)/HalfPI;\n\n  vec2 uv = vec2(sNorm.x*orient, sNorm.y*(1.0-orient))*pitch;\n\n  if (normal.z < 0.0) {\n    uv = sNorm.xy - abs(uv.ts)*sNorm.xy;\n  }\n  vec2 res = uv*0.5+0.5;\n  // Flip-v\n  // return res;\n  return vec2(res.x, 1.0 - res.y);\n}\n\nvec3 sphOctUvToDir(vec2 uv) {\n  uv = uv*2.0-1.0;\n  // Flip-v\n  uv.y = -uv.y;\n  vec2 suv = sectorize(uv);\n  float sabsuv = sum(abs(uv));\n  float pitch = sabsuv*HalfPI;\n\n  if (pitch <= 0.0) {\n    return vec3(0.0, 0.0, 1.0);\n  }\n  if (abs(pitch - PI) < 0.000001) {\n    return vec3(0.0, 0.0, -1.0);\n  }\n  if (sabsuv > 1.0) {\n    uv = (1.0-abs(uv.ts))*suv;\n  }\n\n  float orient = (abs(uv.s)/sabsuv)*HalfPI;\n  float sOrient = sin(orient);\n  float cOrient = cos(orient);\n  float sPitch = sin(pitch);\n  float cPitch = cos(pitch);\n\n  return vec3(\n    sOrient*suv.s*sPitch,\n    cOrient*suv.t*sPitch,\n    cPitch\n  );\n}\n\n"),Ft.setShaderModule("GLSLBits.glsl",'#define GLSLIFY 1\n    \n/////////////////////////////////////////////////////////////////\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\nfloat shift_right(float v, float amt) {\n  v = floor(v) + 0.5;\n  return floor(v / exp2(amt));\n}\nfloat shift_left(float v, float amt) {\n  return floor(v * exp2(amt) + 0.5);\n}\n\nfloat mask_last(float v, float bits) {\n  return mod(v, shift_left(1.0, bits));\n}\nfloat extract_bits(float num, float from, float to) {\n  from = floor(from + 0.5);\n  to = floor(to + 0.5);\n  return mask_last(shift_right(num, from), to - from);\n}\n\n/////////////////////////////////////////////////////////////////\n// https://stackoverflow.com/questions/18453302/how-do-you-pack-one-32bit-int-into-4-8bit-ints-in-glsl-webgl\n\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\nvec4 EncodeFloatRGBA (float v) {\n  vec4 enc = bitEnc * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec2(1./255., 0.).xxxy;\n  return enc;\n}\nfloat DecodeFloatRGBA (vec4 v) {\n  return dot(v, bitDec);\n}\n\n/////////////////////////////////////////////////////////////////\n// https://gist.github.com/Flexi23/1713774\n// \nvec2 encode16BitFloatInto2xUInt8(float v) {\n  vec2 c = vec2(0.);\n\n  int signum = (v >= 0.) ? 128 : 0;\n  v = abs(v);\n  int exponent = 15;\n  float limit = 1024.; // considering the bias from 2^-5 to 2^10 (==1024)\n  for(int exp = 15; exp > 0; exp--) {\n    if ( v < limit) {\n      limit /= 2.;\n      exponent--;\n    }\n  }\n\n  float rest;\n  if (exponent == 0) {\n    rest = v / limit / 2.;      // "subnormalize" implicite preceding 0. \n  } \n  else {\n    rest = (v - limit)/limit;   // normalize accordingly to implicite preceding 1.\n  }\n\n  int mantissa = int(rest * 2048.);   // 2048 = 2^11 for the (split) 11 bit mantissa\n  int msb = mantissa / 256;           // the most significant 3 bits go into the lower part of the first byte\n  int lsb = mantissa - msb * 256;     // there go the other 8 bit of the lower significance\n\n  c.x = float(signum + exponent * 8 + msb) / 255.;    // color normalization for texture2D\n  c.y = float(lsb) / 255.;\n\n  if (v >= 2048.) {\n    c.y = 1.;\n  }\n\n  return c;\n}\n\nfloat decode16BitFloatFrom2xUInt8(vec2 c) {\n  float v = 0.;\n\n  int ix = int(c.x*255.); // 1st byte: 1 bit signum, 4 bits exponent, 3 bits mantissa (MSB)\n  int iy = int(c.y*255.); // 2nd byte: 8 bit mantissa (LSB)\n\n  int s = (c.x >= 0.5) ? 1 : -1;\n  ix = (s > 0) ? ix - 128 : ix;   // remove the signum bit from exponent\n  int iexp = ix / 8;              // cut off the last 3 bits of the mantissa to select the 4 exponent bits\n  int msb = ix - iexp * 8;        // subtract the exponent bits to select the 3 most significant bits of the mantissa\n\n  int norm = (iexp == 0) ? 0 : 2048;          // distinguish between normalized and subnormalized numbers\n  int mantissa = norm + msb * 256 + iy;       // implicite preceding 1 or 0 added here\n  norm = (iexp == 0) ? 1 : 0;                 // normalization toggle\n  float exponent = pow( 2., float(iexp + norm) - 16.); // -5 for the the exponent bias from 2^-5 to 2^10 plus another -11 for the normalized 12 bit mantissa \n  v = float( s * mantissa ) * exponent;\n\n  return v;\n}\n\n// TODO : Encoding Float32 to 4x UInt8\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\n// http://ultraist.hatenablog.com/entry/20110608/1307539319\n\n'),Ft.setShaderModule("GLSLUtils.glsl","#define GLSLIFY 1\n\nint ftoi(float val) {\n  return int(floor(val + 0.5));\n}\nivec2 ftoi(vec2 v2) {\n  return ivec2(ftoi(v2.x), ftoi(v2.y));\n}\nivec3 ftoi(vec3 v4) {\n  return ivec3(ftoi(v4.x), ftoi(v4.y), ftoi(v4.z));\n}\nivec4 ftoi(vec4 v4) {\n  return ivec4(ftoi(v4.x), ftoi(v4.y), ftoi(v4.z), ftoi(v4.w));\n}\n\n#ifdef ENABLE_ES3\n\nint imod(int x, int y) {\n  return x % y;\n}\n\nvoid setFlag(inout int flags, int flag) {\n  flags |= flag;\n}\n\nvoid clearFlag(inout int flags, int flag) {\n  flags &= ~flag;\n}\n\nbool testFlag(int flags, int flag) {\n  return (flags & flag) != 0;\n}\n\n// private function: Mangle me...\nivec2 _pixelIndexToUV(int index, int textureWidth) {\n  return ivec2(index % textureWidth, index / textureWidth);\n}\n\nvec4 fetchTexel(sampler2D texture, int textureWidth, int index) {\n  return texelFetch(texture, _pixelIndexToUV(index, textureWidth), 0);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {\n  return texelFetch(texture, texCoord, 0);\n}\n\n#else\n\n// TODO: integrate: https://gist.github.com/mattatz/70b96f8c57d4ba1ad2cd\n\nint max(int a, int b) {\n  return a > b ? a : b;\n}\nint min(int a, int b) {\n  return a < b ? a : b;\n}\n\nfloat round(float val) {\n  return floor(val + 0.4);\n}\n\nint imod(int x, int y) {\n  return x-y*(x/y);\n}\n\nvoid setFlag(inout int flags, int flag) {\n  flags += flag;\n}\nvoid clearFlag(inout int flags, int flag) {\n  flags -= flag;\n}\n\nbool testFlag(int flags, int flag) {\n  return imod(flags / flag, 2) != 0;\n}\n\n// private function: Mangle me...\nvec2 _pixelIndexToUV(int index, int textureSize) {\n  float flTexSize = float(textureSize);\n  float x = (float(imod(index, textureSize))+0.5)/flTexSize;\n  float y = (floor(float(index / textureSize))+0.5)/flTexSize;\n  return vec2(x, y);\n}\n\nvec4 fetchTexel(sampler2D texture, int textureSize, int index) {\n  vec2 texCoord = _pixelIndexToUV(index, textureSize);\n  return texture2D(texture, texCoord);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {\n  vec2 ftextureSize = vec2(textureSize);\n  return texture2D(texture, (vec2(texCoord) + 0.5) / ftextureSize);\n}\n\n#endif // ENABLE_ES3\n\nint uvToPixelIndex(vec2 uv, int textureSize) {\n  return int(uv.x * float(textureSize)) + (int(floor(uv.y * float(textureSize))) * textureSize);\n}\n\n"),Ft.setShaderModule("Hammersley.glsl","#define GLSLIFY 1\nfloat RadicalInverse_VdC(uint bits) \n{\n  bits = (bits << 16u) | (bits >> 16u);\n  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n  return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n  return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n} \n"),Ft.setShaderModule("ImportanceSampleGGX.glsl","#define GLSLIFY 1\nimport 'constants.glsl'\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n  float a = roughness*roughness;\n\n  float phi = 2.0 * PI * Xi.x;\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n  // from spherical coordinates to cartesian coordinates\n  vec3 H = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\n  // from tangent-space vector to world-space sample vector\n  vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n} \n"),Ft.setShaderModule("materialparams.glsl","#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nimport 'gamma.glsl'\n\n#ifdef ENABLE_MULTI_DRAW\n \nuniform sampler2D materialsTexture;\nuniform highp ivec2 materialsTextureSize;\n\nvec4 getMaterialValue(vec2 materialCoords, int valueIndex) {\n  int index = ftoi(materialCoords.x) + valueIndex;\n  ivec2 texelCoords = ivec2(imod(index, materialsTextureSize.x), index / materialsTextureSize.x);\n  \n  return fetchTexel(materialsTexture, materialsTextureSize, texelCoords);\n}\n\n#else // ENABLE_MULTI_DRAW\n\n////////////////////////\n// Material Param Helpers.\n\nvec4 getColorParamValue(vec4 value, sampler2D tex, int texType, vec2 texCoord) {\n  if (texType == 0) {\n    return toLinear(value);\n  }\n  else if (texType == 1 || texType == 2) {\n    // TODO: Use SRGB textures.\n    return toLinear(texture2D(tex, texCoord));\n  }\n  else if (texType == 3) {\n    // Float HDR Texture\n    return texture2D(tex, texCoord);\n  }\n  else\n    return value;\n}\n\nfloat luminanceFromRGB(vec3 rgb) {\n  return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\nfloat getLuminanceParamValue(float value, sampler2D tex, int texType, vec2 texCoord) {\n  if (texType == 0)\n    return value;\n  else\n    return luminanceFromRGB(texture2D(tex, texCoord).rgb);\n}\n\n#endif // ENABLE_MULTI_DRAW\n"),Ft.setShaderModule("modelMatrix.glsl","#define GLSLIFY 1\n#ifdef ENABLE_FLOAT_TEXTURES\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n  // Unpack 3 x 4 matrix columns into a 4 x 4 matrix.\n  vec4 col0 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 1);\n  vec4 col1 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 2);\n  vec4 col2 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 3);\n  mat4 result = transpose(mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0)));\n  return result;\n}\n\nmat4 getModelMatrix(int id) {\n  return getMatrix(instancesTexture, instancesTextureSize, id);\n}\n\n#else\n\nuniform mat4 modelMatrix;\n\nmat4 getModelMatrix(int id) {\n  return modelMatrix;\n}\n\n#endif\n\n"),Ft.setShaderModule("PBRSurfaceRadiance.glsl","#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nconst int ENVMAP_FLAG_HEADLIGHT =  1; // 1<<0;\n\nstruct MaterialParams {\n  vec3 baseColor;\n  float ambientOcclusion;\n  float metallic;\n  float roughness;\n  float reflectance;\n  float opacity;\n  float emission;\n};\n\n#ifndef ENABLE_PBR\n\nvec4 pbrSurfaceRadiance(in MaterialParams material, vec3 normal, in vec3 viewVector) {\n  vec3 irradiance = vec3(dot(normal, viewVector));\n  float ao = material.ambientOcclusion; \n  return vec4(material.baseColor * ao * irradiance + (material.emission * material.baseColor), material.opacity);\n\n  // return vec4(material.baseColor * ao * irradiance , material.opacity);\n}\n\n#else\n\nuniform int envMapFlags;\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D brdfLUT;\n\nvec3 sampleIrradiance(vec3 dir) {\n  return texture(irradianceMap, dir).rgb;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat luminance(vec3 color) {\n  return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n}\n\nvec4 pbrSurfaceRadiance(in MaterialParams material, vec3 normal, in vec3 viewVector) {\n  if (envMapFlags == -1) {\n    vec3 irradiance = vec3(dot(normal, viewVector));\n    float ao = material.ambientOcclusion; \n    return vec4(material.baseColor * ao * irradiance + (material.emission * material.baseColor), material.opacity);\n  }\n\n  vec3 N = normal;\n  vec3 V = viewVector;\n  vec3 R = reflect(-V, N);\n  float roughness = material.roughness * material.roughness;\n  vec3 diffuseColor = (1.0 - material.metallic) * material.baseColor;\n\n  // Note: The specular reflectance of metallic surfaces is chromatic\n  // https://google.github.io/filament/Filament.html#listing_fnormal\n  vec3 F0 = 0.16 * material.reflectance * material.reflectance * (1.0 - material.metallic) + material.baseColor * material.metallic;\n\n  float NdotV = dot(N, V);\n\n  vec3 F = fresnelSchlickRoughness(max(NdotV, 0.0), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - material.metallic;\n  float ao = material.ambientOcclusion; \n  \n  vec3 irradiance;\n  vec3 irradianceSampleDir = normal;\n  \n  bool headLightMode = testFlag(envMapFlags, ENVMAP_FLAG_HEADLIGHT);\n  if (headLightMode) {\n    irradianceSampleDir = viewVector;\n  }\n  irradiance = sampleIrradiance(irradianceSampleDir);\n  // vec3 irradiance = shGetIrradianceAt(shCoefficients, N);\n  vec3 diffuse    = irradiance * diffuseColor;\n  \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;   \n  vec2 envBRDF  = texture(brdfLUT, vec2(max(NdotV, 0.0), roughness)).rg;\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n  \n  vec3 radiance = (kD * diffuse + specular) * ao;\n  \n  // Now handle semi-transparent objects. We need to be able to linearly interpolate\n  // opacity to make objects disappear, so we need a continuous change.\n  float opacity = material.opacity;\n  vec4 transparent = vec4((radiance * opacity) + specular, opacity + luminance(specular) + luminance(F));\n  vec4 result = mix(transparent, vec4(radiance, 1.0), opacity);\n\n  // Add emission on as the final component.\n  // Note: emission allows a material to blend off its specular component, \n  // which can also be used to make an object completely disappear if also transparent.\n  return mix(result, vec4(material.baseColor, opacity), material.emission);\n}\n\n#endif // ENABLE_PBR\n"),Ft.setShaderModule("SHCoeffs.glsl","#define GLSLIFY 1\nuniform vec3 shCoeffs[9];\n\nvec3 sampleSHCoeffs(vec3 dir) {\n  // dir is assumed to have unit length\n  float x = dir.x, y = dir.y, z = dir.z;\n  // band 0\n  vec3 result = shCoeffs[ 0 ] * 0.886227;\n  // band 1\n  result += shCoeffs[ 1 ] * 2.0 * 0.511664 * y;\n  result += shCoeffs[ 2 ] * 2.0 * 0.511664 * z;\n  result += shCoeffs[ 3 ] * 2.0 * 0.511664 * x;\n  // band 2\n  result += shCoeffs[ 4 ] * 2.0 * 0.429043 * x * y;\n  result += shCoeffs[ 5 ] * 2.0 * 0.429043 * y * z;\n  result += shCoeffs[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n  result += shCoeffs[ 7 ] * 2.0 * 0.429043 * x * z;\n  result += shCoeffs[ 8 ] * 0.429043 * ( x * x - y * y );\n  return result;\n}\n"),Ft.setShaderModule("gamma.glsl","#define GLSLIFY 1\nconst float gamma_const = 2.2;\n\nfloat toLinear(float v) {\n  return pow(v, gamma_const);\n}\n\nvec2 toLinear(vec2 v) {\n  return pow(v, vec2(gamma_const));\n}\n\nvec3 toLinear(vec3 v) {\n  return pow(v, vec3(gamma_const));\n}\n\nvec4 toLinear(vec4 v) {\n  return vec4(toLinear(v.rgb), v.a);\n}\n\nfloat toGamma(float v) {\n  return pow(v, 1.0 / gamma_const);\n}\n\nvec2 toGamma(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_const));\n}\n\nvec3 toGamma(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_const));\n}\n\nvec4 toGamma(vec4 v) {\n  return vec4(toGamma(v.rgb), v.a);\n}\n\nfloat toGamma(float v, float gamma) {\n  return pow(v, 1.0 / gamma);\n}\n\nvec2 toGamma(vec2 v, float gamma) {\n  return pow(v, vec2(1.0 / gamma));\n}\n\nvec3 toGamma(vec3 v, float gamma) {\n  return pow(v, vec3(1.0 / gamma));\n}\n\nvec4 toGamma(vec4 v, float gamma) {\n  return vec4(toGamma(v.rgb, gamma), v.a);\n}\n\n"),Ft.setShaderModule("inverse.glsl","#define GLSLIFY 1\n\n#ifndef ENABLE_ES3\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n#endif\n\n"),Ft.setShaderModule("transpose.glsl","#define GLSLIFY 1\n\n#ifndef ENABLE_ES3\n\nfloat transpose(float m) {\n  return m;\n}\n\nmat2 transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n#endif\n\n"),Ft.setShaderModule("quadVertexFromID.glsl","#define GLSLIFY 1\nattribute float vertexIDs;\n\nvec2 getQuadVertexPositionFromID() {\n  int vertexID = int(vertexIDs);\n  if (vertexID == 0)\n    return vec2(-0.5, -0.5);\n  else if (vertexID == 1)\n    return vec2(0.5, -0.5);\n  else if (vertexID == 2)\n    return vec2(-0.5, 0.5);\n  else if (vertexID == 3)\n    return vec2(0.5, 0.5);\n  return vec2(0,0);\n}\n"),Ft.setShaderModule("unpackHDR.glsl","#define GLSLIFY 1\n\nvec3 decodeHDR(const in vec3 ldrPixel, const in float cdmAlpha) {\n  float avg = (cdmAlpha * 16.0 - 8.0);\n  float scl = 1.0;\n  vec3 color;\n  color.x = (tan((ldrPixel.x-0.5)*1.5)/scl)+avg;\n  color.y = (tan((ldrPixel.y-0.5)*1.5)/scl)+avg;\n  color.z = (tan((ldrPixel.z-0.5)*1.5)/scl)+avg;\n\n  // convert from logarithmic curve to linear curve.\n  // subtract the epsilon that was added during encoding.\n  const float eps = 0.001;\n  color.x = pow(10.0, color.x) - eps;\n  color.y = pow(10.0, color.y) - eps;\n  color.z = pow(10.0, color.z) - eps;\n  return color;\n}\n\nvec3 decodeHDR(sampler2D ldrSampler, sampler2D cdmSampler, vec2 texCoord) {\n#ifdef ENABLE_ES3\n  float cdm = texture2D(cdmSampler, texCoord).r;\n#else\n  float cdm = texture2D(cdmSampler, texCoord).a;\n#endif\n  return decodeHDR(texture2D(ldrSampler, texCoord).rgb, cdm);\n}\n\n");class nt extends tt{constructor(U){super(U,"UnpackHDRShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"),this.setShaderStage("FRAGMENT_SHADER"," \nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2 v_texCoord;\nuniform sampler2D ldrSampler;\nuniform sampler2D cdmSampler;\nuniform vec4 srcRegion; // pos, and size of the source region\n\nimport 'unpackHDR.glsl'\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 srcUv = srcRegion.xy + (v_texCoord * srcRegion.zw);\n\n  fragColor = vec4(decodeHDR(ldrSampler, cdmSampler, srcUv), 1.0);\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n")}}const at=(U,F)=>{let e,t,Q;switch(F){case"UInt8":e=1,t=4,Q=U.UNSIGNED_BYTE;break;case"SInt8":e=1,t=4,Q=U.BYTE;break;case"UInt16":e=1,t=4,Q=U.UNSIGNED_SHORT;break;case"SInt16":e=1,t=4,Q=U.SHORT;break;case"UInt32":e=1,t=4,Q=U.UNSIGNED_INT;break;case"SInt32":e=1,t=4,Q=U.INT;break;case"Float32":e=1,t=4,Q=U.FLOAT;break;case"Vec2":e=2,t=4,Q=U.FLOAT;break;case"Vec3":e=3,t=4,Q=U.FLOAT;break;case"Vec4":case"Color":e=4,t=4,Q=U.FLOAT;break;case"RGBA":e=4,t=1,Q=U.UNSIGNED_BYTE;break;default:throw"Unhandled Type"}return{dimension:e,elementSize:t,dataType:Q}};class dt{}class it extends dt{constructor(U,F,e,t){super(),this.gl=U,this.shaderAttrs=F,this.glattrbuffers=e,this.indexBuffer=t}bind(U){const F=this.gl;for(const U in this.shaderAttrs){if("instancedIds"==U)continue;const e=this.shaderAttrs[U],t=e.location;if(-1==t)continue;const Q=this.glattrbuffers[U];if(!Q){F.disableVertexAttribArray(t);continue}const l=at(this.gl,Q.dataType),n=l.dimension*l.elementSize,a=null!=Q.offset?Q.offset*l.dimension*l.elementSize:0,d=1==Q.normalized,i=e.instanced;F.enableVertexAttribArray(t),F.bindBuffer(F.ARRAY_BUFFER,Q.buffer),F.vertexAttribPointer(t,l.dimension,l.dataType,d,n,a),F.vertexAttribDivisor&&(1==i?F.vertexAttribDivisor(t,1):F.vertexAttribDivisor(t,0))}return F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,this.indexBuffer),!0}unbind(){const U=this.gl;for(const F in this.shaderAttrs){const e=this.shaderAttrs[F],t=e.location;-1==t&&U.enableVertexAttribArray(t),e.instanced&&U.vertexAttribDivisor(t,0)}U.bindBuffer(U.ELEMENT_ARRAY_BUFFER,null)}destroy(){}}class st extends dt{constructor(U,F,e,t){super(),this.gl=U,this.vao=U.createVertexArray(),U.bindVertexArray(this.vao);for(const t in F){if("instancedIds"==t)continue;const Q=F[t],l=Q.location;if(-1==l)continue;let n=e[t];if(!n&&(t.endsWith("Next")&&(n=e[t.substring(0,t.length-4)],Q.offset=1),!n)){U.disableVertexAttribArray(l);continue}const a=at(U,n.dataType),d=a.dimension*a.elementSize,i=null!=Q.offset?Q.offset*a.dimension*a.elementSize:0,s=1==n.normalized,R=Q.instanced;U.enableVertexAttribArray(l),U.bindBuffer(U.ARRAY_BUFFER,n.buffer),U.vertexAttribPointer(l,a.dimension,a.dataType,s,d,i),U.vertexAttribDivisor&&(1==R?U.vertexAttribDivisor(l,1):U.vertexAttribDivisor(l,0))}this.indexBuffer=t,this.indexBuffer&&U.bindBuffer(U.ELEMENT_ARRAY_BUFFER,this.indexBuffer)}bind(U){const F=this.gl;return F.bindVertexArray(this.vao),this.indexBuffer&&F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,this.indexBuffer),!0}unbind(){const U=this.gl;U.bindVertexArray(null),this.indexBuffer&&U.bindBuffer(U.ELEMENT_ARRAY_BUFFER,null)}destroy(){const U=this.gl;this.indexBuffer&&(U.bindVertexArray(this.vao),U.bindBuffer(U.ELEMENT_ARRAY_BUFFER,null)),U.deleteVertexArray(this.vao)}}function Rt(U,F,e,t){return null==U.createVertexArray?new it(U,F,e,t):new st(U,F,e,t)}class Bt extends Ae{constructor(U,F){super(U),this.listenerIDs={},this.fbo=null,this.srcLDRTex=null,this.srcCDMTex=null,this.unpackHDRShader=null,this.shaderBinding=null,this.hdrImage=F,this.hdrImage.setMetadata("gltexture",this);const e=()=>{this.__unpackHDRImage(this.hdrImage.getParams())};this.listenerIDs.updated=this.hdrImage.on("updated",e),this.hdrImage.isLoaded()?e():this.listenerIDs.loaded=this.hdrImage.on("loaded",e)}getImage(){return this.hdrImage}__unpackHDRImage(U){const F=this.__gl,e=U.data.ldr,t=U.data.cdm;if(this.fbo)this.srcLDRTex.bufferData(e),this.srcCDMTex.bufferData(t);else{this.configure({format:"RGBA",type:"FLOAT",width:e.width,height:e.height,filter:"LINEAR",wrap:"CLAMP_TO_EDGE"}),this.fbo=new Qt(this.__gl,this),this.fbo.setClearColor(new B(0,0,0,0)),this.srcLDRTex=new Ae(this.__gl,{format:"RGB",type:"UNSIGNED_BYTE",width:e.width,height:e.height,filter:"NEAREST",mipMapped:!1,wrap:"CLAMP_TO_EDGE",data:e}),this.srcCDMTex=new Ae(this.__gl,{format:"webgl2"==F.name?"RED":"ALPHA",type:"UNSIGNED_BYTE",width:e.width,height:e.height,filter:"NEAREST",mipMapped:!1,wrap:"CLAMP_TO_EDGE",data:t}),this.unpackHDRShader=new nt(this.__gl);const U=this.unpackHDRShader.compileForTarget("GLHDRImage",{directives:["#define ENABLE_ES3"]});this.shaderBinding=Rt(this.__gl,U.attrs,F.__quadattrbuffers,F.__quadIndexBuffer)}this.fbo.bindAndClear();const Q={};this.unpackHDRShader.bind(Q,"GLHDRImage"),this.shaderBinding.bind(Q);const l=Q.unifs;this.srcLDRTex.bindToUniform(Q,l.ldrSampler),this.srcCDMTex.bindToUniform(Q,l.cdmSampler),F.uniform4fv(l.srcRegion.location,[0,0,1,1]),F.drawQuad(),this.fbo.unbind(),this.emit("updated")}bindToUniform(U,F,e){return super.bindToUniform(U,F,e)}destroy(){super.destroy(),this.fbo&&(this.fbo.destroy(),this.srcLDRTex.destroy(),this.srcCDMTex.destroy()),this.unpackHDRShader&&this.unpackHDRShader.destroy(),this.shaderBinding&&this.shaderBinding.destroy(),"loaded"in this.listenerIDs&&this.hdrImage.removeListenerById("loaded",this.listenerIDs.loaded),this.hdrImage.removeListenerById("updated",this.listenerIDs.updated)}}class Vt extends tt{constructor(U){super(U,"PreComputeBRDFShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2 v_texCoord;\n\nimport 'GLSLUtils.glsl'\nimport 'Hammersley.glsl'\nimport 'ImportanceSampleGGX.glsl'\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n  float a = roughness;\n  float k = (a * a) / 2.0;\n\n  float nom   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n  vec3 V;\n  V.x = sqrt(1.0 - NdotV*NdotV);\n  V.y = 0.0;\n  V.z = NdotV;\n\n  float A = 0.0;\n  float B = 0.0;\n\n  vec3 N = vec3(0.0, 0.0, 1.0);\n\n  for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n  {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(L.z, 0.0);\n    float NdotH = max(H.z, 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    if (NdotL > 0.0)\n    {\n      float G = GeometrySmith(N, V, L, roughness);\n      float G_Vis = (G * VdotH) / (NdotH * NdotV);\n      float Fc = pow(1.0 - VdotH, 5.0);\n\n      A += (1.0 - Fc) * G_Vis;\n      B += Fc * G_Vis;\n    }\n  }\n  A /= float(SAMPLE_COUNT);\n  B /= float(SAMPLE_COUNT);\n  return vec2(A, B);\n}\n\nout vec2 fragColor;\nvoid main(void) {\n  vec2 integratedBRDF = IntegrateBRDF(v_texCoord.x, v_texCoord.y);\n  fragColor = integratedBRDF;\n}\n\n")}}class rt extends tt{constructor(U){super(U,"ConvolveIrradianceShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\nimport 'constants.glsl'\nimport 'convolve-helpers.glsl'\n\nuniform float roughness;\nuniform int faceId;\nvarying vec2 v_texCoord;\n\nout vec4 fragColor;\nvoid main(void) {\n\n  vec3 N = cubeFaceUvToDir(v_texCoord.x, v_texCoord.y, faceId);   \n\n  vec3 irradiance = vec3(0.0);\n\n  vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\n  float nrSamples = 0.0; \n  for(float phi = 0.0; phi < 2.0 * PI; phi += SAMPLE_DELTA)\n  {\n    for(float theta = 0.0; theta < 0.5 * PI; theta += SAMPLE_DELTA)\n    {\n      // spherical to cartesian (in tangent space)\n      // from spherical coordinates to cartesian coordinates\n      vec3 H = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n      // tangent space to world\n      vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\n      irradiance += sampleEnvMap(normalize(sampleVec)).rgb * cos(theta) * sin(theta);\n      nrSamples++;\n    }\n  }\n  irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n  fragColor = vec4(irradiance, 1.0);\n}\n")}}class ht extends tt{constructor(U){super(U,"ConvolveSpecularShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"),this.setShaderStage("FRAGMENT_SHADER","precision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'ImportanceSampleGGX.glsl'\nimport 'convolve-helpers.glsl'\nimport 'Hammersley.glsl'\n  \n  \nuniform float roughness;\nuniform int faceId;\nvarying vec2 v_texCoord;\n\nout vec4 fragColor;\nvoid main(void) {\n\n  vec3 N = cubeFaceUvToDir(v_texCoord.x, v_texCoord.y, faceId);   \n\n  vec3 R = N;\n  vec3 V = R;\n\n  float totalWeight = 0.0;   \n  vec3 prefilteredColor = vec3(0.0);     \n  for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n  {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(dot(N, L), 0.0);\n    if (NdotL > 0.0)\n    {\n      prefilteredColor += sampleEnvMap(L).rgb * NdotL;\n      totalWeight      += NdotL;\n    }\n  }\n  prefilteredColor = prefilteredColor / totalWeight;\n\n  fragColor = vec4(prefilteredColor, 1.0);\n}\n")}}class ot extends k{constructor(U,F){super(),this.__gl=U;const e=U;this.maxFragmentShaderTextureUnits=U.getParameter(this.__gl.MAX_TEXTURE_IMAGE_UNITS),e.__quadVertexIdsBuffer||e.setupInstancedQuad(),this.textureType=1,this.textureDesc=[0,0,0,0],this.__convolved=!1,this.__fbos=[]}convolveProbe(U){const F=this.__gl,t={shaderopts:{directives:["#define ENABLE_ES3","#define ENABLE_FLOAT_TEXTURES"]}};"Low"==e.deviceCategory?(t.shaderopts.directives.push("#define SAMPLE_DELTA 0.1"),t.shaderopts.directives.push("#define SAMPLE_COUNT 64u")):"Medium"==e.deviceCategory?(t.shaderopts.directives.push("#define SAMPLE_DELTA 0.08"),t.shaderopts.directives.push("#define SAMPLE_COUNT 256u")):(t.shaderopts.directives.push("#define SAMPLE_DELTA 0.025"),t.shaderopts.directives.push("#define SAMPLE_COUNT 1024u")),this.brdfLUTTexture=F.createTexture(),F.bindTexture(F.TEXTURE_2D,this.brdfLUTTexture),F.texImage2D(F.TEXTURE_2D,0,F.RG16F,512,512,0,F.RG,F.FLOAT,null),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_S,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_T,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MIN_FILTER,F.LINEAR),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MAG_FILTER,F.LINEAR);const Q=new Vt(this.__gl),l=Q.compileForTarget("GLProbe",t.shaderopts),n=Rt(this.__gl,l.attrs,F.__quadattrbuffers,F.__quadIndexBuffer),a=F.createFramebuffer();F.bindFramebuffer(F.DRAW_FRAMEBUFFER,a),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,this.brdfLUTTexture,0),Q.bind(t),n.bind(t),F.clear(F.COLOR_BUFFER_BIT|F.DEPTH_BUFFER_BIT),F.viewport(0,0,512,512),F.drawQuad(),F.bindFramebuffer(F.DRAW_FRAMEBUFFER,null),F.deleteFramebuffer(a),Q.unbind(t),Q.destroy();{const e=new rt(this.__gl),Q=e.compileForTarget("GLProbe",t.shaderopts),l=Rt(this.__gl,Q.attrs,F.__quadattrbuffers,F.__quadIndexBuffer);e.bind(t,"GLProbe"),l.bind(t);const n=t.unifs;U.bindToUniform(t,n.envMap);const a=64;this.irradianceCubeTex=F.createTexture(),F.bindTexture(F.TEXTURE_CUBE_MAP,this.irradianceCubeTex),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_MAG_FILTER,F.LINEAR),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_MIN_FILTER,F.LINEAR_MIPMAP_LINEAR),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_WRAP_S,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_WRAP_T,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_WRAP_R,F.CLAMP_TO_EDGE);for(let U=0;U<6;U++)F.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+U,0,F.RGBA32F,a,a,0,F.RGBA,F.FLOAT,null);const d=F.createFramebuffer();F.bindFramebuffer(F.DRAW_FRAMEBUFFER,d);for(let U=0;U<6;++U)F.uniform1i(n.faceId.location,U),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+U,this.irradianceCubeTex,0),F.viewport(0,0,a,a),F.clearColor(1,0,0,1),F.clear(F.COLOR_BUFFER_BIT|F.DEPTH_BUFFER_BIT),F.drawQuad();F.bindFramebuffer(F.DRAW_FRAMEBUFFER,null),F.deleteFramebuffer(d),F.generateMipmap(F.TEXTURE_CUBE_MAP)}{const e=new ht(this.__gl),Q=e.compileForTarget("GLProbe",t.shaderopts),l=Rt(this.__gl,Q.attrs,F.__quadattrbuffers,F.__quadIndexBuffer);e.bind(t,"GLProbe"),l.bind(t);const n=t.unifs;U.bindToUniform(t,n.envMap),this.specularCubetex=F.createTexture(),F.bindTexture(F.TEXTURE_CUBE_MAP,this.specularCubetex),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_MAG_FILTER,F.LINEAR),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_MIN_FILTER,F.LINEAR_MIPMAP_LINEAR),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_WRAP_S,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_WRAP_T,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_CUBE_MAP,F.TEXTURE_WRAP_R,F.CLAMP_TO_EDGE);const a=256;for(let U=0;U<6;U++)F.texImage2D(F.TEXTURE_CUBE_MAP_POSITIVE_X+U,0,F.RGBA32F,a,a,0,F.RGBA,F.FLOAT,null);F.generateMipmap(F.TEXTURE_CUBE_MAP);const d=5;for(let U=0;U<d;++U){const e=a*Math.pow(.5,U),t=a*Math.pow(.5,U),Q=F.createFramebuffer();F.bindFramebuffer(F.DRAW_FRAMEBUFFER,Q),F.viewport(0,0,e,t);const l=U/(d-1);F.uniform1f(n.roughness.location,l);for(let e=0;e<6;++e)F.uniform1i(n.faceId.location,e),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+e,this.specularCubetex,U),F.drawQuad();F.bindFramebuffer(F.DRAW_FRAMEBUFFER,null),F.deleteFramebuffer(Q)}e.destroy()}this.__convolved=!0}bind(U){const F=this.__gl,{irradianceMap:e,prefilterMap:t,brdfLUT:Q,envMapFlags:l}=U.unifs;if(!this.__convolved)return e&&F.uniform1i(e.location,this.maxFragmentShaderTextureUnits-1),t&&F.uniform1i(t.location,this.maxFragmentShaderTextureUnits-1),l&&F.uniform1i(l.location,-1),!1;if(Q){const e=U.boundTextures++;F.activeTexture(this.__gl.TEXTURE0+e),F.bindTexture(F.TEXTURE_2D,this.brdfLUTTexture),F.uniform1i(Q.location,e)}if(e){const t=U.boundTextures++,Q=this.__gl.TEXTURE0+t;F.activeTexture(Q),F.bindTexture(F.TEXTURE_CUBE_MAP,this.irradianceCubeTex),F.uniform1i(e.location,t)}if(t){const e=U.boundTextures++,Q=this.__gl.TEXTURE0+e;F.activeTexture(Q),F.bindTexture(F.TEXTURE_CUBE_MAP,this.specularCubetex),F.uniform1i(t.location,e)}return l&&F.uniform1i(l.location,0),!0}destroy(){}}class Jt extends tt{constructor(U){super(U,"EnvMapShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n\nimport 'inverse.glsl'\nimport 'transpose.glsl'\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID() * 2.0;\n  v_texCoord = position * 0.5 + 0.5;\n\n  mat4 inverseProjection = inverse(projectionMatrix);\n  mat3 inverseModelview = transpose(mat3(viewMatrix));\n\n  // transform from the normalized device coordinates back to the view space\n  vec3 unprojected = (inverseProjection * vec4(position, 0, 1)).xyz;\n\n  // transfrom from the view space back to the world space\n  // and use it as a sampling vector\n  v_worldDir = inverseModelview * unprojected;\n\n  gl_Position = vec4(position, 0, 1);\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'gamma.glsl'\nimport 'constants.glsl'\n\nuniform float focus;\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n\n#define ENABLE_INLINE_GAMMACORRECTION\n\n#define ENV_MAP_LATLONG 0\n#define ENV_MAP_OCT 1\n#define ENV_MAP_CUBE 2\n#define ENV_MAP_irradianceMap 8\n#define ENV_MAP_prefilterMap 3\n#define ENV_MAP_STEREO_LATLONG 4\n#define ENV_MAP_DUALFISHEYE 5\n#define ENV_MAP_SH 6\n#define ENV_MAP_BRDF_LUT 7\n\n#define ENV_MAPTYPE ENV_MAP_OCT\n\n#if (ENV_MAPTYPE == ENV_MAP_LATLONG)  \n\nimport 'envmap-equirect.glsl'\n\nuniform sampler2D backgroundImage;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = latLongUVsFromDir(normalize(dir));\n  vec4 texel = texture2D(backgroundImage, uv) * exposure;\n  return vec4(texel.rgb/texel.a, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_OCT)  \n\nimport 'envmap-octahedral.glsl'\n\nuniform sampler2D   envMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dirToSphOctUv(normalize(dir));\n  if (false) {\n    vec4 texel = texture2D(envMap, uv);\n    return vec4(texel.rgb/texel.a, 1.0);\n  }\n  else {\n    return texture2D(envMap, uv) * exposure;\n  }\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_CUBE)\n\nuniform samplerCube cubeMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture(cubeMap, dir, 0.0);// * exposure;\n  // return textureLod(cubeMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_irradianceMap)\n\nuniform samplerCube irradianceMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return textureLod(irradianceMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_prefilterMap)\n\nuniform samplerCube prefilterMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return textureLod(prefilterMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_STEREO_LATLONG)  \n\nimport 'envmap-equirect.glsl'\nuniform int eye;// L = 0, R = 1;\nuniform sampler2D backgroundImage;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = latLongUVsFromDir(normalize(v_worldDir));\n  uv.y *= 0.5;\n  if (eye == 1) {\n    uv.y += 0.5;\n  }\n  vec4 texel = texture2D(backgroundImage, uv) * exposure;\n  fragColor = vec4(texel.rgb/texel.a, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_DUALFISHEYE)\n\nimport 'envmap-dualfisheye.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dualfisheyeUVsFromDir(dir);\n  return texture2D(backgroundImage, uv) * exposure;\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_SH)\n\nimport 'SHCoeffs.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n\treturn vec4(sampleSHCoeffs(dir) * exposure, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_BRDF_LUT)\n\nuniform sampler2D brdfLUT;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture2D(brdfLUT, v_texCoord);\n}\n#endif\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = sampleEnvMap(normalize(v_worldDir));\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}}class Zt extends ot{constructor(U,F){super(U.gl,"EnvMap"),this.__srcGLTex=null,this.__envMapShader=null,this.__envMapShaderBinding=null,this.__renderer=U,this.__envMap=F,this.__backgroundFocus=0,this.__envMap.isLoaded()?this.init():this.__envMap.once("loaded",(U=>{this.init()}))}init(){const U=this.__renderer.gl;U.__quadVertexIdsBuffer||U.setupInstancedQuad(),this.__srcGLTex=new Bt(U,this.__envMap),this.__envMapShader=new Jt(U);const F=this.__envMapShader.compileForTarget("GLEnvMap",{directives:["#define ENABLE_ES3"]});this.__envMapShaderBinding=Rt(U,F.attrs,U.__quadattrbuffers,U.__quadIndexBuffer);const e=this.__envMap.headlightModeParam,t=()=>{e.value?this.textureDesc[3]|=1:this.textureDesc[3]&=-2};t(),e.on("valueChanged",(()=>{t(),this.emit("updated")})),this.convolveProbe(this.__srcGLTex),this.emit("updated")}getEnvMap(){return this.__envMap}getBackgroundFocus(){return this.__backgroundFocus}setBackgroundFocus(U){this.__backgroundFocus=U,this.__renderer.requestRedraw()}draw(U){if(this.__envMap.isLoaded()){const F=this.__gl;{this.__envMapShader.bind(U,"GLEnvMap");const e=U.unifs,{envMap:t,focus:Q,exposure:l}=U.unifs;t&&this.__srcGLTex.bindToUniform(U,t),Q&&F.uniform1f(Q.location,this.__backgroundFocus),l&&F.uniform1f(l.location,U.exposure),this.__envMapShaderBinding.bind(U),F.depthMask(!1),U.bindViewports(e,(()=>{F.drawQuad()}))}}}destroy(){super.destroy(),this.__srcGLTex&&this.__srcGLTex.destroy()}}var ct=function(U){var F=typeof U;return null!=U&&("object"==F||"function"==F)},mt="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},St="object"==typeof mt&&mt&&mt.Object===Object&&mt,Wt="object"==typeof self&&self&&self.Object===Object&&self,Et=St||Wt||Function("return this")(),pt=function(){return Et.Date.now()},ut=/\s/;var Nt=function(U){for(var F=U.length;F--&&ut.test(U.charAt(F)););return F},kt=/^\s+/;var bt=function(U){return U?U.slice(0,Nt(U)+1).replace(kt,""):U},Ct=Et.Symbol,Tt=Object.prototype,Gt=Tt.hasOwnProperty,Xt=Tt.toString,gt=Ct?Ct.toStringTag:void 0;var yt=function(U){var F=Gt.call(U,gt),e=U[gt];try{U[gt]=void 0;var t=!0}catch(U){}var Q=Xt.call(U);return t&&(F?U[gt]=e:delete U[gt]),Q},It=Object.prototype.toString;var xt=function(U){return It.call(U)},ft=Ct?Ct.toStringTag:void 0;var Mt=function(U){return null==U?void 0===U?"[object Undefined]":"[object Null]":ft&&ft in Object(U)?yt(U):xt(U)};var vt=function(U){return null!=U&&"object"==typeof U};var Dt=function(U){return"symbol"==typeof U||vt(U)&&"[object Symbol]"==Mt(U)},Lt=/^[-+]0x[0-9a-f]+$/i,Yt=/^0b[01]+$/i,_t=/^0o[0-7]+$/i,wt=parseInt;var zt=function(U){if("number"==typeof U)return U;if(Dt(U))return NaN;if(ct(U)){var F="function"==typeof U.valueOf?U.valueOf():U;U=ct(F)?F+"":F}if("string"!=typeof U)return 0===U?U:+U;U=bt(U);var e=Yt.test(U);return e||_t.test(U)?wt(U.slice(2),e?2:8):Lt.test(U)?NaN:+U},Kt=Math.max,Ht=Math.min;var Pt=function(U,F,e){var t,Q,l,n,a,d,i=0,s=!1,R=!1,B=!0;if("function"!=typeof U)throw new TypeError("Expected a function");function V(F){var e=t,l=Q;return t=Q=void 0,i=F,n=U.apply(l,e)}function r(U){return i=U,a=setTimeout(o,F),s?V(U):n}function h(U){var e=U-d;return void 0===d||e>=F||e<0||R&&U-i>=l}function o(){var U=pt();if(h(U))return J(U);a=setTimeout(o,function(U){var e=F-(U-d);return R?Ht(e,l-(U-i)):e}(U))}function J(U){return a=void 0,B&&t?V(U):(t=Q=void 0,n)}function Z(){var U=pt(),e=h(U);if(t=arguments,Q=this,d=U,e){if(void 0===a)return r(d);if(R)return clearTimeout(a),a=setTimeout(o,F),V(d)}return void 0===a&&(a=setTimeout(o,F)),n}return F=zt(F)||0,ct(e)&&(s=!!e.leading,l=(R="maxWait"in e)?Kt(zt(e.maxWait)||0,F):l,B="trailing"in e?!!e.trailing:B),Z.cancel=function(){void 0!==a&&clearTimeout(a),i=0,t=d=Q=a=void 0},Z.flush=function(){return void 0===a?n:J(pt())},Z};var Ot=function(U,F,e){var t=!0,Q=!0;if("function"!=typeof U)throw new TypeError("Expected a function");return ct(e)&&(t="leading"in e?!!e.leading:t,Q="trailing"in e?!!e.trailing:Q),Pt(U,F,{leading:t,maxWait:F,trailing:Q})};class jt extends tt{constructor(U){super(U,"ScreenQuadShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform vec2 pos;\nuniform vec2 size;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * abs(size) * 2.0), 0.0, 1.0);\n  if (size.x < 0.0)\n    v_texCoord.x = 1.0 - v_texCoord.x;\n  if (size.y < 0.0)\n    v_texCoord.y = 1.0 - v_texCoord.y;\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D image;\n\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  fragColor = texture2D(image, v_texCoord);\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}}class At{constructor(U,F){this.__gl=U,this.__pos=[0,0],this.__size=[1,1],this.flipY=!0,this.__glshader=new jt(U),U.__quadVertexIdsBuffer||U.setupInstancedQuad();const e=this.__glshader.compileForTarget("GLScreenQuad",F);this.__quadBinding=Rt(this.__gl,e.attrs,U.__quadattrbuffers,U.__quadIndexBuffer),this.ready=!0}bind(U,F,e,t){const Q=U.unifs;F&&F.bindToUniform(U,U.unifs.image);const l=this.__gl;{const U=Q.pos;if(U){let F=e?e instanceof d?e.asArray():e:this.__pos;l.uniform2fv(U.location,F)}}{const U=Q.size;if(U){let F=t?t instanceof d?t.asArray():t:this.__size;l.uniform2fv(U.location,F)}}this.__quadBinding.bind(U)}bindShader(U){return this.__glshader.bind(U,"GLScreenQuad")}draw(U,F,e,t){this.bind(U,F,e,t);const Q=this.__gl;Q.drawElements(Q.TRIANGLES,6,Q.UNSIGNED_SHORT,0)}destroy(){}}class qt extends _{constructor(U,F){super(),this.genBufferOpts={},this.__indexBuffer=null,this.__gl=U,this.__geom=F,this.__glattrbuffers={},this.__shaderBindings={},this.buffersDirty=!0;this.__geom.on("geomDataChanged",(U=>{this.dirtyBuffers(U)}));this.__geom.on("geomDataTopologyChanged",(U=>{this.clearBuffers(),this.dirtyBuffers(U)}))}getGeom(){return this.__geom}dirtyBuffers(U){this.genBufferOpts=U,this.buffersDirty=!0,this.emit("updated")}genBuffers(U){}updateBuffers(U){this.genBuffers(U),this.buffersDirty=!1}bind(U){if(this.__destroyed)throw new Error("Error binding a destroyed geom");this.buffersDirty&&this.updateBuffers();let F=this.__shaderBindings[U.shaderkey];if(!F){F=Rt(this.__gl,U.attrs,this.__glattrbuffers,this.__indexBuffer),this.__shaderBindings[U.shaderkey]=F}return F.bind(U),!0}unbind(U){const F=this.__shaderBindings[U.shaderkey];F&&F.unbind(U)}draw(U){throw new Error("Not implemented. Implement this method in a derived class.")}drawInstanced(U,F){throw new Error("Not implemented. Implement this method in a derived class.")}bindAndDraw(U){this.bind(U),this.draw(U)}clearBuffers(){const U=this.__gl;for(const F in this.__glattrbuffers){const e=this.__glattrbuffers[F];e.shared||U.deleteBuffer(e.buffer)}this.__glattrbuffers={};for(const U in this.__shaderBindings){this.__shaderBindings[U].destroy()}this.__shaderBindings={}}destroy(){this.__geom.deleteMetadata("glgeom"),this.clearBuffers(),this.__destroyed=!0,this.emit("destructing")}}class $t extends qt{constructor(U,F){super(U,F),this.__numTriIndices=0,this.__indexDataType=0,this.__numVertices=0,this.__numTriangles=0,this.__numRenderVerts=0}genBuffers(){super.genBuffers();const U=this.__gl,F=this.__geom.genBuffers(),e=F.indices;this.__numTriIndices=F.indices.length,e instanceof Uint8Array&&(this.__indexDataType=this.__gl.UNSIGNED_BYTE),e instanceof Uint16Array&&(this.__indexDataType=this.__gl.UNSIGNED_SHORT),e instanceof Uint32Array&&(this.__indexDataType=this.__gl.UNSIGNED_INT),this.__numVertices=this.__geom.getNumVertices(),this.__numTriangles=e.length/3,this.__numRenderVerts=F.numRenderVerts,this.__indexBuffer&&U.deleteBuffer(this.__indexBuffer),this.__indexBuffer=U.createBuffer(),U.bindBuffer(U.ELEMENT_ARRAY_BUFFER,this.__indexBuffer),U.bufferData(U.ELEMENT_ARRAY_BUFFER,F.indices,U.STATIC_DRAW);for(const e in F.attrBuffers){const t=F.attrBuffers[e];this.__glattrbuffers[e]&&this.__glattrbuffers[e].buffer&&U.deleteBuffer(this.__glattrbuffers[e].buffer);const Q=U.createBuffer();U.bindBuffer(U.ARRAY_BUFFER,Q),U.bufferData(U.ARRAY_BUFFER,t.values,U.STATIC_DRAW),this.__glattrbuffers[e]={buffer:Q,dataType:t.dataType,normalized:t.normalized},"textureCoords"==e&&(this.__glattrbuffers.texCoords=this.__glattrbuffers.textureCoords)}}updateBuffers(U){const F=this.__gl;if(this.__numVertices!=this.__geom.getNumVertices())return void this.genBuffers();const e=this.__geom.genBuffers({includeIndices:!1});for(const U in e.attrBuffers){const t=e.attrBuffers[U],Q=this.__glattrbuffers[U];F.bindBuffer(F.ARRAY_BUFFER,Q.buffer),F.bufferData(F.ARRAY_BUFFER,t.values,F.STATIC_DRAW)}this.buffersDirty=!1}clearBuffers(){this.__gl.deleteBuffer(this.__indexBuffer),this.__indexBuffer=null,super.clearBuffers()}draw(U){this.__gl.drawElements(this.__gl.TRIANGLES,this.__numTriIndices,this.__indexDataType,0)}drawInstanced(U,F){this.__gl.drawElementsInstanced(this.__gl.TRIANGLES,this.__numTriIndices,this.__indexDataType,0,F)}destroy(){super.destroy();this.__gl.deleteBuffer(this.__indexBuffer),this.__indexBuffer=null}}const UQ={MSAA_RENDERBUFFER:0,COLORBUFFER:1,DEPTHBUFFER:2};class FQ extends K{constructor(U){super(),this.__fbo=null,this.offscreenBuffer=null,this.depthTexture=null,this.__backgroundTexture=null,this.__backgroundGLTexture=null,this.offscreenBufferFbo=null,this.__width=0,this.__height=0,this.__canvasWidth=0,this.__canvasHeight=0,this.fb=null,this.depthBuffer=null,this.EXT_frag_depth=null,this.depthRange=[0,0],this.backgroundColorParam=new SU("BackgroundColor",new B("#eeeeee")),this.doubleClickTimeParam=new hU("DoubleClickTimeMS",200),this.renderer=U,this.__renderer=U,this.addParameter(this.doubleClickTimeParam);const F=this.__renderer.gl;this.__gl=F,this.quad=new $t(F,new kF(1,1)),"webgl2"==F.name&&(this.offscreenBuffer=new Ae(F,{type:"UNSIGNED_BYTE",format:"RGBA",filter:"LINEAR",width:4,height:4}),this.depthTexture=new Ae(F,{type:F.UNSIGNED_INT_24_8,format:F.DEPTH_STENCIL,internalFormat:"webgl2"==F.name?F.DEPTH24_STENCIL8:F.DEPTH_COMPONENT,filter:F.NEAREST,wrap:F.CLAMP_TO_EDGE,width:4,height:4})),this.highlightedGeomsBuffer=new Ae(F,{type:"UNSIGNED_BYTE",format:"RGBA",filter:"NEAREST",width:4,height:4}),this.highlightedGeomsBufferFbo=new Qt(F,this.highlightedGeomsBuffer,!0),this.highlightedGeomsBufferFbo.setClearColor(new B(0,0,0,0));const e=()=>{const U=this.backgroundColorParam.value;U instanceof KU?U instanceof yF?(this.__backgroundTexture=U,this.__backgroundGLTexture=new Bt(F,U)):(this.__backgroundTexture=U,this.__backgroundGLTexture=new Ae(F,U)):U instanceof B?(this.__backgroundGLTexture&&(this.__backgroundGLTexture.destroy(),this.__backgroundGLTexture=null,this.__backgroundTexture=null),this.offscreenBufferFbo&&this.offscreenBufferFbo.setClearColor(new B(U.asArray()))):console.warn("Invalid background:"+U),this.emit("updated")};e(),this.backgroundColorParam.on("valueChanged",e)}getWidth(){return this.__width}getHeight(){return this.__height}resize(U,F){if(this.__canvasWidth==U&&this.__canvasHeight==F)return;this.__canvasWidth=U,this.__canvasHeight=F,this.__width=U,this.__height=F,this.resizeRenderTargets(U,F);const e=new b(this.__width,this.__height);this.emit("resized",e)}resizeRenderTargets(U,F){const e=this.__renderer.gl;if(this.renderer.outlineThickness>0&&"webgl2"==e.name){this.fb&&(e.deleteFramebuffer(this.fb[UQ.MSAA_RENDERBUFFER]),e.deleteFramebuffer(this.fb[UQ.COLORBUFFER]),e.deleteFramebuffer(this.fb[UQ.DEPTHBUFFER]),this.colorRenderbuffer&&e.deleteRenderbuffer(this.colorRenderbuffer),this.depthBuffer&&e.deleteRenderbuffer(this.depthBuffer)),this.offscreenBuffer.resize(U,F),this.depthTexture.resize(U,F),this.fb=[],this.fb[UQ.MSAA_RENDERBUFFER]=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.fb[UQ.MSAA_RENDERBUFFER]),this.colorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,this.colorRenderbuffer),e.renderbufferStorageMultisample(e.RENDERBUFFER,4,e.RGBA8,U,F),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,this.colorRenderbuffer),this.depthBuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,this.depthBuffer),e.renderbufferStorageMultisample(e.RENDERBUFFER,4,e.DEPTH24_STENCIL8,U,F),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,this.depthBuffer),this.fb[UQ.COLORBUFFER]=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.fb[UQ.COLORBUFFER]),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.offscreenBuffer.glTex,0),e.bindFramebuffer(e.FRAMEBUFFER,null),this.fb[UQ.DEPTHBUFFER]=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.fb[UQ.DEPTHBUFFER]),e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,this.depthTexture.glTex,0),e.bindFramebuffer(e.FRAMEBUFFER,null);const t=e.checkFramebufferStatus("webgl2"==e.name?e.DRAW_FRAMEBUFFER:e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw new Error("There is no attachment.");case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("Height and width of the attachment are not the same.");case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");case 36061:throw new Error("The framebuffer is unsupported");default:throw new Error("Incomplete Frambuffer")}}this.highlightedGeomsBuffer&&this.highlightedGeomsBuffer.resize(U,F)}draw(U){const F=this.__renderer.gl,e=U.boundRendertarget;if(this.renderer.outlineThickness>0&&"webgl2"==F.name){this.fb||this.resizeRenderTargets(this.__width,this.__height);const e=this.fb[UQ.MSAA_RENDERBUFFER];F.bindFramebuffer("webgl2"==F.name?F.DRAW_FRAMEBUFFER:F.FRAMEBUFFER,e),U.boundRendertarget=e}else U.boundRendertarget||F.bindFramebuffer(F.FRAMEBUFFER,null);F.viewport(0,0,this.__width,this.__height);const t=this.backgroundColorParam.value.asArray();if(F.clearColor(t[0],t[1],t[2],t[3]),F.colorMask(!0,!0,!0,!1),F.clear(F.COLOR_BUFFER_BIT|F.DEPTH_BUFFER_BIT),F.enable(F.DEPTH_TEST),this.__renderer.drawScene(U),this.drawHighlights(U),this.fb&&"webgl2"==F.name){const t=F;t.bindFramebuffer(t.READ_FRAMEBUFFER,this.fb[UQ.MSAA_RENDERBUFFER]),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,this.fb[UQ.COLORBUFFER]),t.clearBufferfv(t.COLOR,0,[0,0,0,0]),t.blitFramebuffer(0,0,this.__width,this.__height,0,0,this.__width,this.__height,t.COLOR_BUFFER_BIT,t.LINEAR),F.bindFramebuffer(F.DRAW_FRAMEBUFFER,e),U.boundRendertarget=e,F.viewport(0,0,this.__width,this.__height),F.disable(F.DEPTH_TEST);const Q=this.__renderer.screenQuad;Q.bindShader(U),Q.draw(U,this.offscreenBuffer)}}drawSilhouettes(U){const F=this.__renderer.gl;if(0==this.renderer.outlineThickness||"webgl2"!=F.name||!this.fb)return;const e=F;if(e.bindFramebuffer(e.READ_FRAMEBUFFER,this.fb[UQ.MSAA_RENDERBUFFER]),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,this.fb[UQ.DEPTHBUFFER]),e.clearBufferfv(e.COLOR,0,[1,1,1,1]),e.blitFramebuffer(0,0,this.__width,this.__height,0,0,this.__width,this.__height,e.DEPTH_BUFFER_BIT,e.NEAREST),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,this.fb[UQ.MSAA_RENDERBUFFER]),U.boundRendertarget=this.fb[UQ.MSAA_RENDERBUFFER],e.viewport(0,0,this.__width,this.__height),0==this.renderer.outlineThickness)return;e.enable(e.BLEND),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.disable(e.DEPTH_TEST),e.depthMask(!1),this.renderer.silhouetteShader.bind(U);const t=U.unifs;this.depthTexture.bindToUniform(U,t.depthTexture),e.uniform2f(t.screenSize.location,this.__width,this.__height),e.uniform1f(t.outlineThickness.location,this.renderer.outlineThickness);const Q=this.renderer.outlineColor.asArray();e.uniform4f(t.outlineColor.location,Q[0],Q[1],Q[2],Q[3]),e.uniform1f(t.outlineSensitivity.location,this.renderer.outlineSensitivity),e.uniform1f(t.outlineDepthBias.location,this.renderer.outlineDepthBias),e.uniform2f(t.depthRange.location,this.depthRange[0],this.depthRange[1]),this.quad.bindAndDraw(U),e.enable(e.DEPTH_TEST),e.depthMask(!0)}drawHighlights(U){if(this.highlightedGeomsBufferFbo){const F=this.__renderer.gl;this.highlightedGeomsBufferFbo.bindForWriting(U),this.highlightedGeomsBufferFbo.clear(),F.disable(F.BLEND),F.enable(F.DEPTH_TEST),F.depthFunc(F.LESS),F.depthMask(!0),U.glShader=null,this.__renderer.drawHighlightedGeoms(U),this.highlightedGeomsBufferFbo.unbindForWriting(U),F.viewport(0,0,this.__width,this.__height);{this.renderer.highlightsShader.bind(U),F.enable(F.BLEND),F.blendEquation(F.FUNC_ADD),F.blendFunc(F.SRC_ALPHA,F.ONE_MINUS_SRC_ALPHA);const e=U.unifs;F.uniform1f(e.outlineThickness.location,this.renderer.highlightOutlineThickness),this.highlightedGeomsBuffer.bindToUniform(U,e.highlightDataTexture),F.uniform2f(e.highlightDataTextureSize.location,U.region[2],U.region[3]),this.quad.bindAndDraw(U),F.disable(F.BLEND)}}}getManipulator(){return this.manipulator}setManipulator(U){this.manipulator!=U&&(this.manipulator&&this.manipulator.deactivateTool&&this.manipulator.deactivateTool(),this.manipulator=U,this.manipulator.activateTool&&this.manipulator.activateTool())}onPointerDown(U){console.warn("@GLBaseViewport#onPointerDown - Implement me!")}onPointerUp(U){console.warn("@GLBaseViewport#onPointerUp - Implement me!")}onPointerMove(U){console.warn("@GLBaseViewport#onPointerMove - Implement me!")}onPointerEnter(U){console.warn("@GLBaseViewport#onPointerEnter - Implement me!")}onPointerLeave(U){console.warn("@GLBaseViewport#onPointerLeave - Implement me!")}onMouseLeave(U){}onKeyDown(U){}onKeyUp(U){}}class eQ extends N{constructor(U,F){super(),this.interfaceType=U,this.viewXfo=F}}class tQ{constructor(U,F,e,t,Q){this.screenPos=U,this.pointerRay=F,this.intersectionPos=e,this.geomData=t,this.geomItem=Q.geomItem,this.dist=Q.dist}}class QQ extends FQ{constructor(U,F,e,t){super(U),this.debugHighlightedGeomsBuffer=!1,this.__x=0,this.__y=0,this.region=[0,0,0,0],this.__cameraXfo=new c,this.__cameraMat=new h,this.__viewMat=new h,this.__geomDataBufferInvalid=!0,this.__screenPos=null,this.__name=F,this.__projectionMatrix=new h,this.__frustumDim=new d,this.__bl=new d(0,0),this.__tr=new d(1,1),this.__prevDownTime=0,this.__geomDataBufferSizeFactor=1,this.debugGeomShader=!1;const Q=this.__renderer.gl;this.__geomDataBuffer=new Ae(Q,{type:U.floatGeomBuffer?"FLOAT":"UNSIGNED_BYTE",format:"RGBA",filter:"NEAREST",width:e<=1?1:Math.floor(e/this.__geomDataBufferSizeFactor),height:t<=1?1:Math.floor(t/this.__geomDataBufferSizeFactor)}),this.__geomDataBufferFbo=new Qt(Q,this.__geomDataBuffer,!0),this.__geomDataBufferFbo.setClearColor(new B(0,0,0,0)),this.__camera=new Xe("DefaultCamera"),this.setCamera(this.__camera),this.setManipulator(new Pe({renderer:U})),this.resize(e,t)}getBl(){return this.__bl}setBl(U){this.__bl.x=U,this.__bl.y=U,this.resize(this.__canvasWidth,this.__canvasHeight)}getTr(){return this.__tr}setTr(U){this.__tr.x=U,this.__tr.y=U,this.resize(this.__canvasWidth,this.__canvasHeight)}getPosX(){return this.__x}getPosY(){return this.__y}resize(U,F){if(this.__canvasWidth==U&&this.__canvasHeight==F)return;this.__canvasWidth=U,this.__canvasHeight=F,this.__x=U*this.__bl.x,this.__y=U*this.__bl.y,this.__width=U*this.__tr.x-U*this.__bl.x,this.__height=F*this.__tr.y-F*this.__bl.y,this.region=[this.__x,this.__y,this.__width,this.__height],this.resizeRenderTargets(this.__width,this.__height),this.__camera&&this.__updateProjectionMatrix();const e=new b(this.__width,this.__height);this.emit("resized",e)}resizeRenderTargets(U,F){super.resizeRenderTargets(U,F),this.__geomDataBufferFbo&&(this.__geomDataBuffer.resize(Math.floor(this.__width/this.__geomDataBufferSizeFactor),Math.floor(this.__height/this.__geomDataBufferSizeFactor)),this.renderGeomDataFbo())}getCamera(){return this.__camera}setCamera(U){this.__camera=U,this.depthRange=[this.__camera.getNear(),this.__camera.getFar()];const F=U.globalXfoParam,e=()=>{this.__cameraXfo=F.value,this.__cameraMat=this.__cameraXfo.toMat4(),this.__viewMat=this.__cameraMat.inverse()};e(),F.on("valueChanged",(()=>{e(),this.invalidateGeomDataBuffer(),this.emit("updated");const U=new eQ("CameraAndPointer",this.__cameraXfo);this.emit("viewChanged",U)})),this.__camera.on("projectionParamChanged",(()=>{this.__updateProjectionMatrix(),this.depthRange=[this.__camera.getNear(),this.__camera.getFar()],this.emit("updated")})),this.__updateProjectionMatrix()}__updateProjectionMatrix(){const U=this.__width/this.__height;this.__camera.updateProjectionMatrix(this.__projectionMatrix,U);const F=Math.tan(this.__camera.getFov()/2)*this.__camera.getNear()*2,e=F*U;this.__frustumDim.set(e,F)}getProjectionMatrix(){return this.__projectionMatrix}getViewMatrix(){return this.__viewMat}frameView(U){this.__width>0&&this.__height>0?this.__camera.frameView(this,U):this.once("resized",(()=>this.frameView()))}calcRayFromScreenPos(U){const F=this.__canvasHeight*(1-this.__tr.y);let e=(U.x-this.__x)/this.__width,t=(U.y-F)/this.__height;e=2*e-1,t=2*t-1;const Q=this.__cameraMat,l=this.__projectionMatrix.inverse();if(null==l)return console.warn(`Unable to generate Ray from screen pos:${U.toString()} in region ${this.region}`),new Z;let n,a;if(this.__camera.isOrthographic()){const U=l.transformVec3(new i(e,-t,-1));U.z=0,n=Q.transformVec3(U),a=new i(0,0,-1)}else n=Q.translation,a=l.transformVec3(new i(e,-t,-1));return a=Q.rotateVec3(a).normalize(),new Z(n,a)}renderGeomDataFbo(){if(this.__geomDataBufferFbo){const U={};this.__initRenderState(U),U.geomDataFbo=this.__geomDataBufferFbo,this.__geomDataBufferFbo.bindAndClear(U),this.__renderer.drawSceneGeomData(U),this.__geomDataBufferInvalid=!1,this.__geomDataBufferFbo.unbind()}}invalidateGeomDataBuffer(){this.__geomDataBufferInvalid=!0}getGeomDataAtPos(U,F){if(this.__geomDataBufferFbo){if(this.__geomDataBufferInvalid&&(this.renderGeomDataFbo(),this.__screenPos=null),U===this.__screenPos)return this.__intersectionData;this.__screenPos=U,this.__intersectionData=null;const e=this.__renderer.gl;e.finish(),this.__geomDataBufferFbo.bindForReading();const t=this.__geomDataBufferFbo.width,Q=this.__geomDataBufferFbo.height,l=Math.floor(U.x*(t/this.__width)),n=Math.floor(U.y*(Q/this.__height));let a,d;if(this.__renderer.floatGeomBuffer){if(d=new Float32Array(4),e.readPixels(l,Q-n-1,1,1,e.RGBA,e.FLOAT,d),0==d[3])return null;a=63&Math.round(d[0])}else{if(d=new Uint8Array(4),e.readPixels(l,Q-n-1,1,1,e.RGBA,e.UNSIGNED_BYTE,d),e.bindFramebuffer(e.FRAMEBUFFER,null),0==d[0]&&0==d[1])return;a=Math.floor(d[1]/32)}this.__geomDataBufferFbo.unbind();const i=this.__renderer.getPass(a);if(!i)return console.warn("Geom data buffer returns invalid pass id:",a),null;const s=i.getGeomItemAndDist(d);if(s){if(!s.geomItem.isSelectable())return null;F||(F=this.calcRayFromScreenPos(U));const e=F.start.add(F.dir.scale(s.dist));this.__intersectionData=new tQ(U,F,e,d,s)}return this.__intersectionData}return null}getGeomItemsInRect(U,F){var e;if(this.__geomDataBufferFbo){const t=this.__renderer.gl;t.finish();const Q=this.__geomDataBufferFbo.width,l=this.__geomDataBufferFbo.height,n=Q/this.__width,a=l/this.__height,d=Math.round(U.x*n),i=Math.round(U.y*a),s=Math.round(F.x*n),R=Math.round(F.y*a),B=Math.round(l-R),V=Math.round(d),r=Math.round(s-d),h=Math.round(R-i),o=r*h;let J;this.__geomDataBufferFbo.bindForReading(),this.__renderer.floatGeomBuffer?(J=new Float32Array(4*o),t.readPixels(V,B,r,h,t.RGBA,t.FLOAT,J)):(J=new Uint8Array(4*o),t.readPixels(V,B,r,h,t.RGBA,t.UNSIGNED_BYTE,J)),t.bindFramebuffer(t.FRAMEBUFFER,null);const Z=new Set;for(let U=0;U<o;U++){let F;const t=J.subarray(4*U,4*(U+1));if(this.__renderer.floatGeomBuffer){if(0==t[3])continue;F=Math.round(t[0])}else{if(0==t[0]&&0==t[1])continue;F=Math.floor(t[1]/64)}const Q=null===(e=this.__renderer.getPass(F))||void 0===e?void 0:e.getGeomItemAndDist(t);if(Q){if(!Q.geomItem.isSelectable())continue;Z.add(Q.geomItem)}}return Z}return new Set}__getPointerPos(U,F){return new d(U-this.getPosX(),F-this.getPosY())}prepareUIEvent(U){U.viewport=this}onPointerDown(U){if(this.prepareUIEvent(U),U.pointerType===X.mouse){const F=U;F.pointerPos=this.__getPointerPos(F.rendererX,F.rendererY),F.pointerRay=this.calcRayFromScreenPos(F.pointerPos),F.intersectionData=this.getGeomDataAtPos(F.pointerPos,F.pointerRay)}else if(U.pointerType===X.touch){const F=U;if(1==F.touches.length){const U=F.touches[0];F.pointerPos=this.__getPointerPos(U.rendererX,U.rendererY),F.pointerRay=this.calcRayFromScreenPos(F.pointerPos),F.intersectionData=this.getGeomDataAtPos(F.pointerPos,F.pointerRay)}}const F=Date.now();if(F-this.__prevDownTime<this.doubleClickTimeParam.value){if(this.manipulator&&(this.manipulator.onPointerDoublePress(U),!U.propagating))return;if(this.emit("pointerDoublePressed",U),!U.propagating)return}else this.__prevDownTime=F;U.getCapture()?U.getCapture().onPointerDown(U):null!=U.intersectionData&&(U.intersectionData.geomItem.onPointerDown(U),!U.propagating||U.getCapture())||(this.emit("pointerDown",U),U.propagating&&!U.getCapture()&&(!this.manipulator||(this.manipulator.onPointerDown(U),U.propagating)))}onPointerUp(U){if(this.prepareUIEvent(U),U.pointerType===X.mouse){const F=U;F.pointerPos=this.__getPointerPos(F.rendererX,F.rendererY),F.pointerRay=this.calcRayFromScreenPos(F.pointerPos),F.intersectionData=this.getGeomDataAtPos(F.pointerPos,F.pointerRay)}else if(U.pointerType===X.touch){const F=U;if(0==F.touches.length&&1==F.changedTouches.length){const U=F.changedTouches[0];F.pointerPos=this.__getPointerPos(U.rendererX,U.rendererY),F.pointerRay=this.calcRayFromScreenPos(F.pointerPos),F.intersectionData=this.getGeomDataAtPos(F.pointerPos,F.pointerRay)}}U.getCapture()&&(U.getCapture().onPointerUp(U),!U.propagating)||(null==U.intersectionData||(U.intersectionData.geomItem.onPointerUp(U),U.propagating))&&(this.emit("pointerUp",U),U.propagating&&(!this.manipulator||(this.manipulator.onPointerUp(U),U.propagating)))}onPointerMove(U){if(this.prepareUIEvent(U),U.pointerType===X.mouse){const F=U,e=this.__getPointerPos(F.rendererX,F.rendererY);F.pointerPos=e,F.pointerRay=this.calcRayFromScreenPos(e)}else if(U.pointerType===X.touch){const F=U;for(let U=0;U<F.touches.length;U++){const e=F.touches[U];e.touchPos=this.__getPointerPos(e.rendererX,e.rendererY),e.touchRay=this.calcRayFromScreenPos(e.touchPos)}F.pointerPos=F.touches[0].touchPos,F.pointerRay=F.touches[0].touchRay}if(!U.getCapture()||(U.getCapture().onPointerMove(U),U.propagating)){if(U.intersectionData=this.getGeomDataAtPos(U.pointerPos,U.pointerRay),U.intersectionData){if(U.intersectionData.geomItem!=this.pointerOverItem){if(this.pointerOverItem&&(U.leftGeometry=this.pointerOverItem,this.pointerOverItem.onPointerLeave(U),U.propagating&&this.emit("pointerLeaveGeom",U)),this.pointerOverItem=U.intersectionData.geomItem,this.pointerOverItem.onPointerEnter(U),!U.propagating)return;this.emit("pointerOverGeom",U)}if(U.intersectionData.geomItem.onPointerMove(U),!U.propagating||U.getCapture())return}else if(this.pointerOverItem){if(U.leftGeometry=this.pointerOverItem,this.pointerOverItem.onPointerLeave(U),this.pointerOverItem=null,!U.propagating)return;this.emit("pointerLeaveGeom",U)}this.emit("pointerMove",U),U.propagating&&(!this.manipulator||(this.manipulator.onPointerMove(U),U.propagating))}}onPointerEnter(U){this.prepareUIEvent(U),this.emit("pointerEnter",U),U.propagating&&(!this.manipulator||!this.manipulator.onPointerEnter||(this.manipulator.onPointerEnter(U),U.propagating))}onPointerLeave(U){this.prepareUIEvent(U),this.emit("pointerLeave",U),U.propagating&&(!this.manipulator||!this.manipulator.onPointerLeave||(this.manipulator.onPointerLeave(U),U.propagating))}onKeyDown(U){this.manipulator&&(this.manipulator.onKeyDown(U),!U.propagating)||this.emit("keyDown",U)}onKeyUp(U){this.manipulator&&(this.manipulator.onKeyUp(U),!U.propagating)||this.emit("keyUp",U)}onWheel(U){this.prepareUIEvent(U),U.pointerPos=this.__getPointerPos(U.rendererX,U.rendererY),U.pointerRay=this.calcRayFromScreenPos(U.pointerPos),U.intersectionData=this.getGeomDataAtPos(U.pointerPos,U.pointerRay),(null==U.intersectionData||(U.intersectionData.geomItem.onWheel(U),U.propagating))&&(this.manipulator?this.manipulator.onWheel(U):this.emit("mouseWheel",U))}onTouchCancel(U){this.prepareUIEvent(U),U.getCapture()?U.getCapture().onTouchCancel(U):this.manipulator?this.manipulator.onTouchCancel(U):this.emit("touchCancel",U)}__initRenderState(U){U.viewXfo=this.__cameraXfo,U.viewScale=1,U.region=this.region,U.cameraMatrix=this.__cameraMat,U.viewport=this,U.viewports=[{region:this.region,viewMatrix:this.__viewMat,projectionMatrix:this.__projectionMatrix,viewportFrustumSize:this.__frustumDim,isOrthographic:this.__camera.isOrthographic(),fovY:this.__camera.getFov()}]}draw(){const U={};if(this.__initRenderState(U),super.draw(U),this.debugGeomShader){this.renderGeomDataFbo();const F=this.__renderer.screenQuad;F.bindShader(U),F.draw(U,this.__geomDataBuffer,new d(0,0),new d(1,1))}if(this.debugHighlightedGeomsBuffer){const F=this.__renderer.screenQuad;F.bindShader(U),F.draw(U,this.highlightedGeomsBuffer,new d(0,0),new d(1,1))}}}class lQ{constructor(U,F){this.__xrvp=U,this.__treeItem=new DU("VRHead"),F.addChild(this.__treeItem),this.__mat4=new h,this.__localXfo=new c}setVisible(U){if(U&&!this.hmdGeomItem){const U=this.__xrvp.getAsset();if(!U)return;const F=U.getChildByName("HMD");if(!F)return;this.hmdGeomItem=F.clone({assetItem:U}),this.hmdGeomItem&&(this.hmdGeomItem.localXfoParam.value=new c(new i(0,-.035,-.03),new o(0,1,0,Math.PI),new i(.001,.001,.001)),this.__treeItem.addChild(this.hmdGeomItem,!1))}this.hmdGeomItem&&(this.hmdGeomItem.visibleParam.value=U)}update(U){this.__mat4.setDataArray(U.transform.matrix),this.__localXfo.setFromMat4(this.__mat4),this.__treeItem.localXfoParam.value=this.__localXfo}getTreeItem(){return this.__treeItem}getXfo(){return this.__localXfo}}class nQ{constructor(U,F,t){if(this.activeVolumeSize=.04,this.xrvp=U,this.inputSource=F,this.id=t,this.buttonPressed=!1,this.mat4=new h,this.xfo=new c,this.treeItem=new DU("VRController:"+F.handedness+t),!e.isMobileDevice){this.tipItem=new DU("Tip");const e=new c;if(e.tr.set(0,-.05,-.13),this.tipItem.localXfoParam.value=e,this.treeItem.addChild(this.tipItem,!1),U.getTreeItem().addChild(this.treeItem),"tracked-pointer"==F.targetRayMode){switch(F.profiles[0]){case"htc-vive":localStorage.setItem("ZeaEngine_XRDevice","Vive");break;case"oculus-touch":case"oculus-touch-v2":case"oculus-touch-v3":localStorage.setItem("ZeaEngine_XRDevice","Oculus")}U.loadHMDResources().then((U=>{if(!U)return;const e=new c;let t;if(e.ori.setFromAxisAndAngle(new i(0,1,0),Math.PI),e.sc.set(.001,.001,.001),"htc-vive"==F.profiles[0])t=U.getChildByName("Controller"),e.tr.set(0,-.035,-.085);else switch(F.handedness){case"left":t=U.getChildByName("LeftController"),e.tr.set(0,-.035,-.085),e.sc.scaleInPlace(.85);break;case"right":t=U.getChildByName("RightController"),e.tr.set(0,-.035,-.085),e.sc.scaleInPlace(.85);break;case"none":case"left-right":case"left-right-none":t=U.getChildByName("Controller")}if(t){const F=t.clone({assetItem:U});F.localXfoParam.value=e,this.treeItem.addChild(F,!1)}}))}}this.tick=0}getHandedness(){return this.inputSource.handedness}getId(){return this.id}getTreeItem(){return this.treeItem}getTipItem(){return this.tipItem}getTipXfo(){return this.tipItem.globalXfoParam.value}getTouchPadValue(){return this.touchpadValue}isButtonPressed(){return this.buttonPressed}getControllerStageLocalXfo(){return this.xfo}getControllerTipStageLocalXfo(){return this.xfo.multiply(this.tipItem.localXfoParam.value)}updatePose(U,F,e,t){const Q=F.getPose(e.gripSpace,U);if(Q&&Q.transform){if(this.mat4.setDataArray(Q.transform.matrix),this.xfo.setFromMat4(this.mat4),this.treeItem.localXfoParam.value=this.xfo,this.hitTested=!1,this.tick%5==0&&!t.getCapture()){const U=this.getGeomItemAtTip();null!=U?(t.intersectionData=U,U.geomItem!=this.pointerOverItem&&(this.pointerOverItem&&this.pointerOverItem.onPointerLeave(t),this.pointerOverItem=U.geomItem,t.intersectionData=U,this.pointerOverItem.onPointerEnter(t)),U.geomItem.onPointerMove(t)):this.pointerOverItem&&(t.leftGeometry=this.pointerOverItem,this.pointerOverItem.onPointerLeave(t),this.pointerOverItem=null)}this.tick++}}getGeomItemAtTip(){if(this.hitTested)return this.intersectionData;this.hitTested=!0;const U=this.xrvp.getRenderer(),F=this.tipItem.globalXfoParam.value,e=this.activeVolumeSize;return this.intersectionData=U.raycastWithXfo(F,e,e),this.intersectionData}}class aQ extends we{constructor(U){super(),this.listenerIDs={},this.__controllerTriggersHeld=[],this.xrvp=U,this.vrControllerToolTip=new bF(.015),this.vrControllerToolTipMat=new qU("Cross","FlatSurfaceShader"),this.vrControllerToolTipMat.getParameter("BaseColor").value=new B("#03E3AC"),this.listenerIDs={}}addIconToController(U){const F=new he("HandleToolTip",this.vrControllerToolTip,this.vrControllerToolTipMat);F.setSelectable(!1),U.getTipItem().removeAllChildren(),U.getTipItem().addChild(F,!1)}activateTool(){super.activateTool();for(const U of this.xrvp.getControllers())this.addIconToController(U);this.listenerIDs.controllerAdded=this.xrvp.on("controllerAdded",(U=>{this.addIconToController(U.controller)}))}deactivateTool(){super.deactivateTool();for(const U of this.xrvp.getControllers())U.getTipItem().removeAllChildren();this.xrvp.removeListenerById("controllerAdded",this.listenerIDs.controllerAdded)}__initMoveStage(){if(1==this.__controllerTriggersHeld.length)this.__grabPos=this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr.clone(),this.stageXfo__GrabStart=this.xrvp.getXfo().clone(),this.__invOri=this.stageXfo__GrabStart.ori.inverse();else if(2==this.__controllerTriggersHeld.length){const U=this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr,F=this.__controllerTriggersHeld[1].getControllerTipStageLocalXfo().tr;this.__grabDir=F.subtract(U),this.__grabPos=U.lerp(F,.5),this.__grabDir.y=0,this.__grabDist=this.__grabDir.length(),this.__grabDir.scaleInPlace(1/this.__grabDist),this.stageXfo__GrabStart=this.xrvp.getXfo().clone(),this.__grab_to_stage=this.__grabPos.subtract(this.stageXfo__GrabStart.tr)}}onVRControllerButtonDown(U){1==U.button&&(this.__controllerTriggersHeld.push(U.controller),this.__initMoveStage(),U.stopPropagation())}onVRControllerButtonUp(U){if(1!=U.button)return;const F=this.__controllerTriggersHeld.indexOf(U.controller);this.__controllerTriggersHeld.splice(F,1),this.__initMoveStage(),U.stopPropagation()}onVRControllerDoubleClicked(U){console.log("onVRControllerDoubleClicked:",this.__controllerTriggersHeld.length);const F=this.xrvp.getXfo().clone();F.sc.set(1,1,1),this.xrvp.setXfo(F)}onVRPoseChanged(U){if(1==this.__controllerTriggersHeld.length){const U=this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr,F=new c;F.tr=this.__grabPos.subtract(U);const e=this.stageXfo__GrabStart.multiply(F);this.xrvp.setXfo(e)}else if(2==this.__controllerTriggersHeld.length){const U=this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr,F=this.__controllerTriggersHeld[1].getControllerTipStageLocalXfo().tr,e=U.lerp(F,.5),t=F.subtract(U);t.y=0;const Q=t.length();if(Q<1e-4)return;t.scaleInPlace(1/Q);const l=new c,n=Math.max(Math.min(this.__grabDist/Q,10),.1);l.sc.set(n,n,n);let a=this.__grabDir.angleTo(t);this.__grabDir.cross(t).y>0&&(a=-a),l.ori.rotateY(a);const d=l.ori.rotateVec3(this.__grabPos);l.tr.addInPlace(this.__grabPos.subtract(d));const i=this.__grabPos.scale(1-n);l.tr.addInPlace(l.ori.rotateVec3(i));const s=this.__grabPos.subtract(e).scale(n);l.tr.addInPlace(l.ori.rotateVec3(s));const R=this.stageXfo__GrabStart.multiply(l);this.xrvp.setXfo(R)}}onPointerDown(U){U.pointerType===X.xr&&this.onVRControllerButtonDown(U)}onPointerMove(U){U.pointerType===X.xr&&this.onVRPoseChanged(U)}onPointerUp(U){U.pointerType===X.xr&&this.onVRControllerButtonUp(U)}onPointerDoublePress(U){U.pointerType===X.xr&&this.onVRControllerDoubleClicked(U)}}class dQ extends eQ{constructor(U){super("VR",U),this.hmd="",this.controllers=[]}}class iQ extends N{constructor(U){super(),this.controller=U}}class sQ extends N{constructor(U){super(),this.state=U}}class RQ extends FQ{constructor(U){super(U),this.__stageXfo=new c,this.__stageMatrix=new h,this.__hmd="",this.__projectionMatrices=[],this.doubleClickTimeParam.value=300,this.__projectionMatricesUpdated=!1,this.__stageTreeItem=new DU("VRStage"),this.__stageTreeItem.setVisible(!1),this.__renderer.addTreeItem(this.__stageTreeItem),this.__vrhead=new lQ(this,this.__stageTreeItem),this.controllersMap={},this.controllers=[],this.controllerPointerDownTime=[],this.spectatorMode=!1,this.tick=0;const F=new c;F.ori.setFromAxisAndAngle(new i(1,0,0),.5*Math.PI),this.setXfo(F),this.__leftViewMatrix=new h,this.__leftProjectionMatrix=new h,this.__rightViewMatrix=new h,this.__rightProjectionMatrix=new h,this.setManipulator(new aQ(this))}getRenderer(){return this.renderer}getAsset(){return this.__vrAsset}getTreeItem(){return this.__stageTreeItem}getVRHead(){return this.__vrhead}getXfo(){return this.__stageXfo}setXfo(U){this.__stageXfo=U,this.__stageTreeItem.globalXfoParam.value=U,this.__stageMatrix=U.inverse().toMat4(),this.__stageScale=U.sc.x}getControllers(){return this.controllers}canPresent(){return this.__canPresent}isPresenting(){return this.session}setSpectatorMode(U){if(!U){const U=this.__renderer.gl;U.bindFramebuffer(U.FRAMEBUFFER,null),U.viewport(0,0,U.drawingBufferWidth,U.drawingBufferHeight);let F=this.backgroundColorParam.value.asArray();U.clearColor(F[0],F[1],F[2],F[3]),U.colorMask(!0,!0,!0,!0),U.clear(U.COLOR_BUFFER_BIT|U.DEPTH_BUFFER_BIT)}this.spectatorMode=U}__startSession(){const U=(F,e)=>{this.session&&(this.session.requestAnimationFrame(U),this.drawXRFrame(e))};this.session.requestAnimationFrame(U)}loadHMDResources(){if(e.isMobileDevice)return Promise.resolve(null);let U=localStorage.getItem("ZeaEngine_XRDevice");if(U||(U="Vive",localStorage.setItem("ZeaEngine_XRDevice",U)),this.__hmd!=U)this.__hmdAssetPromise=void 0;else if(this.__hmdAssetPromise)return this.__hmdAssetPromise;return this.__hmd=U,this.__hmdAssetPromise=new Promise(((F,e)=>{{let e;if("Oculus"===U)e="ZeaEngine/Oculus.vla";else e="ZeaEngine/Vive.vla";if(!nU.commonResources[e]){const U=new Ye(e);U.load(nU.systemUrls[e]),nU.commonResources[e]=U}this.__vrAsset=nU.getCommonResource(e);const t=()=>{const U=this.__vrAsset.getMaterialLibrary(),e=U.getMaterialNames();for(const F of e){const e=U.getMaterial(F,!1);e&&e.setShaderName("SimpleSurfaceShader")}this.__vrAsset.traverse((U=>{U.setSelectable(!1)})),F(this.__vrAsset)};this.__vrAsset.isLoaded()?t():this.__vrAsset.once("loaded",t)}})),this.__hmdAssetPromise}startPresenting(){return new Promise(((U,F)=>{this.spectatorMode||this.setSpectatorMode(!1);(()=>{var t;null===(t=navigator)||void 0===t||t.xr.requestSession("immersive-vr",{requiredFeatures:["local-floor"],optionalFeatures:["bounded-floor"]}).then((t=>{this.__renderer.__xrViewportPresenting=!0;const Q=this.__renderer.getViewport();if(Q){const U=Q.getCamera().globalXfoParam.value,F=new c;F.tr=U.tr.clone(),F.tr.z-=1.3;const e=U.ori.getZaxis();e.z=0,e.normalizeInPlace(),F.ori.setFromDirectionAndUpvector(e,new i(0,0,1)),this.setXfo(F)}t.addEventListener("end",(U=>{this.__stageTreeItem.setVisible(!1),this.session=null,this.emit("presentingChanged",new sQ(!1))}));const l=U=>{console.log("creating controller:",U.handedness,U.profiles);const F=this.controllers.length,e=new nQ(this,U,F);this.controllersMap[U.handedness]=e,this.controllers[F]=e;const t=new iQ(e);return this.emit("controllerAdded",t),e};t.addEventListener("selectstart",(U=>{const F=this.controllersMap[U.inputSource.handedness];F&&(F.buttonPressed=!0,this.onPointerDown(new D(1,F)))})),t.addEventListener("selectend",(U=>{const F=this.controllersMap[U.inputSource.handedness];F&&(F.buttonPressed=!1,this.onPointerUp(new D(1,F)))})),t.addEventListener("inputsourceschange",(U=>{for(const F of U.added)0!=F.profiles.length&&l(F)})),this.session=t;const n=new XRWebGLLayer(t,this.__gl);t.updateRenderState({baseLayer:n}),this.__width=n.framebufferWidth,this.__height=n.framebufferHeight,this.__region=[0,0,this.__width,this.__height],this.resizeRenderTargets(this.__width,this.__height);const a=F=>{this.__refSpace=F,this.__stageTreeItem.setVisible(!0),this.emit("presentingChanged",new sQ(!0)),this.loadHMDResources().then((()=>{this.__startSession(),U()}))};t.requestReferenceSpace(e.isMobileDevice?"local":"bounded-floor").catch((U=>{console.log("Falling back to local-floor reference space"),t.requestReferenceSpace("local-floor").then(a)})).then((U=>{a(U)})).catch((U=>{console.warn(U.message),F(new Error("Unable to start XR Session:"+U.message))}))})).catch((U=>{console.warn(U.message)}))})()}))}stopPresenting(){this.session&&this.session.end()}togglePresenting(){this.session?this.stopPresenting():this.startPresenting()}getHMDCanvasSize(){return this.__hmdCanvasSize}updateControllers(U,F){const e=this.session.inputSources;for(let t=0;t<e.length;t++){const Q=e[t];if(0==Q.profiles.length)return;this.controllers[t]?this.controllers[t].updatePose(this.__refSpace,U,Q,F):console.warn("Missing controller")}}drawXRFrame(U){const F=U.session,t=F.renderState.baseLayer,Q=U.getViewerPose(this.__refSpace);if(!Q)return;this.__vrhead.update(Q);const l=this.__vrhead.getTreeItem().globalXfoParam.value,n=Q.views;if(!this.__projectionMatricesUpdated){this.__projectionMatrices=[],this.__viewMatrices=[],this.__cameraMatrices=[];for(let U=0;U<n.length;U++){const F=n[U],e=new h;e.setDataArray(F.projectionMatrix),this.__projectionMatrices[U]=e,this.__viewMatrices[U]=new h,this.__cameraMatrices[U]=new h}this.__projectionMatricesUpdated=!0}const a=this.__renderer.gl;a.bindFramebuffer(a.FRAMEBUFFER,t.framebuffer);let d=this.backgroundColorParam.value.asArray();a.clearColor(d[0],d[1],d[2],d[3]),a.colorMask(!0,!0,!0,!0),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),this.depthRange=[F.renderState.depthNear,F.renderState.depthFar];const i={};i.boundRendertarget=t.framebuffer,i.region=this.__region,i.viewport=this,i.vrviewport=this,i.viewports=[];for(let U=0;U<n.length;U++){const F=n[U];this.__viewMatrices[U].setDataArray(F.transform.inverse.matrix),this.__viewMatrices[U].multiplyInPlace(this.__stageMatrix);const e=t.getViewport(F);i.viewports.push({viewMatrix:this.__viewMatrices[U],projectionMatrix:this.__projectionMatrices[U],region:[e.x,e.y,e.width,e.height],isOrthographic:!1})}i.viewXfo=l,i.viewScale=1/this.__stageScale,i.cameraMatrix=i.viewXfo.toMat4(),i.region=this.__region,i.vrPresenting=!0,this.draw(i);const s=new L(this,l,this.controllers);this.updateControllers(U,s),this.capturedElement&&s.propagating&&this.capturedElement.onPointerMove(s),this.manipulator&&s.propagating&&this.manipulator.onPointerMove(s);const R=new dQ(i.viewXfo);if(R.hmd=this.__hmd,R.controllers=this.controllers,R.viewport=this,R.vrviewport=this,this.emit("viewChanged",R),this.spectatorMode&&!e.isMobileDevice&&this.tick%5==0){const U=this.__renderer.getViewport();U&&(this.__vrhead.setVisible(!0),U.draw(),this.__vrhead.setVisible(!1))}this.tick++}onPointerDown(U){U.intersectionData=U.controller.getGeomItemAtTip();const F=Date.now();if(F-this.controllerPointerDownTime[U.controller.id]<this.doubleClickTimeParam.value){if(this.emit("pointerDoublePressed",U),!U.propagating)return;if(this.manipulator&&(this.manipulator.onPointerDoublePress(U),!U.propagating))return}this.controllerPointerDownTime[U.controller.id]=F,this.capturedItem?this.capturedItem.onPointerDown(U):null!=U.intersectionData&&(U.intersectionData.geomItem.onPointerDown(U),!U.propagating||this.capturedItem)||(this.emit("pointerDown",U),U.propagating&&!this.capturedItem&&this.manipulator&&this.manipulator.onPointerDown(U))}onPointerUp(U){this.controllerPointerDownTime[U.controller.id]=0,this.capturedItem?this.capturedItem.onPointerUp(U):(U.intersectionData=U.controller.getGeomItemAtTip(),(null==U.intersectionData||(U.intersectionData.geomItem.onPointerUp(U),U.propagating))&&(this.emit("pointerUp",U),U.propagating&&(!this.manipulator||(this.manipulator.onPointerUp(U),U.propagating))))}}class BQ extends u{constructor(U){super(),this.dirty=!1,this.unif=U}bind(U){}unbind(U){}destroy(){}}class VQ extends BQ{constructor(U,F,e,t,Q){super(t),this.gltexture=null,this.textureType=-1;const l=e.getName();switch(this.param=e,this.unif=t,this.textureUnif=Q[l+"Tex"],this.textureTypeUnif=Q[l+"TexType"],this.uniform1i=U.uniform1i.bind(U),this.unif.type){case"Boolean":case"SInt32":this.uniformXX=U.uniform1i.bind(U);break;case"UInt32":"webgl2"==U.name?this.uniformXX=U.uniform1ui.bind(U):this.uniformXX=U.uniform1i.bind(U);break;case"Float32":this.uniformXX=U.uniform1f.bind(U)}this.bind=this.bindValue;const n=e=>{let t=e.getMetadata("gltexture");t||(t="FLOAT"===e.type?new Bt(U,e):new Ae(U,e)),this.texBinding=t.preBind(this.textureUnif,Q),t.on("updated",(()=>{F.emit("updated")})),this.gltexture=t,this.gltexture.addRef(this),this.textureType=1,this.bind=this.bindTexture,F.emit("updated")};let a,d;if(this.update=()=>{try{a||(this.val=e.value)}catch(U){}F.emit("updated")},e instanceof HU){const U=U=>{U.isLoaded()?n(U):d=U.on("loaded",(()=>{n(a)})),a=U},t=()=>{a.getMetadata("gltexture").removeRef(this),this.texBinding=null,this.gltexture=null,this.textureType=-1,this.bind=this.bindValue,d&&a.removeListenerById("loaded",d),a=null,d=null,F.emit("updated")};e.getImage()&&U(e.getImage()),e.on("textureConnected",(()=>{U(e.getImage())})),e.on("textureDisconnected",(()=>{t()}))}this.dirty=!0,e.on("valueChanged",(()=>{this.dirty=!0,F.emit("updated")}))}bindValue(U){this.dirty&&(this.update(),this.dirty=!1),this.unif&&this.uniformXX(this.unif.location,this.val),this.textureTypeUnif&&this.uniform1i(this.textureTypeUnif.location,0)}bindTexture(U){this.dirty&&(this.update(),this.dirty=!1),this.gltexture.bindToUniform(U,this.textureUnif,this.texBinding)}}class rQ extends BQ{constructor(U,F,e,t){switch(super(t),this.param=e,this.unif.type){case"Vec2":this.uniformXX=U.uniform2fv.bind(U);break;case"Vec3":this.uniformXX=U.uniform3fv.bind(U);break;case"Vec4":this.uniformXX=U.uniform4fv.bind(U)}this.dirty=!0,e.on("valueChanged",(()=>{this.dirty=!0,F.emit("updated")}))}bind(U){this.dirty&&(this.values=this.param.value.asArray(),this.dirty=!1),this.uniformXX(this.unif.location,this.values)}unbind(){}destroy(){}}class hQ extends BQ{constructor(U,F,e,t){switch(super(t),this.values=new Float32Array(0),this.param=e,this.unif.type){case"Mat3":this.uniformMatrixXXX=U.uniformMatrix3fv.bind(U);break;case"Mat4":this.uniformMatrixXXX=U.uniformMatrix4fv.bind(U)}this.dirty=!0,e.on("valueChanged",(()=>{this.dirty=!0,F.emit("updated")}))}bind(U){this.dirty&&(this.values=this.param.value.asArray(),this.dirty=!1),this.uniformMatrixXXX(this.unif.location,!1,this.values)}unbind(){}destroy(){}}class oQ extends BQ{constructor(U,F,e,t,Q){super(t);const l=e.getName();this.param=e,this.textureUnif=Q[l+"Tex"],this.textureTypeUnif=Q[l+"TexType"],this.values=Float32Array.from([0,0,0,0]),this.bind=this.bindValue;const n=e=>{a=e;let t=e.getMetadata("gltexture");t||(t="FLOAT"===e.type?new Bt(U,e):new Ae(U,e)),this.texBinding=t.preBind(this.textureUnif,Q),t.on("updated",(()=>{F.emit("updated")})),this.gltexture=t,this.gltexture.addRef(this),this.textureType=1,this.bind=this.bindTexture,F.emit("updated")};let a,d;const i=U=>{U.isLoaded()?n(U):d=U.once("loaded",(()=>{n(U)}))},s=()=>{this.gltexture.removeRef(this),this.gltexture=null,this.texBinding=null,this.textureType=null,d&&a.removeListenerById("loaded",d),this.bind=this.bindValue,a=null,d=null,F.emit("updated")};this.update=()=>{try{a||this.unif&&(this.values=e.value.asArray())}catch(U){}F.emit("updated")},e instanceof PU&&(e.getImage()&&i(e.getImage()),e.on("textureConnected",(()=>{i(e.getImage())})),e.on("textureDisconnected",(()=>{s()}))),this.dirty=!0,e.on("valueChanged",(()=>{this.dirty=!0})),this.uniform1i=U.uniform1i.bind(U),this.uniform4fv=U.uniform4fv.bind(U)}bindValue(U){this.unif&&(this.dirty&&(this.update(),this.dirty=!1),this.unif&&this.uniform4fv(this.unif.location,this.values),this.textureTypeUnif&&this.uniform1i(this.textureTypeUnif.location,0))}bindTexture(U){this.dirty&&(this.update(),this.dirty=!1),this.gltexture.bindToUniform(U,this.textureUnif,this.texBinding)}}const JQ={};class ZQ{constructor(U,F,e,t){this.uniformBindings=[];const Q=Q=>{const l=Q.getName(),n=e[l];if(null!=n)switch(n.type){case"Boolean":case"UInt32":case"SInt32":case"Float32":this.uniformBindings.push(new VQ(U,F,Q,n,e));break;case"Vec2":case"Vec3":case"Vec4":this.uniformBindings.push(new rQ(U,F,Q,n));break;case"Color":this.uniformBindings.push(new oQ(U,F,Q,n,e));break;case"Mat4":this.uniformBindings.push(new hQ(U,F,Q,n));break;default:return void console.warn("Param :"+l+" has unhandled data type:"+n.type)}else{if(e[l+"Tex"])return void this.uniformBindings.push(new oQ(U,F,Q,n,e));if(t){const U=F.getMaterial().getShaderName();JQ[U]||(JQ[U]={}),JQ[U][l]||(console.warn("Material:"+F.getMaterial().getName(),"with Shader ",U,"Param has no unif",l),JQ[U][l]=!0)}}},l=F.getMaterial().getParameters();for(const U of l)Q(U)}bind(U){for(const F of this.uniformBindings)F.bind(U);return!0}unbind(U){for(const F of this.uniformBindings)F.unbind(U)}destroy(){for(const U of this.uniformBindings)U.destroy()}}class cQ extends k{constructor(U,F,e){super(),this.__gl=U,this.__material=F,this.__glshader=e,this.__shaderBindings={},F.on("parameterValueChanged",(()=>this.emit("updated")))}getMaterial(){return this.__material}getGLShader(){return this.__glshader}bind(U,F){this.__boundTexturesBeforeMaterial=U.boundTextures;let e=this.__shaderBindings[U.shaderkey];if(!e){const t=this.__gl;e=new ZQ(t,this,U.unifs,F),this.__shaderBindings[U.shaderkey]=e}return e.bind(U)}unbind(U){U.boundTextures=this.__boundTexturesBeforeMaterial}}class mQ extends k{constructor(U){super(),this.materials=[],this.materialIndices={},this.glMaterials={},this.refCounts=[],this.freeIndices=[],this.materialsAllocator=new G,this.renderer=U,this.materials=[],this.refCounts=[],this.materialIndices={},this.glMaterials={},this.freeIndices=[],this.dirtyIndices=new Set,this.materialsAllocator=new G,this.materialsAllocator.on("dataReallocated",(U=>{const F=U.id;this.dirtyIndices.add(F)}))}addMaterial(U){let F=this.materialIndices[U.getId()];if(null!=F)return this.refCounts[F]++,F;F=this.freeIndices.length?this.freeIndices.pop():this.materials.length,this.materials[F]=U,this.refCounts[F]=1,this.materialIndices[U.getId()]=F;const e=U.getShaderClass().getPackedMaterialData(U);this.materialsAllocator.allocate(F,e.length/4);return U.on("parameterValueChanged",(()=>{this.dirtyIndices.add(F),this.emit("updated")})),this.dirtyIndices.add(F),F}getGLMaterial(U){if(this.glMaterials[U.getId()])return this.glMaterials[U.getId()];const F=this.renderer.getOrCreateShader(U.getShaderName()),e=this.renderer.gl,t=new cQ(e,U,F);return t.on("updated",(()=>{this.renderer.requestRedraw()})),U.setMetadata("glMaterial",t),this.glMaterials[U.getId()]=t,t}getMaterialAllocation(U){const F=this.materialIndices[U.getId()];if(null!=F)return this.materialsAllocator.getAllocation(F)}removeMaterial(U){const F=this.materialIndices[U.getId()];this.refCounts[F]--,this.refCounts[F]>0||(this.freeIndices.push(F),this.materialsAllocator.deallocate(F),this.materials[F]=null,delete this.materialIndices[U.getId()],this.dirtyIndices.has(F)&&this.dirtyIndices.delete(F))}uploadMaterials(U){const F=this.renderer.__gl,e=J.nextPow2(Math.ceil(Math.sqrt(this.materialsAllocator.reservedSpace))),t=U.boundTextures++;if(F.activeTexture(F.TEXTURE0+t),this.materialsTexture){if(this.materialsTexture.width<e){this.materialsTexture.resize(e,e);for(let U=0;U<this.materials.length;U++)this.materialsAllocator.getAllocation(U)&&this.dirtyIndices.add(U)}}else this.materialsTexture=new Ae(this.renderer.__gl,{format:"RGBA",type:"FLOAT",width:e,height:e,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.materialsTexture.clear();const Q=this.materialsTexture,l=this.materialsTexture.width;F.bindTexture(F.TEXTURE_2D,Q.glTex),this.dirtyIndices.forEach((U=>{const e=this.materialsAllocator.getAllocation(U),t=this.materials[U],n=t.getShaderClass().getPackedMaterialData(t),a=e.start%l,d=Math.ceil((a+e.size)/l);let i=0,s=e.size,R=a;for(let U=0;U<d;U++){let U;R+s>l?(U=l-R,R=0):U=s;const t=(e.start+i)%l,a=Math.floor((e.start+i)/l),d=n.subarray(4*i,4*(i+U));F.texSubImage2D(F.TEXTURE_2D,0,t,a,U,1,Q.__format,Q.__type,d),i+=U,s-=U}})),this.dirtyIndices=new Set,F.bindTexture(F.TEXTURE_2D,null),U.boundTextures--}update(U){this.dirtyItemIndices.length>0&&this.uploadMaterials(U),U.drawItemsTexture=this.glGeomItemsTexture}bind(U){if(this.dirtyIndices.size>0&&this.uploadMaterials(U),!this.materialsTexture)return!1;const{materialsTexture:F,materialsTextureSize:e}=U.unifs;if(F&&(this.materialsTexture.bindToUniform(U,F),e)){this.renderer.gl.uniform2i(e.location,this.materialsTexture.width,this.materialsTexture.height)}return!0}}class SQ extends qt{constructor(U,F){super(U,F),this.__numVertices=9,this.__vboState=-1,this.genBuffers()}genBuffers(U){super.genBuffers(U);const F=this.__gl,e=this.__geom.genBuffers();for(const U in e.attrBuffers){const t=e.attrBuffers[U],Q=F.createBuffer();F.bindBuffer(F.ARRAY_BUFFER,Q),F.bufferData(F.ARRAY_BUFFER,t.values,F.STATIC_DRAW),this.__glattrbuffers[U]={buffer:Q,dataType:t.dataType,normalized:t.normalized}}this.__numVertices=e.numVertices,this.__vboState=2}updateBuffers(U){const F=this.__gl,e=this.__geom.genBuffers(),t=e.numVertices!=this.__numVertices;for(const U in e.attrBuffers){const Q=e.attrBuffers[U],l=this.__glattrbuffers[U];t&&(F.deleteBuffer(l.buffer),l.buffer=F.createBuffer()),F.bindBuffer(F.ARRAY_BUFFER,l.buffer),F.bufferData(F.ARRAY_BUFFER,Q.values,F.STATIC_DRAW)}this.__numVertices=e.numVertices}bind(U){if(U.unifs.PointSize){const F=this.__gl;let e=this.__shaderBindings[U.shaderkey];if(!e){F.__quadVertexIdsBuffer||F.setupInstancedQuad();const t=Object.assign(this.__glattrbuffers,F.__quadattrbuffers);e=Rt(this.__gl,U.attrs,t,F.__quadIndexBuffer),this.__shaderBindings[U.shaderkey]=e}return e.bind(U),!0}return super.bind(U)}draw(U){const F=this.__gl;U.unifs.PointSize?F.drawElementsInstanced(F.TRIANGLES,6,F.UNSIGNED_SHORT,0,this.__numVertices):F.drawArrays(F.POINTS,0,this.__numVertices)}drawInstanced(U,F){this.__gl.drawArraysInstanced(this.__gl.POINTS,0,this.__numVertices,F)}}class WQ extends qt{constructor(U,F){super(U,F),this.__numSegIndices=0,this.__numVertices=0,this.__fatBuffersNeedUpload=!1,this.fatBuffers=null,this.__buffersNeedUpload=!1,this.__indexDataType=0,this.__numSegIndices=0,this.__numVertices=0,this.__fatBuffersNeedUpload=!0}dirtyBuffers(U){super.dirtyBuffers(U),this.__fatBuffersNeedUpload=!0,this.emit("updated")}clearBuffers(){const U=this.__gl;if(U.deleteBuffer(this.__indexBuffer),this.__indexBuffer=null,this.fatBuffers&&this.fatBuffers.positionsTexture){this.fatBuffers.positionsTexture&&(this.fatBuffers.positionsTexture.destroy(),this.fatBuffers.positionsTexture=null);const F=this.fatBuffers.glattrbuffers.segmentIndices;F.buffer&&(U.deleteBuffer(F.buffer),this.fatBuffers.glattrbuffers.segmentIndices=null)}super.clearBuffers()}genFatBuffers(U){const F=this.__gl,e=this.__geom.genBuffers(),t=e.indices,Q=e.numVertices!=this.__numVertices;F.__quadVertexIdsBuffer||F.setupInstancedQuad(),this.fatBuffers||(this.fatBuffers={drawCount:0,positionsTexture:null,glattrbuffers:{}},this.fatBuffers.glattrbuffers.vertexIDs=F.__quadattrbuffers.vertexIDs);const l=U.boundTextures++;F.activeTexture(this.__gl.TEXTURE0+l),this.fatBuffers.drawCount=t.length/2;const n=this.__geom.getVertexAttributes(),a=n.positions,d=n.lineThickness,s=new Float32Array(4*a.getCount());for(let U=0;U<a.getCount();U++){new i(new Float32Array(s.buffer,4*U*4,3)).setFromOther(a.getValueRef(U)),s[4*U+3]=d?d.getFloat32Value(U):1}Q&&this.fatBuffers.positionsTexture&&(this.fatBuffers.positionsTexture.destroy(),this.fatBuffers.positionsTexture=null),this.fatBuffers.positionsTexture?this.fatBuffers.positionsTexture.bufferData(s,a.getCount(),1):this.fatBuffers.positionsTexture=new Ae(this.__gl,{format:"RGBA",type:"FLOAT",width:a.getCount(),height:1,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",data:s,mipMapped:!1});const R=()=>{const U=new Float32Array(t.length);for(let F=0;F<t.length;F++){let e;e=F%2==0?F>0?t[F]==t[F-1]:t[F]==t[t.length-1]:F<t.length-1?t[F]==t[F+1]:t[F]==t[0],U[F]=(e?1:0)+2*t[F]}return U};if(this.fatBuffers.glattrbuffers.segmentIndices)(!this.genBufferOpts||this.genBufferOpts&&this.genBufferOpts.topologyChanged)&&(F.bindBuffer(F.ARRAY_BUFFER,this.fatBuffers.glattrbuffers.segmentIndices.buffer),F.bufferData(F.ARRAY_BUFFER,R(),F.STATIC_DRAW));else{const U=F.createBuffer();F.bindBuffer(F.ARRAY_BUFFER,U),F.bufferData(F.ARRAY_BUFFER,R(),F.STATIC_DRAW),this.fatBuffers.glattrbuffers.segmentIndices={buffer:U,dimension:2,dataType:"Vec2"}}this.__numSegIndices=t.length,this.__numVertices=e.numVertices,F.bindTexture(F.TEXTURE_2D,null),U.boundTextures--,this.__fatBuffersNeedUpload=!1}genBuffers(U){const F=this.__gl,e=this.__geom.genBuffers(),t=e.indices,Q=e.numVertices!=this.__numVertices;this.__indexBuffer?(!this.genBufferOpts||this.genBufferOpts&&this.genBufferOpts.topologyChanged)&&(this.__numSegIndices!=t.length&&(F.deleteBuffer(this.__indexBuffer),this.__indexBuffer=F.createBuffer()),F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,this.__indexBuffer),F.bufferData(F.ELEMENT_ARRAY_BUFFER,t,F.STATIC_DRAW),this.__numSegIndices=t.length):(this.__indexBuffer=F.createBuffer(),F.bindBuffer(F.ELEMENT_ARRAY_BUFFER,this.__indexBuffer),F.bufferData(F.ELEMENT_ARRAY_BUFFER,t,F.STATIC_DRAW));for(const U in e.attrBuffers){const t=e.attrBuffers[U];if(this.__glattrbuffers[U]){const e=this.__glattrbuffers[U];Q&&(F.deleteBuffer(e.buffer),e.buffer=F.createBuffer()),F.bindBuffer(F.ARRAY_BUFFER,e.buffer),F.bufferData(F.ARRAY_BUFFER,t.values,F.STATIC_DRAW)}else{const e=F.createBuffer();F.bindBuffer(F.ARRAY_BUFFER,e),F.bufferData(F.ARRAY_BUFFER,t.values,F.STATIC_DRAW),this.__glattrbuffers[U]={buffer:e,dataType:t.dataType,normalized:t.normalized}}}this.__numSegIndices=t.length,this.__numVertices=e.numVertices,this.__buffersNeedUpload=!1,t instanceof Uint8Array&&(this.__indexDataType=this.__gl.UNSIGNED_BYTE),t instanceof Uint16Array&&(this.__indexDataType=this.__gl.UNSIGNED_SHORT),t instanceof Uint32Array&&(this.__indexDataType=this.__gl.UNSIGNED_INT)}bind(U){const F=this.__gl,e=U.unifs;if(e.LineThickness&&F.floatTexturesSupported){this.__fatBuffersNeedUpload&&this.genFatBuffers(U);const t=this.fatBuffers;let Q=this.__shaderBindings[U.shaderkey];return Q||(Q=Rt(this.__gl,U.attrs,t.glattrbuffers,F.__quadIndexBuffer),this.__shaderBindings[U.shaderkey]=Q),Q.bind(U),e.positionsTexture&&(t.positionsTexture.bindToUniform(U,e.positionsTexture),F.uniform1i(e.positionsTextureSize.location,t.positionsTexture.width)),!0}return super.bind(U)}drawPoints(){this.__gl.drawArrays(this.__gl.POINTS,0,this.__geom.numVertices())}draw(U){const F=this.__gl;U.unifs.LineThickness&&F.floatTexturesSupported?F.drawElementsInstanced(F.TRIANGLES,6,F.UNSIGNED_SHORT,0,this.fatBuffers.drawCount):F.drawElements(this.__gl.LINES,this.__numSegIndices,this.__indexDataType,0)}drawInstanced(U,F){const e=this.__gl,{occluded:t}=U.unifs;t&&e.uniform1i(t.location,0),e.drawElementsInstanced(this.__gl.LINES,this.__numSegIndices,this.__indexDataType,0,F),t&&(e.uniform1i(t.location,1),e.depthFunc(e.GREATER),e.drawElementsInstanced(this.__gl.LINES,this.__numSegIndices,this.__indexDataType,0,F),e.depthFunc(e.LEQUAL))}}class EQ extends N{constructor(U){super(),this.visible=U}}const pQ={GEOMITEM_FLAG_CUTAWAY:1,GEOMITEM_INVISIBLE_IN_GEOMDATA:2};class uQ extends k{constructor(U,F,e,t,Q,l=!1){if(super(),this.listenerIDs={},this.GLShaderGeomSets=null,this.cutDataChanged=!1,this.cutData=[],this.geomMatrixDirty=!1,this.gl=U,this.geomItem=F,this.drawItemId=e,this.geomId=t,this.materialId=Q,this.supportInstancing=l,this.geomVisible=this.geomItem.isVisible(),this.visible=this.geomVisible,this.culled=!1,this.listenerIDs.visibilityChanged=this.geomItem.on("visibilityChanged",(U=>{this.updateVisibility()})),!this.supportInstancing){this.cutDataChanged=!1,this.cutData=[0,0,0,0];const U=0;let e=0;this.geomItem.isCutawayEnabled()&&(e|=pQ.GEOMITEM_FLAG_CUTAWAY),0==F.isSelectable()&&(e|=pQ.GEOMITEM_INVISIBLE_IN_GEOMDATA),this.geomData=[e,U,0,0],this.geomMatrixDirty=!0,this.listenerIDs["GeomMat.valueChanged"]=this.geomItem.geomMatParam.on("valueChanged",(()=>{this.geomMatrixDirty=!0,this.emit("updated")})),this.listenerIDs.cutAwayChanged=this.geomItem.on("cutAwayChanged",(()=>{this.cutDataChanged=!0,this.emit("updated")}))}}getGeomItem(){return this.geomItem}isVisible(){return this.visible}getDrawItemId(){return this.drawItemId}updateVisibility(){this.geomVisible=this.geomItem.isVisible();const U=this.geomVisible&&!this.culled;if(this.visible!=U){this.visible=U;const F=new EQ(U);this.emit("visibilityChanged",F),this.emit("updated")}}setCulled(U){this.culled=U;const F=this.geomVisible&&!this.culled;if(this.visible!=F){this.visible=F;const U=new EQ(F);this.emit("visibilityChanged",U)}}bind(U){const F=this.gl,e=U.unifs;if(!this.supportInstancing){const U=e.modelMatrix;U&&(this.geomMatrixDirty&&(this.modelMatrixArray=this.geomItem.geomMatParam.value.asArray()),F.uniformMatrix4fv(U.location,!1,this.modelMatrixArray));const t=e.drawItemData;t&&F.uniform4fv(t.location,this.geomData);const Q=e.cutawayData;if(Q){if(this.cutDataChanged&&this.geomItem.isCutawayEnabled()){const U=this.geomItem.getCutVector(),F=this.geomItem.getCutDist();this.cutData=[U.x,U.y,U.z,F]}F.uniform4fv(Q.location,this.cutData)}}const t=e.drawItemId;return t&&F.uniform1i(t.location,this.drawItemId),!0}destroy(){this.geomItem.removeListenerById("visibilityChanged",this.listenerIDs.visibilityChanged),this.supportInstancing||(this.geomItem.geomMatParam.removeListenerById("valueChanged",this.listenerIDs["GeomMat.valueChanged"]),this.geomItem.removeListenerById("cutAwayChanged",this.listenerIDs.cutAwayChanged))}}class NQ extends N{constructor(U,F){super(),this.change=U,this.count=F}}class kQ extends k{constructor(U,F){super(),this.drawIdsArray=null,this.drawIdsBuffer=null,this.highlightedIdsArray=null,this.highlightedIdsBuffer=null,this.gl=U,this.glGeom=F,this.id=F?F.getGeom().getId():this.getId(),this.glGeomItems=[],this.glgeomItems_freeIndices=[],this.glgeomItemEventHandlers=[],this.drawIdsArray=null,this.drawIdsBuffer=null,this.drawIdsBufferDirty=!0,this.highlightedIdsArray=null,this.highlightedIdsBuffer=null,this.highlightedIdsBufferDirty=!0,this.visibleItems=[],this.highlightedItems=[]}getGLGeom(){return this.glGeom}getDrawCount(){return this.visibleItems.length}addGLGeomItem(U){let F;if(this.glgeomItems_freeIndices.length>0?F=this.glgeomItems_freeIndices.pop():(F=this.glGeomItems.length,this.glGeomItems.push(null)),U.geomItem.isVisible()){this.visibleItems.push(F);const U=new NQ(1,this.visibleItems.length);this.emit("drawCountChanged",U)}U.geomItem.isHighlighted()&&(this.highlightedItems.push(F),this.highlightedIdsBufferDirty=!0);const e={};e.highlightChanged=e=>{if(U.geomItem.isHighlighted()){if(this.highlightedItems.includes(F))return;this.highlightedItems.push(F);const U=new NQ(1,this.highlightedItems.length);this.emit("highlightedCountChanged",U)}else{this.highlightedItems.splice(this.highlightedItems.indexOf(F),1);const U=new NQ(-1,this.highlightedItems.length);this.emit("highlightedCountChanged",U)}this.highlightedIdsBufferDirty=!0},U.geomItem.on("highlightChanged",e.highlightChanged),e.visibilityChanged=U=>{if(U.visible){this.visibleItems.push(F);const U=new NQ(1,this.visibleItems.length);this.emit("drawCountChanged",U)}else{this.visibleItems.splice(this.visibleItems.indexOf(F),1);const U=new NQ(-1,this.visibleItems.length);this.emit("drawCountChanged",U)}this.drawIdsBufferDirty=!0},U.geomItem.on("visibilityChanged",e.visibilityChanged),this.glGeomItems[F]=U,this.glgeomItemEventHandlers[F]=e,this.drawIdsBufferDirty=!0,U.GLGeomItemSet=this}removeGLGeomItem(U){const F=this.glGeomItems.indexOf(U),e=this.glgeomItemEventHandlers[F];if(U.geomItem.off("highlightChanged",e.highlightChanged),U.geomItem.off("visibilityChanged",e.visibilityChanged),this.glGeomItems[F]=null,this.glgeomItemEventHandlers[F]=null,U.GLGeomItemSet=null,this.glgeomItems_freeIndices.push(F),U.geomItem.isVisible()){this.visibleItems.splice(this.visibleItems.indexOf(F),1);const U=new NQ(-1,this.visibleItems.length);this.emit("drawCountChanged",U)}if(U.geomItem.isHighlighted()){this.highlightedItems.splice(this.highlightedItems.indexOf(F),1);const U=new NQ(-1,this.highlightedItems.length);this.emit("highlightedCountChanged",U)}this.drawIdsBufferDirty=!0,this.glGeomItems.length==this.glgeomItems_freeIndices.length&&this.destroy()}updateDrawIDsBuffer(){const U=this.gl;U.floatTexturesSupported?(this.drawIdsBuffer&&this.glGeomItems.length!=this.drawIdsArray.length&&(this.gl.deleteBuffer(this.drawIdsBuffer),this.drawIdsBuffer=null),this.drawIdsBuffer||(this.drawIdsBuffer=U.createBuffer(),U.bindBuffer(U.ARRAY_BUFFER,this.drawIdsBuffer)),U.bindBuffer(U.ARRAY_BUFFER,this.drawIdsBuffer),U.bufferData(U.ARRAY_BUFFER,this.getDrawIdsArray(),U.STATIC_DRAW),this.drawIdsBufferDirty=!1):this.drawIdsBufferDirty=!1}getDrawIdsArray(){return this.drawIdsBufferDirty&&(this.drawIdsArray&&this.glGeomItems.length==this.drawIdsArray.length||(this.drawIdsArray=new Float32Array(this.glGeomItems.length)),this.visibleItems.forEach(((U,F)=>{this.drawIdsArray[F]=this.glGeomItems[U].getDrawItemId()})),this.drawIdsBufferDirty=!1),this.drawIdsArray}updateHighlightedIDsBuffer(){const U=this.gl;U.floatTexturesSupported?(this.highlightedIdsBuffer&&this.glGeomItems.length>this.highlightedIdsArray.length&&(this.gl.deleteBuffer(this.highlightedIdsBuffer),this.highlightedIdsBuffer=null),this.highlightedIdsBuffer||(this.highlightedIdsBuffer=U.createBuffer()),U.bindBuffer(U.ARRAY_BUFFER,this.highlightedIdsBuffer),U.bufferData(U.ARRAY_BUFFER,this.getHighlightedIdsArray(),U.STATIC_DRAW),this.highlightedIdsBufferDirty=!1):this.highlightedIdsBufferDirty=!1}getHighlightedIdsArray(){return this.highlightedIdsBufferDirty&&((!this.highlightedIdsArray||this.highlightedItems.length>this.highlightedIdsArray.length)&&(this.highlightedIdsArray=new Float32Array(this.glGeomItems.length)),this.highlightedItems.forEach(((U,F)=>{this.highlightedIdsArray[F]=this.glGeomItems[U].getDrawItemId()})),this.highlightedIdsBufferDirty=!1),this.highlightedIdsArray}draw(U){0!=this.visibleItems.length&&(this.drawIdsBufferDirty&&this.updateDrawIDsBuffer(),this.__bindAndRender(U,this.visibleItems,this.drawIdsBuffer))}drawHighlighted(U){0!=this.highlightedItems.length&&(this.highlightedIdsBufferDirty&&this.updateHighlightedIDsBuffer(),this.__bindAndRender(U,this.highlightedItems,this.highlightedIdsBuffer))}__bindAndRender(U,F,e){const t=this.gl,Q=U.unifs;if(U.glGeom!=this.glGeom&&(this.glGeom.bind(U),U.glGeom=this.glGeom),t.floatTexturesSupported&&t.drawElementsInstanced&&U.supportsInstancing){U.unifs.instancedDraw&&t.uniform1i(U.unifs.instancedDraw.location,1);const l=U.attrs.instancedIds.location;t.enableVertexAttribArray(l),t.bindBuffer(t.ARRAY_BUFFER,e),t.vertexAttribPointer(l,1,t.FLOAT,!1,4,0),t.vertexAttribDivisor(l,1),U.bindViewports(Q,(()=>{this.glGeom.drawInstanced(U,F.length)}))}else U.unifs.instancedDraw&&t.uniform1i(U.unifs.instancedDraw.location,0),F.forEach((F=>{this.glGeomItems[F].bind(U),U.bindViewports(Q,(()=>{this.glGeom.draw(U)}))}))}destroy(){this.drawIdsBuffer&&(this.gl.deleteBuffer(this.drawIdsBuffer),this.drawIdsBuffer=null),this.highlightedIdsBuffer&&(this.gl.deleteBuffer(this.highlightedIdsBuffer),this.highlightedIdsBuffer=null),this.emit("destructing")}}class bQ extends k{constructor(U,F){super(),this.glGeomItemSets={},this.pass=U,this.__gl=U.renderer.gl,this.glMaterial=F,this.glGeomItemSets={},this.drawCount=0;const e=F.getMaterial(),t=U=>{e.off("transparencyChanged",t);for(const U in this.glGeomItemSets){const F=this.glGeomItemSets[U];for(const U of F.glGeomItems){const F=U.geomItem;this.pass.removeGeomItem(F),this.pass.renderer.assignTreeItemToGLPass(F)}}};e.on("transparencyChanged",t)}getGLMaterial(){return this.glMaterial}addGLGeomItem(U,F){const e=F.getGeom().getId();let t=this.glGeomItemSets[e];t||(t=new kQ(this.__gl,F),this.addGeomItemSet(t)),t.addGLGeomItem(U)}drawCountChanged(U){this.drawCount+=U.change,this.emit("updated")}__materialChanged(){const U=this.glMaterial.getMaterial();if(!this.pass.checkMaterial(U))for(const U in this.glGeomItemSets){const F=this.glGeomItemSets[U];for(const U of F.glGeomItems){const F=U.geomItem;this.pass.removeGeomItem(F),this.pass.renderer.assignTreeItemToGLPass(F)}}}addGeomItemSet(U){const F=U.getGLGeom().getGeom().getId();this.glGeomItemSets[F]=U;const e=U.on("drawCountChanged",(U=>{this.drawCountChanged(U)}));U.once("destructing",(()=>{U.removeListenerById("drawCountChanged",e),delete this.glGeomItemSets[F],0==Object.keys(this.glGeomItemSets).length&&this.emit("destructing")}))}draw(U){if(0==this.drawCount)return;this.glMaterial.bind(U,!0);for(const F in this.glGeomItemSets){this.glGeomItemSets[F].draw(U)}}drawHighlighted(U){this.glMaterial.bind(U,!1);for(const F in this.glGeomItemSets){this.glGeomItemSets[F].drawHighlighted(U)}}drawGeomData(U){this.glMaterial.bind(U,!1);for(const F in this.glGeomItemSets){this.glGeomItemSets[F].draw(U)}}}class CQ extends k{constructor(U,F,e){super(),this.gl=U,this.pass=F,this.glShader=e.glShader,this.glgeomdatashader=e.glgeomdatashader,this.glselectedshader=e.glselectedshader,this.glMaterialGeomItemSets=[]}findMaterialGeomItemSets(U){for(const F of this.glMaterialGeomItemSets)if(F.glMaterial==U)return F}addGLGeomItem(U,F,e){let t=this.findMaterialGeomItemSets(e);t||(t=new bQ(this.pass,e),this.addMaterialGeomItemSets(t)),t.addGLGeomItem(U,F)}addMaterialGeomItemSets(U){this.glMaterialGeomItemSets.push(U);const F=()=>{this.emit("updated")},e=()=>{U.off("updated",F),U.off("destructing",e);const t=this.glMaterialGeomItemSets.indexOf(U);this.glMaterialGeomItemSets.splice(t,1),0==this.glMaterialGeomItemSets.length&&this.emit("destructing")};U.on("updated",F),U.on("destructing",e)}removeMaterialGeomItemSets(U){const F=this.glMaterialGeomItemSets.indexOf(U);this.glMaterialGeomItemSets.splice(F,1)}getMaterialGeomItemSets(){return this.glMaterialGeomItemSets}draw(U){const F=this.glShader;if(this.glShader.bind(U)){this.pass.renderer.glGeomItemLibrary.bind(U);for(const F of this.glMaterialGeomItemSets)F.draw(U);F.unbind(U)}}drawHighlightedGeoms(U){if(this.glselectedshader&&this.glselectedshader.bind(U,"highlight")){this.pass.renderer.glGeomItemLibrary.bind(U);for(const F of this.glMaterialGeomItemSets)F.drawHighlighted(U)}}drawGeomData(U){if(!this.glgeomdatashader||!this.glgeomdatashader.bind(U,"geomData"))return;this.pass.renderer.glGeomItemLibrary.bind(U);const F=this.gl,{floatGeomBuffer:e,passId:t}=U.unifs;e&&F.uniform1i(e.location,U.floatGeomBuffer?1:0),t&&F.uniform1i(t.location,U.passIndex);for(const F of this.glMaterialGeomItemSets)F.drawGeomData(U)}}class TQ extends N{constructor(U){super(),this.index=U}}const GQ=(U,F)=>{const e=new Int32Array(F);return e.set(U),e};class XQ extends k{constructor(U){super(),this.indexBuffer=null,this.__destroyed=!1,this.renderer=U,this.__gl=U.gl,this.shaderAttrSpec={},this.freeGeomIndices=[],this.geoms=[],this.geomRefCounts=[],this.geomsDict={},this.glGeomsDict={},this.geomBuffersTmp=[],this.glattrbuffers={},this.shaderBindings={},this.bufferNeedsRealloc=!1,this.attributesAllocator=new G,this.dirtyGeomIndices=new Set,this.attributesAllocator.on("resized",(()=>{this.bufferNeedsRealloc=!0})),this.attributesAllocator.on("dataReallocated",(U=>{const F=U.id,e=U.allocation;this.dirtyGeomIndices.add(F),this.geomVertexOffsets[F]=e.start,this.geomVertexCounts[F]=e.size})),this.geomVertexCounts=new Int32Array(1),this.geomVertexOffsets=new Int32Array(1),this.indicesCounts=new Int32Array(1),this.indicesOffsets=new Int32Array(1),this.freeGeomIndices.push(0),this.numIndices=0,this.indicesAllocator=new G,this.indicesAllocator.on("resized",(()=>{this.bufferNeedsRealloc=!0})),this.indicesAllocator.on("dataReallocated",(U=>{const F=U.id;this.dirtyGeomIndices.add(F)}))}constructGLGeom(U){let F=this.glGeomsDict[U.getId()];if(null!=F)return F;const e=this.__gl;if(U instanceof iF||U instanceof VF)F=new $t(e,U);else if(U instanceof dF||U instanceof BF)F=new WQ(e,U);else{if(!(U instanceof aF||U instanceof RF))throw new Error("Unsupported geom type:"+U.constructor.name);F=new SQ(e,U)}return this.glGeomsDict[U.getId()]=F,F.on("updated",(()=>{this.renderer.requestRedraw()})),F.addRef(this),F}addGeom(U){let F=this.geomsDict[U.getId()];if(null!=F)return this.geomRefCounts[F]++,F;if(0==this.freeGeomIndices.length){const U=this.geomVertexCounts.length,F=2*U;this.geomVertexCounts=GQ(this.geomVertexCounts,F),this.geomVertexOffsets=GQ(this.geomVertexOffsets,F),this.indicesCounts=GQ(this.indicesCounts,F),this.indicesOffsets=GQ(this.indicesOffsets,F);for(let e=F-1;e>=U;e--)this.freeGeomIndices.push(e)}F=this.freeGeomIndices.pop(),this.geoms[F]=U,this.geomRefCounts[F]=1,this.geomsDict[U.getId()]=F,this.dirtyGeomIndices.add(F),this.geomVertexCounts[F]=0,this.geomVertexOffsets[F]=0,this.indicesCounts[F]=0,this.indicesOffsets[F]=0;return U.on("geomDataChanged",(()=>{this.dirtyGeomIndices.add(F),this.emit("updated")})),U.on("geomDataTopologyChanged",(()=>{this.dirtyGeomIndices.add(F),this.emit("updated")})),F}removeGeom(U){const F=this.geomsDict[U.getId()];this.geomRefCounts[F]--,this.geomRefCounts[F]>0||(this.attributesAllocator.getAllocation(F)&&this.attributesAllocator.deallocate(F),this.indicesAllocator.getAllocation(F)&&this.indicesAllocator.deallocate(F),this.dirtyGeomIndices.has(F)&&this.dirtyGeomIndices.delete(F),this.geomVertexCounts[F]=0,this.geomVertexOffsets[F]=0,this.geoms[F]=null,this.freeGeomIndices.push(F),delete this.geomsDict[U.getId()],delete this.geomBuffersTmp[F],this.indicesCounts[F]=0,this.indicesOffsets[F]=0)}getGeom(U){return this.geoms[U]}getGeomOffsetAndCount(U){return[this.indicesOffsets[U],this.indicesCounts[U]]}allocateBuffers(U){const F=this.geoms[U];if(!F)return;const e=F.genBuffers(),t=e.numRenderVerts?e.numRenderVerts:e.numVertices;if(this.geomVertexCounts[U]!=t)if(0==t)this.attributesAllocator.deallocate(U),this.geomVertexOffsets[U]=0,this.geomVertexCounts[U]=0;else{const F=this.attributesAllocator.allocate(U,t);this.geomVertexOffsets[U]=F.start,this.geomVertexCounts[U]=F.size}for(const U in e.attrBuffers)if(!this.shaderAttrSpec[U]){const F=e.attrBuffers[U],t=at(this.__gl,F.dataType);this.shaderAttrSpec[U]={dataType:F.dataType,normalized:F.normalized,dimension:t.dimension,elementSize:t.elementSize}}if(e.indices){const F=e.indices.length;if(this.indicesCounts[U]!=F)if(0==F)this.indicesAllocator.deallocate(U),this.indicesOffsets[U]=0,this.indicesCounts[U]=0;else{const e=this.indicesAllocator.allocate(U,F),t=4;this.indicesOffsets[U]=e.start*t,this.indicesCounts[U]=e.size}}else this.indicesOffsets[U]=this.geomVertexOffsets[U],this.indicesCounts[U]=this.geomVertexCounts[U];this.geomBuffersTmp[U]=e}genBuffers(){const U=this.attributesAllocator.reservedSpace,F=this.__gl;for(const e in this.shaderAttrSpec){const t=this.shaderAttrSpec[e],Q=U*t.dimension;t.numValues=Q,this.glattrbuffers[e]&&this.glattrbuffers[e].buffer&&F.deleteBuffer(this.glattrbuffers[e].buffer);const l=F.createBuffer();F.bindBuffer(F.ARRAY_BUFFER,l);const n=Q*t.elementSize;F.bufferData(F.ARRAY_BUFFER,n,F.STATIC_DRAW),this.glattrbuffers[e]={buffer:l,dataType:t.dataType,normalized:t.normalized,length:Q,dimension:t.dimension},"textureCoords"==e&&(this.glattrbuffers.texCoords=this.glattrbuffers.textureCoords)}const e=this.indicesAllocator.reservedSpace;if(this.numIndices!=e){const U=this.__gl;this.indexBuffer&&U.deleteBuffer(this.indexBuffer),this.indexBuffer=U.createBuffer(),U.bindBuffer(U.ELEMENT_ARRAY_BUFFER,this.indexBuffer);const F=this.indicesAllocator.reservedSpace,e=F*4;U.bufferData(U.ELEMENT_ARRAY_BUFFER,e,U.STATIC_DRAW),this.numIndices=F}}uploadBuffers(U){const F=this.__gl;let e=this.geomBuffersTmp[U];if(!e){const F=this.geoms[U];if(!F)return;e=F.genBuffers(),this.geomBuffersTmp[U]=e}const t=this.geomVertexCounts[U],Q=e.numRenderVerts?e.numRenderVerts:e.numVertices;if(t!=Q)throw new Error("Invalid allocation for this geom");if(0==Q){const F=new TQ(U);return void this.emit("geomDataChanged",F)}for(const t in e.attrBuffers){const Q=this.shaderAttrSpec[t],l=e.attrBuffers[t],n=this.glattrbuffers[t];if(!l||!n)continue;F.bindBuffer(F.ARRAY_BUFFER,n.buffer);const a=Q.elementSize,d=this.geomVertexOffsets[U]*a*Q.dimension;F.bufferSubData(F.ARRAY_BUFFER,d,l.values)}if(F.bindBuffer(F.ARRAY_BUFFER,null),e.indices&&e.indices.length>0){const F=e.indices,t=this.indicesAllocator.getAllocation(U);if(t.size!=F.length)throw new Error("Invalid allocation for this geom");const Q=this.attributesAllocator.getAllocation(U),l=new Uint32Array(t.size);for(let U=0;U<F.length;U++)l[U]=e.indices[U]+Q.start;const n=this.__gl;n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer);const a=4,d=t.start*a;n.bufferSubData(n.ELEMENT_ARRAY_BUFFER,d,l),n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)}let l=new TQ(U);this.emit("geomDataChanged",l)}cleanGeomBuffers(){if(new Set(this.dirtyGeomIndices).forEach((U=>{this.allocateBuffers(U)})),this.bufferNeedsRealloc){for(const U in this.shaderBindings){this.shaderBindings[U].destroy()}this.shaderBindings={};for(let U=0;U<this.geoms.length;U++)this.geoms[U]&&this.dirtyGeomIndices.add(U);this.genBuffers(),this.bufferNeedsRealloc=!1}this.dirtyGeomIndices.forEach((U=>{this.uploadBuffers(U)})),this.dirtyGeomIndices=new Set,this.geomBuffersTmp=[]}bind(U){this.dirtyGeomIndices.size>0&&this.cleanGeomBuffers();let F=this.shaderBindings[U.shaderkey];if(F)F.bind(U);else{F=Rt(this.__gl,U.attrs,this.glattrbuffers,this.indexBuffer),this.shaderBindings[U.shaderkey]=F}return!0}unbind(U){const F=this.shaderBindings[U.shaderkey];F&&F.unbind(U)}clearBuffers(){const U=this.__gl;for(const F in this.glattrbuffers){const e=this.glattrbuffers[F];e.shared||U.deleteBuffer(e.buffer)}this.glattrbuffers={},this.indexBuffer&&(U.deleteBuffer(this.indexBuffer),this.indexBuffer=null);for(const U in this.shaderBindings){this.shaderBindings[U].destroy()}this.shaderBindings={}}destroy(){this.clearBuffers(),this.__destroyed=!0,this.emit("destructing")}}var gQ=eU("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwp2YXIgd29ya2VyX2NvZGU9ZnVuY3Rpb24oZSl7InVzZSBzdHJpY3QiO2NvbnN0IHQ9KGUsdCk9PltlWzBdLXRbMF0sZVsxXS10WzFdLGVbMl0tdFsyXV0scz0oZSx0KT0+W2VbMF0qdCxlWzFdKnRdLGk9ZT0+TWF0aC5zcXJ0KGVbMF0qZVswXStlWzFdKmVbMV0pLG49ZT0+Wy1lWzBdLC1lWzFdLC1lWzJdLGVbM11dLGE9KGUsdCk9Pntjb25zdCBzPWVbMF0saT1lWzFdLG49ZVsyXSxhPWVbM10sbz10WzBdLHI9dFsxXSxsPXRbMl0sZD10WzNdO3JldHVybltzKmQrYSpvK2kqbC1uKnIsaSpkK2EqcituKm8tcypsLG4qZCthKmwrcypyLWkqbyxhKmQtcypvLWkqci1uKmxdfSxvPShlLHQpPT57Y29uc3Qgcz1bdFswXSx0WzFdLHRbMl0sMF0saT1hKGEoZSxzKSxuKGUpKTtyZXR1cm5baVswXSxpWzFdLGlbMl1dfSxyPVtdLGw9W107bGV0IGQsdSxoPVtdLGY9W10sYz0hMSxNPTAsZz0wLG09MCxwPTAsYj0uMDA0LHY9e3NvbGlkQW5nbGU6MCxmcnVzdHVtOjAsdG9vQ2xvc2U6MCxiZWhpbmQ6MH07Y29uc3QgeT1lPT57bFtlXXx8KGxbZV09ITAsaC5wdXNoKGUpKX0sQz1lPT57bFtlXSYmKGxbZV09ITEsZi5wdXNoKGUpKX0sQT1lPT57aWYoIWV8fCFkKXJldHVybjtpZighZS52aXNpYmxlKXJldHVybjtpZighZS5jdWxsYWJsZSlyZXR1cm4gdm9pZCBDKGUuaWQpO2NvbnN0IG49ZS5ib3VuZGluZ1JhZGl1cztpZihjKXtjb25zdCBzPW4vTTtpZihiPjAmJnM8YilyZXR1cm4gdm9pZCB5KGUuaWQpO2NvbnN0IGk9dChlLnBvcyxkKSxhPW8odSxpKTtpZihNYXRoLmFicyhhWzBdKS1uPi41Kmd8fE1hdGguYWJzKGFbMV0pLW4+LjUqTSlyZXR1cm4gdm9pZCB5KGUuaWQpfWVsc2V7Y29uc3QgYT10KGUucG9zLGQpLHI9KGU9Pk1hdGguc3FydChlWzBdKmVbMF0rZVsxXSplWzFdK2VbMl0qZVsyXSkpKGEpO2lmKHI8bilyZXR1cm4gdi50b29DbG9zZSsrLHZvaWQgQyhlLmlkKTtjb25zdCBsPU1hdGguYXNpbihuL3IpO2lmKGI+MCYmbDxiKXJldHVybiB2LnNvbGlkQW5nbGUrKyx2b2lkIHkoZS5pZCk7Y29uc3QgaD1vKHUsYSksZj1baFswXSxoWzJdXSxjPVtoWzFdLGhbMl1dLE09aShmKSxnPWkoYyksQT1NYXRoLmFzaW4obi9NKSxJPU1hdGguYXNpbihuL2cpLHc9cyhmLDEvTSksRT1zKGMsMS9nKTtsZXQgUDtpZihoWzJdPjA/KHYuYmVoaW5kKyssUD1bTWF0aC5QSS1NYXRoLmFicyhNYXRoLmFzaW4od1swXSkpLUEsTWF0aC5QSS1NYXRoLmFicyhNYXRoLmFzaW4oRVswXSkpLUldKTpQPVtNYXRoLmFicyhNYXRoLmFzaW4od1swXSkpLUEsTWF0aC5hYnMoTWF0aC5hc2luKEVbMF0pKS1JXSxQWzBdPm18fFBbMV0+cClyZXR1cm4gdi5mcnVzdHVtKyssdm9pZCB5KGUuaWQpfUMoZS5pZCl9LEk9ZT0+e2gubGVuZ3RoPjB8fGYubGVuZ3RoPjA/KGUoe3R5cGU6IkN1bGxSZXN1bHRzIixuZXdseUN1bGxlZDpoLG5ld2x5VW5DdWxsZWQ6Zn0pLGg9W10sZj1bXSk6ZSh7dHlwZToiRG9uZSJ9KSx2PXtzb2xpZEFuZ2xlOjAsZnJ1c3R1bTowLHRvb0Nsb3NlOjAsYmVoaW5kOjB9fSx3PShlLHQpPT57IlZpZXdwb3J0Q2hhbmdlZCI9PWUudHlwZT8oKGUsdCk9PntlLmlzT3J0aG9ncmFwaGljPyhjPSEwLE09ZS5mcnVzdHVtSGVpZ2h0LGc9ZS5mcnVzdHVtV2lkdGgpOihjPSExLG09ZS5mcnVzdHVtSGFsZkFuZ2xlWCxwPWUuZnJ1c3R1bUhhbGZBbmdsZVkpLGI9ZS5zb2xpZEFuZ2xlTGltaXQsZCYmdSYmKHIuZm9yRWFjaChBKSxJKHQpKX0pKGUsdCk6IlZpZXdDaGFuZ2VkIj09ZS50eXBlPygoZSx0KT0+e2Q9ZS5jYW1lcmFQb3MsdT1uKGUuY2FtZXJhT3JpKSxiPWUuc29saWRBbmdsZUxpbWl0LHIuZm9yRWFjaChBKSxJKHQpfSkoZSx0KToiVXBkYXRlR2VvbUl0ZW1zIj09ZS50eXBlJiYoZS5yZW1vdmVkSXRlbUluZGljZXMuZm9yRWFjaCgoZT0+e3JbZV09bnVsbH0pKSxlLmdlb21JdGVtcy5mb3JFYWNoKChlPT57cltlLmlkXXx8KGxbZS5pZF09ITEpLHJbZS5pZF09ZSxBKHJbZS5pZF0pfSkpLEkodCkpfTtyZXR1cm4gc2VsZi5vbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7dyhlLmRhdGEsc2VsZi5wb3N0TWVzc2FnZSl9LGUuaGFuZGxlTWVzc2FnZT13LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxlfSh7fSk7Cgo=",null,!1);class yQ extends k{constructor(U,F){super(),this.dirtyWorkerItemIndices=new Set,this.glGeomItemsTexture=null,this.renderer=U,this.glGeomItems=[],this.glGeomItemEventHandlers=[],this.glGeomItemsMap={},this.glGeomItemsIndexFreeList=[],this.dirtyItemIndices=[],this.dirtyWorkerItemIndices=new Set,this.removedItemIndices=[],this.enableFrustumCulling=F.enableFrustumCulling,this.enableFrustumCulling&&this.setupCullingWorker(U)}setupCullingWorker(U){this.worker=new gQ;let F=!0;this.worker.onmessage=U=>{"CullResults"==U.data.type?this.applyCullResults(U.data):"Done"==U.data.type&&this.renderer.emit("CullingUpdated"),F=!0};const e=()=>{const F=U.getViewport(),e=U.getViewport().getCamera(),t=F.getWidth()/F.getHeight();if(e.isOrthographic()){const F=e.getFrustumHeight(),Q=F*t;this.worker.postMessage({type:"ViewportChanged",frustumHeight:F,frustumWidth:Q,isOrthographic:!0,solidAngleLimit:U.solidAngleLimit})}else{const F=.5*e.getFov(),Q=Math.atan(Math.tan(F)*t);this.worker.postMessage({type:"ViewportChanged",frustumHalfAngleX:Q,frustumHalfAngleY:F,isOrthographic:!1,solidAngleLimit:U.solidAngleLimit})}};U.on("resized",e);const t=U.getViewport().getCamera();t.on("projectionParamChanged",(U=>{t.isOrthographic()&&e()})),e(),U.once("xrViewportSetup",(F=>{F.xrViewport.on("presentingChanged",(F=>{if(F.state){l=10;const F=Math.PI/180,e=62*F,t=50*F;this.worker.postMessage({type:"ViewportChanged",frustumHalfAngleX:t,frustumHalfAngleY:e,isOrthographic:!1,solidAngleLimit:2*U.solidAngleLimit})}else l=5,e()}))}));let Q=0,l=5;U.on("viewChanged",(e=>{if(F){if(Q%l==0){F=!1;const t=e.viewXfo.tr,Q=e.viewXfo.ori;this.worker.postMessage({type:"ViewChanged",cameraPos:t.asArray(),cameraOri:Q.asArray(),solidAngleLimit:U.solidAngleLimit})}Q++}}));const n=()=>{const F=U.getViewport().getCamera().globalXfoParam.value,e=F.tr,t=F.ori;this.worker.postMessage({type:"ViewChanged",cameraPos:e.asArray(),cameraOri:t.asArray(),solidAngleLimit:U.solidAngleLimit})};U.getViewport().getCamera().on("movementFinished",n),n()}addGeomItem(U){let F=this.glGeomItemsMap[U.getId()];if(null!=F)return this.glGeomItems[F];const e=U.materialParam;let t=e.value,Q=-1;Q=this.renderer.glMaterialLibrary.addMaterial(t);const l=()=>{this.renderer.glMaterialLibrary.removeMaterial(t),t=e.value,B.materialId=this.renderer.glMaterialLibrary.addMaterial(t),V()};e.on("valueChanged",l);const n=U.geomParam;let a=n.value;const d=this.renderer.glGeomLibrary.addGeom(a),i=U=>{this.renderer.glGeomLibrary.removeGeom(a),a=n.value,B.geomId=this.renderer.glGeomLibrary.addGeom(a),this.enableFrustumCulling&&this.dirtyWorkerItemIndices.add(F),V()};n.on("valueChanged",i),this.glGeomItemsIndexFreeList.length>0?F=this.glGeomItemsIndexFreeList.pop():(F=this.glGeomItems.length,this.glGeomItems.push(null)),this.removedItemIndices.includes(F)&&this.removedItemIndices.splice(this.removedItemIndices.indexOf(F),1),this.dirtyItemIndices.push(F);const s=this.renderer.gl,R=s.floatTexturesSupported,B=new uQ(s,U,F,d,Q,R),V=()=>{this.dirtyItemIndices.includes(F)||(this.dirtyItemIndices.push(F),this.renderer.drawItemChanged())};U.geomMatParam.on("valueChanged",V),U.on("cutAwayChanged",V),U.on("highlightChanged",V),U.on("selectabilityChanged",V);const r=()=>{this.enableFrustumCulling&&(this.dirtyWorkerItemIndices.has(F)||(this.dirtyWorkerItemIndices.add(F),this.renderer.drawItemChanged()))};return this.enableFrustumCulling&&this.dirtyWorkerItemIndices.add(F),U.on("visibilityChanged",r),U.geomMatParam.on("valueChanged",r),n.on("boundingBoxChanged",r),this.glGeomItems[F]=B,this.glGeomItemEventHandlers[F]={geomItemChanged:V,materialChanged:l,geomChanged:i,workerItemDataChanged:r},this.glGeomItemsMap[U.getId()]=F,this.renderer.requestRedraw(),B}applyCullResults(U){const{newlyCulled:F,newlyUnCulled:e}=U;0==F.length&&0==e.length||(F.forEach((U=>{this.glGeomItems[U]?this.glGeomItems[U].setCulled(!0):-1==this.removedItemIndices.indexOf(U)&&console.warn("Culling worker has items that are deleted.")})),e.forEach((U=>{this.glGeomItems[U]?this.glGeomItems[U].setCulled(!1):-1==this.removedItemIndices.indexOf(U)&&console.warn("Culling worker has items that are deleted.")})),this.renderer.requestRedraw(),this.renderer.emit("CullingUpdated"))}removeGeomItem(U){const F=this.glGeomItemsMap[U.getId()];if(null==F)return null;const e=this.glGeomItems[F],t=U.geomParam.value;this.renderer.glGeomLibrary.removeGeom(t);const Q=U.materialParam.value;this.renderer.glMaterialLibrary.removeMaterial(Q);const l=this.glGeomItemEventHandlers[F];U.materialParam.off("valueChanged",l.materialChanged),U.geomMatParam.off("valueChanged",l.geomItemChanged),U.off("cutAwayChanged",l.geomItemChanged),U.off("highlightChanged",l.geomItemChanged),U.off("visibilityChanged",l.workerItemDataChanged),U.geomMatParam.off("valueChanged",l.workerItemDataChanged);const n=U.geomParam;return n.off("valueChanged",l.geomChanged),n.off("boundingBoxChanged",l.workerItemDataChanged),this.glGeomItems[F]=null,this.glGeomItemEventHandlers[F]=null,this.glGeomItemsIndexFreeList.push(F),delete this.glGeomItemsMap[U.getId()],this.removedItemIndices.push(F),this.renderer.requestRedraw(),e}getGeomItem(U){var F;if(!(U>=this.glGeomItems.length))return null===(F=this.glGeomItems[U])||void 0===F?void 0:F.geomItem;console.warn("Invalid Draw Item id:"+U+" NumItems:"+(this.glGeomItems.length-1))}getGLGeomItem(U){const F=this.glGeomItemsMap[U.getId()];return null!=F?this.glGeomItems[F]:null}populateDrawItemDataArray(U,F,e){const t=this.glGeomItems[U];if(!t)return;const{geomItem:Q,geomId:l}=t,n=24*F;let a=0;Q.isCutawayEnabled()&&(a|=pQ.GEOMITEM_FLAG_CUTAWAY),0==Q.isSelectable()&&(a|=pQ.GEOMITEM_INVISIBLE_IN_GEOMDATA);const d=new s(new Float32Array(e.buffer,4*(n+0),4));d.set(a,0,0,0);const i=Q.materialParam.value,R=this.renderer.glMaterialLibrary.getMaterialAllocation(i);R&&(d.z=R.start),d.w=l;const B=Q.geomMatParam.value,V=new s(new Float32Array(e.buffer,4*(n+4),4)),r=new s(new Float32Array(e.buffer,4*(n+8),4)),h=new s(new Float32Array(e.buffer,4*(n+12),4));V.set(B.xAxis.x,B.yAxis.x,B.zAxis.x,B.translation.x),r.set(B.xAxis.y,B.yAxis.y,B.zAxis.y,B.translation.y),h.set(B.xAxis.z,B.yAxis.z,B.zAxis.z,B.translation.z);const o=new s(new Float32Array(e.buffer,4*(n+16),4));if(Q.isHighlighted()){const U=Q.getHighlight();o.set(U.r,U.g,U.b,U.a)}const J=new s(new Float32Array(e.buffer,4*(n+20),4));if(Q.isCutawayEnabled()){const U=Q.getCutVector(),F=Q.getCutDist();J.set(U.x,U.y,U.z,F)}}getCullingWorkerData(U,F,e){const t=U.boundingBoxParam.value,Q=.5*t.size(),l=t.center();let n=0!=U.cullable;const a=F.getParameter("MaintainScreenSize");return a&&a.value&&(n=!1),F.getShaderName().startsWith("ScreenSpace")&&(n=!1),F.hasParameter("PointSize")&&(n=!1),{id:e,boundingRadius:Q,pos:l.asArray(),cullable:n,visible:U.isVisible()}}uploadGeomItemsToWorker(){if(this.enableFrustumCulling){const U=[];this.dirtyWorkerItemIndices.forEach((F=>{const e=this.glGeomItems[F];if(!e)return;const{geomItem:t}=e,Q=t.materialParam.value;U.push(this.getCullingWorkerData(t,Q,F))})),this.worker.postMessage({type:"UpdateGeomItems",geomItems:U,removedItemIndices:this.removedItemIndices}),this.dirtyWorkerItemIndices.clear(),this.removedItemIndices=[]}}uploadGeomItems(U){const F=this.renderer.gl;if(!F.floatTexturesSupported)return;let e=Math.round(Math.sqrt(6*this.glGeomItems.length)+.5);e=J.nextPow2(e),e%6!=0&&(e+=6-e%6),this.glGeomItemsTexture?this.glGeomItemsTexture.width!=e&&(this.glGeomItemsTexture.resize(e,e),this.dirtyItemIndices=Array(e*e/6).fill(0).map(((U,F)=>F))):(this.glGeomItemsTexture=new Ae(F,{format:"RGBA",type:"FLOAT",width:e,height:e,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.glGeomItemsTexture.clear()),F.bindTexture(F.TEXTURE_2D,this.glGeomItemsTexture.glTex);const t=this.glGeomItemsTexture.getType();for(let U=0;U<this.dirtyItemIndices.length;U++){const Q=this.dirtyItemIndices[U],l=Math.floor(6*Q/e);let n=Q+1;for(let F=U+1;F<this.dirtyItemIndices.length;F++){const U=this.dirtyItemIndices[F];if(Math.floor(6*U/e)!=l)break;if(U!=n)break;n++}const a=n-Q,d=6*Q%e,i=6*a,s=1,R=new Float32Array(24*a);for(let U=Q;U<n;U++)this.populateDrawItemDataArray(U,U-Q,R);if(t==F.FLOAT)this.glGeomItemsTexture.populate(R,i,s,d,l,!1);else{const U=J.convertFloat32ArrayToUInt16Array(R);this.glGeomItemsTexture.populate(U,i,s,d,l,!1)}U+=a-1}this.removedItemIndices=[],this.dirtyItemIndices=[]}bind(U){(this.dirtyWorkerItemIndices.size>0||this.removedItemIndices.length>0)&&this.uploadGeomItemsToWorker(),this.dirtyItemIndices.length>0&&this.uploadGeomItems(U);const F=this.renderer.gl,{instancesTexture:e,instancesTextureSize:t}=U.unifs;e&&(this.glGeomItemsTexture.bindToUniform(U,e),F.uniform1i(t.location,this.glGeomItemsTexture.width))}destroy(){}}class IQ extends N{constructor(U){super(),this.scene=U}}class xQ extends N{constructor(U){super(),this.xrViewport=U}}class fQ extends N{constructor(U){super(),this.propagating=!0,this.sourceEvent=U,this.altKey=U.altKey,this.code=U.code,this.ctrlKey=U.ctrlKey,this.isComposing=U.isComposing,this.key=U.key,this.location=U.location,this.metaKey=U.metaKey,this.repeat=U.repeat,this.shiftKey=U.shiftKey,this.which=U.which}stopPropagation(){this.propagating=!1,this.sourceEvent&&this.sourceEvent.stopPropagation()}preventDefault(){this.sourceEvent&&this.sourceEvent.preventDefault()}}let MQ,vQ=!1,DQ=!1;const LQ={};class YQ extends K{constructor(U,F={}){if(super(),this.listenerIDs={},this.directives=[],this.solidAngleLimit=.004,this.__glcanvas=null,this.__scene=null,this.__shaderDirectives={},this.__renderGeomDataFbosRequested=!1,this.__shaders={},this.__passes={},this.__passesRegistrationOrder=[],this.__passCallbacks=[],this.__viewports=[],this.__activeViewport=void 0,this.__continuousDrawing=!1,this.__redrawRequested=!1,this.__isMobile=!1,this.__drawSuspensionLevel=0,this.__xrViewportPresenting=!1,this.floatGeomBuffer=!0,this.__supportXR=!1,this.__xrViewport=void 0,this.screenQuad=null,!e.gpuDesc)throw new Error("Unable to create renderer. WebGL not Supported");this.__isMobile=e.isMobileDevice,this.requestRedraw=this.requestRedraw.bind(this),this.__gl=this.setupWebGL(U,F),this.screenQuad=new At(this.__gl,{directives:this.directives}),this.bindEventHandlers(),this.addViewport("main"),this.glMaterialLibrary=new mQ(this),this.glMaterialLibrary.on("updated",(()=>{this.requestRedraw()})),this.glGeomLibrary=new XQ(this),this.glGeomLibrary.on("updated",(()=>{this.requestRedraw()})),this.glGeomItemLibrary=new yQ(this,F),this.glGeomItemLibrary.on("updated",(()=>{this.requestRedraw()}));for(const U in LQ)for(const F of LQ[U])this.addPass(new F,parseInt(U),!1);this.__supportXR=void 0===F.supportXR||F.supportXR,this.__xrViewportPromise=new Promise(((U,F)=>{var e,t;if(this.__supportXR&&(null===(e=navigator)||void 0===e?void 0:e.xr)){const F=()=>{this.__gl.makeXRCompatible().then((()=>{this.__xrViewport=this.__setupXRViewport();let F=new xQ(this.__xrViewport);this.emit("xrViewportSetup",F),U(this.__xrViewport)}))};null===(t=navigator)||void 0===t||t.xr.isSessionSupported("immersive-vr").then((U=>{U&&F()})).catch((U=>{console.warn("Unable to setup XR:"+U)}))}}))}addShaderPreprocessorDirective(U,F){this.__shaderDirectives[U]=F?"#define "+U+" = "+F:"#define "+U;const e=[];for(const U in this.__shaderDirectives)e.push(this.__shaderDirectives[U]);this.directives=e}getWidth(){return this.__glcanvas.width}getHeight(){return this.__glcanvas.height}addViewport(U){const F=new QQ(this,U,this.getWidth(),this.getHeight());return F.on("updated",(()=>{this.requestRedraw()})),F.on("viewChanged",(U=>{this.__xrViewportPresenting||this.emit("viewChanged",U)})),this.__viewports.push(F),this.__activeViewport=F,F}getViewport(U=0){return this.__viewports[U]}getViewportAtPos(U,F){for(const e of this.__viewports){const t=e.getPosX(),Q=e.getPosY(),l=e.getWidth(),n=e.getHeight();if(U>=t&&F>=Q&&U<=l+t&&F<=n+Q)return e}}activateViewport(U){this.__activeViewport!=U&&(this.__activeViewport=U)}activateViewportAtPos(U,F){if(this.__xrViewportPresenting)return;const e=this.getViewportAtPos(U,F);e&&e!=this.__activeViewport&&this.activateViewport(e)}getActiveViewport(){return this.__activeViewport}suspendDrawing(){this.__drawSuspensionLevel++}resumeDrawing(){this.__drawSuspensionLevel--,0==this.__drawSuspensionLevel&&(this.renderGeomDataFbos(),this.requestRedraw())}renderGeomDataFbos(){if(1==this.__renderGeomDataFbosRequested)return;this.__renderGeomDataFbosRequested=!0;window.requestAnimationFrame((()=>{for(const U of this.__viewports)U.renderGeomDataFbo();this.__renderGeomDataFbosRequested=!1}))}getScene(){return this.__scene}setScene(U){this.__scene=U,this.addTreeItem(this.__scene.getRoot());let F=new IQ(this.__scene);this.emit("sceneSet",F)}addTreeItem(U){if(!(U instanceof DU))return;const F=U.getId(),e={};if(this.listenerIDs[F]=e,U instanceof he){const F=U.geomParam;if(null==F.value){const t=()=>{delete e["Geometry.valueChanged"],this.assignTreeItemToGLPass(U)};e["Geometry.valueChanged"]=F.once("valueChanged",t)}else this.assignTreeItemToGLPass(U)}else this.assignTreeItemToGLPass(U);for(const F of U.getChildren())F&&this.addTreeItem(F);e.childAdded=U.on("childAdded",(U=>{this.addTreeItem(U.childItem)})),e.childRemoved=U.on("childRemoved",(U=>{this.removeTreeItem(U.childItem)})),this.renderGeomDataFbos()}assignTreeItemToGLPass(U){if(U instanceof he){const F=U;this.glGeomItemLibrary.addGeomItem(F)}let F=!1;for(let e=this.__passesRegistrationOrder.length-1;e>=0;e--){const t={continueInSubTree:!0};if(F=this.__passesRegistrationOrder[e].itemAddedToScene(U,t),F){if(!t.continueInSubTree)return;break}}if(!F)for(const F of this.__passCallbacks){const e={continueInSubTree:!0};if(F.itemAddedFn(U,e)){if(!e.continueInSubTree)return;break}}}removeTreeItem(U){if(!(U instanceof DU))return;const F=U.getId(),e=this.listenerIDs[F];delete this.listenerIDs[F],U.removeListenerById("childAdded",e.childAdded),U.removeListenerById("childRemoved",e.childRemoved);for(let F=this.__passesRegistrationOrder.length-1;F>=0;F--){const e={continueInSubTree:!0};if(this.__passesRegistrationOrder[F].itemRemovedFromScene(U,e)){if(!e.continueInSubTree)return;break}}for(const F of this.__passCallbacks){if(!F.itemRemovedFn)continue;const e={continueInSubTree:!0};if(F.itemRemovedFn(U,e)){if(!e.continueInSubTree)return;break}}for(const F of U.getChildren())F&&this.removeTreeItem(F);if(U instanceof he){const F=U;if(e["Geometry.valueChanged"]){U.geomParam.removeListenerById("valueChanged",e["Geometry.valueChanged"])}this.glGeomItemLibrary.removeGeomItem(F)}this.renderGeomDataFbos()}get gl(){return this.__gl}getGL(){return this.__gl}handleResize(U,F){if(this.__xrViewportPresenting)return;const e=Math.max(4,U),t=Math.max(4,F);this.__glcanvas.width=e,this.__glcanvas.height=t,this.__viewports.forEach((U=>{U.resize(e,t)}));const Q=new b(e,t);this.emit("resized",Q),this.requestRedraw()}getDiv(){return this.__glcanvas.parentElement}setupWebGL(U,F){const{tagName:t}=U;if(!["DIV","CANVAS"].includes(t))throw new Error("Only CANVAS and DIV are valid root elements.");const Q="DIV"===t;this.__glcanvas=U,Q?(console.warn("@GLBaseRenderer#setupWebGL.","Using a DIV as root element is deprecated.","Use a CANVAS instead.","See: https://docs.zea.live/zea-engine/#/getting-started/get-started-with-engine?id=basic-setup"),this.__glcanvas=document.createElement("canvas"),U.appendChild(this.__glcanvas)):this.__glcanvas=U,this.__glcanvas.style["touch-action"]="none",this.__glcanvas.parentElement.style.position="relative",this.__glcanvas.style.position="absolute";const l=Ot((U=>{for(const F of U){if(!Array.isArray(U)||!U.length||!F.contentRect)return;const e=Math.round(F.contentRect.width),t=Math.round(F.contentRect.height);this.handleResize(e,t)}}),500),n=new ResizeObserver(l);this.handleResize(this.__glcanvas.parentElement.clientWidth,this.__glcanvas.parentElement.clientHeight);try{n.observe(this.__glcanvas.parentNode,{box:"device-pixel-content-box"})}catch(U){n.observe(this.__glcanvas.parentNode,{box:"content-box"})}F.preserveDrawingBuffer=!0,F.antialias=null==F.antialias||F.antialias,F.depth=!0,F.stencil=!1,F.alpha=!!F.alpha&&F.alpha,F.xrCompatible=!1,F.powerPreference=F.powerPreference||"high-performance";const a=Oe(this.__glcanvas,F);a||alert("Unable to create WebGL context. WebGL not supported."),"webgl2"==a.name&&this.addShaderPreprocessorDirective("ENABLE_ES3"),a.floatTexturesSupported&&this.addShaderPreprocessorDirective("ENABLE_FLOAT_TEXTURES");{const U="webgl2"==a.name?a.getExtension("WEBGL_multi_draw"):null;U&&!F.disableMultiDraw?(a.multiDrawArrays=U.multiDrawArraysWEBGL.bind(U),a.multiDrawElements=U.multiDrawElementsWEBGL.bind(U),a.multiDrawElementsInstanced=U.multiDrawElementsInstancedWEBGL.bind(U),a.multiDrawArraysInstanced=U.multiDrawArraysInstancedWEBGL.bind(U)):this.addShaderPreprocessorDirective("EMULATE_MULTI_DRAW")}return"Safari"==e.browserName&&"webgl"==a.name?this.floatGeomBuffer=!1:this.floatGeomBuffer=null!=F.floatGeomBuffer?F.floatGeomBuffer:a.floatTexturesSupported,a.floatGeomBuffer=this.floatGeomBuffer,a}bindEventHandlers(){const U=()=>this.getWidth()>0&&this.getHeight(),F=U=>!(!e.isMobileDevice||"Safari"!=e.browserName)&&(console.warn("Mobile Safari is triggering mouse event:",U.type),!0);this.__glcanvas.addEventListener("mousedown",(U=>{if(F(U))return;const e=new x(U,this.__glcanvas.getBoundingClientRect());vQ=!0,MQ=this,this.activateViewportAtPos(e.rendererX,e.rendererY);const t=this.getActiveViewport();t&&t.onPointerDown(e),DQ=!1})),document.addEventListener("mouseup",(e=>{if(F(e))return;if(MQ!=this||!U())return;const t=new x(e,this.__glcanvas.getBoundingClientRect());vQ=!1;const Q=this.getActiveViewport();Q&&Q.onPointerUp(t),DQ&&(Q&&Q.onPointerLeave(t),MQ=void 0)})),document.addEventListener("mousemove",(e=>{if(F(e))return;if(MQ!=this||!U())return;const t=new x(e,this.__glcanvas.getBoundingClientRect());vQ||this.activateViewportAtPos(t.rendererX,t.rendererY);const Q=this.getActiveViewport();Q&&Q.onPointerMove(t)})),this.__glcanvas.addEventListener("mouseenter",(U=>{if(!F(U)&&!vQ){MQ=this;const F=new x(U,this.__glcanvas.getBoundingClientRect());if(this.activateViewportAtPos(F.rendererX,F.rendererY),!vQ){const U=this.getActiveViewport();U&&U.onPointerEnter(F)}DQ=!1}})),this.__glcanvas.addEventListener("mouseleave",(e=>{if(F(e))return;if(MQ!=this||!U())return;const t=new x(e,this.__glcanvas.getBoundingClientRect());if(vQ)DQ=!0;else{const U=this.getActiveViewport();U&&U.onPointerLeave(t),MQ=void 0}})),this.__glcanvas.addEventListener("touchstart",(U=>{MQ=this;const F=this.getActiveViewport(),e=new M(U,this.__glcanvas.getBoundingClientRect());F.onPointerDown(e)}),{passive:!0}),this.__glcanvas.addEventListener("touchend",(U=>{const F=this.getActiveViewport(),e=new M(U,this.__glcanvas.getBoundingClientRect());F.onPointerUp(e)}),{passive:!0}),this.__glcanvas.addEventListener("touchmove",(U=>{const F=this.getActiveViewport(),e=new M(U,this.__glcanvas.getBoundingClientRect());F.onPointerMove(e)}),{passive:!0}),this.__glcanvas.addEventListener("touchcancel",(U=>{const F=this.getActiveViewport(),e=new M(U,this.__glcanvas.getBoundingClientRect());F.onTouchCancel(e)}),{passive:!0});window.addEventListener("wheel",(F=>{if(MQ==this&&U()&&MQ){const U=new v(F,this.__glcanvas.getBoundingClientRect()),e=MQ.getActiveViewport();e&&e.onWheel(U)}}),{passive:!1}),window.oncontextmenu=function(){return!1},document.addEventListener("keydown",(F=>{if(MQ!=this||!U())return;const e=new fQ(F),t=MQ.getActiveViewport();t&&t.onKeyDown(e)})),document.addEventListener("keyup",(F=>{if(MQ!=this||!U())return;const e=new fQ(F),t=MQ.getActiveViewport();t&&t.onKeyUp(e)}))}getGLCanvas(){return this.__glcanvas}frameAll(U=0){this.__viewports[U].frameView([this.__scene.getRoot()])}getOrCreateShader(U){let F=this.__shaders[U];return F||(F=n.constructClass(U),F||console.error("@GLBaseRenderer#getOrCreateShader - Shader not registered with the Registry:",U),F.setGLContext(this.__gl),this.__shaders[U]=F),F}addPass(U,F=-1,e=!0){-1==F&&(F=U.getPassType()),this.__passes[F]||(this.__passes[F]=[]);let t=0;for(const U in this.__passes){if(U==F.toString())break;t+=this.__passes[U].length}if(t+=this.__passes[F].length,U.on("updated",(U=>{this.requestRedraw(),this.renderGeomDataFbos()})),U.init(this,t),this.__passes[F].push(U),e){let U=0;for(const F in this.__passes){const e=this.__passes[F];e.forEach(((F,e)=>{F.setPassIndex(U+e)})),U+=e.length}}return this.__passesRegistrationOrder.push(U),this.requestRedraw(),t}getPass(U){let F=0;for(const e in this.__passes){const t=this.__passes[e];if(U-F<t.length)return t[U-F];F+=t.length}}supportsVR(){var U;return console.warn("@GLBaseRenderer#supportVR - Deprecated Method. Please instead connect to the vrViewportSetup signal."),this.__supportXR&&null!=(null===(U=navigator)||void 0===U?void 0:U.xr)}__setupXRViewport(){const U=new RQ(this),F=U=>{this.emit("viewChanged",U)};return U.on("presentingChanged",(e=>{const t=e.state;if(this.__xrViewportPresenting=t,t){for(const U in this.__passes){const F=this.__passes[U];for(const U of F)U.startPresenting()}U.on("viewChanged",F)}else{U.off("viewChanged",F),this.emit("updated");for(const U in this.__passes){const F=this.__passes[U];for(const U of F)U.stopPresenting()}const e=this.getViewport().getCamera().globalXfoParam.value,t=new eQ("CameraAndPointer",e);this.emit("viewChanged",t),this.requestRedraw()}})),U}getVRViewport(){return this.__xrViewport}getXRViewport(){return this.__xrViewportPromise}isXRViewportPresenting(){return this.__xrViewportPresenting}isContinuouslyDrawing(){return this.__continuousDrawing}startContinuousDrawing(){if(this.isContinuouslyDrawing()||this.__xrViewportPresenting)return;const U=()=>{this.__continuousDrawing&&!this.__xrViewportPresenting&&window.requestAnimationFrame(U);for(const U of this.__viewports)U.draw()};this.__continuousDrawing=!0,window.requestAnimationFrame(U)}stopContinuousDrawing(){this.__continuousDrawing=!1}toggleContinuousDrawing(){this.__continuousDrawing?this.stopContinuousDrawing():this.startContinuousDrawing()}drawItemChanged(){for(const U of this.__viewports)U.invalidateGeomDataBuffer();this.requestRedraw()}requestRedraw(){if(this.__redrawRequested||this.__continuousDrawing||this.__xrViewportPresenting||this.__drawSuspensionLevel>0)return!1;return window.requestAnimationFrame((()=>{this.__redrawRequested=!1;for(const U of this.__viewports)U.draw()})),this.__redrawRequested=!0,!0}forceRender(){if(this.__redrawRequested){this.__redrawRequested=!1;for(const U of this.__viewports)U.draw()}else console.warn("@GlBaseRenderer#forceRender - Scene is not dirty")}bindGLBaseRenderer(U){U.gl=this.__gl,U.shaderopts={directives:this.directives};const F=this.__gl;U.viewports&&1!=U.viewports.length?(U.bindRendererUnifs=e=>{const{cameraMatrix:t}=e;t&&F.uniformMatrix4fv(t.location,!1,U.cameraMatrix.asArray())},U.bindViewports=(e,t)=>{U.viewports.forEach(((U,Q)=>{let l=U.region;F.viewport(l[0],l[1],l[2],l[3]);const{viewMatrix:n,projectionMatrix:a,eye:d,isOrthographic:i}=e;n&&F.uniformMatrix4fv(n.location,!1,U.viewMatrix.asArray()),a&&F.uniformMatrix4fv(a.location,!1,U.projectionMatrix.asArray()),d&&F.uniform1i(d.location,Q),i&&F.uniform1i(i.location,U.isOrthographic),t()}))}):(U.bindRendererUnifs=e=>{const{cameraMatrix:t,viewMatrix:Q,projectionMatrix:l,eye:n,isOrthographic:a}=e;t&&F.uniformMatrix4fv(t.location,!1,U.cameraMatrix.asArray());const d=U.viewports[0];Q&&F.uniformMatrix4fv(Q.location,!1,d.viewMatrix.asArray()),l&&F.uniformMatrix4fv(l.location,!1,d.projectionMatrix.asArray()),n&&F.uniform1i(n.location,0),a&&F.uniform1i(a.location,d.isOrthographic)},U.bindViewports=(U,F)=>F())}drawScene(U){U.directives=[...this.directives,"#define DRAW_COLOR"],U.shaderopts.directives=U.directives;for(const F in this.__passes){const e=this.__passes[F];for(const F of e)F.enabled&&F.draw(U)}}drawHighlightedGeoms(U){this.bindGLBaseRenderer(U),U.directives=[...this.directives,"#define DRAW_HIGHLIGHT"],U.shaderopts.directives=U.directives;for(const F in this.__passes){const e=this.__passes[F];for(const F of e)F.enabled&&F.drawHighlightedGeoms(U)}}drawSceneGeomData(U,F=255){this.bindGLBaseRenderer(U),U.directives=[...this.directives,"#define DRAW_GEOMDATA"],U.shaderopts.directives=U.directives,U.floatGeomBuffer=this.floatGeomBuffer;for(const e in this.__passes){if(0==(Number.parseInt(e)&F))continue;const t=this.__passes[e];for(const F of t)F.enabled&&F.drawGeomData(U)}}static registerPass(U,F){LQ[F]||(LQ[F]=[]),LQ[F].push(U)}destroy(){this.resizeObserver.disconnect()}}class _Q extends tt{constructor(U){super(U,"HighlightsShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;    //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, 0.0, 1.0);\n}\n\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float outlineThickness;\nuniform sampler2D highlightDataTexture;\nuniform vec2 highlightDataTextureSize;\n\nvarying vec2 v_texCoord;\n\nvec3 SobelFactor(vec3 ldc, vec3 ldl, vec3 ldr, vec3 ldu, vec3 ldd)\n{\n  return abs(ldl - ldc) +\n      abs(ldr - ldc) +\n      abs(ldu - ldc) +\n      abs(ldd - ldc);\n}\n\n// https://github.com/ssell/UnitySobelOutline/blob/2e1f4a5b4e703ae2c96aaf08d5518ce58abbaab9/Assets/Resources/Shaders/SobelOutlineHLSL.shader#L18\nvec4 SobelSample(vec2 uv)\n{\n  vec3 offset = vec3((1.0 / highlightDataTextureSize.x), (1.0 / highlightDataTextureSize.y), 0.0) * outlineThickness;\n\n  vec4 pixelCenter = texture2D(highlightDataTexture, uv);\n  vec3 pixelLeft   = texture2D(highlightDataTexture, uv - offset.xz).rgb;\n  vec3 pixelRight  = texture2D(highlightDataTexture, uv + offset.xz).rgb;\n  vec3 pixelUp     = texture2D(highlightDataTexture, uv + offset.zy).rgb;\n  vec3 pixelDown   = texture2D(highlightDataTexture, uv - offset.zy).rgb;\n\n  vec3 sobelNormalVec = SobelFactor(pixelCenter.rgb, pixelLeft, pixelRight, pixelUp, pixelDown);\n  \n  float sobelNormal = sobelNormalVec.x + sobelNormalVec.y + sobelNormalVec.z;\n  \n  float outlineDepthMultiplier = 10.0;\n  float outlineDepthBias = 2.5;\n  sobelNormal = pow(sobelNormal * outlineDepthMultiplier, outlineDepthBias);\n\n  sobelNormal = clamp(sobelNormal, 0.0, 1.0);\n\n  \n  float pixelCenterWeight = length(pixelCenter.rgb) > 0.0 ? 1.0 : 0.0;\n  float pixelLeftWeight   = length(pixelLeft) > 0.0 ? 1.0 : 0.0;\n  float pixelRightWeight  = length(pixelRight) > 0.0 ? 1.0 : 0.0;\n  float pixelUpWeight     = length(pixelUp) > 0.0 ? 1.0 : 0.0;\n  float pixelDownWeight   = length(pixelDown) > 0.0 ? 1.0 : 0.0;\n  \n  // Weight each neighbors contribution to the current pixel color.\n  pixelCenter.rgb = pixelCenter.rgb * pixelCenterWeight;\n  pixelLeft   *= pixelLeftWeight;\n  pixelRight  *= pixelRightWeight;\n  pixelUp     *= pixelUpWeight;\n  pixelDown   *= pixelDownWeight;\n\n  // Add all the weighted contributions, and then normalize.\n  vec3 outlineColor = pixelCenter.rgb + pixelLeft + pixelRight +  pixelUp + pixelDown;\n  outlineColor /= pixelCenterWeight + pixelLeftWeight + pixelRightWeight + pixelUpWeight + pixelDownWeight;\n\n  return mix(vec4(outlineColor, sobelNormal), pixelCenter, pixelCenter.a);\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n    \n  vec4 outlineColor = SobelSample(v_texCoord);\n  \n  if (outlineColor.a > 0.0001) {\n#ifndef ENABLE_ES3\n    gl_FragColor = outlineColor;\n#else\n    fragColor = outlineColor;\n#endif\n  }\n  else {\n      discard;\n  }\n}\n\n")}}class wQ extends tt{constructor(U){super(U,"SilhouetteShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 positions;    //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, 0.0, 1.0);\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\n#ifndef ENABLE_ES3\n#extension GL_EXT_frag_depth: enable\n#endif\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform vec2 screenSize;\nuniform vec2 depthRange;\n\nuniform float outlineThickness;\nuniform color outlineColor;\nuniform float outlineSensitivity;\nuniform float outlineDepthBias;\n\nvarying vec2 v_texCoord;\n\n// http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real\nfloat LinearEyeDepth(float z_b) {\n  float z_n = 2.0 * z_b - 1.0;\n  float z_e = 2.0 * depthRange.x * depthRange.y / (depthRange.y + depthRange.x - z_n * (depthRange.y - depthRange.x));\n  return z_e;\n}\n\nfloat LogEyeDepth(float z_b) {\n  return depthRange.x + ((depthRange.y - depthRange.x) * z_b);\n}\n\n// https://www.vertexfragment.com/ramblings/unity-postprocessing-sobel-outline/#depth-based-outline\n// https://github.com/ssell/UnitySobelOutline/blob/2e1f4a5b4e703ae2c96aaf08d5518ce58abbaab9/Assets/Resources/Shaders/SobelOutlineHLSL.shader\n\nfloat SobelDepth(float ldc, float ldl, float ldr, float ldu, float ldd)\n{\n  return abs(ldl - ldc) +\n      abs(ldr - ldc) +\n      abs(ldu - ldc) +\n      abs(ldd - ldc);\n}\n\nfloat SobelSampleDepth(vec2 uv, vec3 offset)\n{\n  float pixelCenter = LinearEyeDepth(texture2D(depthTexture, uv).r);\n  float pixelLeft   = LinearEyeDepth(texture2D(depthTexture, uv - offset.xz).r);\n  float pixelRight  = LinearEyeDepth(texture2D(depthTexture, uv + offset.xz).r);\n  float pixelUp     = LinearEyeDepth(texture2D(depthTexture, uv + offset.zy).r);\n  float pixelDown   = LinearEyeDepth(texture2D(depthTexture, uv - offset.zy).r);\n\n  float  outlineDepthMultiplier = (1.0 / pixelCenter) * outlineSensitivity;\n\n  return SobelDepth(pixelCenter, pixelLeft, pixelRight, pixelUp, pixelDown) * outlineDepthMultiplier;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec3 offset = vec3((1.0 / screenSize.x), (1.0 / screenSize.y), 0.0) * outlineThickness;\n  float sobelDepth = SobelSampleDepth(v_texCoord, offset);\n  float sobelValue = pow(sobelDepth, outlineDepthBias);\n\n  float minEdgeValue = 0.25;\n  float maxEdgeValue = 0.55;\n  sobelDepth = smoothstep(minEdgeValue, maxEdgeValue, sobelValue);\n\n#ifdef ENABLE_ES3\n  fragColor = vec4(outlineColor.rgb, sobelDepth);\n#else\n  fragColor = vec4(mix(texture2D(colorTexture, v_texCoord).rgb, outlineColor.rgb, sobelDepth), 1.0);\n#ifdef  GL_EXT_frag_depth\n  gl_FragDepthEXT = texture2D(depthTexture, v_texCoord).r;\n#endif\n#endif\n\n  // float z = texture2D(depthTexture, v_texCoord).r;\n  // float near = depthRange.x * 2.0;    // the near plane\n  // float far = depthRange.y / 2.0;     // the far plane\n  // float c = (2.0 * near) / (far + near - z * (far - near));  // convert to linear values \n  // fragColor = vec4(vec3(c), 1.0);\n\n  \n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}}class zQ extends N{constructor(U){super(),this.envMap=U}}const KQ=ze.OPAQUE|ze.TRANSPARENT|ze.OVERLAY;class HQ extends YQ{constructor(U,F={}){super(U,F),this.__glEnvMap=null,this.__rayCastRenderTarget=null,this.__backgroundMapShader=null,this.__backgroundMapShaderBinding=null,this.__rayCastRenderTargetProjMatrix=new h,this.__exposure=1,this.__tonemap=!0,this.__gamma=2.2,this.__displayEnvironment=!0,this.__debugMode=0,this._planeDist=0,this.__cutPlaneNormal=new i(1,0,0),this.rayCastDist=0,this.rayCastArea=0;const e=this.__gl;this.highlightsShader=new _Q(e),this.silhouetteShader=new wQ(e),this.highlightOutlineThickness=1.5,this.outlineThickness=0,this.outlineColor=new B(.15,.15,.15,1),this.outlineSensitivity=2,this.outlineDepthBias=.7,this.__debugTextures=[void 0],this.addShaderPreprocessorDirective("ENABLE_INLINE_GAMMACORRECTION"),F.disableTextures||this.addShaderPreprocessorDirective("ENABLE_TEXTURES"),F.debugGeomIds&&this.addShaderPreprocessorDirective("DEBUG_GEOM_ID")}__bindEnvMap(U){const F=this.__gl;if(!(U instanceof qF)){const e=U;if(this.__glBackgroundMap=e.getMetadata("gltexture"),this.__glBackgroundMap||("FLOAT"===e.type?this.__glBackgroundMap=new Bt(this.__gl,e):this.__glBackgroundMap=new Ae(this.__gl,e)),this.__glBackgroundMap.on("loaded",(()=>{this.requestRedraw()})),this.__glBackgroundMap.on("updated",(()=>{this.requestRedraw()})),!this.__backgroundMapShader){F.__quadVertexIdsBuffer||F.setupInstancedQuad(),this.__backgroundMapShader=new Jt(this.__gl);const U=this.__backgroundMapShader.compileForTarget();this.__backgroundMapShaderBinding=Rt(this.__gl,U.attrs,F.__quadattrbuffers,F.__quadIndexBuffer)}return}if("webgl2"!==F.name)return;this.__glEnvMap=U.getMetadata("gltexture"),this.__glEnvMap||"FLOAT"===U.type&&(this.addShaderPreprocessorDirective("ENABLE_PBR"),this.__glEnvMap=new Zt(this,U)),this.__glEnvMap.on("loaded",(U=>{this.requestRedraw()})),this.__glEnvMap.on("updated",(U=>{this.requestRedraw()}));const e=new zQ(this.__glEnvMap);this.emit("envMapAssigned",e)}setScene(U){const F=U.envMapParam;null!=F.value&&this.__bindEnvMap(F.value),F.on("valueChanged",(()=>{this.__bindEnvMap(F.value)}));const e=U.displayEnvMapParam;this.__displayEnvironment=e.value,e.on("valueChanged",(()=>{this.__displayEnvironment=e.value,this.requestRedraw()})),super.setScene(U)}addViewport(U){return super.addViewport(U)}get exposure(){return this.__exposure}set exposure(U){this.__exposure=U,this.requestRedraw()}get gamma(){return this.__gamma}set gamma(U){this.__gamma=U,this.requestRedraw()}get displayEnvironment(){return this.__displayEnvironment}set displayEnvironment(U){this.__displayEnvironment=U,this.requestRedraw()}raycastWithRay(U,F,e=.01,t=KQ){const Q=new c;return Q.setLookAt(U.start,U.start.add(U.dir),new i(0,0,1)),this.raycast(Q,U,F,e,t)}raycastWithXfo(U,F,e=.01,t=KQ){const Q=new Z(U.tr,U.ori.getZaxis().negate());return this.raycast(U,Q,F,e,t)}raycast(U,F,e,t=.01,Q=KQ){var l;const n=this.__gl;this.__rayCastRenderTarget||(this.__rayCastRenderTarget=new lt(n,{type:"FLOAT",format:"RGBA",filter:"NEAREST",width:3,height:3,numColorChannels:1})),this.rayCastDist==e&&this.rayCastArea==t||(this.__rayCastRenderTargetProjMatrix.setOrthographicMatrix(-.5*t,.5*t,-.5*t,.5*t,0,e),this.rayCastDist=e,this.rayCastArea=t);const a={cameraMatrix:U.toMat4(),viewports:[{region:[0,0,3,3],viewMatrix:U.inverse().toMat4(),projectionMatrix:this.__rayCastRenderTargetProjMatrix,isOrthographic:!0}]};this.__rayCastRenderTarget.bindForWriting(a,!0),n.enable(n.CULL_FACE),n.enable(n.DEPTH_TEST),n.depthFunc(n.LEQUAL),n.depthMask(!0),this.drawSceneGeomData(a,Q),n.finish(),this.__rayCastRenderTarget.unbindForWriting(),this.__rayCastRenderTarget.bindForReading();const d=new Float32Array(36);n.readPixels(0,0,3,3,n.RGBA,n.FLOAT,d),this.__rayCastRenderTarget.unbindForReading();const i=[4,3,5,1,7];let s;for(const U of i)if(0!=d[4*U+3]){s=d.subarray(4*U,4*U+4);break}if(!s)return null;const R=63&Math.round(s[0]),B=null===(l=this.getPass(R))||void 0===l?void 0:l.getGeomItemAndDist(s);if(B){const U=F.start.add(F.dir.scale(B.dist));return{pointerRay:F,intersectionPos:U,geomItem:B.geomItem,dist:B.dist,geomData:s}}return null}raycastCluster(U,F,e,t=.01,Q=KQ){const l=this.__gl;this.__rayCastRenderTarget||(this.__rayCastRenderTarget=new lt(l,{type:"FLOAT",format:"RGBA",filter:"NEAREST",width:3,height:3,numColorChannels:1}),this.__rayCastRenderTargetProjMatrix=new h),this.rayCastDist==e&&this.rayCastArea==t||(this.__rayCastRenderTargetProjMatrix.setOrthographicMatrix(-.5*t,.5*t,-.5*t,.5*t,0,e),this.rayCastDist=e,this.rayCastArea=t);const n={};n.viewports.push({region:[0,0,3,3],viewMatrix:U.inverse().toMat4(),projectionMatrix:this.__rayCastRenderTargetProjMatrix,isOrthographic:!0}),n.cameraMatrix=U.toMat4(),this.__rayCastRenderTarget.bindForWriting(n,!0),l.enable(l.CULL_FACE),l.enable(l.DEPTH_TEST),l.depthFunc(l.LEQUAL),l.depthMask(!0),this.drawSceneGeomData(n,Q),l.finish(),this.__rayCastRenderTarget.unbindForWriting(),this.__rayCastRenderTarget.bindForReading();const a=new Float32Array(36);l.readPixels(0,0,3,3,l.RGBA,l.FLOAT,a),this.__rayCastRenderTarget.unbindForReading();const d=[];for(let U=0;U<9;U++)if(0!=a[4*U+3]){const e=a.subarray(4*U,4*U+4),t=63&Math.round(e[0]),Q=this.getPass(t);if(Q){const U=Q.getGeomItemAndDist(e);if(U){const t=F.start.add(F.dir.scale(U.dist));d.push({ray:F,intersectionPos:t,geomItem:U.geomItem,dist:U.dist,geomData:e})}}}return d}drawBackground(U){if(this.__glBackgroundMap&&this.__backgroundMapShader&&this.__backgroundMapShaderBinding){if(!this.__glBackgroundMap.isLoaded())return;const F=this.__gl;F.depthMask(!1),this.__backgroundMapShader.bind(U);const e=U.unifs;this.__glBackgroundMap.bindToUniform(U,e.backgroundImage),this.__backgroundMapShaderBinding.bind(U),F.drawQuad()}else this.__glEnvMap&&this.__glEnvMap.draw&&this.__glEnvMap.draw(U)}bindGLRenderer(U){super.bindGLBaseRenderer(U),U.envMap=this.__glEnvMap,U.exposure=this.__exposure,U.gamma=this.__gamma}drawScene(U){this.bindGLRenderer(U),this.__displayEnvironment&&this.drawBackground(U),super.drawScene(U),this.emit("redrawOccurred")}}class PQ extends tt{constructor(U){super(U,"BillboardShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 cameraMatrix;\n\nimport 'GLSLUtils.glsl'\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\n// A sorted attribute of instance Ids so we draw from back to front.\ninstancedattribute float instanceIds;\n\nimport 'transpose.glsl'\nimport 'imageAtlas.glsl'\n\nuniform sampler2D atlasBillboards_layout;\nuniform vec4 atlasBillboards_desc;\n\nuniform sampler2D instancesTexture;\nuniform int instancesTextureSize;\nuniform int passId;\n\nconst int cols_per_instance = 7;\n\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\n  vec4 col0 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 0);\n  vec4 col1 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 1);\n  vec4 col2 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 2);\n  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\n  return transpose(result);\n  // return mat4(1.0);\n}\n\nmat4 getModelMatrix(int id) {\n  return getMatrix(instancesTexture, instancesTextureSize, id);\n}\nvec4 getInstanceData(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 3);\n}\nvec4 getPivot(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 4);\n}\nvec4 getTintColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 5);\n}\n\n#else\n\nuniform vec4 atlasBillboards_desc;\n\nuniform mat4 modelMatrix;\nuniform vec2 pivot;\nuniform vec4 billboardData;\nuniform vec4 tintColor;\nuniform vec4 layoutData;\n\n#endif\n\nuniform int inVR;\n\nmat4 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  // vec3 rr = vec3(sin(roll), 0.0, cos(roll));\n  vec3 rr = vec3(0.0, 0.0, 1.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(rr, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  return mat4(vec4(uu, 0.0), vec4(vv, 0.0), vec4(ww, 0.0), vec4(origin, 1.0));\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n/* VS Outputs */\nvarying float v_instanceID;\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_tint;\nvarying vec3 v_viewPos;\n\nvoid main(void) {\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\n  int instanceID = int(instanceIds);\n  v_instanceID = float(instanceID) + 0.25;\n\n  mat4 modelMatrix = getModelMatrix(instanceID);\n  vec2 pivot = getPivot(instanceID).xy;\n  vec4 billboardData = getInstanceData(instanceID);\n  vec4 layoutData = fetchTexel(atlasBillboards_layout, int(atlasBillboards_desc.z), int(billboardData.z));\n  v_tint = getTintColor(instanceID);\n\n#else\n\n  v_tint = tintColor;\n\n#endif\n\n  vec2 quadVertex = getQuadVertexPositionFromID();\n  \n  vec2 pos = quadVertex + vec2(0.5, 0.0) - pivot;\n  v_texCoord = vec2(quadVertex.x, -quadVertex.y) + 0.5;\n  v_alpha = billboardData.w;\n  v_texCoord *= layoutData.zw;\n  v_texCoord += layoutData.xy;\n\n  float scl = billboardData.x;\n  float width = layoutData.z * atlasBillboards_desc.x * scl;\n  float height = layoutData.w * atlasBillboards_desc.y * scl;\n  int flags = int(billboardData.y);\n\n  // Use cross platform bit flags methods\n  bool alignedToCamera = testFlag(flags, 4); // flag = 1<<2\n  bool drawOnTop = testFlag(flags, 8); // flag = 1 << 3\n  bool fixedSizeOnscreen = testFlag(flags, 16); // flag = 1 << 4\n\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  // Note: items in front of the camera will have a negative value here.\n  float sc = 1.0;\n  if (fixedSizeOnscreen) {\n    sc = -modelViewMatrix[3][2];;\n  }\n  \n  mat4 modelViewProjectionMatrix;\n  if (alignedToCamera) {\n    if (inVR == 0) {\n      gl_Position = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n      gl_Position += vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 0.0);\n      v_viewPos = gl_Position.xyz;\n      gl_Position = projectionMatrix * gl_Position;\n    } else {\n      vec3 cameraPos = vec3(cameraMatrix[3][0], cameraMatrix[3][1], cameraMatrix[3][2]);\n      vec3 billboardPos = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);\n      mat4 lookAt = calcLookAtMatrix(billboardPos, cameraPos, 0.0);\n      mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * lookAt;\n      gl_Position = modelViewProjectionMatrix * vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 1.0);\n      v_viewPos = (modelViewMatrix * vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 1.0)).xyz;\n    }\n  }\n  else {\n    modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position = modelViewProjectionMatrix * vec4(pos.x * width, (pos.y + 0.5) * height, 0.0, 1.0);\n    v_viewPos = (modelViewMatrix * vec4(pos.x * width, (pos.y + 0.5) * height, 0.0, 1.0)).xyz;\n  }\n\n  // Use cross platform bit flags methods\n  if (drawOnTop) {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.w, 0.5);\n  }\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'imageAtlas.glsl'\n\nuniform sampler2D atlasBillboards;\n\n/* VS Outputs */\nvarying float v_instanceID;\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_tint;\nvarying vec3 v_viewPos;\n\nuniform sampler2D instancesTexture;\nuniform int instancesTextureSize;\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#endif // DRAW_GEOMDATA\n\nconst int cols_per_instance = 7;\n\nvec4 getHilightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 6);\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int instanceID = int(v_instanceID);\n  vec4 imageColor = texture2D(atlasBillboards, v_texCoord) * v_tint;\n  imageColor.a *= v_alpha;\n  if(imageColor.a < 0.1)\n    discard;\n\n#if defined(DRAW_COLOR)\n  fragColor = imageColor;\n  // fragColor.r = 1.0;\n  // fragColor.a = 1.0;\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, v_instanceID, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = getHilightColor(instanceID);\n  // Skip unhilighting labels.\n  if(fragColor.r < 0.001 && fragColor.g < 0.001 && fragColor.b < 0.001)\n    discard;\n#endif // DRAW_HIGHLIGHT\n  \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}}class OQ extends tt{constructor(U){super(U,"EnvProjectionShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;    //(location = 0)\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 projectionCenter;\n\nimport 'inverse.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n \nvoid main()\n{\n  int drawItemId = getDrawItemId();\n  vec4 pos = vec4(positions, 1.);\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n\n  gl_Position = modelViewProjectionMatrix * pos;\n\n  vec4 worldPos = modelMatrix * pos;\n  v_worldDir = worldPos.xyz - projectionCenter;\n}\n\n")}}new qU("EnvProjectionShader_template").addParameter(new cU("projectionCenter",new i(0,0,1.7)));class jQ extends tt{constructor(U){super(U,"FatLinesShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\ninstancedattribute vec2 segmentIndices;\nattribute float vertexIDs;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nuniform int drawItemId;\nint getDrawItemId() {\n  return drawItemId;\n}\n\nuniform sampler2D positionsTexture;\nuniform int positionsTextureSize;\n\nuniform float LineThickness;\nuniform float Overlay;\n\nimport 'calcFatLinesViewPos.glsl'\n\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_texCoord;\n\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData = getInstanceData(drawItemId);\n\n  int vertexID = int(vertexIDs);\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec3 pos;\n\n  #if defined(DRAW_COLOR)\n    v_viewPos       = calcFatLinesViewPos(vertexID, modelViewMatrix, v_viewNormal, v_texCoord, pos);\n  #elif defined(DRAW_GEOMDATA)\n    vec3  viewNormal;\n    vec2  texCoord;\n    v_viewPos       = calcFatLinesViewPos(vertexID, modelViewMatrix, viewNormal, texCoord, pos);\n    v_drawItemID = float(getDrawItemId());\n    v_worldPos      = (modelMatrix * vec4(pos, 1.0)).xyz;\n  #endif\n\n  gl_Position     = projectionMatrix * vec4(v_viewPos, 1.0);\n  if (Overlay > 0.0) {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.w, Overlay);\n  }\n\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nuniform color BaseColor;\nuniform mat4 cameraMatrix;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_texCoord;\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'GLSLBits.glsl'\n\nuniform int floatGeomBuffer;\nuniform int passId;\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getCutaway(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n}\n#else\n\nuniform vec4 cutawayData;\n\nvec4 getCutaway(int id) {\n  return cutawayData;\n}\n\n#endif\n\n#if defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n#if defined(DRAW_COLOR)\n  int debugLevel = 0;\n  if (debugLevel == 0) {\n\n    vec3 viewVector = mat3(cameraMatrix) * normalize(-v_viewPos);\n    vec3 normal = mat3(cameraMatrix) * v_viewNormal;\n    float NdotV = dot(normalize(normal), normalize(viewVector));\n\n    // Modulate the lighting using the texture coord so the line looks round.\n    NdotV *= cos((v_texCoord.x - 0.5) * 2.0);\n\n    vec4 color = BaseColor * NdotV;\n    fragColor = vec4(color.rgb, BaseColor.a);\n  }\n  else {\n    fragColor = vec4(v_texCoord.x, 0.0, 0.0, 1.0);\n  }\n#elif defined(DRAW_GEOMDATA)\n  int drawItemId = int(v_drawItemId + 0.5);\n  int flags = int(v_geomItemData.r + 0.5);\n // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    vec4 cutAwayData  = getCutaway(drawItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n      discard;\n      return;\n    }\n  }\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n\n  float dist = length(v_viewPos);\n\n  if (floatGeomBuffer != 0) {\n    fragColor.r = float(passId); \n    fragColor.g = float(v_drawItemID);\n    fragColor.b = 0.0;// TODO: store poly-id or something.\n    fragColor.a = dist;\n  }\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemId);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}bind(U,F){return!!super.bind(U,F)&&(U.supportsInstancing=!1,!0)}static supportsInstancing(){return!1}static getMaterialTemplate(){return AQ}}const AQ=new te("FatLinesShader_template");n.register("FatLinesShader",jQ);class qQ extends tt{constructor(U){super(U,"FlatSurfaceShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nimport 'GLSLUtils.glsl'\n\nimport 'drawItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData  = getInstanceData(drawItemId);\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  vec4 pos = vec4(positions, 1.);\n  vec4 viewPos = (modelViewMatrix * pos);\n  gl_Position = projectionMatrix * viewPos;\n\n  v_viewPos = viewPos.xyz;\n#ifdef ENABLE_TEXTURES\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n#endif\n\n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n#endif\n\n#endif // ENABLE_MULTI_DRAW\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nuniform color cutColor;\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getCutaway(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n}\n\n#else\n\nuniform vec4 cutawayData;\n\nvec4 getCutaway(int id) {\n  return cutawayData;\n}\n\n#endif\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int drawItemId = int(v_drawItemId + 0.5);\n  int flags = int(v_geomItemData.r + 0.5);\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(drawItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n      discard;\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Material\n#ifdef ENABLE_MULTI_DRAW\n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 baseColor = toLinear(getMaterialValue(materialCoords, 0));\n\n#else // ENABLE_MULTI_DRAW\n\n#ifndef ENABLE_TEXTURES\n  vec4 baseColor = toLinear(BaseColor);\n#else\n  vec4 baseColor = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n#endif // ENABLE_TEXTURES\n\n#endif // ENABLE_MULTI_DRAW\n\n  if (baseColor.a < 0.001) discard;\n\n#if defined(DRAW_COLOR)\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    if (!gl_FrontFacing) {\n#ifdef ENABLE_ES3\n      fragColor = cutColor;\n#else\n      gl_FragColor = cutColor;\n#endif\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  fragColor = baseColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#elif defined(DRAW_GEOMDATA)\n\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n\n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId,v_drawItemId, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemId);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}bind(U,F){super.bind(U,F);const e=this.__gl;return e.disable(e.CULL_FACE),!0}unbind(U){super.unbind(U);const F=this.__gl;return F.enable(F.CULL_FACE),!0}static getPackedMaterialData(U){const F=new Float32Array(4),e=U.getParameter("BaseColor").value;return F[0]=e.r,F[1]=e.g,F[2]=e.b,F[3]=e.a,F}static getMaterialTemplate(){return $Q}}const $Q=new le("FlatSurfaceShader_template");n.register("FlatSurfaceShader",qQ);class Ul extends tt{constructor(U){super(U,"LinesShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\nattribute vec3 positionsNext;\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n#ifdef ENABLE_MULTI_DRAW\nimport 'materialparams.glsl'\n#else\nuniform float Overlay;\n#endif\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_nextVertexDist;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData  = getInstanceData(drawItemId);\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.0);\n  vec4 viewPosNext = modelViewMatrix * vec4(positionsNext, 1.0);\n\n#ifdef ENABLE_ES3\n  float nextVertexDist = length(viewPosNext.xyz - viewPos.xyz);\n  if (imod(gl_VertexID, 2) == 0) {\n    v_nextVertexDist.x = nextVertexDist;\n    v_nextVertexDist.y = 0.0;\n  } else {\n    v_nextVertexDist.x = 0.0;\n    v_nextVertexDist.y = nextVertexDist;\n  }\n  v_nextVertexDist.z = float(gl_VertexID);\n#endif\n\n  v_viewPos = viewPos.xyz;\n  gl_Position = projectionMatrix * viewPos;\n    \n\n  //////////////////////////////////////////////\n  // Overlay\n\n#ifdef ENABLE_MULTI_DRAW\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  int maintainScreenSize = int(materialValue1.x + 0.5);\n  float overlay = materialValue1.y;\n#else\n  float overlay = Overlay;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  gl_Position.z = mix(gl_Position.z, -gl_Position.w, mix(overlay, 1.0, 0.0001));\n#else\n  gl_Position.z = mix(gl_Position.z, -gl_Position.w, overlay);\n#endif\n\n  //////////////////////////////////////////////\n  \n  \n  vec4 pos = vec4(positions, 1.);\n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'materialparams.glsl'\n\nuniform int occluded;\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\nuniform float Opacity;\n\nuniform float StippleScale;\nuniform float StippleValue;\nuniform float OccludedStippleValue;\n\n#endif // ENABLE_MULTI_DRAW\n\n#if defined(DRAW_GEOMDATA)\n\nuniform int floatGeomBuffer;\nuniform int passId;\n\nimport 'GLSLBits.glsl'\n\n#elif defined(DRAW_HIGHLIGHT)\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else // ENABLE_FLOAT_TEXTURES\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor() {\n  return highlightColor;\n}\n\n#endif // ENABLE_FLOAT_TEXTURES\n\n#endif // DRAW_HIGHLIGHT\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getCutaway(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n}\n\n#else\n\nuniform vec4 cutawayData;\n\nvec4 getCutaway(int id) {\n  return cutawayData;\n}\n\n#endif\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_nextVertexDist;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int drawItemId = int(v_drawItemId + 0.5);\n  int flags = int(v_geomItemData.r + 0.5);\n\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(drawItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n      discard;\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Material\n\n#ifdef ENABLE_MULTI_DRAW\n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 BaseColor = getMaterialValue(materialCoords, 0);\n  vec4 matValue1 = getMaterialValue(materialCoords, 1);\n  vec4 matValue2 = getMaterialValue(materialCoords, 2);\n  float Opacity  = matValue1.r;\n\n  float StippleScale = matValue1.b;\n  float StippleValue = matValue1.a;\n  float OccludedStippleValue = matValue2.r;\n#endif // ENABLE_MULTI_DRAW\n\n  ///////////////////\n  // Stippling\n  float stippleValue = occluded == 0 ? StippleValue : OccludedStippleValue;\n#ifdef ENABLE_ES3 // No stippling < es3 \n  if (stippleValue > 0.0) {\n    // Note: a value of 0.0, means no stippling (solid). A value of 1.0 means invisible\n    float dist = -v_viewPos.z * StippleScale;\n    float nextVertexDist = imod(int(floor(v_nextVertexDist.z)), 2) == 0 ? v_nextVertexDist.x : v_nextVertexDist.y;\n    if (mod(nextVertexDist / dist, 1.0) < stippleValue) {\n      discard;\n      return;\n    }\n  }\n#endif\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n  fragColor = BaseColor;\n  fragColor.a *= Opacity;\n\n  \n#ifndef ENABLE_ES3\n  if (occluded == 1) fragColor.a *= 1.0 - stippleValue;\n#endif\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n  \n  float viewDist = length(v_viewPos);\n\n  if (floatGeomBuffer != 0) {\n    fragColor.r = float(passId); \n    fragColor.g = float(v_drawItemId);\n    // Note: to make lines visually stand out from triangles\n    // this value is 0.0 in the surface shaders.\n    fragColor.b = 1.0;// TODO: store segment-id or something.\n    fragColor.a = viewDist;\n  } else {\n    ///////////////////////////////////\n    // UInt8 buffer\n    fragColor.r = mod(v_drawItemId, 256.) / 256.;\n    fragColor.g = (floor(v_drawItemId / 256.) + (float(passId) * 64.)) / 256.;\n\n    // encode the dist as a 16 bit float\n    vec2 float16bits = encode16BitFloatInto2xUInt8(viewDist);\n    fragColor.b = float16bits.x;\n    fragColor.a = float16bits.y;\n  }\n\n  //////////////////////////////////////////////\n  // Highlight\n#elif defined(DRAW_HIGHLIGHT)\n  \n  fragColor = getHighlightColor(drawItemId);\n\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}static getPackedMaterialData(U){const F=new Float32Array(12),e=U.getParameter("BaseColor").value;return F[0]=e.r,F[1]=e.g,F[2]=e.b,F[3]=e.a,F[4]=U.getParameter("Opacity").value,F[5]=U.getParameter("Overlay").value,F[6]=U.getParameter("StippleScale").value,F[7]=U.getParameter("StippleValue").value,F[8]=U.getParameter("OccludedStippleValue").value,F}static getMaterialTemplate(){return Fl}}const Fl=new ne("LinesShader_template");n.register("LinesShader",Ul);class el extends tt{constructor(U){super(U,"PointsShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n#ifdef ENABLE_MULTI_DRAW\nimport 'materialparams.glsl'\n#else\nuniform float PointSize;\nuniform float Overlay;\n#endif\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData  = getInstanceData(drawItemId);\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  \n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.);\n  gl_Position = projectionMatrix * viewPos;\n  \n\n  //////////////////////////////////////////////\n  // Material\n#ifdef ENABLE_MULTI_DRAW\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  int maintainScreenSize = int(materialValue1.x + 0.5);\n  float pointSize = materialValue1.x;\n  float overlay = materialValue1.y;\n#else\n  float pointSize = PointSize;\n  float overlay = Overlay;\n#endif\n  //////////////////////////////////////////////\n\n  // Note: as of 22/01/2021 gl_PointSize has stopped working again...\n  gl_PointSize = pointSize;\n\n#if defined(DRAW_GEOMDATA)\n  // Make the geom data point size at least 8 pixels across, else its impossible to hit.\n  gl_PointSize = max(8.0, pointSize);\n#endif\n  gl_Position.z = mix(gl_Position.z, -gl_Position.w, overlay);\n\n  \n  v_viewPos = -viewPos.xyz;\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\n\n#endif\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'materialparams.glsl'\n\n#if defined(DRAW_GEOMDATA)\n\nuniform int floatGeomBuffer;\nuniform int passId;\n\nimport 'GLSLBits.glsl'\n\n#elif defined(DRAW_HIGHLIGHT)\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else // ENABLE_FLOAT_TEXTURES\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor() {\n  return highlightColor;\n}\n\n#endif // ENABLE_FLOAT_TEXTURES\n\n#endif // DRAW_HIGHLIGHT\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n/* VS Outputs */\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n#ifdef ENABLE_MULTI_DRAW\n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 baseColor = getMaterialValue(materialCoords, 0);\n  vec4 matValue1 = getMaterialValue(materialCoords, 1);\n  float pointSize       = baseColor.a * matValue1.r;\n  float overlay      = matValue1.g;\n\n#else // ENABLE_MULTI_DRAW\n\n  vec4 baseColor = BaseColor;\n\n#endif // ENABLE_MULTI_DRAW\n\n  fragColor = baseColor;\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n\n  float viewDist = length(v_viewPos);\n\n  if (floatGeomBuffer != 0) {\n    fragColor.r = float(passId); \n    fragColor.g = float(v_drawItemId);\n    fragColor.b = 0.0;// TODO: store poly-id or something.\n    fragColor.a = viewDist;\n  }\n  else {\n    ///////////////////////////////////\n    // UInt8 buffer\n    fragColor.r = mod(v_drawItemId, 256.) / 256.;\n    fragColor.g = (floor(v_drawItemId / 256.) + (float(passId) * 64.)) / 256.;\n\n    // encode the dist as a 16 bit float\n    vec2 float16bits = encode16BitFloatInto2xUInt8(viewDist);\n    fragColor.b = float16bits.x;\n    fragColor.a = float16bits.y;\n  }\n\n  //////////////////////////////////////////////\n  // Highlight\n#elif defined(DRAW_HIGHLIGHT)\n  \n  int drawItemId = int(v_drawItemId + 0.5);\n  fragColor = getHighlightColor(drawItemId);\n\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}static getPackedMaterialData(U){const F=new Float32Array(12),e=U.getParameter("BaseColor").value;return F[0]=e.r,F[1]=e.g,F[2]=e.b,F[3]=e.a,F[4]=U.getParameter("PointSize").value,F[5]=U.getParameter("Overlay").value,F}static getMaterialTemplate(){return tl}}const tl=new ae("PointsShader_template");n.register("PointsShader",el);class Ql extends tt{constructor(U){super(U,"FatPointsShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\ninstancedattribute vec3 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nimport 'GLSLUtils.glsl' \nimport 'inverse.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\nimport 'quadVertexFromID.glsl'\n\nuniform int drawItemId;\nint getDrawItemId() {\n  return drawItemId;\n}\n\nuniform float PointSize;\nuniform float Overlay;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying vec3 v_viewPos;\nvarying float v_drawItemId;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  vec2 quadPointPos = getQuadVertexPositionFromID();\n  v_texCoord = quadPointPos + 0.5;\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  \n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.);\n\n  // During XR sessions, there is a scaling applied to the view matrix\n  // which causes a distortion to the line width. We extract that scale here\n  // and use to correct the distortion.\n  // See also: FatLinesShader\n  vec3 viewZ = modelViewMatrix[2].xyz;\n  float viewScale = length(viewZ);\n  viewPos += vec4(vec3(quadPointPos, 0.0) * PointSize * viewScale, 0.);\n\n  // Generate a quad which is 0.5 * PointSize closer towards\n  // us. This allows points to be visualized even if snug on \n  // a surface. (else they get fully clipped)\n  viewPos.z += 0.5 * PointSize;\n\n  v_drawItemId = float(getDrawItemId());\n  v_viewPos = -viewPos.xyz;\n  \n  gl_Position = projectionMatrix * viewPos;\n  if (Overlay > 0.0) {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.w, Overlay);\n  }\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'constants.glsl'\n\nuniform color BaseColor;\nuniform float Rounded;\nuniform float BorderWidth;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying vec3 v_viewPos;\nvarying float v_drawItemId;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\nfloat dist = length(v_texCoord - 0.5);\nif (dist > 0.5)\n  discard;\n\n#if defined(DRAW_COLOR)\n\n  if (dist > 0.5 - (BorderWidth * 0.5))\n    fragColor = vec4(0.,0.,0.,1.);\n  else {\n    // Modulate the lighting using the texture coord so the point looks round.\n    float NdotV = cos(dist * PI);\n\n    fragColor = BaseColor * mix(1.0, NdotV, Rounded);\n  }\n\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId,v_drawItemId, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemId);\n#endif // DRAW_HIGHLIGHT\n\n  \n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}bind(U,F){return!!super.bind(U,F)&&(U.supportsInstancing=!1,!0)}static supportsInstancing(){return!1}static getMaterialTemplate(){return ll}}const ll=new Qe("FatPointsShader_template");n.register("FatPointsShader",Ql);class nl extends tt{constructor(U){super(U,"SimpleSurfaceShader"),this.setShaderStage("VERTEX_SHADER","precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nimport 'inverse.glsl'\nimport 'drawItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData  = getInstanceData(drawItemId);\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  vec4 pos = vec4(positions, 1.);\n  vec4 viewPos    = modelViewMatrix * pos;\n  gl_Position     = projectionMatrix * viewPos;\n\n  mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n  v_viewPos       = -viewPos.xyz;\n  v_viewNormal    = normalMatrix * normals;\n\n#ifdef ENABLE_TEXTURES\n  v_textureCoord  = texCoords;\n  // v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n#endif\n\n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"),this.setShaderStage("FRAGMENT_SHADER","precision highp float;\n#define GLSLIFY 1\n#ifdef ENABLE_MULTI_DRAW\n// #define DEBUG_GEOM_ID\n#endif\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\n#ifdef DEBUG_GEOM_ID\nimport 'debugColors.glsl'\n#endif\n\nuniform color cutColor;\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getCutaway(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n}\n\n#else\n\nuniform vec4 cutawayData;\n\nvec4 getCutaway(int id) {\n  return cutawayData;\n}\n\n#endif\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\nuniform mat4 cameraMatrix;\nuniform int isOrthographic;\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\nuniform float Opacity;\nuniform float EmissiveStrength;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\nuniform sampler2D OpacityTex;\nuniform int OpacityTexType;\nuniform sampler2D EmissiveStrengthTex;\nuniform int EmissiveStrengthTexType;\n#endif // ENABLE_TEXTURES\n\n#endif // ENABLE_MULTI_DRAW\n\nimport 'computeViewNormal.glsl'\n  \n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int drawItemId = int(v_drawItemId + 0.5);\n  int flags = int(v_geomItemData.r + 0.5);\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(drawItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n      discard;\n      return;\n    }\n  }\n\n#if defined(DRAW_COLOR)\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    if (!gl_FrontFacing) {\n#ifdef ENABLE_ES3\n  fragColor = cutColor;\n#else\n  gl_FragColor = cutColor;\n#endif\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Normals\n  \n  vec3 viewNormal;\n  if (length(v_viewNormal) < 0.1) {\n    viewNormal = computeViewNormal(v_viewPos);\n  } else {\n    viewNormal = normalize(v_viewNormal);\n  }\n  vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n  \n  vec3 viewVector;\n  if (isOrthographic == 0)\n    viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n  else \n    viewVector = vec3(-cameraMatrix[2][0], -cameraMatrix[2][1], -cameraMatrix[2][2]);\n  \n  //////////////////////////////////////////////\n  // Material\n\n#ifdef ENABLE_MULTI_DRAW\n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 baseColor = toLinear(getMaterialValue(materialCoords, 0));\n  vec4 matValue1 = getMaterialValue(materialCoords, 1);\n  float opacity       = baseColor.a * matValue1.r;\n  float emission      = matValue1.g;\n\n#else // ENABLE_MULTI_DRAW\n\n#ifndef ENABLE_TEXTURES\n  vec4 baseColor      = toLinear(BaseColor);\n  float emission      = EmissiveStrength;\n  float opacity       = baseColor.a * Opacity;\n#else\n  vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n  float opacity       = baseColor.a * getLuminanceParamValue(Opacity, OpacityTex, OpacityTexType, v_textureCoord);\n  float emission      = getLuminanceParamValue(EmissiveStrength, EmissiveStrengthTex, EmissiveStrengthTexType, v_textureCoord);\n#endif\n\n#endif // ENABLE_MULTI_DRAW\n\n  // Hacky simple irradiance. \n  float ndotv = dot(normal, viewVector);\n  if (ndotv < 0.0) {\n    normal = -normal;\n    ndotv = dot(normal, viewVector);\n\n    // Note: these 2 lines can be used to debug inverted meshes.\n    //baseColor = vec4(1.0, 0.0, 0.0, 1.0);\n    //ndotv = 1.0;\n  }\n\n  fragColor = vec4((ndotv * baseColor.rgb) + (emission * baseColor.rgb), opacity);\n\n#ifdef DEBUG_GEOM_ID\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n\n  // ///////////////////////\n  // Debug Draw ID (this correlates to GeomID within a GLGeomSet)\n  float geomId = v_geomItemData.w;\n  fragColor.rgb = getDebugColor(geomId);\n  // ///////////////////////\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#elif defined(DRAW_GEOMDATA)\n\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId,v_drawItemId, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemId);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}")}static getPackedMaterialData(U){const F=new Float32Array(8),e=U.getParameter("BaseColor").value;return F[0]=e.r,F[1]=e.g,F[2]=e.b,F[3]=e.a,F[4]=U.getParameter("Opacity").value,F[5]=U.getParameter("EmissiveStrength").value,F}static getMaterialTemplate(){return al}}const al=new ie("SimpleSurfaceShader_template");n.register("SimpleSurfaceShader",nl);class dl extends tt{constructor(U){super(U,"StandardSuraceShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n// should be imported by bottom 3\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nimport 'inverse.glsl'\n\nimport 'drawItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n#if defined(DRAW_COLOR)\n#elif defined(DRAW_GEOMDATA)\n#elif defined(DRAW_HIGHLIGHT)\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData = getInstanceData(drawItemId);\n  vec4 pos = vec4(positions, 1.);\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec4 viewPos    = modelViewMatrix * pos;\n  gl_Position     = projectionMatrix * viewPos;\n  v_viewPos = -viewPos.xyz;\n  v_worldPos      = (modelMatrix * pos).xyz;\n\n  mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n  v_viewPos       = -viewPos.xyz;\n  v_viewNormal    = normalMatrix * normals;\n\n#ifdef ENABLE_TEXTURES\n  v_textureCoord  = texCoords;\n#endif\n\n}\n"),this.setShaderStage("FRAGMENT_SHADER","  precision highp float;\n#define GLSLIFY 1\n\n  import 'GLSLUtils.glsl'\n  import 'drawItemTexture.glsl' \n  import 'cutaways.glsl'\n  import 'gamma.glsl'\n  import 'materialparams.glsl'\n  import 'GLSLBits.glsl'\n\n  #ifdef ENABLE_FLOAT_TEXTURES\n    vec4 getCutaway(int id) {\n      return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n    }\n\n  #else\n\n    uniform vec4 cutawayData;\n\n    vec4 getCutaway(int id) {\n      return cutawayData;\n    }\n\n  #endif\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\n#if defined(DRAW_COLOR)\n\n#ifdef ENABLE_MULTI_DRAW\n// #define DEBUG_GEOM_ID\n#endif\n#ifdef DEBUG_GEOM_ID\nimport 'debugColors.glsl'\n#endif\n\nuniform color cutColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nuniform mat4 cameraMatrix;\nuniform int isOrthographic;\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\nuniform float AmbientOcclusion;\nuniform float Roughness;\nuniform float Metallic;\nuniform float Reflectance;\nuniform float EmissiveStrength;\nuniform float Opacity;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n\nuniform sampler2D AmbientOcclusionTex;\nuniform int AmbientOcclusionTexType;\n\n#ifdef ENABLE_PBR\nuniform sampler2D RoughnessTex;\nuniform int RoughnessTexType;\n\nuniform sampler2D MetallicTex;\nuniform int MetallicTexType;\n\nuniform sampler2D ReflectanceTex;\nuniform int ReflectanceTexType;\n\nuniform sampler2D NormalTex;\nuniform int NormalTexType;\n#endif // ENABLE_PBR\n\nuniform sampler2D EmissiveStrengthTex;\nuniform int EmissiveStrengthTexType;\n\n#endif // ENABLE_TEXTURES\n#endif // ENABLE_MULTI_DRAW\n\nimport 'PBRSurfaceRadiance.glsl'\n\n#ifdef ENABLE_PBR\nmat3 cotangentFrame( in vec3 normal, in vec3 pos, in vec2 texCoord ) {\n  // https://stackoverflow.com/questions/5255806/how-to-calculate-tangent-and-binormal\n  vec3 n = normal;\n  // derivations of the fragment position\n  vec3 pos_dx = dFdx( pos );\n  vec3 pos_dy = dFdy( pos );\n  // derivations of the texture coordinate\n  vec2 texC_dx = dFdx( texCoord );\n  vec2 texC_dy = dFdy( texCoord );\n  // tangent vector and binormal vector\n  vec3 t = -(texC_dy.y * pos_dx - texC_dx.y * pos_dy);\n  vec3 b = -(texC_dx.x * pos_dy - texC_dy.x * pos_dx);\n\n  t = t - n * dot( t, n ); // orthonormalization ot the tangent vectors\n  b = b - n * dot( b, n ); // orthonormalization of the binormal vectors to the normal vector\n  b = b - t * dot( b, t ); // orthonormalization of the binormal vectors to the tangent vector\n  mat3 tbn = mat3( normalize(t), normalize(b), n );\n\n  return tbn;\n}\n#endif\n\nimport 'computeViewNormal.glsl'\n\n#elif defined(DRAW_GEOMDATA)\nuniform int isOrthographic;\nimport 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\nimport 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n  #ifndef ENABLE_ES3\n    vec4 fragColor;\n  #endif\n\n  int drawItemId = int(v_drawItemId + 0.5);\n  int flags = int(v_geomItemData.r + 0.5);\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    vec4 cutAwayData   = getCutaway(drawItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n        discard;\n        return;\n    }\n  }\n  \n#if defined(DRAW_COLOR)\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    if (!gl_FrontFacing) {\n#ifdef ENABLE_ES3\n      fragColor = cutColor;\n#else\n      gl_FragColor = cutColor;\n#endif\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Normals\n  vec3 viewNormal;\n  if (length(v_viewNormal) < 0.1) {\n    viewNormal = computeViewNormal(v_viewPos);\n  } else {\n    viewNormal = normalize(v_viewNormal);\n  }\n  vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n  \n  vec3 viewVector;\n  if (isOrthographic == 0)\n    viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n  else \n    viewVector = vec3(-cameraMatrix[2][0], -cameraMatrix[2][1], -cameraMatrix[2][2]);\n    \n  if (dot(normal, viewVector) < 0.0) {\n      normal = -normal;\n      // Note: this line can be used to debug inverted meshes.\n      //material.baseColor = vec3(1.0, 0.0, 0.0);\n  }\n\n  //////////////////////////////////////////////\n  // Material\n\n  MaterialParams material;\n\n#ifdef ENABLE_MULTI_DRAW\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 matValue0      = getMaterialValue(materialCoords, 0);\n  vec4 matValue1      = getMaterialValue(materialCoords, 1);\n  vec4 matValue2      = getMaterialValue(materialCoords, 2);\n\n  material.baseColor     = toLinear(matValue0.rgb);\n  material.ambientOcclusion      = matValue1.r;\n  material.metallic      = matValue1.g;\n  material.roughness     = matValue1.b;\n  material.reflectance   = matValue1.a;\n\n  material.emission         = matValue2.r;\n  material.opacity          = matValue2.g * matValue0.a;\n\n#else // ENABLE_MULTI_DRAW\n\n#ifndef ENABLE_TEXTURES\n  material.baseColor     = toLinear(BaseColor.rgb);\n  material.emission      = EmissiveStrength;\n\n#ifdef ENABLE_PBR\n  material.roughness     = Roughness;\n  material.metallic      = Metallic;\n  material.reflectance   = Reflectance;\n#endif\n\n#else\n  // Planar YZ projection for texturing, repeating every meter.\n  // vec2 texCoord       = v_worldPos.xz * 0.2;\n  vec2 texCoord          = v_textureCoord;\n\n  vec4 baseColor         = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, texCoord);\n  material.ambientOcclusion = getLuminanceParamValue(AmbientOcclusion, AmbientOcclusionTex, AmbientOcclusionTexType, texCoord);\n  material.baseColor     = baseColor.rgb;\n  \n#ifdef ENABLE_PBR\n\n  material.metallic      = getLuminanceParamValue(Metallic, MetallicTex, MetallicTexType, texCoord);\n  material.roughness     = getLuminanceParamValue(Roughness, RoughnessTex, RoughnessTexType, texCoord);\n\n  // TODO: Communicate that this tex contains the roughness as well.\n  if (MetallicTexType != 0) {\n    vec4 metallicRoughness = vec4(Metallic, Roughness, 0.0, 1.0);\n    metallicRoughness     = texture2D(MetallicTex, texCoord);\n    material.roughness     = metallicRoughness.g;\n    material.metallic     = metallicRoughness.b;\n  }\n\n  material.reflectance   = getLuminanceParamValue(Reflectance, ReflectanceTex, ReflectanceTexType, texCoord);\n#endif // ENABLE_PBR\n  material.emission         = getLuminanceParamValue(EmissiveStrength, EmissiveStrengthTex, EmissiveStrengthTexType, texCoord);\n#endif // ENABLE_TEXTURES\n  material.opacity       = Opacity * baseColor.a;\n\n#ifdef ENABLE_TEXTURES\n#ifdef ENABLE_PBR\n  if (NormalTexType != 0) {\n      mat3 tbn = cotangentFrame(normal, viewVector, texCoord);\n      normal = normalize(tbn * (texture2D(NormalTex, texCoord).rgb * 2.0 - 1.0));\n  }\n#endif // ENABLE_PBR\n#endif // ENABLE_TEXTURES\n#endif // ENABLE_MULTI_DRAW\n\n  fragColor = pbrSurfaceRadiance(material, normal, viewVector);\n  // fragColor = vec4(texture2D(NormalTex, texCoord).rgb, 1.0);\n  // fragColor = metallicRoughness;\n  // fragColor = vec4(material.baseColor, 1.0);;\n  // fragColor = vec4(vec3(material.metallic), 1.0);;\n  // fragColor = vec4(vec3(material.roughness), 1.0);;\n  // fragColor = vec4(vec3(material.ambientOcclusion), 1.0);\n  \n#ifdef DEBUG_GEOM_ID\n  // ///////////////////////\n  // Debug Draw ID (this correlates to GeomID within a GLGeomSet)\n  float geomId = v_geomItemData.w;\n  fragColor.rgb = getDebugColor(geomId);\n  // ///////////////////////\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#elif defined(DRAW_GEOMDATA)\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n  \n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId,v_drawItemId, isOrthographic);\n   \n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = getHighlightColor(drawItemId);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n\n}")}bind(U,F){const e=U;super.bind(U,F);const t=this.__gl;e.envMap&&e.envMap.bind(e);const{exposure:Q}=e.unifs;return Q&&t.uniform1f(Q.location,e.exposure),!0}static getPackedMaterialData(U){const F=new Float32Array(12),e=U.getParameter("BaseColor").value;return F[0]=e.r,F[1]=e.g,F[2]=e.b,F[3]=e.a,F[4]=U.getParameter("AmbientOcclusion").value,F[5]=U.getParameter("Metallic").value,F[6]=U.getParameter("Roughness").value,F[7]=U.getParameter("Reflectance").value,F[8]=U.getParameter("EmissiveStrength").value,F[9]=U.getParameter("Opacity").value,F}static getMaterialTemplate(){return il}}const il=new se("StandardSurfaceShader_template");n.register("StandardSurfaceShader",dl),n.register("TransparentSurfaceShader",dl);class sl extends tt{constructor(U){super(U,"ScreenSpaceShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData  = getInstanceData(drawItemId);\n\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n\n  gl_Position = (modelMatrix * vec4(positions, 1.0));\n\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\n#ifdef ENABLE_MULTI_DRAW\nimport 'drawItemTexture.glsl'\n#endif // ENABLE_MULTI_DRAW\n\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\n#if defined(DRAW_COLOR)\n\n  #ifndef ENABLE_MULTI_DRAW\n\n    uniform color BaseColor;\n\n    #ifdef ENABLE_TEXTURES\n      uniform sampler2D BaseColorTex;\n      uniform int BaseColorTexType;\n    #endif\n\n  #endif // ENABLE_MULTI_DRAW\n#endif // DRAW_COLOR\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n  \n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n  #ifdef ENABLE_MULTI_DRAW\n\n    vec2 materialCoords = v_geomItemData.zw;\n    vec4 baseColor = getMaterialValue(materialCoords, 0);\n\n  #else // ENABLE_MULTI_DRAW\n\n  #ifndef ENABLE_TEXTURES\n    vec4 baseColor = BaseColor;\n  #else\n    vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n  #endif\n\n  #endif // ENABLE_MULTI_DRAW\n\n    fragColor = baseColor;\n\n  #ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb);\n  #endif\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(vec3(0,0,0), floatGeomBuffer, passId,v_drawItemId, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemId);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}static isOverlay(){return!0}static getPackedMaterialData(U){const F=new Float32Array(8),e=U.getParameter("BaseColor").value;return F[0]=e.r,F[1]=e.g,F[2]=e.b,F[3]=e.a,F}static getMaterialTemplate(){return Rl}}const Rl=new de("ScreenSpaceShader_template");n.register("ScreenSpaceShader",sl);class Bl extends Ke{constructor(){super()}init(U,F){super.init(U,F)}itemAddedToScene(U,F){if(U instanceof he){const F=U;return!!this.filterGeomItem(F)&&(this.addGeomItem(F),F.setMetadata("glpass",this),!0)}return!1}itemRemovedFromScene(U,F){return U instanceof he&&U.getMetadata("glpass")==this&&this.removeGeomItem(U)}filterGeomItem(U){return!0}addGeomItem(U){}removeGeomItem(U){return!1}constructShaders(U){let F,e;const t=this.__renderer.getOrCreateShader(U);return F=t.getGeomDataShaderName()?this.__renderer.getOrCreateShader(t.getGeomDataShaderName()):t,e=t.getSelectedShaderName()?this.__renderer.getOrCreateShader(t.getSelectedShaderName()):t,{glShader:t,glgeomdatashader:F,glselectedshader:e}}getGeomItemAndDist(U){let F,e;U instanceof Float32Array?(F=Math.round(U[1]),e=U[3]):(F=U[0]+((63&U[1])<<8),e=J.decode16BitFloatFrom2xUInt8(U.slice(2,3)));const t=this.renderer.glGeomItemLibrary.getGeomItem(F);if(t)return{geomItem:t,dist:e}}}class Vl extends k{constructor(U){super(),this.drawIdsTexture=null,this.highlightedIdsTexture=null,this.renderer=U,this.gl=U.gl,this.glGeomItems=[],this.glGeomIdsMapping={},this.glgeomItemEventHandlers=[],this.freeIndices=[],this.drawElementCounts=new Int32Array(0),this.drawElementOffsets=new Int32Array(0),this.highlightElementCounts=new Int32Array(0),this.highlightElementOffsets=new Int32Array(0),this.reserved=0,this.visibleItems=[],this.drawIdsArray=new Float32Array(0),this.drawIdsBufferDirty=!0,this.drawIdsTexture=null,this.highlightedItems=[],this.highlightedIdsArray=null,this.highlightedIdsTexture=null,this.highlightedIdsBufferDirty=!0,this.renderer.glGeomLibrary.on("geomDataChanged",(U=>{const F=this.glGeomIdsMapping[U.index];null!=F&&F.forEach((U=>{const F=this.glGeomItems[U];if(F.isVisible()){const U=this.visibleItems.indexOf(F),e=this.renderer.glGeomLibrary.getGeomOffsetAndCount(F.geomId);this.drawElementOffsets[U]=e[0],this.drawElementCounts[U]=e[1];const t=this.highlightedItems.indexOf(F);-1!=t&&(this.highlightElementOffsets[t]=e[0],this.highlightElementCounts[t]=e[1])}}))}))}addGLGeomItem(U){const F=this.freeIndices.length>0?this.freeIndices.pop():this.glGeomItems.length;this.glGeomIdsMapping[U.geomId]?this.glGeomIdsMapping[U.geomId].push(F):this.glGeomIdsMapping[U.geomId]=[F];const e={};U.visible&&this.visibleItems.push(U),e.visibilityChanged=F=>{F.visible?this.visibleItems.push(U):this.visibleItems.splice(this.visibleItems.indexOf(U),1),this.drawIdsBufferDirty||(this.drawIdsBufferDirty=!0,this.emit("updated"))},U.on("visibilityChanged",e.visibilityChanged),U.geomItem.isHighlighted()&&(this.highlightedItems.push(U),this.highlightedIdsBufferDirty=!0),e.highlightChanged=F=>{if(F&&F.name){if(this.highlightedItems.includes(U))return;this.highlightedItems.push(U)}else this.highlightedItems.splice(this.highlightedItems.indexOf(U),1);this.highlightedIdsBufferDirty=!0,this.emit("updated")},U.geomItem.on("highlightChanged",e.highlightChanged),this.glGeomItems[F]=U,this.glgeomItemEventHandlers[F]=e,this.drawIdsBufferDirty=!0,this.emit("updated")}removeGLGeomItem(U){const F=this.glGeomItems.indexOf(U),e=this.glGeomIdsMapping[U.geomId];e.splice(e.indexOf(F),1),0==e.length&&delete this.glGeomIdsMapping[U.geomId];const t=this.glgeomItemEventHandlers[F];if(U.geomItem.off("highlightChanged",t.highlightChanged),U.off("visibilityChanged",t.visibilityChanged),this.glGeomItems[F]=null,this.glgeomItemEventHandlers[F]=null,this.drawIdsArray[F]=0,this.drawElementOffsets[F]=0,this.drawElementCounts[F]=0,this.freeIndices.push(F),U.isVisible()){const F=this.visibleItems.indexOf(U);this.visibleItems.splice(F,1),this.drawIdsBufferDirty=!0}if(U.geomItem.isHighlighted()){const F=this.highlightedItems.indexOf(U);this.highlightedItems.splice(F,1),this.highlightedIdsBufferDirty=!0}this.emit("updated")}updateDrawIDsBuffer(U){(!this.drawIdsArray||this.visibleItems.length>this.drawIdsArray.length)&&(this.drawIdsArray=new Float32Array(this.visibleItems.length),this.drawElementOffsets=new Int32Array(this.visibleItems.length),this.drawElementCounts=new Int32Array(this.visibleItems.length)),this.visibleItems.forEach(((U,F)=>{const e=this.renderer.glGeomLibrary.getGeomOffsetAndCount(U.geomId);this.drawElementOffsets[F]=e[0],this.drawElementCounts[F]=e[1],this.drawIdsArray[F]=U.drawItemId}));const F=this.renderer.gl;if(!F.multiDrawElements)return;const e=U.boundTextures++;F.activeTexture(F.TEXTURE0+e);const t=2*J.nextPow2(Math.ceil(Math.sqrt(this.visibleItems.length)));this.drawIdsTexture?(this.drawIdsTexture.width<t||this.drawIdsTexture.height<t)&&this.drawIdsTexture.resize(t,t):this.drawIdsTexture=new Ae(this.gl,{format:"webgl2"==F.name?"RED":"ALPHA",type:"FLOAT",width:t,height:t,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1});{const U=this.drawIdsTexture,e=this.drawIdsTexture.width;F.bindTexture(F.TEXTURE_2D,U.glTex);const t=0,Q=0,l=1,n=U.getFormat(),a=U.getType(),d=Math.ceil((Q+this.visibleItems.length)/e);let i=0,s=this.visibleItems.length,R=Q;for(let U=0;U<d;U++){let U;R+s>e?(U=e-R,R=0):U=s;const Q=i%e,d=Math.floor(i/e),B=this.drawIdsArray.subarray(i,i+U);F.texSubImage2D(F.TEXTURE_2D,t,Q,d,U,l,n,a,B),i+=U,s-=U}}F.bindTexture(F.TEXTURE_2D,null),U.boundTextures--,this.drawIdsBufferDirty=!1}updateHighlightedIDsBuffer(U){if(this.highlightedIdsBufferDirty){(!this.highlightedIdsArray||this.highlightedItems.length>this.highlightedIdsArray.length)&&(this.highlightedIdsArray=new Float32Array(this.highlightedItems.length),this.highlightElementOffsets=new Int32Array(this.highlightedItems.length),this.highlightElementCounts=new Int32Array(this.highlightedItems.length)),this.highlightedItems.forEach(((U,F)=>{this.highlightedIdsArray[F]=U.drawItemId;const e=this.renderer.glGeomLibrary.getGeomOffsetAndCount(U.geomId);this.highlightElementOffsets[F]=e[0],this.highlightElementCounts[F]=e[1]}));for(let U=this.highlightedItems.length;U<this.highlightElementCounts.length;U++)this.highlightElementOffsets[U]=0,this.highlightElementCounts[U]=0;this.highlightedIdsBufferDirty=!1}const F=this.renderer.gl;if(!F.multiDrawElements)return;const e=U.boundTextures++;F.activeTexture(F.TEXTURE0+e);const t=J.nextPow2(Math.ceil(Math.sqrt(this.highlightedItems.length)));this.highlightedIdsTexture?(this.highlightedIdsTexture.width<t||this.highlightedIdsTexture.height<t)&&this.highlightedIdsTexture.resize(t,t):this.highlightedIdsTexture=new Ae(this.gl,{format:"webgl2"==F.name?"RED":"ALPHA",type:"FLOAT",width:t,height:t,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1});{const U=this.highlightedIdsTexture,e=this.highlightedIdsTexture.width;F.bindTexture(F.TEXTURE_2D,U.glTex);const t=0,Q=0,l=1,n=U.getFormat(),a=U.getType(),d=Math.ceil((Q+this.highlightedIdsArray.length)/e);let i=0,s=this.highlightedIdsArray.length,R=Q;for(let U=0;U<d;U++){let U;R+s>e?(U=e-R,R=0):U=s;const Q=i%e,d=Math.floor(i/e),B=this.highlightedIdsArray.subarray(i,i+U);F.texSubImage2D(F.TEXTURE_2D,t,Q,d,U,l,n,a,B),i+=U,s-=U}}F.bindTexture(F.TEXTURE_2D,null),U.boundTextures--}draw(U){if(this.drawIdsBufferDirty&&this.updateDrawIDsBuffer(U),0!=this.visibleItems.length){if(this.drawIdsTexture){const{drawIdsTexture:F}=U.unifs;this.drawIdsTexture.bindToUniform(U,F)}this.bindAndRender(U,this.drawIdsArray,this.drawElementCounts,this.drawElementOffsets,this.visibleItems.length)}}drawHighlighted(U){if(0!=this.highlightedItems.length){if(this.highlightedIdsBufferDirty&&this.updateHighlightedIDsBuffer(U),this.highlightedIdsTexture){const{drawIdsTexture:F}=U.unifs;this.highlightedIdsTexture.bindToUniform(U,F)}this.bindAndRender(U,this.highlightedIdsArray,this.highlightElementCounts,this.highlightElementOffsets,this.highlightedItems.length)}}bindAndRender(U,F,e,t,Q){const l=this.gl,n=U.unifs;n.instancedDraw&&l.uniform1i(U.unifs.instancedDraw.location,1),U.bindViewports(n,(()=>{this.multiDraw(U,F,e,t,Q)}))}sortItems(U){const F=[],e=[];this.visibleItems.forEach(((t,Q)=>{if(t){const l=t.geomItem.geomMatParam.value.translation.distanceTo(U);F.push(l),e.push(Q)}})),e.sort(((U,e)=>F[e]-F[U]));const t=[],Q=new Int32Array(this.drawElementCounts.length),l=new Int32Array(this.drawElementOffsets.length);e.forEach(((U,F)=>{t[F]=this.visibleItems[U],Q[F]=this.drawElementCounts[U],l[F]=this.drawElementOffsets[U],this.drawIdsArray[F]=this.visibleItems[U].drawItemId})),this.visibleItems=t,this.drawElementCounts=Q,this.drawElementOffsets=l,this.drawIdsBufferDirty=!0}destroy(){this.drawIdsTexture&&this.drawIdsTexture.destroy(),this.highlightedIdsTexture&&this.highlightedIdsTexture.destroy(),this.emit("destructing")}}class rl extends Vl{multiDraw(U,F,e,t,Q){const l=this.gl;if(l.multiDrawArrays){const{occluded:F}=U.unifs;F&&l.uniform1i(F.location,0),l.multiDrawElements(l.LINES,e,0,l.UNSIGNED_INT,t,0,Q),F&&(l.uniform1i(F.location,1),l.depthFunc(l.GREATER),l.multiDrawElements(l.LINES,e,0,l.UNSIGNED_INT,t,0,Q),l.depthFunc(l.LEQUAL))}else{const{drawId:n,occluded:a}=U.unifs;a&&l.uniform1i(a.location,0);for(let U=0;U<Q;U++)l.uniform1i(n.location,F[U]),l.drawElements(l.LINES,e[U],l.UNSIGNED_INT,t[U]);if(a){l.uniform1i(a.location,1),l.depthFunc(l.GREATER);for(let U=0;U<Q;U++)l.uniform1i(n.location,F[U]),l.drawElements(l.LINES,e[U],l.UNSIGNED_INT,t[U]);l.depthFunc(l.LEQUAL)}}}}class hl extends Vl{multiDraw(U,F,e,t,Q){const l=this.gl;if(l.multiDrawArrays)l.multiDrawArrays(l.POINTS,t,0,e,0,Q);else{const{drawId:n}=U.unifs;for(let U=0;U<Q;U++)l.uniform1i(n.location,F[U]),l.drawArrays(l.TRIANGLES,t[U],e[U])}}}class ol extends Vl{multiDraw(U,F,e,t,Q){const l=this.gl;if(l.multiDrawElements)l.multiDrawElements(l.TRIANGLES,e,0,l.UNSIGNED_INT,t,0,Q);else{const{drawId:n}=U.unifs;for(let U=0;U<Q;U++)l.uniform1i(n.location,F[U]),l.drawElements(l.TRIANGLES,e[U],l.UNSIGNED_INT,t[U])}}}class Jl extends k{constructor(U,F,e){super(),this.glGeomDataShaderKey="",this.glHighlightShaderKey="",this.pass=U,this.gl=F,this.glShader=e.glShader,this.glGeomDataShader=e.glgeomdatashader?e.glgeomdatashader:e.glShader,this.glHighlightShader=e.glselectedshader?e.glselectedshader:e.glShader,this.glGeomItemSets={},this.glShaderKey=e.glShader.getId()+"multidraw-draw",this.glGeomDataShader&&(this.glGeomDataShaderKey=this.glGeomDataShader.getId()+"multidraw-geomdata"),this.glHighlightShader&&(this.glHighlightShaderKey=this.glHighlightShader.getId()+"multidraw-highlight")}getOrCreateGLGeomItemSet(U){let F;if(U instanceof iF||U instanceof VF){if(this.glGeomItemSets.GLMesh)return this.glGeomItemSets.GLMesh;F=new ol(this.pass.renderer),this.glGeomItemSets.GLMesh=F}else if(U instanceof dF||U instanceof BF){if(this.glGeomItemSets.GLLines)return this.glGeomItemSets.GLLines;F=new rl(this.pass.renderer),this.glGeomItemSets.GLLines=F}else{if(!(U instanceof aF||U instanceof RF))throw new Error("Unsupported geom type:"+U.constructor.name);if(this.glGeomItemSets.GLPoints)return this.glGeomItemSets.GLPoints;F=new hl(this.pass.renderer),this.glGeomItemSets.GLPoints=F}return F.on("updated",(()=>{this.emit("updated")})),F}addGLGeomItem(U){const F=U.geomItem,e=F.geomParam.value,t=U.geomItem.materialParam.value,Q=()=>{this.pass.removeGeomItem(F),this.pass.renderer.assignTreeItemToGLPass(F)};t.on("transparencyChanged",Q),F.materialParam.on("valueChanged",Q),F.geomParam.on("valueChanged",Q);const l=this.getOrCreateGLGeomItemSet(e);U.material=t,U.GLGeomItemSet=l,U.geomItemParamChanged=Q,l.addGLGeomItem(U)}removeGLGeomItem(U){const F=U.geomItem,e=U.material,t=U.geomItemParamChanged;e.off("transparencyChanged",t),F.materialParam.off("valueChanged",t),F.geomParam.off("valueChanged",t),U.material=null,U.geomItemParamChanged=null;U.GLGeomItemSet.removeGLGeomItem(U),U.GLGeomItemSet=null}bindShader(U,F,e){const t=this.gl;if(U.isCompiledForTarget(e)||(t.multiDrawElements?F.shaderopts.directives.push("#define ENABLE_MULTI_DRAW\n#extension GL_ANGLE_multi_draw : enable"):F.shaderopts.directives.push("#define ENABLE_MULTI_DRAW"),U.compileForTarget(e,F.shaderopts),F.shaderopts.directives.pop()),!U.bind(F,e))throw new Error("Unable to bind shader:"+U);this.pass.renderer.glGeomItemLibrary.bind(F),this.pass.renderer.glGeomLibrary.bind(F),this.pass.renderer.glMaterialLibrary.bind(F)}draw(U){this.bindShader(this.glShader,U,this.glShaderKey);for(const F in this.glGeomItemSets)this.glGeomItemSets[F].draw(U);this.glShader.unbind(U)}drawHighlightedGeoms(U){if(this.glHighlightShader){this.bindShader(this.glHighlightShader,U,this.glHighlightShaderKey);for(const F in this.glGeomItemSets)this.glGeomItemSets[F].drawHighlighted(U);this.glHighlightShader.unbind(U)}}drawGeomData(U){this.bindShader(this.glGeomDataShader,U,this.glGeomDataShaderKey);const F=U.gl,{floatGeomBuffer:e,passId:t}=U.unifs;e&&F.uniform1i(e.location,U.floatGeomBuffer?1:0),t&&F.uniform1i(t.location,U.passIndex);for(const F in this.glGeomItemSets)this.glGeomItemSets[F].draw(U);this.glGeomDataShader.unbind(U)}sortItems(U){for(const F in this.glGeomItemSets)this.glGeomItemSets[F].sortItems(U)}}class Zl extends Bl{constructor(){super(),this.__glshadermaterials={},this.__glShaderGeomSets={}}init(U,F){super.init(U,F)}getPassType(){return ze.OPAQUE}filterGeomItem(U){const F=U.materialParam.value;return this.checkMaterial(F)}checkMaterial(U){return!U.isTransparent()}removeAndReAddGeomItem(U){this.removeGeomItem(U),this.__renderer.assignTreeItemToGLPass(U)}addGeomItem(U){const F=U.materialParam,e=F.value,t=this.renderer.glGeomLibrary,Q=this.renderer.glGeomItemLibrary;if(!e.isTextured()&&e.getShaderClass().supportsInstancing()){const F=e.getShaderName();let t=this.__glShaderGeomSets[F];if(!t){const U=this.constructShaders(F);t=new Jl(this,this.__gl,U),t.on("updated",(()=>{this.__renderer.requestRedraw()})),this.__glShaderGeomSets[F]=t}const Q=this.renderer.glGeomItemLibrary.getGLGeomItem(U);return t.addGLGeomItem(Q),Q.GLShaderGeomSets=t,this.emit("updated"),!0}const l=t.constructGLGeom(U.geomParam.value),n=Q.getGLGeomItem(U),a=()=>{this.removeGeomItem(U),this.__renderer.assignTreeItemToGLPass(U)};F.on("valueChanged",a),n.materialChanged=a;const d=e.getShaderName(),i=this.renderer.glMaterialLibrary.getGLMaterial(e);let s=this.__glshadermaterials[d];if(!s){const U=this.constructShaders(d);s=new CQ(this.__gl,this,U),this.__glshadermaterials[d]=s,s.on("updated",(()=>{this.__renderer.requestRedraw()}))}return s.addGLGeomItem(n,l,i),!0}removeGeomItem(U){const F=this.renderer.glGeomItemLibrary.getGLGeomItem(U);if(F.GLShaderGeomSets){return F.GLShaderGeomSets.removeGLGeomItem(F),F.GLShaderGeomSets=null,!0}const e=U.materialParam,t=F.materialChanged;if(e&&t&&(e.off("valueChanged",t),F.materialChanged=null),F.GLGeomItemSet){return F.GLGeomItemSet.removeGLGeomItem(F),F.GLGeomItemSet=null,!0}return!0}removeMaterial(U){const F=U.getShaderName(),e=this.__glshadermaterials[F];if(!e||e!=U.getMetadata("glshaderMaterials"))return void console.warn("Material not found in pass");const t=U.getMetadata("glMaterialGeomItemSets");e.removeMaterialGeomItemSets(t)}__traverseTreeAndDraw(U){for(const F in this.__glShaderGeomSets)this.__glShaderGeomSets[F].draw(U);for(const F in this.__glshadermaterials)this.__glshadermaterials[F].draw(U);U.glGeom&&U.glGeom.unbind(U)}draw(U){const F=this.__gl;F.disable(F.BLEND),F.disable(F.CULL_FACE),F.enable(F.DEPTH_TEST),F.depthFunc(F.LEQUAL),F.depthMask(!0),this.__traverseTreeAndDraw(U),U.viewport.drawSilhouettes(U)}drawHighlightedGeoms(U){const F=this.__gl;F.disable(F.CULL_FACE);for(const F in this.__glShaderGeomSets)this.__glShaderGeomSets[F].drawHighlightedGeoms(U);for(const F in this.__glshadermaterials){this.__glshadermaterials[F].drawHighlightedGeoms(U)}U.glGeom&&U.glGeom.unbind(U)}drawGeomData(U){U.passIndex=this.passIndex;const F=this.__gl;F.disable(F.BLEND),F.disable(F.CULL_FACE),F.enable(F.DEPTH_TEST),F.depthFunc(F.LEQUAL),F.depthMask(!0);for(const F in this.__glShaderGeomSets)this.__glShaderGeomSets[F].drawGeomData(U);for(const F in this.__glshadermaterials){this.__glshadermaterials[F].drawGeomData(U)}U.glGeom&&U.glGeom.unbind(U)}}HQ.registerPass(Zl,ze.OPAQUE);class cl extends tt{constructor(U){super(U,"FattenLinesShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 positions;  //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, -1.0, 1.0);\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform vec2 screenSize;\n\nuniform float growth;\n\nvarying vec2 v_texCoord;\n\nbool sampleNeiPixel(vec2 fragCoord, inout vec4 res) {\n  res = texture2D(colorTexture, fragCoord/screenSize);\n  if (res.a > 0.0) {\n    return true;\n  }\n  return false;\n}\n\nvec4 samplePixels(vec2 fragCoord) {\n  vec4 res = vec4(0.0);\n  \n  if (sampleNeiPixel(fragCoord, res)) return res; // M\n  \n  // Search surrounding pixels for geoms\n  if (sampleNeiPixel(fragCoord+vec2( 1, 0), res)) return res; // E\n  if (sampleNeiPixel(fragCoord+vec2(-1, 0), res)) return res; // W\n  if (sampleNeiPixel(fragCoord+vec2( 0, 1), res)) return res; // N\n  if (sampleNeiPixel(fragCoord+vec2( 0,-1), res)) return res; // S\n  if (sampleNeiPixel(fragCoord+vec2( 1, 1), res)) return res; // NW\n  if (sampleNeiPixel(fragCoord+vec2(-1, 1), res)) return res; // NE\n  if (sampleNeiPixel(fragCoord+vec2( 1,-1), res)) return res; // SW\n  if (sampleNeiPixel(fragCoord+vec2(-1,-1), res)) return res; // SE\n  \n  return res;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = samplePixels(gl_FragCoord.xy);\n  if (fragColor.a < 0.0001) {\n    discard; \n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}}class ml extends Zl{constructor(){super(),this.linesGeomDataBuffer=null,this.fattenLinesShader=null,this.quad=null,this.fbo=null}init(U,F){super.init(U,F)}filterGeomItem(U){const F=U.geomParam.value;return F instanceof dF||F instanceof BF||F instanceof aF||F instanceof RF}__checkFramebuffer(U,F){const e=this.__gl;let t;if(t="webgl2"==e.name?e.checkFramebufferStatus(e.DRAW_FRAMEBUFFER):e.checkFramebufferStatus(e.FRAMEBUFFER),t!==e.FRAMEBUFFER_COMPLETE)switch(e.bindTexture(e.TEXTURE_2D,null),"webgl2"==e.name?e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null):e.bindFramebuffer(e.FRAMEBUFFER,null),console.warn("Error creating Fbo width:",U,", height:",F),t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:throw new Error("There is no attachment.");case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("Height and width of the attachment are not the same.");case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");case 36061:throw new Error("The framebuffer is unsupported");default:throw new Error("Incomplete Frambuffer")}}draw(U){const F=this.__gl;F.enable(F.BLEND),F.blendFunc(F.SRC_ALPHA,F.ONE_MINUS_SRC_ALPHA),F.enable(F.DEPTH_TEST),F.depthFunc(F.LEQUAL),F.depthMask(!0),this.__traverseTreeAndDraw(U),F.disable(F.BLEND)}drawGeomData(U){const F=this.__gl;if(U.geomDataFbo){this.linesGeomDataBuffer||(this.linesGeomDataBuffer=new Ae(F,{type:this.__renderer.floatGeomBuffer?"FLOAT":"UNSIGNED_BYTE",format:"RGBA",filter:"NEAREST",width:1,height:2}),this.fattenLinesShader=new cl(F),this.quad=new $t(F,new kF(1,1)));const e=U.geomDataFbo,t=e.width,Q=e.height;if(this.linesGeomDataBuffer.width!=t||this.linesGeomDataBuffer.height!=Q){this.fbo&&(F.deleteFramebuffer(this.fbo),this.fbo=null),this.linesGeomDataBuffer.resize(t,Q),this.fbo=F.createFramebuffer();const U=this.linesGeomDataBuffer.glTex,l=e.__depthTexture;"webgl2"==F.name?(F.bindFramebuffer(F.DRAW_FRAMEBUFFER,this.fbo),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,U,0),F.framebufferTexture2D(F.DRAW_FRAMEBUFFER,F.DEPTH_ATTACHMENT,F.TEXTURE_2D,l,0)):(F.bindFramebuffer(F.FRAMEBUFFER,this.fbo),F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,U,0),F.framebufferTexture2D(F.FRAMEBUFFER,F.DEPTH_ATTACHMENT,F.TEXTURE_2D,l,0)),this.__checkFramebuffer(t,Q)}else"webgl2"==F.name?F.bindFramebuffer(F.DRAW_FRAMEBUFFER,this.fbo):F.bindFramebuffer(F.FRAMEBUFFER,this.fbo);F.colorMask(!0,!0,!0,!0),F.clearColor(0,0,0,0),F.clear(F.COLOR_BUFFER_BIT)}if(super.drawGeomData(U),U.geomDataFbo){U.geomDataFbo.bindForWriting(U),this.fattenLinesShader.bind(U);const{colorTexture:e,screenSize:t}=U.unifs;this.linesGeomDataBuffer.bindToUniform(U,e);const Q=U.geomDataFbo;F.uniform2f(t.location,Q.width,Q.height),this.quad.bindAndDraw(U)}}}HQ.registerPass(ml,ze.OPAQUE);class Sl extends Bl{constructor(){super(),this.listenerIDs={},this.itemCount=0,this.__glShaderGeomSets={},this.transparentItems=[],this.transparentItemIndices={},this.freeList=[],this.visibleItems=[],this.prevSortCameraPos=new i,this.sortCameraMovementDistance=0,this.reSort=!1}init(U,F){super.init(U,F),this.itemCount=0,this.__glShaderGeomSets={},this.transparentItems=[],this.transparentItemIndices={},this.freeList=[],this.visibleItems=[],this.prevSortCameraPos=new i(999,999,999),this.sortCameraMovementDistance=.25,this.reSort=!1}getPassType(){return ze.TRANSPARENT}filterGeomItem(U){const F=U.geomParam.value;if(F instanceof dF||F instanceof aF||F instanceof RF||F instanceof BF)return!1;return U.materialParam.value.isTransparent()}resortNeeded(){this.reSort=!0}addGeomItem(U){this.itemCount++;const F={};this.listenerIDs[U.getId()]=F;const e=U.materialParam,t=e.value,Q=t.getShaderName(),l=this.constructShaders(Q);if(!t.isTextured()&&t.getShaderClass().supportsInstancing()){let e=this.__glShaderGeomSets[Q];e||(e=new Jl(this,this.__gl,l),e.on("updated",(()=>{this.renderer.requestRedraw()})),this.__glShaderGeomSets[Q]=e);const t=this.renderer.glGeomItemLibrary.getGLGeomItem(U);return e.addGLGeomItem(t),F["glGeomItem.visibilityChanged"]=t.on("visibilityChanged",(()=>{this.resortNeeded()})),this.emit("updated"),t.GLShaderGeomSets=e,void(this.reSort=!0)}const n=this.renderer.glGeomLibrary.constructGLGeom(U.geomParam.value),a=this.renderer.glGeomItemLibrary.getGLGeomItem(U);if(!a)throw new Error("glGeomItem not found for geomItem:"+U.getName());const d=this.renderer.glMaterialLibrary.getGLMaterial(t),i=()=>{t.removeListenerById("valueChanged",F["material.valueChanged"]),t.removeListenerById("transparencyChanged",F["material.transparencyChanged"]),e.removeListenerById("valueChanged",F["materialParam.valueChanged"]),this.removeGeomItem(U),this.renderer.assignTreeItemToGLPass(U)};F["material.valueChanged"]=t.on("valueChanged",i),F["material.transparencyChanged"]=t.on("transparencyChanged",i),F["materialParam.valueChanged"]=e.on("valueChanged",i);F["glGeomItem.visibilityChanged"]=a.on("visibilityChanged",(U=>{if(U.visible)this.visibleItems.push(s);else{const U=this.visibleItems.indexOf(s);this.visibleItems.splice(U,1)}this.reSort=!0})),F["GeomMat.valueChanged"]=U.geomMatParam.on("valueChanged",(()=>{this.reSort=!0}));const s={geomItem:U,shaders:l,glGeom:n,glMaterial:d,glGeomItem:a,material:t};let R;R=this.freeList.length>0?this.freeList.pop():this.transparentItems.length,this.transparentItems[R]=s,this.transparentItemIndices[U.getId()]=R,U.isVisible()&&this.visibleItems.push(s),this.reSort=!0}removeGeomItem(U){this.itemCount--;const F=this.renderer.glGeomItemLibrary.getGLGeomItem(U);if(!F)throw new Error("glGeomItem not found for geomItem:"+U.getName());const e=this.listenerIDs[U.getId()];delete this.listenerIDs[U.getId()];const t=U.getParameter("Material"),Q=t.value;if(F.removeListenerById("visibilityChanged",e["glGeomItem.visibilityChanged"]),F.GLShaderGeomSets){return F.GLShaderGeomSets.removeGLGeomItem(F),F.GLShaderGeomSets=null,!0}{const F=this.transparentItemIndices[U.getId()],l=this.transparentItems[F];delete this.transparentItemIndices[U.getId()],Q.removeListenerById("valueChanged",e["material.valueChanged"]),Q.removeListenerById("transparencyChanged",e["material.transparencyChanged"]),t.removeListenerById("valueChanged",e["materialParam.valueChanged"]),U.getParameter("GeomMat").removeListenerById("valueChanged",e["GeomMat.valueChanged"]),this.transparentItems[F]=null,this.freeList.push(F);const n=this.visibleItems.indexOf(l);-1!=n&&this.visibleItems.splice(n,1)}return this.emit("updated"),!0}sortItems(U){for(const F in this.__glShaderGeomSets)this.__glShaderGeomSets[F].sortItems(U);for(const F of this.visibleItems){const e=F.glGeomItem.geomItem.geomMatParam.value;F.dist=e.translation.distanceTo(U)}this.visibleItems.sort(((U,F)=>U.dist>F.dist?-1:U.dist<F.dist?1:0)),this.reSort=!1}_drawItem(U,F,e){if(e.currentGLMaterial!=F.glMaterial&&(e.currentGLMaterial=F.glMaterial,!e.currentGLMaterial.bind(U)))return;if(e.currentGLGeom!=F.glGeom&&(e.currentGLGeom=F.glGeom,!e.currentGLGeom.bind(U)))return;F.glGeomItem.bind(U)&&U.bindViewports(U.unifs,(()=>{e.currentGLGeom.draw(U)}))}_drawItems(U){for(const F in this.__glShaderGeomSets)this.__glShaderGeomSets[F].draw(U);const F={currentglShader:null,currentGLMaterial:null,currentGLGeom:null};for(const e of this.visibleItems){const t=e.shaders.glShader;if(F.currentglShader!=t){if(!t.bind(U,"color"))continue;const e=this.__gl,Q=U.unifs;Q.instancedDraw&&e.uniform1i(Q.instancedDraw.location,0),this.renderer.glGeomItemLibrary.bind(U),F.currentglShader=t}this._drawItem(U,e,F)}}draw(U){if(0==this.itemCount)return;const F=this.__gl,e=U.viewXfo.tr;if(this.reSort||e.distanceTo(this.prevSortCameraPos)>this.sortCameraMovementDistance)if(this.sortItems(e),this.prevSortCameraPos=e,U.vrviewport)this.sortCameraMovementDistance=.2*U.viewScale;else if(U.viewport){const F=U.viewport.getCamera();this.sortCameraMovementDistance=.3*F.getFocalDistance()}F.enable(F.DEPTH_TEST),F.depthFunc(F.LESS),F.enable(F.BLEND),F.blendEquation(F.FUNC_ADD),U.pass="ADD",F.blendFunc(F.SRC_ALPHA,F.ONE_MINUS_SRC_ALPHA),F.enable(F.CULL_FACE),F.cullFace(F.BACK),this._drawItems(U),F.disable(F.BLEND),F.depthMask(!0)}drawHighlightedGeoms(U){const F=this.__gl;F.disable(F.CULL_FACE);for(const F in this.__glShaderGeomSets)this.__glShaderGeomSets[F].drawHighlightedGeoms(U);const e={currentglShader:null,currentGLMaterial:null,currentGLGeom:null};for(const t of this.visibleItems){if(!t.geomItem.isHighlighted())continue;if(!t.shaders.glselectedshader)continue;const Q=t.shaders;if(e.currentglShader!=Q.glselectedshader){if(!Q.glselectedshader.bind(U,"highlight"))continue;e.currentglShader=Q.glselectedshader}const{floatGeomBuffer:l,passId:n,instancedDraw:a}=U.unifs;l&&F.uniform1i(l.location,F.floatGeomBuffer?1:0),n&&F.uniform1i(n.location,this.passIndex),a&&F.uniform1i(a.location,0),this.renderer.glGeomItemLibrary.bind(U),this._drawItem(U,t,e)}e.currentGLGeom&&e.currentGLGeom.unbind(U)}drawGeomData(U){const F=this.__gl;F.disable(F.BLEND),F.disable(F.CULL_FACE),F.enable(F.DEPTH_TEST),F.depthFunc(F.LESS),F.depthMask(!0);for(const F in this.__glShaderGeomSets)this.__glShaderGeomSets[F].drawGeomData(U);const e={currentglShader:null,currentGLMaterial:null,currentGLGeom:null};for(const t of this.visibleItems){if(!t.glGeomItem.geomItem.isSelectable())continue;const Q=t.shaders;if(!Q.glgeomdatashader)continue;if(e.currentglShader!=Q.glgeomdatashader){if(!Q.glgeomdatashader.bind(U,"geomdata"))continue;e.currentglShader=Q.glgeomdatashader}const{floatGeomBuffer:l,passId:n,instancedDraw:a}=U.unifs;l&&F.uniform1i(l.location,F.floatGeomBuffer?1:0),n&&F.uniform1i(n.location,this.passIndex),a&&F.uniform1i(a.location,0),this.renderer.glGeomItemLibrary.bind(U),this._drawItem(U,t,e)}e.currentGLGeom&&e.currentGLGeom.unbind(U)}}HQ.registerPass(Sl,ze.TRANSPARENT);class Wl extends tt{constructor(U){super(U,"AtlasLayoutShader"),this.setShaderStage("VERTEX_SHADER","\n\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform vec2 pos;\nuniform vec2 size;\nuniform vec2 srctextureDim;\nconst int border = 2;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * size * 2.0), 0.0, 1.0);\n\n  vec2 borderVec2 = vec2(float(border), float(border));\n  v_texCoord *= (srctextureDim + (borderVec2 * 2.0)) / srctextureDim;\n  v_texCoord -= borderVec2 / srctextureDim;\n}\n\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D srctexture;\nuniform vec2 srctextureDim;\nuniform bool alphaFromLuminance;\nuniform bool invert;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n\nfloat luminanceFromRGB(vec3 rgb) {\n  return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n  vec2 pixelCoord = v_texCoord*srctextureDim;\n  vec2 uv = v_texCoord;\n\n  // Wrap X coords\n  if (pixelCoord.x < 0.0) {\n    uv.x += 1.0/srctextureDim.x;\n    uv.y = 1.0 - uv.y;\n  }\n  else if (pixelCoord.x > srctextureDim.x) {\n    uv.x -= 1.0/srctextureDim.x;\n    uv.y = 1.0 - uv.y;\n  }\n\n  // Wrap Y coords\n  if (pixelCoord.y < 0.0) {\n    uv.y += 1.0/srctextureDim.y;\n    uv.x = 1.0 - uv.x;\n  }\n  else if (pixelCoord.y > srctextureDim.y) {\n    uv.y -= 1.0/srctextureDim.y;\n    uv.x = 1.0 - uv.x;\n  }\n\n  vec4 texel = texture2D(srctexture, uv);\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  // TODO: check why we pre-multiply alphas here.\n  // fragColor = vec4(texel.rgb/texel.a, texel.a);\n\n  if (alphaFromLuminance) {\n    fragColor = vec4(texel.rgb, luminanceFromRGB(texel.rgb));\n  }\n  else {\n    fragColor = texel;\n  }\n  \n  if (invert) {\n    fragColor = vec4(1.0) - fragColor;\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n")}}class El extends lt{constructor(U,F,e="RGBA",t="FLOAT"){super(U),this.__asyncCount=0,this.loaded=!1,this.ready=!1,this.__layout=[],this.__layoutVec4s=[],this.__atlasLayoutShaderBinding=null,this.__atlasLayoutShader=null,this.__name=F,this.__formatParam=e,this.__typeParam=t,this.clearColor=new B(0,0,0,0),this.__subImages=[],this.__layoutNeedsRegeneration=!1,this.__asyncCount=0,this.loaded=!1}incAsyncCount(U=1){this.__asyncCount+=U,this.ready=!1}decAsyncCount(){this.__asyncCount>0&&(this.__asyncCount--,0==this.__asyncCount&&(this.loaded=!0,this.emit("loaded")))}isLoaded(){return 0==this.__asyncCount}getMainImage(){return this.frameBuffer}addSubImage(U){if(U instanceof KU){const F=new Ae(this.__gl,U);U.isLoaded()||(this.incAsyncCount(),U.on("loaded",(()=>{this.decAsyncCount()}))),U.setMetadata("ImageAtlas_gltex",F),F.addRef(this);const e=()=>{this.__layoutNeedsRegeneration=!0,this.renderAtlas()};U.on("updated",e),this.__subImages.push(F)}else{const F=U;F.addRef(this),this.__subImages.push(F)}return this.__layoutNeedsRegeneration=!0,this.__subImages.length-1}removeSubImage(U){let F;if(U instanceof KU){const e=U.getMetadata("ImageAtlas_gltex");F=this.__subImages.indexOf(e),U.deleteMetadata("ImageAtlas_gltex")}else F=this.__subImages.indexOf(U);this.__subImages[F].removeRef(this),this.__subImages.splice(F,1),this.__layoutNeedsRegeneration=!0}getSubImage(U){return this.__subImages[U]}numSubImages(){return this.__layout?this.__layout.length:this.__subImages.length}generateAtlasLayout(U){if(0==this.__subImages.length)return void(this.__layoutNeedsRegeneration=!1);const F=[];this.__subImages.forEach(((U,e)=>{F.push({w:U.width+4,h:U.height+4,area:U.width*U.height,index:e})})),F.sort(((U,F)=>U.area>F.area?-1:U.area<F.area?1:0));const e=new C;e.fit(F),this.__layout=[],F.forEach(((U,F)=>{U.fit?this.__layout[U.index]={pos:new d(U.fit.x+2,U.fit.y+2),size:new d(U.w,U.h)}:console.warn("Unable to fit image")}));const t=e.root.w,Q=e.root.h;this.configure({width:t,height:Q,format:"FLOAT"==this.__typeParam&&"RGB"==this.__formatParam?"RGBA":this.__formatParam,type:this.__typeParam,filter:"LINEAR"});const l=this.__gl;if(l.__quadVertexIdsBuffer||l.setupInstancedQuad(),!this.__atlasLayoutShader){this.__atlasLayoutShader=new Wl(this.__gl);const U=[];"webgl2"==l.name&&U.push("#define ENABLE_ES3");const F=this.__atlasLayoutShader.compileForTarget("GLImageAtlas",{directives:U});this.__atlasLayoutShaderBinding=Rt(this.__gl,F.attrs,l.__quadattrbuffers,l.__quadIndexBuffer)}let n=Math.round(Math.sqrt(1*this.__layout.length)+.5);if(n=J.nextPow2(n),n%1!=0&&(n+=1-n%1),l.floatTexturesSupported){const U=new Float32Array(n*n*4);for(let F=0;F<this.__layout.length;F++){const e=this.__layout[F];new s(new Float32Array(U.buffer,4*F*4,4)).set(e.pos.x/t,e.pos.y/Q,e.size.x/t,e.size.y/Q)}this.__atlasLayoutTexture&&this.__atlasLayoutTexture.width==n&&this.__atlasLayoutTexture.height==n?this.__atlasLayoutTexture.bufferData(U,n,n):(this.__atlasLayoutTexture&&this.__atlasLayoutTexture.destroy(),this.__atlasLayoutTexture=new Ae(l,{format:"RGBA",type:"FLOAT",filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,width:n,height:n,data:U}))}else this.__layoutVec4s=[],this.__layout.forEach(((U,F)=>{this.__layoutVec4s[F]=[U.pos.x/t,U.pos.y/Q,U.size.x/t,U.size.y/Q]}));this.textureDesc[0]=this.width,this.textureDesc[1]=this.height,this.textureDesc[2]=this.__atlasLayoutTexture.width,this.__layoutNeedsRegeneration=!1}getLayoutData(U){return this.__layoutVec4s[U]}renderAtlas(U=!1,F=0){if(0==this.__subImages.length)return;this.__layoutNeedsRegeneration&&this.generateAtlasLayout();const e=this.__gl,t={};this.bindForWriting(t,!0),this.__atlasLayoutShader.bind(t,"GLImageAtlas"),this.__atlasLayoutShaderBinding.bind(t);const Q=new d(1/this.width,1/this.height),l=t.unifs;for(let U=F;U<this.__subImages.length;U++){const F=this.__subImages[U],n=this.__layout[U];F.bindToUniform(t,l.srctexture)&&(e.uniform2fv(l.pos.location,n.pos.multiply(Q).asArray()),e.uniform2fv(l.size.location,n.size.multiply(Q).asArray()),e.uniform2f(l.srctextureDim.location,F.width,F.height),e.uniform1i(l.alphaFromLuminance.location,F.alphaFromLuminance?1:0),e.uniform1i(l.invert.location,F.invert?1:0),e.drawQuad(),t.boundTextures--)}U&&this.cleanup(),this.unbind(t),this.emit("updated")}isReady(){return null!=this.__atlasLayoutTexture}bindToUniform(U,F){super.bindToUniform(U,F);const e=U.unifs;if(this.__atlasLayoutTexture){const t=e[F.name+"_layout"];t&&this.__atlasLayoutTexture.bindToUniform(U,t);const Q=e[F.name+"_desc"];Q&&this.__gl.uniform4fv(Q.location,this.textureDesc)}else{const U=e[F.name+"_desc"];U&&this.__gl.uniform4f(U.location,this.width,this.height,0,0)}return!0}cleanup(){for(const U of this.__subImages)U.removeRef(this);this.__subImages=[],this.destroy()}destroy(){this.cleanup(),super.destroy()}}class pl extends Ke{constructor(){super(),this.atlas=null,this.indexArrayUpdateNeeded=!1,this.instanceIdsBuffer=null,this.indexArray=new Float32Array(0),this.glshader=null,this.shaderComp={},this.shaderBinding=null,this.modelMatrixArray=[],this.billboardDataArray=[],this.tintColorArray=[],this.width=0,this.drawItemsTexture=null,this.billboards=[],this.dirtyBillboards=new Set,this.freeIndices=[],this.drawCount=0,this.threshold=0,this.updateRequested=!1,this.prevSortCameraPos=new i}init(U,F){super.init(U,F),this.atlas=new El(this.renderer.gl,"Billboards","RGBA","UNSIGNED_BYTE"),this.atlas.clearColor=new B(1,1,1,0);const e=U=>this.emit("updated",U);this.atlas.on("loaded",e),this.atlas.on("updated",e)}getPassType(){return ze.TRANSPARENT}itemAddedToScene(U,F){return U instanceof Ge&&(this.addBillboard(U),!0)}itemRemovedFromScene(U,F){return U instanceof Ge&&(this.removeBillboard(U),!0)}filterRenderTree(){}addBillboard(U){const F=U.imageParam,e=F.value;if(!e)return void F.on("valueChanged",(()=>this.addBillboard(U)));let t;t=this.freeIndices.length>0?this.freeIndices.pop():this.billboards.length;const Q=this.atlas.addSubImage(e);U.setMetadata("GLBillboardsPass_Index",t);const l=()=>{U.isVisible()?(this.drawCount++,this.dirtyBillboards.add(t)):this.drawCount--,this.reqUpdateIndexArray()};U.on("visibilityChanged",l);const n=()=>{U.isVisible()&&(this.dirtyBillboards.add(t),this.emit("updated"))};U.globalXfoParam.on("valueChanged",n),U.alphaParam.on("valueChanged",n),U.on("highlightChanged",n),U.isVisible()&&this.drawCount++,this.billboards[t]={billboard:U,imageIndex:Q,visibilityChanged:l,updateBillboard:n},this.indexArrayUpdateNeeded=!0,this.requestUpdate()}removeBillboard(U){const F=U.getMetadata("GLBillboardsPass_Index");if(-1==F)return void console.warn("Billboard already removed.");const e=this.billboards[F],t=e.billboard.imageParam.value;this.atlas.removeSubImage(t),U.off("visibilityChanged",e.visibilityChanged),U.off("highlightChanged",e.updateBillboard),U.globalXfoParam.off("valueChanged",e.updateBillboard),U.alphaParam.off("valueChanged",e.updateBillboard),this.billboards[F]=null,this.freeIndices.push(F),U.isVisible()&&this.drawCount--,this.indexArrayUpdateNeeded=!0,this.requestUpdate()}populateBillboardDataArray(U,F,e){const t=U.billboard,Q=t.globalXfoParam.value.toMat4(),l=t.pixelsPerMeterParam.value,n=t.pivotParam.value,a=1/l;let d=0;t.alignedToCameraParam.value&&(d|=4),t.drawOnTopParam.value&&(d|=8),t.fixedSizeOnscreenParam.value&&(d|=16);const i=t.alphaParam.value,R=t.colorParam.value,B=7*F*4,V=new s(new Float32Array(e.buffer,4*B,4)),r=new s(new Float32Array(e.buffer,4*(B+4),4)),h=new s(new Float32Array(e.buffer,4*(B+8),4)),o=new s(new Float32Array(e.buffer,4*(B+12),4));V.set(Q.xAxis.x,Q.yAxis.x,Q.zAxis.x,Q.translation.x),r.set(Q.xAxis.y,Q.yAxis.y,Q.zAxis.y,Q.translation.y),h.set(Q.xAxis.z,Q.yAxis.z,Q.zAxis.z,Q.translation.z),o.set(a,d,U.imageIndex,i);new s(new Float32Array(e.buffer,4*(B+16),4)).set(n.x,n.y,0,0);if(new s(new Float32Array(e.buffer,4*(B+20),4)).set(R.r,R.g,R.b,R.a),t.isHighlighted()){const U=t.getHighlight();new s(new Float32Array(e.buffer,4*(B+24),4)).set(U.r,U.g,U.b,U.a)}}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.emit("updated"))}reqUpdateIndexArray(){this.indexArrayUpdateNeeded||(this.indexArrayUpdateNeeded=!0,this.emit("updated"))}updateIndexArray(){const U=this.__gl;this.indexArray&&this.indexArray.length!=this.drawCount&&(U.deleteBuffer(this.instanceIdsBuffer),this.instanceIdsBuffer=null),this.indexArray=new Float32Array(this.drawCount);let F=0;for(let U=0;U<this.billboards.length;U++)this.billboards[U]&&this.billboards[U].billboard.isVisible()&&(this.indexArray[F]=U,F++);this.instanceIdsBuffer||(this.instanceIdsBuffer=U.createBuffer()),U.bindBuffer(U.ARRAY_BUFFER,this.instanceIdsBuffer),U.bufferData(U.ARRAY_BUFFER,this.indexArray,U.STATIC_DRAW),this.indexArrayUpdateNeeded=!1}updateBillboards(U){const F=()=>{this.indexArrayUpdateNeeded&&this.updateIndexArray();const F=this.__gl;if(!this.glshader){F.__quadVertexIdsBuffer||F.setupInstancedQuad(),this.glshader=new PQ(F);const e=this.glshader.compileForTarget("GLBillboardsPass",U.shaderopts);this.shaderBinding=Rt(F,e.attrs,F.__quadattrbuffers,F.__quadIndexBuffer)}if(this.atlas.renderAtlas(),!F.floatTexturesSupported||!F.drawElementsInstanced)return this.modelMatrixArray=[],this.billboardDataArray=[],this.tintColorArray=[],this.indexArray.forEach((U=>{const F=this.billboards[U],e=F.billboard,t=e.globalXfoParam.value.toMat4(),Q=1/e.pixelsPerMeterParam.value;let l=0;e.alignedToCameraParam.value&&(l|=4),e.drawOnTopParam.value&&(l|=8),e.fixedSizeOnscreenParam.value&&(l|=16);const n=e.alphaParam.value,a=e.colorParam.value;this.modelMatrixArray[U]=t.asArray(),this.billboardDataArray[U]=[Q,l,F.imageIndex,n],this.tintColorArray[U]=[a.r,a.g,a.b,a.a]})),void(this.updateRequested=!1);let e=Math.round(Math.sqrt(7*(this.billboards.length-this.freeIndices.length))+.5);if(e%7!=0&&(e+=7-e%7),this.width=e,this.drawItemsTexture)this.drawItemsTexture.resize(e,e);else{const U={format:"RGBA",type:"FLOAT",width:e,height:e,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1};this.drawItemsTexture=new Ae(F,U),this.drawItemsTexture.clear()}this.indexArray.forEach((U=>{-1!=U&&this.updateBillboard(U)})),this.updateRequested=!1};this.atlas.isLoaded()?F():this.atlas.on("loaded",F)}updateBillboard(U){if(0==this.drawCount||!this.drawItemsTexture)return;const F=this.billboards[U];if(!F.billboard.isVisible())return;const e=this.__gl,t=new Float32Array(28);this.populateBillboardDataArray(F,0,t),e.bindTexture(e.TEXTURE_2D,this.drawItemsTexture.glTex);const Q=7*U%this.width,l=Math.floor(7*U/this.width),n=this.drawItemsTexture.getType(),a=this.drawItemsTexture.getFormat();if(n==e.FLOAT)e.texSubImage2D(e.TEXTURE_2D,0,Q,l,7,1,a,n,t);else{const U=J.convertFloat32ArrayToUInt16Array(t);e.texSubImage2D(e.TEXTURE_2D,0,Q,l,7,1,a,n,U)}}sort(U){for(const F of this.billboards){const{billboard:e}=F;if(e&&e.isVisible()){const t=e.globalXfoParam.value;F.dist=t.tr.distanceTo(U)}}this.indexArray.sort(((U,F)=>-1==U?1:-1==F||this.billboards[U].dist>this.billboards[F].dist?-1:this.billboards[U].dist<this.billboards[F].dist?1:0));const F=this.__gl;F.floatTexturesSupported&&this.instanceIdsBuffer&&(F.bindBuffer(F.ARRAY_BUFFER,this.instanceIdsBuffer),F.bufferData(F.ARRAY_BUFFER,this.indexArray,F.STATIC_DRAW))}__draw(U,F){const e=this.__gl;if(!this.glshader)return;this.glshader.bind(U,F),this.shaderBinding.bind(U);const t=U.unifs,{atlasBillboards:Q,passId:l,floatGeomBuffer:n,inVR:a}=U.unifs;if(Q&&this.atlas.bindToUniform(U,t.atlasBillboards),n&&e.uniform1i(n.location,U.floatGeomBuffer?1:0),l&&e.uniform1i(l.location,this.passIndex),a&&e.uniform1i(a.location,U.vrPresenting?1:0),e.floatTexturesSupported&&e.drawElementsInstanced){const{instancesTexture:F,instancesTextureSize:Q}=U.unifs;this.drawItemsTexture.bindToUniform(U,F),e.uniform1i(Q.location,this.width);{const F=U.attrs.instanceIds.location;e.enableVertexAttribArray(F),e.bindBuffer(e.ARRAY_BUFFER,this.instanceIdsBuffer),e.vertexAttribPointer(F,1,e.FLOAT,!1,4,0),e.vertexAttribDivisor(F,1)}U.bindViewports(t,(()=>{e.drawElementsInstanced(e.TRIANGLES,6,e.UNSIGNED_SHORT,0,this.drawCount)}))}else{const{modelMatrix:F,billboardData:Q,tintColor:l,layoutData:n}=U.unifs,a=this.indexArray.length;for(let d=0;d<a;d++)e.uniformMatrix4fv(F.location,!1,this.modelMatrixArray[d]),e.uniform4fv(Q.location,this.billboardDataArray[d]),e.uniform4fv(l.location,this.tintColorArray[d]),e.uniform4fv(n.location,this.atlas.getLayoutData(this.billboards[d].imageIndex)),U.bindViewports(t,(()=>{e.drawQuad()}))}}draw(U){if(0==this.drawCount)return;if(this.updateRequested&&this.updateBillboards(U),this.dirtyBillboards.size>0&&(this.dirtyBillboards.forEach((U=>{this.updateBillboard(U)})),this.dirtyBillboards.clear()),this.indexArrayUpdateNeeded&&this.updateIndexArray(),!this.glshader)return;const F=U.viewXfo.tr;if(F.distanceTo(this.prevSortCameraPos)>this.threshold)if(this.sort(F),this.prevSortCameraPos=F.clone(),this.drawCount>1){const U=this.indexArray[this.indexArray.length-1],F=this.indexArray[this.indexArray.length-2],e=this.billboards[U].billboard,t=this.billboards[F].billboard,Q=e.globalXfoParam.value.tr,l=t.globalXfoParam.value.tr;this.threshold=Q.distanceTo(l)}else this.threshold=9999;const e=this.__gl;e.depthMask(!1),e.disable(e.CULL_FACE),e.enable(e.BLEND),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),this.__draw(U,"DRAW_COLOR"),e.disable(e.BLEND),e.depthMask(!0)}drawHighlightedGeoms(U){0!=this.drawCount&&this.__draw(U,"DRAW_HIGHLIGHT")}drawGeomData(U){0!=this.drawCount&&this.__draw(U,"DRAW_GEOMDATA")}getGeomItemAndDist(U){let F,e;if(U instanceof Float32Array?(F=Math.round(U[1]),e=U[3]):(F=U[0]+((63&U[1])<<8),e=J.decode16BitFloatFrom2xUInt8(U.slice(2,3))),!(F>=this.billboards.length))return{geomItem:this.billboards[F].billboard,dist:e};console.warn("Invalid Draw Item id:"+F+" NumBillboards:"+(this.billboards.length-1))}}HQ.registerPass(pl,ze.TRANSPARENT);class ul extends Zl{constructor(){super()}getPassType(){return ze.OVERLAY}filterGeomItem(U){if(U.isOverlay())return!0;const F=U.materialParam.value.getShaderClass();return!(!F||!F.isOverlay())}draw(U){const F=this.__gl;F.clear(F.DEPTH_BUFFER_BIT),F.enable(F.CULL_FACE),F.cullFace(F.BACK),F.enable(F.BLEND),F.blendEquation(F.FUNC_ADD),U.pass="ADD",F.blendFunc(F.SRC_ALPHA,F.ONE_MINUS_SRC_ALPHA),this.__traverseTreeAndDraw(U),F.disable(F.BLEND)}drawGeomData(U){const F=this.__gl;F.clear(F.DEPTH_BUFFER_BIT),F.enable(F.CULL_FACE),F.cullFace(F.BACK),F.enable(F.BLEND),F.blendEquation(F.FUNC_ADD),U.pass="ADD",F.blendFunc(F.SRC_ALPHA,F.ONE_MINUS_SRC_ALPHA),super.drawGeomData(U),F.disable(F.BLEND),F.enable(F.DEPTH_TEST)}}HQ.registerPass(ul,ze.OVERLAY);class Nl extends tt{constructor(U){super(U,"BoundingBoxShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec4 positions;\ninstancedattribute float instanceIds;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 cameraMatrix;\n\nimport 'GLSLUtils.glsl'\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\nimport 'transpose.glsl'\n\nuniform sampler2D instancesTexture;\nuniform int instancesTextureSize;\n\nconst int cols_per_instance = 6;\n\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\n  vec4 col0 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 0);\n  vec4 col1 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 1);\n  vec4 col2 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 2);\n  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\n  return transpose(result);\n  // return mat4(1.0);\n}\n\nmat4 getModelMatrix(int id) {\n  return getMatrix(instancesTexture, instancesTextureSize, id);\n}\nvec4 getInstanceData(int id, int row) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + row);\n}\n\n#else\n\nuniform mat4 modelMatrix;\nuniform vec4 row3;\nuniform vec4 row4;\nuniform vec4 row5;\n\n#endif\n\n/* VS Outputs */\nvarying vec4 v_color;\n\nvoid main(void) {\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\n  int instanceID = int(instanceIds);\n\n  mat4 modelMatrix = getModelMatrix(instanceID);\n  vec4 row3 = getInstanceData(instanceID, 3);\n  vec4 row4 = getInstanceData(instanceID, 4);\n  vec4 row5 = getInstanceData(instanceID, 5);\n\n#else\n\n#endif\n\n  v_color = row5;\n\n  vec4 pos = positions;\n  if (pos.x < 0.0) pos.x = row3.x;\n  else if (pos.x > 0.0) pos.x = row4.x;\n  if (pos.y < 0.0) pos.y = row3.y;\n  else if (pos.y > 0.0) pos.y = row4.y;\n  if (pos.z < 0.0) pos.z = row3.z;\n  else if (pos.z > 0.0) pos.z = row4.z;\n\n  // Use cross platform bit flags methods\n  bool drawOnTop = false;//testFlag(flags, 8); // flag = 1 << 3\n\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix;// * modelMatrix;\n  gl_Position = modelViewProjectionMatrix * pos;\n\n  // Use cross platform bit flags methods\n  if (drawOnTop) {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.w, 0.5);\n  }\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\n/* VS Outputs */\nvarying vec4 v_color;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = v_color;\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}}const kl=new class{constructor(U){this.version=U,this.registry={}}registerLib(U){const F=U.name,e=U.version;this.registry[F]&&console.warn("Library already registered:"+F),this.registry[F]=e,console.log(`Registered lib '${F}' v${e}`)}listLibs(){return this.registry}}(F.version);console.log(`Zea Engine v${F.version}`),U.Allocation1D=T,U.Allocator1D=G,U.AssetItem=Ce,U.AssetLoadContext=Te,U.Attribute=FF,U.BaseGeom=QF,U.BaseGeomItem=Be,U.BaseGroup=oe,U.BaseImage=KU,U.BaseItem=A,U.BaseProxy=sF,U.BaseTool=we,U.BillboardItem=Ge,U.BillboardShader=PQ,U.BinReader=BU,U.BinWriter=class{constructor(U=0){this.__data=new ArrayBuffer(U),this.__byteOffset=0,this.__reserved=U,this.__dataView=new DataView(this.__data)}pos(){return this.__byteOffset}seek(U){this.__byteOffset=U}seekEnd(){this.__byteOffset=this.__reserved}getBuffer(){if(this.__data.byteLength==this.__byteOffset)return this.__data;return new Uint8Array(this.__data).slice(0,this.__byteOffset).buffer}__grow(){const U=2*(this.__reserved>0?this.__reserved:1),F=new ArrayBuffer(U),e=new Uint8Array(F),t=new Uint8Array(this.__data);e.set(t),this.__data=F,this.__dataView=new DataView(this.__data),this.__reserved=U}__reserve(U){this.__byteOffset+U>this.__reserved&&this.__grow()}__offset(U){this.__byteOffset+=U,this.__byteOffset>this.__reserved&&this.__grow()}writeUInt8(U){this.__reserve(1),this.__dataView.setUint8(this.__byteOffset,U),this.__offset(1)}writeUInt16(U){this.__reserve(2),this.__dataView.setUint16(this.__byteOffset,U,!0),this.__offset(2)}writeUInt32(U){this.__reserve(4),this.__dataView.setUint32(this.__byteOffset,U,!0),this.__offset(4)}writeSInt32(U){this.__reserve(4),this.__dataView.setInt32(this.__byteOffset,U,!0),this.__offset(4)}writeFloat16(U){const F=J.encode16BitFloat(U);this.writeUInt16(F)}writeFloat32(U){this.__reserve(4),this.__dataView.setFloat32(this.__byteOffset,U,!0),this.__offset(4)}writeUInt8Array(U,F=!0){const e=(U.length,U.length);this.__reserve(e+(F?4:0)),F&&this.writeUInt32(e);for(let F=0;F<e;F++)this.writeUInt8(U[F])}writeUInt16Array(U,F=!0){const e=(U.length,U.length);this.__reserve(2*e+(F?4:0)),F&&this.writeUInt32(e);for(let F=0;F<e;F++)this.writeUInt16(U[F])}writeUInt32Array(U,F=!0){const e=(U.length,U.length);this.__reserve(4*e+(F?4:0)),F&&this.writeUInt32(e);for(let F=0;F<e;F++)this.writeUInt32(U[F])}writeFloat32Array(U,F=!0){const e=(U.length,U.length);this.__reserve(4*e+(F?4:0)),F&&this.writeUInt32(e);for(let F=0;F<e;F++)this.writeFloat32(U[F])}writeStr(U,F=!0){const e=U.length;this.__reserve(4*e+(F?4:0)),F&&this.writeUInt32(e);for(let F=0;F<e;F++)this.writeFloat32(U.charCodeAt(F))}writeSInt32Vec2(U){this.writeSInt32(U.x),this.writeSInt32(U.y)}writeUInt32Vec2(U){this.writeUInt32(U.x),this.writeUInt32(U.y)}writeFloat16Vec2(U){this.writeFloat16(U.x),this.writeFloat16(U.y)}writeFloat32Vec2(U){this.writeFloat32(U.x),this.writeFloat32(U.y)}writeFloat16Vec3(U){this.writeFloat16(U.x),this.writeFloat16(U.y),this.writeFloat16(U.z)}writeFloat32Vec3(U){this.writeFloat32(U.x),this.writeFloat32(U.y),this.writeFloat32(U.z)}writeFloat16Quat(U){this.writeFloat16(U.x),this.writeFloat16(U.y),this.writeFloat16(U.z),this.writeFloat16(U.w)}writeFloat32Quat(U){this.writeFloat32(U.x),this.writeFloat32(U.y),this.writeFloat32(U.z),this.writeFloat32(U.w)}writeRGBFloat32Color(U){this.writeFloat32(U.r),this.writeFloat32(U.g),this.writeFloat32(U.b)}writeRGBAFloat32Color(U){this.writeFloat32(U.r),this.writeFloat32(U.g),this.writeFloat32(U.b),this.writeFloat32(U.a)}writeRGBUInt8Color(U){this.writeUInt8(U.r),this.writeUInt8(U.g),this.writeUInt8(U.b)}writeRGBAUInt8Color(U){this.writeUInt8(U.r),this.writeUInt8(U.g),this.writeUInt8(U.b),this.writeUInt8(U.a)}writeBox2(U){this.writeFloat32Vec2(U.p0),this.writeFloat32Vec2(U.p1)}writeBox3(U){this.writeFloat32Vec3(U.p0),this.writeFloat32Vec3(U.p1)}writePadd(U){const F=U-this.__byteOffset;this.__reserve(F),this.__offset(F)}writeAlignment(U){const F=this.__byteOffset%U;0!=F&&(this.__reserve(U-F),this.__offset(U-F))}},U.BooleanOperatorInput=class extends xU{},U.BooleanOperatorOutput=class extends GU{},U.BooleanParameter=JU,U.Box2=m,U.Box3=W,U.Camera=Xe,U.CameraManipulator=Pe,U.Circle=cF,U.Color=B,U.ColorAttribute=nF,U.ColorOperatorInput=class extends xU{},U.ColorOperatorOutput=class extends GU{},U.ColorParameter=SU,U.Cone=EF,U.Cross=mF,U.Cuboid=pF,U.CuttingPlane=ve,U.Cylinder=uF,U.DataImage=TF,U.Disc=NF,U.EnvMap=qF,U.EnvMapShader=Jt,U.EnvProjectionShader=OQ,U.EulerAngles=V,U.EventEmitter=k,U.FRAMEBUFFER=UQ,U.FatLinesMaterial=te,U.FatLinesShader=jQ,U.FatPointsMaterial=Qe,U.FatPointsShader=Ql,U.FileImage=XF,U.FileImage2D=class extends XF{constructor(U,F={}){console.warn("FileImage2D is becoming deprecated in favor of simple FileImage"),super(U,F)}},U.FilePathParameter=zU,U.FlatSurfaceMaterial=le,U.FlatSurfaceShader=qQ,U.Float32=6,U.Frustum=class{constructor(U,F,e,t,Q,l){this.planes=[U||new E,F||new E,e||new E,t||new E,Q||new E,l||new E]}setFromMatrix(U){const F=U,e=this.planes;e[0].set(F.m03-F.m00,F.m13-F.m10,F.m23-F.m20,F.m33-F.m30),e[1].set(F.m03+F.m00,F.m13+F.m10,F.m23+F.m20,F.m33+F.m30),e[2].set(F.m03+F.m01,F.m13+F.m11,F.m23+F.m21,F.m33+F.m31),e[3].set(F.m03-F.m01,F.m13-F.m11,F.m23-F.m21,F.m33-F.m31),e[4].set(F.m03-F.m02,F.m13-F.m12,F.m23-F.m22,F.m33-F.m32),e[5].set(F.m03+F.m02,F.m13+F.m12,F.m23+F.m22,F.m33+F.m32),e.forEach((U=>U.normalizeInPlace()))}intersectsBox(U){const F=new i,e=this.planes,{min:t,max:Q}=U;for(let U=0;U<6;U++){const l=e[U];if(F.x=l.normal.x>0?Q.x:t.x,F.y=l.normal.y>0?Q.y:t.y,F.z=l.normal.z>0?Q.z:t.z,l.distanceToPoint(F)<0)return!1}return!0}toJSON(){return{p0:this.planes[0].toJSON(),p1:this.planes[1].toJSON(),p2:this.planes[2].toJSON(),p3:this.planes[3].toJSON(),p4:this.planes[4].toJSON(),p5:this.planes[5].toJSON()}}fromJSON(U){this.planes[0].fromJSON(U.p0),this.planes[1].fromJSON(U.p1),this.planes[2].fromJSON(U.p2),this.planes[3].fromJSON(U.p3),this.planes[4].fromJSON(U.p4),this.planes[5].fromJSON(U.p5)}toString(){return a.stringifyJSONWithFixedPrecision(this.toJSON())}},U.GIFImage=AF,U.GLBaseViewport=FQ,U.GLBillboardsPass=pl,U.GLBoundingBoxPass=class extends Ke{constructor(){super(),this.boxes=[],this.dirtyBoxes=new Set,this.freeIndices=[],this.idToIndex=[],this.drawCount=0,this.indexArrayUpdateNeeded=!1,this.__updateRequested=!1,this.__modelMatrixArray=[],this.__treeitemDataArray=[],this.__tintColorArray=[],this.__indexArray=new Float32Array(0),this.__width=0}getPassType(){return ze.OPAQUE}init(U,F){super.init(U,F);const e=this.__renderer.gl;this.glgeom=new WQ(e,new SF(1,1,1)),this.glshader=new Nl(e)}itemAddedToScene(U,F){return!1}itemRemovedFromScene(U,F){return!1}addTreeItem(U,F=!0){if(U instanceof DU&&(this.bindTreeItem(U),F)){for(const F of U.getChildren())F&&this.addTreeItem(F);U.on("childAdded",(U=>{this.addTreeItem(U.childItem)})),U.on("childRemoved",(U=>{this.unbindTreeItem(U.childItem)}))}}bindTreeItem(U){let F,e=this.freeIndices.pop();F=e||this.boxes.length,this.idToIndex[U.getId()]=F;const t=()=>{U.isVisible()?(this.drawCount++,this.dirtyBoxes.add(F)):this.drawCount--,this.indexArrayUpdateNeeded=!0};U.on("visibilityChanged",t);const Q=()=>{U.isVisible()&&(this.dirtyBoxes.add(F),this.emit("updated"))};U.globalXfoParam.on("valueChanged",Q),U.boundingBoxParam.on("valueChanged",Q),U.isVisible()&&this.drawCount++,this.boxes[F]={treeitem:U,visibilityChanged:t,xfoChanged:Q},this.indexArrayUpdateNeeded=!0,this.__updateRequested=!0,this.emit("updated")}unbindTreeItem(U){if(!(U.getId()in this.idToIndex))return void console.warn("Billboard already removed.");const F=this.idToIndex[U.getId()],e=this.boxes[F];U.off("visibilityChanged",e.visibilityChanged),U.globalXfoParam.off("valueChanged",e.xfoChanged),U.boundingBoxParam.off("valueChanged",e.xfoChanged),this.boxes[F]=null,this.freeIndices.push(F),U.isVisible()&&this.drawCount--,this.indexArrayUpdateNeeded=!0,this.__updateRequested=!0,this.__updateBoxes(),this.emit("updated")}__populateBoxesDataArray(U,F,e){const t=U.treeitem,Q=t.globalXfoParam,l=t.geomMatParam,n=l?new B(1,0,0,1):new B(0,0,1,1),a=l?l.value:Q.value.toMat4(),d=t.boundingBoxParam.value,i=6*F*4,R=new s(new Float32Array(e.buffer,4*i,4)),V=new s(new Float32Array(e.buffer,4*(i+4),4)),r=new s(new Float32Array(e.buffer,4*(i+8),4)),h=new s(new Float32Array(e.buffer,4*(i+12),4)),o=new s(new Float32Array(e.buffer,4*(i+16),4)),J=new s(new Float32Array(e.buffer,4*(i+20),4));R.set(a.xAxis.x,a.yAxis.x,a.zAxis.x,a.translation.x),V.set(a.xAxis.y,a.yAxis.y,a.zAxis.y,a.translation.y),r.set(a.xAxis.z,a.yAxis.z,a.zAxis.z,a.translation.z),h.set(d.p0.x,d.p0.y,d.p0.z,0),o.set(d.p1.x,d.p1.y,d.p1.z,0),J.set(n.r,n.g,n.b,n.a)}__updateIndexArray(){const U=this.__gl;this.__indexArray&&this.__indexArray.length!=this.drawCount&&(U.deleteBuffer(this.__instanceIdsBuffer),this.__instanceIdsBuffer=void 0),this.__indexArray=new Float32Array(this.drawCount);let F=0;for(let U=0;U<this.boxes.length;U++)this.boxes[U]&&this.boxes[U].treeitem.isVisible()&&(this.__indexArray[F]=U,F++);this.__instanceIdsBuffer||(this.__instanceIdsBuffer=U.createBuffer()),U.bindBuffer(U.ARRAY_BUFFER,this.__instanceIdsBuffer),U.bufferData(U.ARRAY_BUFFER,this.__indexArray,U.STATIC_DRAW),this.indexArrayUpdateNeeded=!1}__updateBoxes(){this.indexArrayUpdateNeeded&&this.__updateIndexArray();const U=this.__renderer.gl;let F=Math.round(Math.sqrt(6*(this.boxes.length-this.freeIndices.length))+.5);F%6!=0&&(F+=6-F%6),this.__width=F,this.__drawItemsTexture?this.__drawItemsTexture.resize(F,F):(this.__drawItemsTexture=new Ae(U,{format:"RGBA",type:"FLOAT",width:F,height:F,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__drawItemsTexture.clear()),this.__indexArray.forEach((U=>{-1!=U&&this.__updateBox(U)})),this.__updateRequested=!1}__updateBox(U){if(0==this.drawCount||!this.__drawItemsTexture)return;const F=this.boxes[U];if(!F.treeitem.isVisible())return;const e=this.__gl,t=new Float32Array(24);this.__populateBoxesDataArray(F,0,t),e.bindTexture(e.TEXTURE_2D,this.__drawItemsTexture.glTex);const Q=6*U%this.__width,l=Math.floor(6*U/this.__width),n=this.__drawItemsTexture.getType(),a=this.__drawItemsTexture.getFormat();if(n==e.FLOAT)e.texSubImage2D(e.TEXTURE_2D,0,Q,l,6,1,a,n,t);else{const U=J.convertFloat32ArrayToUInt16Array(t);e.texSubImage2D(e.TEXTURE_2D,0,Q,l,6,1,a,n,U)}}draw(U){if(0==this.drawCount)return;this.__updateRequested&&this.__updateBoxes(),this.dirtyBoxes.size>0&&(this.dirtyBoxes.forEach((U=>{this.__updateBox(U)})),this.dirtyBoxes.clear()),this.indexArrayUpdateNeeded&&this.__updateIndexArray();const F=this.__gl;this.glshader.bind(U),this.glgeom.bind(U);const e=U.unifs;if(F.floatTexturesSupported&&F.drawElementsInstanced){this.__drawItemsTexture.bindToUniform(U,e.instancesTexture),F.uniform1i(e.instancesTextureSize.location,this.__width);{const e=U.attrs.instanceIds.location;F.enableVertexAttribArray(e),F.bindBuffer(F.ARRAY_BUFFER,this.__instanceIdsBuffer),F.vertexAttribPointer(e,1,F.FLOAT,!1,4,0),F.vertexAttribDivisor(e,1)}U.bindViewports(e,(()=>{this.glgeom.drawInstanced(U,this.drawCount)}))}else{const t=this.__indexArray.length;for(let Q=0;Q<t;Q++)U.bindViewports(e,(()=>{F.drawQuad()}))}}},U.GLFbo=Qt,U.GLGeom=qt,U.GLGeomItem=uQ,U.GLGeomItemChangeType={GEOMITEM_CHANGED:0,GEOM_CHANGED:1,VISIBILITY_CHANGED:2,HIGHLIGHT_CHANGED:3},U.GLGeomItemFlags=pQ,U.GLGeomItemSet=kQ,U.GLLines=WQ,U.GLLinesPass=ml,U.GLMaterial=cQ,U.GLMaterialGeomItemSets=bQ,U.GLMesh=$t,U.GLOpaqueGeomsPass=Zl,U.GLOverlayPass=ul,U.GLPass=Ke,U.GLPoints=SQ,U.GLRenderTarget=lt,U.GLRenderer=HQ,U.GLShader=tt,U.GLShaderMaterials=CQ,U.GLStandardGeomsPass=Bl,U.GLTexture2D=Ae,U.GLTransparentGeomsPass=Sl,U.GLViewport=QQ,U.GeomItem=he,U.GeomLibrary=Ne,U.GeometryParameter=wU,U.Grid=WF,U.GridTreeItem=De,U.GrowingPacker=C,U.IGeomShaderBinding=dt,U.ImageParameter=NU,U.InstanceItem=Re,U.ItemEvent=YU,U.ItemSetParameter=_U,U.KinematicGroup=xe,U.LDRImage=gF,U.LDRVideo=IF,U.Label=Fe,U.LabelManager=$F,U.LatLongEnvProjectionShader=class extends OQ{constructor(U){super(U),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'envmap-equirect.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\nuniform color envMap;\nuniform sampler2D envMapTex;\nuniform int envMapTexType;\n\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 texCoord = latLongUVsFromDir(normalize(v_worldDir));\n  vec4 env = getColorParamValue(envMap, envMapTex, envMapTexType, texCoord);\n  fragColor = vec4(env.rgb/env.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}},U.Lines=dF,U.LinesCuboid=SF,U.LinesMaterial=ne,U.LinesProxy=BF,U.LinesShader=Ul,U.ListParameter=CU,U.Mat3=r,U.Mat3OperatorInput=class extends xU{},U.Mat3OperatorOutput=class extends GU{},U.Mat3Parameter=EU,U.Mat4=h,U.Mat4OperatorInput=class extends xU{},U.Mat4OperatorOutput=yU,U.Mat4Parameter=pU,U.Material=qU,U.MaterialColorParam=PU,U.MaterialFloatParam=HU,U.MaterialGroup=fe,U.MaterialLibrary=ke,U.MaterialParameter=$U,U.MathFunctions=J,U.Mesh=iF,U.MeshProxy=VF,U.MultiChoiceParameter=oU,U.NormalsShader=class extends tt{constructor(U){super(U,"NormalsShader"),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\ninstancedattribute vec3 positions;\ninstancedattribute vec3 normals;\nattribute vec2 vertexIDs;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform float normalLength;\n\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying float v_weight;\n\nvoid main(void) {\n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n  if (vertexIDs.x == 0.0) {\n    gl_Position = modelViewProjectionMatrix * vec4(positions, 1.0);\n    v_weight = 1.0;\n  }\n  else {\n    gl_Position = modelViewProjectionMatrix * vec4(positions+(normals*normalLength), 1.0);\n    v_weight = 0.0;\n  }\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nuniform color normalColor;\n\n/* VS Outputs */\nvarying float v_weight;\n\nvoid main(void) {\n  gl_FragColor = normalColor;\n  gl_FragColor.a = v_weight;\n}\n")}},U.NumberOperatorInput=class extends xU{},U.NumberOperatorOutput=class extends GU{},U.NumberParameter=hU,U.ObjAsset=class extends Ce{constructor(U){super(U),this.splitObjects=new JU("splitObjects",!1),this.splitGroupsIntoObjects=new JU("splitGroupsIntoObjects",!1),this.loadMtlFile=new JU("loadMtlFile",!0),this.unitsConversion=new hU("unitsConversion",1),this.defaultShader=new kU("defaultShader",""),this.splitObjectsParam=new JU("splitObjects",!1),this.splitGroupsIntoObjectsParam=new JU("splitGroupsIntoObjects",!1),this.loadMtlFileParam=new JU("loadMtlFile",!0),this.unitsConversionParam=new hU("unitsConversion",1),this.defaultShaderParam=new kU("defaultShader",""),this.addParameter(this.splitObjectsParam),this.addParameter(this.splitGroupsIntoObjectsParam),this.addParameter(this.loadMtlFileParam),this.addParameter(this.unitsConversionParam),this.addParameter(this.defaultShaderParam)}load(U){return this.loaded=!1,new Promise(((F,e)=>{const t=U.substring(0,U.lastIndexOf("/"))+"/",Q=U=>new Promise((F=>{$(U,(U=>{nU.incrementWorkDone(1),(U=>{const F=U.split("\n"),e=/\s+/;for(let U=0;U<F.length;U++){let t=F[U].trim();if(t.startsWith("#"))continue;t.includes("#")&&(t=t.substring(0,t.indexOf("#")).trim());const Q=t.split(e);throw Q.shift(),Q.join(" "),Error("no material defined.")}})(U),nU.incrementWorkDone(1),F()}))})),l=[],n=[],a=[],s={},R=U=>_e(this,void 0,void 0,(function*(){const F=U.split("\n"),e=/\s+/;let d,i,R=0;const B=U=>{if(U in s){let F=1;for(;U+String(F)in s;)F++;U+=String(F)}d={verticesRemapping:{},texCoordsRemapping:{},normalsRemapping:{},vertexIndices:[],texCoordIndices:[],normalIndices:[],numVertices:0,numTexCoords:0,numNormals:0,faceCounts:[],material:i},s[U]=d,R++};B("geom");const V=this.splitGroupsIntoObjectsParam.value;for(let U=0;U<F.length;U++){let r=F[U].trim();if(r.startsWith("#"))continue;r.includes("#")&&(r=r.substring(0,r.indexOf("#")).trim());const h=r.split(e),o=h.shift(),J=h.join(" ");switch(o){case"":case"s":continue;case"mtllib":if(!this.loadMtlFileParam.value)continue;nU.incrementWorkload(2);const U=t+J;U&&(yield Q(U));break;case"o":B(J);break;case"usemtl":i=J,B(J+Object.keys(s).length);break;case"g":V&&B(J?h.join("_"):"Group"+R);break;case"v":l.push(h.map((U=>parseFloat(U))));break;case"vt":a.push(h.map((U=>parseFloat(U))));break;case"vn":n.push(h.map((U=>parseFloat(U))));break;case"f":{const U=[],F=[],e=[];for(let t=0,Q=h.length;t<Q;t++){const Q=h[t].split("/").map((U=>parseInt(U)-1)),l=Q[0];let n=d.verticesRemapping[l];if(null==n&&(n=d.numVertices,d.verticesRemapping[l]=n,d.numVertices++),U.push(n),Q.length>1&&!isNaN(Q[1])){const U=Q[1];F.push(U)}if(Q.length>2&&!isNaN(Q[2])){const U=Q[2];e.push(U)}}d.vertexIndices.push(U),e.length>0&&d.normalIndices.push(e),F.length>0&&d.texCoordIndices.push(F),null==d.faceCounts[U.length-3]&&(d.faceCounts[U.length-3]=[]),d.faceCounts[U.length-3]++;break}default:console.warn("Unhandled line:"+r)}}})),B=()=>{for(const U in s)0!=s[U].numVertices&&V(U,s[U]);this.emit("loaded"),this.getGeometryLibrary().emit("loaded"),this.emit("geomsLoaded"),F()},V=(U,F)=>{for(let U=0;U<F.faceCounts.length;U++)null==F.faceCounts[U]&&(F.faceCounts[U]=0);const e=F.numVertices,t=new iF;t.setDebugName(U),t.setFaceCounts(F.faceCounts),t.setNumVertices(e);const Q=t.getVertexAttribute("positions"),s=this.unitsConversionParam.value;for(const U in F.verticesRemapping){const e=Number.parseInt(U),t=F.verticesRemapping[e];Q.getValueRef(t).set(l[e][0]*s,l[e][1]*s,l[e][2]*s)}let R,B;F.normalIndices.length>0&&(R=new eF,t.addVertexAttribute("normals",R)),F.texCoordIndices.length>0&&(B=new tF,t.addVertexAttribute("texCoords",B));const V=Array(F.faceCounts.length).fill(0);for(let U=0;U<F.vertexIndices.length;U++){const e=F.vertexIndices[U];let Q=0;for(let U=0;U<e.length-3;++U)F.faceCounts[U]&&(Q+=F.faceCounts[U]);if(Q+=V[e.length-3],V[e.length-3]++,t.setFaceVertexIndices(Q,e),R){const e=F.normalIndices[U];for(let U=0;U<e.length;U++){const F=new i(n[e[U]][0],n[e[U]][1],n[e[U]][2]);R.setFaceVertexValue(Q,U,F)}}if(B&&F.texCoordIndices.length==F.vertexIndices.length){const e=F.texCoordIndices[U];for(let U=0;U<e.length;U++){const F=new d(a[e[U]][0],a[e[U]][1]);B.setFaceVertexValue(Q,U,F)}}}const r=new he(U,t),h=t.getBoundingBox().center();{const U=h.negate(),F=t.getVertexAttribute("positions");for(let e=0;e<F.getCount();e++)F.getValueRef(e).addInPlace(U);t.setBoundingBoxDirty()}if(r.localXfoParam.value=new c(h),null!=F.material&&this.materialLibrary.hasMaterial(F.material))r.materialParam.value=this.materialLibrary.getMaterial(F.material);else{const F=this.defaultShaderParam.value,e=new qU(U+" mat");e.setShaderName(""!=F?F:"StandardSurfaceShader"),this.materialLibrary.addMaterial(e),r.materialParam.value=e}this.addChild(r,!1)};(()=>{nU.incrementWorkload(2),$(U,(U=>{nU.incrementWorkDone(1),R(U).then((()=>{B(),nU.incrementWorkDone(1)}))}),(U=>{this.emit("error",U),e(U)}))})()}))}},U.OctahedralEnvProjectionShader=class extends OQ{constructor(U){super(U),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'envmap-octahedral.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\nuniform color envMap;\nuniform sampler2D envMapTex;\nuniform int envMapTexType;\n\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 texCoord = dirToSphOctUv(normalize(v_worldDir));\n  vec4 env = getColorParamValue(envMap, envMapTex, envMapTexType, texCoord);\n\n  fragColor = vec4(env.rgb/env.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}},U.Operator=IU,U.OperatorInput=xU,U.OperatorOutput=GU,U.POINTER_TYPES=X,U.Parameter=rU,U.ParameterOwner=K,U.PassType=ze,U.Plane=kF,U.PlaneType=E,U.PointGrid=JF,U.Points=aF,U.PointsMaterial=ae,U.PointsProxy=RF,U.PointsShader=el,U.ProceduralLines=hF,U.ProceduralMesh=oF,U.ProceduralPoints=rF,U.Quat=o,U.QuatOperatorInput=class extends xU{},U.QuatOperatorOutput=class extends GU{},U.QuatParameter=WU,U.RGBA=R,U.Ray=Z,U.Rect=ZF,U.RefCounted=_,U.Registry=n,U.ResourceLoader=lU,U.SInt16=3,U.SInt32=5,U.SInt8=1,U.Scene=class{constructor(){this.envMapParam=new NU("EnvMap"),this.displayEnvMapParam=new JU("Display EnvMap",!1),this.envMapLODParam=new hU("EnvMapLOD",0),this.root=new DU("root")}getRoot(){return this.root}getResourceLoader(){return nU}setEnvMap(U){this.envMapParam.value=U}setupGrid(U=5,F=50,e=Le){const t=new De(U,F,e);return this.root.addChild(t,!1),t}},U.ScreenQuadShader=jt,U.ScreenSpaceMaterial=de,U.ScreenSpaceShader=sl,U.SelectionSet=Je,U.ShaderLibrary=Ut,U.SimpleSurfaceMaterial=ie,U.SimpleSurfaceShader=nl,U.Sphere=bF,U.SphereType=S,U.StandardSurfaceMaterial=se,U.StandardSurfaceShader=dl,U.StringFunctions=a,U.StringListParameter=bU,U.StringParameter=kU,U.StructParameter=TU,U.SystemDesc=e,U.Torus=CF,U.Touch=f,U.TreeItem=DU,U.TreeItemParameter=LU,U.UInt16=2,U.UInt32=4,U.UInt8=0,U.UnpackHDRShader=nt,U.VLAAsset=Ye,U.VLHImage=yF,U.VRViewport=RQ,U.Vec2=d,U.Vec2Attribute=tF,U.Vec2OperatorInput=class extends xU{},U.Vec2OperatorOutput=class extends GU{},U.Vec2Parameter=ZU,U.Vec3=i,U.Vec3Attribute=eF,U.Vec3OperatorInput=class extends xU{},U.Vec3OperatorOutput=class extends GU{},U.Vec3Parameter=cU,U.Vec4=s,U.Vec4Attribute=lF,U.Vec4OperatorInput=class extends xU{},U.Vec4OperatorOutput=XU,U.Vec4Parameter=mU,U.Version=RU,U.VideoStreamImage2D=ee,U.XRControllerEvent=D,U.XRPoseEvent=L,U.Xfo=c,U.XfoOperatorInput=fU,U.XfoOperatorOutput=gU,U.XfoParameter=uU,U.ZeaMouseEvent=x,U.ZeaPointerEvent=y,U.ZeaTouchEvent=M,U.ZeaUIEvent=I,U.ZeaWheelEvent=v,U.create3DContext=Oe,U.genDataTypeDesc=at,U.generateShaderGeomBinding=Rt,U.getFileFolder=function(U){return U.substring(0,U.lastIndexOf("/"))+"/"},U.labelManager=Ue,U.libsRegistry=kl,U.loadBinfile=UU,U.loadJSONfile=function(U,F,e,t){q(U,"json",(U=>{F(U.response,U)}),(F=>{if(null==e)throw new Error("Unable to XHR File:"+U);e(F)}),t)},U.loadTextfile=$,U.loadXMLfile=function(U,F,e,t){q(U,"document",(U=>{F(U.responseXML)}),(F=>{if(null==e)throw new Error("Unable to XHR File:"+U);e(F)}),t)},U.packageJson=F,U.resourceLoader=nU,U.shaderLibrary=Ft,Object.defineProperty(U,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
